var TAG_GLOBAL = function(tagInput) { 					        
    var tagPath              = tagInput.path || "", 					        
        containerId          = tagInput.containerId || "tagContainer", 					        
        ip                   = tagInput.serverIp || "browntagserver.com", 					        
        allowServerChange    = tagInput.allowServerChange, 					        
 		  allowAuthoringMode   = tagInput.allowAuthoringMode, 					        
        idleDuration         = tagInput.idleDuration, 					        
        currentPage          = {}, // name and obj properties 					        
        urlToLoad            = tagInput.urlToLoad, 					        
        urlToParse           = tagInput.urlToParse, 					        
        pageToLoad           = {}, // a specific page to load 					        
        TELEMETRY_SESSION_ID = null, 					        
        TELEMETRY_SWITCH     = localStorage.tagTelemetry ? localStorage.tagTelemetry : "off",                             
        IS_WINDOWS           = (typeof Windows !== "undefined"),                             
        IS_WEBAPP            = !IS_WINDOWS, // perhaps more intuitive than writing !IS_WINDOWS 					        
        idleTimer,                             
        Worktop = {}, 			                
        TAG                  = {}; 

/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
	navigator = window.navigator,
	location = window.location;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        },

        // Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

        // Map over the $ in case of overwrite
	_$ = window.$,

        // A central reference to the root jQuery(document)
	rootjQuery,

        // A simple way to check for HTML strings or ID strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

        // Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

        // Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

        // JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

        // Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

        // Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

        // Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
            return (letter + "").toUpperCase();
        },

        // Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

        // For matching the engine and version of the browser
	browserMatch,

        // The deferred used on DOM ready
	readyList,

        // The ready event handler
	DOMContentLoaded,

        // Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

        // [[Class]] -> type pairs
	class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = selector;
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [null, selector, null];

                    } else {
                        match = quickExpr.exec(selector);
                    }

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.7.1",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                // Return a 'clean' array
			this.toArray() :

                // Return just the object
			(num < 0 ? this[this.length + num] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.add(fn);

                return this;
            },

            eq: function (i) {
                i = +i;
                return i === -1 ?
			this.slice(i) :
			this.slice(i, i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
			"slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || this.constructor(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },

            // Handle when the DOM is ready
            ready: function (wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ((wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.fireWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.trigger) {
                        jQuery(document).trigger("ready").off("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyList) {
                    return;
                }

                readyList = jQuery.Callbacks("once memory");

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
            },

            type: function (obj) {
                return obj == null ?
			String(obj) :
			class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                try {
                    // Not own constructor property must be Object
                    if (obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                } catch (e) {
                    // IE8,9 Will throw exceptions on certain host objects #9897
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw new Error(msg);
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                    return window.JSON.parse(data);
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, ""))) {

                    return (new Function("return " + data))();

                }
                jQuery.error("Invalid JSON: " + data);
            },

            // Cross-browser xml parsing
            parseXML: function (data) {
                var xml, tmp;
                try {
                    if (window.DOMParser) { // Standard
                        tmp = new DOMParser();
                        xml = tmp.parseFromString(data, "text/xml");
                    } else { // IE
                        xml = new ActiveXObject("Microsoft.XMLDOM");
                        xml.async = "false";
                        xml.loadXML(data);
                    }
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            },

            noop: function () { },

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // We use execScript on Internet Explorer
                    // We use an anonymous function so that context is window
                    // rather than jQuery in Firefox
                    (window.execScript || function (data) {
                        window["eval"].call(window, data);
                    })(data);
                }
            },

            // Convert dashed to camelCase; used by the css and data modules
            // Microsoft forgot to hump their vendor prefix (#9572)
            camelCase: function (string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length;) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length;) {
                            if (callback.call(object[i], i, object[i++]) === false) {
                                break;
                            }
                        }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
		function (text) {
                return text == null ?
				"" :
				trim.call(text);
            } :

            // Otherwise use our own trimming functionality
		function (text) {
                return text == null ?
				"" :
				text.toString().replace(trimLeft, "").replace(trimRight, "");
            },

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array, i) {
                var len;

                if (array) {
                    if (indexOf) {
                        return indexOf.call(array, elem, i);
                    }

                    len = array.length;
                    i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

                    for (; i < len; i++) {
                        // Skip accessing in sparse arrays
                        if (i in array && array[i] === elem) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length,
			j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var value, key, ret = [],
			i = 0,
			length = elems.length,
                // jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for (key in elems) {
                        value = callback(elems[key], key, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function (fn, context) {
                if (typeof context === "string") {
                    var tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }

                // Simulated bind
                var args = slice.call(arguments, 2),
			proxy = function () {
                    return fn.apply(context, args.concat(slice.call(arguments)));
                };

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec(ua) ||
			ropera.exec(ua) ||
			rmsie.exec(ua) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
			[];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            sub: function () {
                function jQuerySub(selector, context) {
                    return new jQuerySub.fn.init(selector, context);
                }
                jQuery.extend(true, jQuerySub, this);
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init(selector, context) {
                    if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                        context = jQuerySub(context);
                    }

                    return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = true;
        }

        // IE doesn't match non-breaking spaces with \s
        if (rnotwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        return jQuery;

    })();


    // String to Object flags format cache
    var flagsCache = {};

    // Convert String-formatted flags into Object-formatted ones and store in cache
    function createFlags(flags) {
        var object = flagsCache[flags] = {},
		i, length;
        flags = flags.split(/\s+/);
        for (i = 0, length = flags.length; i < length; i++) {
            object[flags[i]] = true;
        }
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function (flags) {

        // Convert flags from String-formatted to Object-formatted
        // (we check in cache first)
        flags = flags ? (flagsCache[flags] || createFlags(flags)) : {};

        var // Actual callback list
		list = [],
        // Stack of fire calls for repeatable lists
		stack = [],
        // Last fire value (for non-forgettable lists)
		memory,
        // Flag to know if list is currently firing
		firing,
        // First callback to fire (used internally by add and fireWith)
		firingStart,
        // End of the loop when firing
		firingLength,
        // Index of currently firing callback (modified by remove if needed)
		firingIndex,
        // Add one or several callbacks to the list
		add = function (args) {
            var i,
				length,
				elem,
				type,
				actual;
            for (i = 0, length = args.length; i < length; i++) {
                elem = args[i];
                type = jQuery.type(elem);
                if (type === "array") {
                    // Inspect recursively
                    add(elem);
                } else if (type === "function") {
                    // Add if not in unique mode and callback is not in
                    if (!flags.unique || !self.has(elem)) {
                        list.push(elem);
                    }
                }
            }
        },
        // Fire callbacks
		fire = function (context, args) {
            args = args || [];
            memory = !flags.memory || [context, args];
            firing = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            for (; list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(context, args) === false && flags.stopOnFalse) {
                    memory = true; // Mark as halted
                    break;
                }
            }
            firing = false;
            if (list) {
                if (!flags.once) {
                    if (stack && stack.length) {
                        memory = stack.shift();
                        self.fireWith(memory[0], memory[1]);
                    }
                } else if (memory === true) {
                    self.disable();
                } else {
                    list = [];
                }
            }
        },
        // Actual Callbacks object
		self = {
        // Add a callback or a collection of callbacks to the list
            add: function () {
                if (list) {
                    var length = list.length;
                    add(arguments);
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if (firing) {
                        firingLength = list.length;
                        // With memory, if we're not firing then
                        // we should call right away, unless previous
                        // firing was halted (stopOnFalse)
                    } else if (memory && memory !== true) {
                        firingStart = length;
                        fire(memory[0], memory[1]);
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function () {
                if (list) {
                    var args = arguments,
						argIndex = 0,
						argLength = args.length;
                    for (; argIndex < argLength ; argIndex++) {
                        for (var i = 0; i < list.length; i++) {
                            if (args[argIndex] === list[i]) {
                                // Handle firingIndex and firingLength
                                if (firing) {
                                    if (i <= firingLength) {
                                        firingLength--;
                                        if (i <= firingIndex) {
                                            firingIndex--;
                                        }
                                    }
                                }
                                // Remove the element
                                list.splice(i--, 1);
                                // If we have some unicity property then
                                // we only need to do this once
                                if (flags.unique) {
                                    break;
                                }
                            }
                        }
                    }
                }
                return this;
            },
            // Control if a given callback is in the list
            has: function (fn) {
                if (list) {
                    var i = 0,
						length = list.length;
                    for (; i < length; i++) {
                        if (fn === list[i]) {
                            return true;
                        }
                    }
                }
                return false;
            },
            // Remove all callbacks from the list
            empty: function () {
                list = [];
                return this;
            },
            // Have the list do nothing anymore
            disable: function () {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function () {
                return !list;
            },
            // Lock the list in its current state
            lock: function () {
                stack = undefined;
                if (!memory || memory === true) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function () {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function (context, args) {
                if (stack) {
                    if (firing) {
                        if (!flags.once) {
                            stack.push([context, args]);
                        }
                    } else if (!(flags.once && memory)) {
                        fire(context, args);
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function () {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function () {
                return !!memory;
            }
        };

        return self;
    };




    var // Static reference to slice
	sliceDeferred = [].slice;

    jQuery.extend({

        Deferred: function (func) {
            var doneList = jQuery.Callbacks("once memory"),
			failList = jQuery.Callbacks("once memory"),
			progressList = jQuery.Callbacks("memory"),
			state = "pending",
			lists = {
                resolve: doneList,
                reject: failList,
                notify: progressList
            },
			promise = {
                done: doneList.add,
                fail: failList.add,
                progress: progressList.add,

                state: function () {
                    return state;
                },

                // Deprecated
                isResolved: doneList.fired,
                isRejected: failList.fired,

                then: function (doneCallbacks, failCallbacks, progressCallbacks) {
                    deferred.done(doneCallbacks).fail(failCallbacks).progress(progressCallbacks);
                    return this;
                },
                always: function () {
                    deferred.done.apply(deferred, arguments).fail.apply(deferred, arguments);
                    return this;
                },
                pipe: function (fnDone, fnFail, fnProgress) {
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each({
                            done: [fnDone, "resolve"],
                            fail: [fnFail, "reject"],
                            progress: [fnProgress, "notify"]
                        }, function (handler, data) {
                            var fn = data[0],
								action = data[1],
								returned;
                            if (jQuery.isFunction(fn)) {
                                deferred[handler](function () {
                                    returned = fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().then(newDefer.resolve, newDefer.reject, newDefer.notify);
                                    } else {
                                        newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
                                    }
                                });
                            } else {
                                deferred[handler](newDefer[action]);
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function (obj) {
                    if (obj == null) {
                        obj = promise;
                    } else {
                        for (var key in promise) {
                            obj[key] = promise[key];
                        }
                    }
                    return obj;
                }
            },
			deferred = promise.promise({}),
			key;

            for (key in lists) {
                deferred[key] = lists[key].fire;
                deferred[key + "With"] = lists[key].fireWith;
            }

            // Handle state
            deferred.done(function () {
                state = "resolved";
            }, failList.disable, progressList.lock).fail(function () {
                state = "rejected";
            }, doneList.disable, progressList.lock);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (firstParam) {
            var args = sliceDeferred.call(arguments, 0),
			i = 0,
			length = args.length,
			pValues = new Array(length),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
            function resolveFunc(i) {
                return function (value) {
                    args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    if (!(--count)) {
                        deferred.resolveWith(deferred, args);
                    }
                };
            }
            function progressFunc(i) {
                return function (value) {
                    pValues[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    deferred.notifyWith(promise, pValues);
                };
            }
            if (length > 1) {
                for (; i < length; i++) {
                    if (args[i] && args[i].promise && jQuery.isFunction(args[i].promise)) {
                        args[i].promise().then(resolveFunc(i), deferred.reject, progressFunc(i));
                    } else {
                        --count;
                    }
                }
                if (!count) {
                    deferred.resolveWith(deferred, args);
                }
            } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
            }
            return promise;
        }
    });




    jQuery.support = (function () {

        var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement("div"),
		documentElement = document.documentElement;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        support = {
        // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Tests for enctype support on a form(#6743)
            enctype: !!document.createElement("form").enctype,

            // Makes sure cloning an html5 element does not cause problems
            // Where outerHTML is undefined, this still works
            html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        // Check if a radio maintains its value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.lastChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        fragment.removeChild(input);
        fragment.appendChild(div);

        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if (window.getComputedStyle) {
            marginDiv = document.createElement("div");
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.style.width = "2px";
            div.appendChild(marginDiv);
            support.reliableMarginRight =
			(parseInt((window.getComputedStyle(marginDiv, null) || { marginRight: 0 }).marginRight, 10) || 0) === 0;
        }

        // Technique from Juriy Zaytsev
        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
			submit: 1,
			change: 1,
			focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        fragment.removeChild(div);

        // Null elements to avoid leaks in IE
        fragment = select = opt = marginDiv = div = input = null;

        // Run tests that need a body at doc ready
        jQuery(function () {
            var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

            if (!body) {
                // Return for frameset docs that don't have a body
                return;
            }

            conMarginTop = 1;
            ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
            vb = "visibility:hidden;border:0;";
            style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
            html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

            container = document.createElement("div");
            container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
            body.insertBefore(container, body.firstChild);

            // Construct the test element
            div = document.createElement("div");
            container.appendChild(div);

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName("td");
            isSupported = (tds[0].offsetHeight === 0);

            tds[0].style.display = "";
            tds[1].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE <= 8 fail this test)
            support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

            // Figure out if the W3C box model works as expected
            div.innerHTML = "";
            div.style.width = div.style.paddingLeft = "1px";
            jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

            if (typeof div.style.zoom !== "undefined") {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.style.display = "inline";
                div.style.zoom = 1;
                support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "";
                div.innerHTML = "<div style='width:4px;'></div>";
                support.shrinkWrapBlocks = (div.offsetWidth !== 2);
            }

            div.style.cssText = ptlm + vb;
            div.innerHTML = html;

            outer = div.firstChild;
            inner = outer.firstChild;
            td = outer.nextSibling.firstChild.firstChild;

            offsetSupport = {
                doesNotAddBorder: (inner.offsetTop !== 5),
                doesAddBorderForTableAndCells: (td.offsetTop === 5)
            };

            inner.style.position = "fixed";
            inner.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            offsetSupport.fixedPosition = (inner.offsetTop === 20 || inner.offsetTop === 15);
            inner.style.position = inner.style.top = "";

            outer.style.overflow = "hidden";
            outer.style.position = "relative";

            offsetSupport.subtractsBorderForOverflowNotVisible = (inner.offsetTop === -5);
            offsetSupport.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== conMarginTop);

            body.removeChild(container);
            div = container = null;

            jQuery.extend(support, offsetSupport);
        });

        return support;
    })();




    var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[internalKey] : elem[internalKey] && internalKey,
			isEvents = name === "events";

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[internalKey] = id = ++jQuery.uuid;
                } else {
                    id = internalKey;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id] = jQuery.extend(cache[id], name);
                } else {
                    cache[id].data = jQuery.extend(cache[id].data, name);
                }
            }

            privateCache = thisCache = cache[id];

            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            if (!pvt) {
                if (!thisCache.data) {
                    thisCache.data = {};
                }

                thisCache = thisCache.data;
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // Users should not attempt to inspect the internal events object using jQuery.data,
            // it is undocumented and subject to change. But does anyone listen? No.
            if (isEvents && !thisCache[name]) {
                return privateCache.events;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if (getByName) {

                // First Try to find as-is property data
                ret = thisCache[name];

                // Test for null|undefined property data
                if (ret == null) {

                    // Try to find the camelCased property
                    ret = thisCache[jQuery.camelCase(name)];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, i, l,

            // Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

            // See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

            // See jQuery.data for more information
			id = isNode ? elem[internalKey] : internalKey;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {

                thisCache = pvt ? cache[id] : cache[id].data;

                if (thisCache) {

                    // Support array or space separated string names for data keys
                    if (!jQuery.isArray(name)) {

                        // try the string as a key before any manipulation
                        if (name in thisCache) {
                            name = [name];
                        } else {

                            // split the camel cased version by spaces unless a key with the spaces exists
                            name = jQuery.camelCase(name);
                            if (name in thisCache) {
                                name = [name];
                            } else {
                                name = name.split(" ");
                            }
                        }
                    }

                    for (i = 0, l = name.length; i < l; i++) {
                        delete thisCache[name[i]];
                    }

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (!pvt) {
                delete cache[id].data;

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            // Ensure that `cache` is not a window object #10080
            if (jQuery.support.deleteExpando || !cache.setInterval) {
                delete cache[id];
            } else {
                cache[id] = null;
            }

            // We destroyed the cache and need to eliminate the expando on the node to avoid
            // false lookups in the cache for entries that no longer exist
            if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                    delete elem[internalKey];
                } else if (elem.removeAttribute) {
                    elem.removeAttribute(internalKey);
                } else {
                    elem[internalKey] = null;
                }
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var parts, attr, name,
			data = null;

            if (typeof key === "undefined") {
                if (this.length) {
                    data = jQuery.data(this[0]);

                    if (this[0].nodeType === 1 && !jQuery._data(this[0], "parsedAttrs")) {
                        attr = this[0].attributes;
                        for (var i = 0, l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(this[0], name, data[name]);
                            }
                        }
                        jQuery._data(this[0], "parsedAttrs", true);
                    }
                }

                return data;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);
                    data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ?
				this.data(parts[0]) :
				data;

            } else {
                return this.each(function () {
                    var self = jQuery(this),
					args = [parts[0], value];

                    self.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    self.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {

            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric(data) ? parseFloat(data) :
					rbrace.test(data) ? jQuery.parseJSON(data) :
					data;
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        for (var name in obj) {

            // if the public data object is empty, the private is still empty
            if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer(elem, type, src) {
        var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data(elem, deferDataKey);
        if (defer &&
		(src === "queue" || !jQuery._data(elem, queueDataKey)) &&
		(src === "mark" || !jQuery._data(elem, markDataKey))) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout(function () {
                if (!jQuery._data(elem, queueDataKey) &&
				!jQuery._data(elem, markDataKey)) {
                    jQuery.removeData(elem, deferDataKey, true);
                    defer.fire();
                }
            }, 0);
        }
    }

    jQuery.extend({

        _mark: function (elem, type) {
            if (elem) {
                type = (type || "fx") + "mark";
                jQuery._data(elem, type, (jQuery._data(elem, type) || 0) + 1);
            }
        },

        _unmark: function (force, elem, type) {
            if (force !== true) {
                type = elem;
                elem = force;
                force = false;
            }
            if (elem) {
                type = type || "fx";
                var key = type + "mark",
				count = force ? 0 : ((jQuery._data(elem, key) || 1) - 1);
                if (count) {
                    jQuery._data(elem, key, count);
                } else {
                    jQuery.removeData(elem, key, true);
                    handleQueueMarkDefer(elem, type, "mark");
                }
            }
        },

        queue: function (elem, type, data) {
            var q;
            if (elem) {
                type = (type || "fx") + "queue";
                q = jQuery._data(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!q || jQuery.isArray(data)) {
                        q = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        q.push(data);
                    }
                }
                return q || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
			fn = queue.shift(),
			hooks = {};

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                jQuery._data(elem, type + ".run", hooks);
                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                }, hooks);
            }

            if (!queue.length) {
                jQuery.removeData(elem, type + "queue " + type + ".run", true);
                handleQueueMarkDefer(elem, type, "queue");
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function () {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function (next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function () {
                    clearTimeout(timeout);
                };
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, object) {
            if (typeof type !== "string") {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
            function resolve() {
                if (!(--count)) {
                    defer.resolveWith(elements, [elements]);
                }
            }
            while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) ||
					(jQuery.data(elements[i], queueDataKey, undefined, true) ||
						jQuery.data(elements[i], markDataKey, undefined, true)) &&
					jQuery.data(elements[i], deferDataKey, jQuery.Callbacks("once memory"), true))) {
                    count++;
                    tmp.add(resolve);
                }
            }
            resolve();
            return defer.promise();
        }
    });




    var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.prop);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) { }
            });
        },

        addClass: function (value) {
            var classNames, i, l, elem,
			setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (!~setClass.indexOf(" " + classNames[c] + " ")) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classNames, i, l, elem, className, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                classNames = (value || "").split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            className = (" " + elem.className + " ").replace(rclass, " ");
                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
			isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className,
					i = 0,
					self = jQuery(this),
					state = stateVal,
					classNames = value.split(rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ",
			i = 0,
			l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret, isFunction,
			elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
					ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
					ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.nodeName.toLowerCase()] || jQuery.valHooks[this.type];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function (elem) {
                    var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

                    // Nothing was selected
                    if (index < 0) {
                        return null;
                    }

                    // Loop through all the selected options
                    i = one ? index : 0;
                    max = one ? index + 1 : options.length;
                    for (; i < max; i++) {
                        option = options[i];

                        // Don't return options that are disabled or in a disabled optgroup
                        if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if (one && !values.length && options.length) {
                        return jQuery(options[index]).val();
                    }

                    return values;
                },

                set: function (elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attr: function (elem, name, value, pass) {
            var ret, hooks, notxml,
			nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (notxml) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, "" + value);
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
				undefined :
				ret;
            }
        },

        removeAttr: function (elem, value) {
            var propName, attrNames, name, l,
			i = 0;

            if (value && elem.nodeType === 1) {
                attrNames = value.toLowerCase().split(rspace);
                l = attrNames.length;

                for (; i < l; i++) {
                    name = attrNames[i];

                    if (name) {
                        propName = jQuery.propFix[name] || name;

                        // See #9699 for explanation of this approach (setting first, then removal)
                        jQuery.attr(elem, name, "");
                        elem.removeAttribute(getSetAttribute ? name : propName);

                        // Set corresponding property to false for boolean attributes
                        if (rboolean.test(name) && propName in elem) {
                            elem[propName] = false;
                        }
                    }
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function (elem, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.get(elem, name);
                    }
                    return name in elem ?
					elem.value :
					null;
                },
                set: function (elem, value, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var ret, hooks, notxml,
			nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");

                    return attributeNode && attributeNode.specified ?
					parseInt(attributeNode.value, 10) :
					rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
						0 :
						undefined;
                }
            }
        }
    });

    // Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
    jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

    // Hook for boolean attributes
    boolHook = {
        get: function (elem, name) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode,
			property = jQuery.prop(elem, name);
            return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
        },
        set: function (elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!getSetAttribute) {

        fixSpecified = {
            name: true,
            id: true
        };

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                return ret && (fixSpecified[name] ? ret.nodeValue !== "" : ret.specified) ?
				ret.nodeValue :
				undefined;
            },
            set: function (elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    ret = document.createAttribute(name);
                    elem.setAttributeNode(ret);
                }
                return (ret.nodeValue = value + "");
            }
        };

        // Apply the nodeHook to tabindex
        jQuery.attrHooks.tabindex.set = nodeHook.set;

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function (elem, value, name) {
                if (value === "") {
                    value = "false";
                }
                nodeHook.set(elem, value, name);
            }
        };
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = "" + value);
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }

    // IE6/7 call enctype encoding
    if (!jQuery.support.enctype) {
        jQuery.propFix.enctype = "encoding";
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                get: function (elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });




    var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function (selector) {
        var quick = rquickIs.exec(selector);
        if (quick) {
            //   0  1    2   3
            // [ _, tag, id, class ]
            quick[1] = (quick[1] || "").toLowerCase();
            quick[3] = quick[3] && new RegExp("(?:^|\\s)" + quick[3] + "(?:\\s|$)");
        }
        return quick;
    },
	quickIs = function (elem, m) {
        var attrs = elem.attributes || {};
        return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test((attrs["class"] || {}).value))
		);
    },
	hoverHack = function (events) {
        return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
    };

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        add: function (elem, types, handler, data, selector) {

            var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

            // Don't attach events to noData or text/comment nodes (allow plain objects tho)
            if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            events = elemData.events;
            if (!events) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
					undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = jQuery.trim(hoverHack(types)).split(" ");
            for (t = 0; t < types.length; t++) {

                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    quick: quickParse(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                handlers = events[type];
                if (!handlers) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var elemData = jQuery.hasData(elem) && jQuery._data(elem),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = jQuery.trim(hoverHack(types || "")).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

                // Remove matching events
                for (j = 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
					 (!handler || handler.guid === handleObj.guid) &&
					 (!namespaces || namespaces.test(handleObj.namespace)) &&
					 (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        eventType.splice(j--, 1);

                        if (handleObj.selector) {
                            eventType.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (eventType.length === 0 && origCount !== eventType.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData(elem, ["events", "handle"], true);
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Don't do events on text and comment nodes
            if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
                return;
            }

            // Event object or event type
            var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
			event[jQuery.expando] ? event :
            // Object literal
			new jQuery.Event(type, event) :
            // Just the event type (string)
			new jQuery.Event(type);

            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
            ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Handle a global trigger
            if (!elem) {

                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for (i in cache) {
                    if (cache[i].events && cache[i].events[type]) {
                        jQuery.event.trigger(event, data, cache[i].handle.elem, true);
                    }
                }
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            eventPath = [[elem, special.bindType || type]];
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                old = null;
                for (; cur; cur = cur.parentNode) {
                    eventPath.push([cur, bubbleType]);
                    old = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (old && old === elem.ownerDocument) {
                    eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
                }
            }

            // Fire handlers on the event path
            for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

                cur = eventPath[i][0];
                event.type = eventPath[i][1];

                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply(cur, data) === false) {
                    event.preventDefault();
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
				!(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    // IE<9 dies on focus/blur to hidden element (#1486)
                    if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        old = elem[ontype];

                        if (old) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (old) {
                            elem[ontype] = old;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function (event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event || window.event);

            var handlers = ((jQuery._data(this, "events") || {})[event.type] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call(arguments, 0),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Determine handlers that should run if there are delegated events
            // Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
            if (delegateCount && !event.target.disabled && !(event.button && event.type === "click")) {

                // Pregenerate a single jQuery object for reuse with .is()
                jqcur = jQuery(this);
                jqcur.context = this.ownerDocument || this;

                for (cur = event.target; cur != this; cur = cur.parentNode || this) {
                    selMatch = {};
                    matches = [];
                    jqcur[0] = cur;
                    for (i = 0; i < delegateCount; i++) {
                        handleObj = handlers[i];
                        sel = handleObj.selector;

                        if (selMatch[sel] === undefined) {
                            selMatch[sel] = (
							handleObj.quick ? quickIs(cur, handleObj.quick) : jqcur.is(sel)
						);
                        }
                        if (selMatch[sel]) {
                            matches.push(handleObj);
                        }
                    }
                    if (matches.length) {
                        handlerQueue.push({ elem: cur, matches: matches });
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (handlers.length > delegateCount) {
                handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) });
            }

            // Run delegates first; they may want to stop propagation beneath us
            for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
                matched = handlerQueue[i];
                event.currentTarget = matched.elem;

                for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
                    handleObj = matched.matches[j];

                    // Triggered event must either 1) be non-exclusive and have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
							.apply(matched.elem, args);

                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            return event.result;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (event, original) {
                var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
            }
        },

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[event.type] || {},
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = jQuery.Event(originalEvent);

            for (i = copy.length; i;) {
                prop = copy[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }

            // Target should not be a text node (#504, Safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
            if (event.metaKey === undefined) {
                event.metaKey = event.ctrlKey;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            ready: {
            // Make sure the ready event is setup
                setup: jQuery.bindReady
            },

            load: {
            // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },

            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },

        simulate: function (type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
			new jQuery.Event(),
			event,
            {
                type: type,
                isSimulated: true,
                originalEvent: {}
            }
		);
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };

    // Some plugins are using, but it's undocumented/deprecated and will be removed.
    // The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;

    jQuery.removeEvent = document.removeEventListener ?
	function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } :
	function (elem, type, handle) {
        if (elem.detachEvent) {
            elem.detachEvent("on" + type, handle);
        }
    };

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    // IE submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, "click._submit keypress._submit", function (e) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
					form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                    if (form && !form._submit_attached) {
                        jQuery.event.add(form, "submit._submit", function (event) {
                            // If form was submitted by the user, bubble the event up the tree
                            if (this.parentNode && !event.isTrigger) {
                                jQuery.event.simulate("submit", this.parentNode, event, true);
                            }
                        });
                        form._submit_attached = true;
                    }
                });
                // return undefined since we don't need an event listener
            },

            teardown: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, "._submit");
            }
        };
    }

    // IE change delegation and checkbox/radio fix
    if (!jQuery.support.changeBubbles) {

        jQuery.event.special.change = {

            setup: function () {

                if (rformElems.test(this.nodeName)) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function (event) {
                            if (event.originalEvent.propertyName === "checked") {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, "click._change", function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                                jQuery.event.simulate("change", this, event, true);
                            }
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, "beforeactivate._change", function (e) {
                    var elem = e.target;

                    if (rformElems.test(elem.nodeName) && !elem._change_attached) {
                        jQuery.event.add(elem, "change._change", function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate("change", this.parentNode, event, true);
                            }
                        });
                        elem._change_attached = true;
                    }
                });
            },

            handle: function (event) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },

            teardown: function () {
                jQuery.event.remove(this, "._change");

                return rformElems.test(this.nodeName);
            }
        };
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0,
			handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };

            jQuery.event.special[fix] = {
                setup: function () {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function (types, selector, data, fn, /*INTERNAL*/ one) {
            var origFn, type;

            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                    // ( types-Object, data )
                    data = selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on.call(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                var handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
				handleObj.namespace ? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (var type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        live: function (types, data, fn) {
            jQuery(this.context).on(types, this.selector, data, fn);
            return this;
        },
        die: function (types, fn) {
            jQuery(this.context).off(types, this.selector || "**", fn);
            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length == 1 ? this.off(selector, "**") : this.off(types, selector, fn);
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function (event) {
                // Figure out which function to execute
                var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
                jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);

                // Make sure that clicks stop
                event.preventDefault();

                // and execute the function
                return args[lastToggle].apply(this, arguments) || false;
            };

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
            if (fn == null) {
                fn = data;
                data = null;
            }

            return arguments.length > 0 ?
			this.on(name, null, data, fn) :
			this.trigger(name);
        };

        if (jQuery.attrFn) {
            jQuery.attrFn[name] = true;
        }

        if (rkeyEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
        }

        if (rmouseEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
        }
    });



    /*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return[];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML(context),
		parts = [],
		soFar = selector;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {

                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context, seed);

                } else {
                    set = Expr.relative[parts[0]] ?
				[context] :
				Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set, seed);
                    }
                }

            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {

                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ?
				Sizzle.filter(ret.expr, ret.set)[0] :
				ret.set[0];
                }

                if (context) {
                    ret = seed ?
                    { expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);

                    set = ret.expr ?
				Sizzle.filter(ret.expr, ret.set) :
				ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);

                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }

                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);

                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }

                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }

            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set, i, len, match, type, left;

            if (!expr) {
                return[];
            }

            for (i = 0, len = Expr.order.length; i < len; i++) {
                type = Expr.order[i];

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(rBackslash, "");
                        set = Expr.find[type](match, context, isXML);

                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName("*") :
			[];
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        filter = Expr.filter[type];
                        left = match[1];

                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;

                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    pass = not ^ found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;

                                        } else {
                                            curLoop[i] = false;
                                        }

                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return[];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);

                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        /**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
        var getText = Sizzle.getText = function (elem) {
            var i, node,
		nodeType = elem.nodeType,
		ret = "";

            if (nodeType) {
                if (nodeType === 1 || nodeType === 9) {
                    // Use textContent || innerText for elements
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else if (typeof elem.innerText === 'string') {
                        // Replace IE's carriage returns
                        return elem.innerText.replace(rReturn, '');
                    } else {
                        // Traverse it's children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
            } else {

                // If no nodeType, this is expected to be an array
                for (i = 0; (node = elem[i]); i++) {
                    // Do not traverse comment nodes
                    if (node.nodeType !== 8) {
                        ret += getText(node);
                    }
                }
            }
            return ret;
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                },
                type: function (elem) {
                    return elem.getAttribute("type");
                }
            },

            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test(part),
				isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },

                ">": function (checkSet, part) {
                    var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

                    if (isPartStr && !rNonWord.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }

                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },

                "": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },

            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },

                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [],
					results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },

                TAG: function (match, context) {
                    var a = context.Methods;
                    var b = context.getElementsByTagName;
                    if (typeof context.getElementsByTagName == "function") {
                        return context.getElementsByTagName(match[1]);
                    }
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(rBackslash, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }

                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },

                ID: function (match) {
                    return match[1].replace(rBackslash, "");
                },

                TAG: function (match, curLoop) {
                    return match[1].replace(rBackslash, "").toLowerCase();
                },

                CHILD: function (match) {
                    if (match[1] === "nth") {
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        match[2] = match[2].replace(/^\+|\s*/g, '');

                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }
                    else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },

                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1] = match[1].replace(rBackslash, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    // Handle if an un-quoted value was used
                    match[4] = (match[4] || match[5] || "").replace(rBackslash, "");

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },

                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);

                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                            if (!inplace) {
                                result.push.apply(result, ret);
                            }

                            return false;
                        }

                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },

                POS: function (match) {
                    match.unshift(true);

                    return match;
                }
            },

            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function (elem) {
                    return elem.disabled === true;
                },

                checked: function (elem) {
                    return elem.checked === true;
                },

                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                parent: function (elem) {
                    return !!elem.firstChild;
                },

                empty: function (elem) {
                    return !elem.firstChild;
                },

                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },

                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },

                text: function (elem) {
                    var attr = elem.getAttribute("type"), type = elem.type;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" && "text" === type && (attr === type || attr === null);
                },

                radio: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && "button" === elem.type || name === "button";
                },

                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                },

                focus: function (elem) {
                    return elem === elem.ownerDocument.activeElement;
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },

                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },

                even: function (elem, i) {
                    return i % 2 === 0;
                },

                odd: function (elem, i) {
                    return i % 2 === 1;
                },

                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },

                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },

                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },

                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1],
				filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);

                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || getText([elem]) || "").indexOf(match[3]) >= 0;

                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;

                    } else {
                        Sizzle.error(name);
                    }
                },

                CHILD: function (elem, match) {
                    var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

                    switch (type) {
                        case "only":
                        case "first":
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            if (type === "first") {
                                return true;
                            }

                            node = elem;

                        case "last":
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            return true;

                        case "nth":
                            first = match[2];
                            last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            doneName = match[0];
                            parent = elem.parentNode;

                            if (parent && (parent[expando] !== doneName || !elem.nodeIndex)) {
                                count = 0;

                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }

                                parent[expando] = doneName;
                            }

                            diff = elem.nodeIndex - last;

                            if (first === 0) {
                                return diff === 0;

                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },

                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
                },

                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf(match) > -1;
                },

                ATTR: function (elem, match) {
                    var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr(elem, name) :
					Expr.attrHandle[name] ?
					Expr.attrHandle[name](elem) :
					elem[name] != null ?
						elem[name] :
						elem.getAttribute(name),
				value = result + "",
				type = match[2],
				check = match[4];

                    return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
                },

                POS: function (elem, match, i, array) {
                    var name = match[2],
				filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
	fescape = function (all, num) {
            return "\\" + (num - 0 + 1);
        };

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var i = 0,
			ret = results || [];

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);

                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }

                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };

        } else {
            sortOrder = function (a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
			siblingCheck(a, bp[i], -1) :
			siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);

                        return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);

            // release memory in IE
            root = form = null;
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";

            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#") {

                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            // release memory in IE
            div = null;
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        // See if we find a selector to speed up
                        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(query);

                        if (match && (context.nodeType === 1 || context.nodeType === 9)) {
                            // Speed-up: Sizzle("TAG")
                            if (match[1]) {
                                return makeArray(context.getElementsByTagName(query), extra);

                                // Speed-up: Sizzle(".CLASS")
                            } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {
                                return makeArray(context.getElementsByClassName(match[2]), extra);
                            }
                        }

                        if (context.nodeType === 9) {
                            // Speed-up: Sizzle("body")
                            // The body element only exists once, optimize finding it
                            if (query === "body" && context.body) {
                                return makeArray([context.body], extra);

                                // Speed-up: Sizzle("#ID")
                            } else if (match && match[3]) {
                                var elem = context.getElementById(match[3]);

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if (elem.id === match[3]) {
                                        return makeArray([elem], extra);
                                    }

                                } else {
                                    return makeArray([], extra);
                                }
                            }

                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var oldContext = context,
						old = context.getAttribute("id"),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test(query);

                            if (!old) {
                                context.setAttribute("id", nid);
                            } else {
                                nid = nid.replace(/'/g, "\\$&");
                            }
                            if (relativeHierarchySelector && hasParent) {
                                context = context.parentNode;
                            }

                            try {
                                if (!relativeHierarchySelector || hasParent) {
                                    return makeArray(context.querySelectorAll("[id='" + nid + "'] " + query), extra);
                                }

                            } catch (pseudoError) {
                            } finally {
                                if (!old) {
                                    oldContext.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                // release memory in IE
                div = null;
            })();
        }

        (function () {
            var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

            if (matches) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call(document.createElement("div"), "div"),
			pseudoWorks = false;

                try {
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(document.documentElement, "[test!='']:sizzle");

                } catch (pseudoError) {
                    pseudoWorks = true;
                }

                Sizzle.matchesSelector = function (node, expr) {
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                    if (!Sizzle.isXML(node)) {
                        //Debug.enableFirstChanceException(false);
                        try {
                            if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {
                                
                                var ret = matches.call(node, expr);
                                
                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || !disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11) {
                                    return ret;
                                }
                            }
                        } catch (e) { }//Debug.enableFirstChanceException(true); }
                        //Debug.enableFirstChanceException(true);
                    }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            // release memory in IE
            div = null;
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem[expando] === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem[expando] = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem[expando] === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem[expando] = doneName;
                                elem.sizset = i;
                            }

                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        if (document.documentElement.contains) {
            Sizzle.contains = function (a, b) {
                return a !== b && (a.contains ? a.contains(b) : true);
            };

        } else if (document.documentElement.compareDocumentPosition) {
            Sizzle.contains = function (a, b) {
                return !!(a.compareDocumentPosition(b) & 16);
            };

        } else {
            Sizzle.contains = function () {
                return false;
            };
        }

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context, seed) {
            var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet, seed);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        // Override sizzle attribute retrieval
        Sizzle.attr = jQuery.attr;
        Sizzle.selectors.attrMap = {};
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
    // Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
    // methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

    jQuery.fn.extend({
        find: function (selector) {
            var self = this,
			i, l;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack("", "find", selector),
			length, n, r;

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && (
			typeof selector === "string" ?
            // If this is a positional selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test(selector) ?
					jQuery(selector, this.context).index(this[0]) >= 0 :
					jQuery.filter(selector, this).length > 0 :
				this.filter(selector).length > 0);
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            // Array (deprecated as of jQuery 1.7)
            if (jQuery.isArray(selectors)) {
                var level = 1;

                while (cur && cur.ownerDocument && cur !== context) {
                    for (i = 0; i < selectors.length; i++) {

                        if (jQuery(cur).is(selectors[i])) {
                            ret.push({ selector: selectors[i], elem: cur, level: level });
                        }
                    }

                    cur = cur.parentNode;
                    level++;
                }

                return ret;
            }

            // String
            var pos = POS.test(selectors) || typeof selectors !== "string" ?
				jQuery(selectors, context || this.context) :
				0;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
            }

            // index in selector
            if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
            }

            // Locate the position of the desired element
            return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
				jQuery(selector, context) :
				jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
			all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
			all :
			jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, slice.call(arguments).join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
			jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [],
			cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    function createSafeFragment(document) {
        var list = nodeNames.split("|"),
	safeFrag = document.createDocumentFragment();

        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(
				list.pop()
			);
            }
        }
        return safeFrag;
    }

    var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
    // checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        area: [1, "<map>", "</map>"],
        _default: [0, "", ""]
    },
	safeFragment = createSafeFragment(document);

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);

                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
				contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery.clean(arguments);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery.clean(arguments));
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnoInnerhtml.test(value) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
			!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);

                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling,
					parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.length ?
				this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
				this;
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, fragment, parent,
			value = args[0],
			scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {
                        callback.call(
						table ?
							root(this[i], first) :
							this[i],
                        // Make sure that we do not leak memory by inadvertently discarding
                        // the original fragment (which might have attached data) instead of
                        // using it; in addition, use the original fragment object for the last
                        // item instead of first because it can end up being emptied incorrectly
                        // in certain situations (Bug #8070).
                        // Fragments from the fragment cache must always be cloned and never used
                        // in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone(fragment, true, true) :
							fragment
					);
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var type, i, l,
		oldData = jQuery._data(src),
		curData = jQuery._data(dest, oldData),
		events = oldData.events;

        if (events) {
            delete curData.handle;
            curData.events = {};

            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                }
            }
        }

        // make the cloned public data object a copy from the original
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if (nodeName === "object") {
            dest.outerHTML = src.outerHTML;

        } else if (nodeName === "input" && (src.type === "checkbox" || src.type === "radio")) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if (src.checked) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults, doc,
	first = args[0];

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if (nodes && nodes[0]) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if (!doc.createDocumentFragment) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
        if (args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test(first) &&
		(jQuery.support.checkClone || !rchecked.test(first)) &&
		(jQuery.support.html5Clone || !rnoshimcache.test(first))) {

            cacheable = true;

            cacheresults = jQuery.fragments[first];
            if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[first] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [],
			insert = jQuery(selector),
			parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if (typeof elem.getElementsByTagName !== "undefined") {
            return elem.getElementsByTagName("*");

        } else if (typeof elem.querySelectorAll !== "undefined") {
            return elem.querySelectorAll("*");

        } else {
            return[];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (elem.type === "checkbox" || elem.type === "radio") {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs(elem) {
        var nodeName = (elem.nodeName || "").toLowerCase();
        if (nodeName === "input") {
            fixDefaultChecked(elem);
            // Skip scripts, get other children
        } else if (nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined") {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
        }
    }

    // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
    function shimCloneNode(elem) {
        var div = document.createElement("div");
        safeFragment.appendChild(div);

        div.innerHTML = elem.outerHTML;
        return div.firstChild;
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var srcElements,
			destElements,
			i,
            // IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test("<" + elem.nodeName) ?
				elem.cloneNode(true) :
				shimCloneNode(elem);

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        cloneFixAttributes(srcElements[i], destElements[i]);
                    }
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [], j;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[tag] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

                        // Append wrapper element to unknown element safe doc fragment
                        if (context === document) {
                            // Use the fragment we've already created for this document
                            safeFragment.appendChild(div);
                        } else {
                            // Use a fragment created with the owner document
                            createSafeFragment(context).appendChild(div);
                        }

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

                            // String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

                            for (j = tbody.length - 1; j >= 0 ; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                    if (elem[0] && typeof (len = elem.length) === "number") {
                        for (j = 0; j < len; j++) {
                            findInputs(elem[j]);
                        }
                    } else {
                        findInputs(elem);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                checkScriptType = function (elem) {
                    return !elem.type || rscriptType.test(elem.type);
                };
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if (data.handle) {
                            data.handle.elem = null;
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "/*$0*/"));
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }




    var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
    // fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = ["Left", "Right"],
	cssHeight = ["Top", "Bottom"],
	curCSS,

	getComputedStyle,
	currentStyle;

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
			jQuery.style(elem, name, value) :
			jQuery.css(elem, name);
        });
    };

    jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
        // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase(name),
			style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (+(ret[1] + 1) * +ret[2]) + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if (value == null || type === "number" && isNaN(value)) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase(name);
            hooks = jQuery.cssHooks[name];
            name = jQuery.cssProps[name] || name;

            // cssFloat needs a special treatment
            if (name === "cssFloat") {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        return getWH(elem, name, extra);
                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val;
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "") {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute("filter");

                    // if there there is no filter style applied in a css rule, we are done
                    if (currentStyle && !currentStyle.filter) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				filter + " " + opacity;
            }
        };
    }

    jQuery(function () {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    var ret;
                    jQuery.swap(elem, { "display": "inline-block" }, function () {
                        if (computed) {
                            ret = curCSS(elem, "margin-right", "marginRight");
                        } else {
                            ret = elem.style.marginRight;
                        }
                    });
                    return ret;
                }
            };
        }
    });

    if (document.defaultView && document.defaultView.getComputedStyle) {
        getComputedStyle = function (elem, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if ((defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };
    }

    if (document.documentElement.currentStyle) {
        currentStyle = function (elem, name) {
            var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[name],
			style = elem.style;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if (ret === null && style && (uncomputed = style[name])) {
                ret = uncomputed;
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {

                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH(elem, name, extra) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

        if (val > 0) {
            if (extra !== "border") {
                for (; i < len; i++) {
                    if (!extra) {
                        val -= parseFloat(jQuery.css(elem, "padding" + which[i])) || 0;
                    }
                    if (extra === "margin") {
                        val += parseFloat(jQuery.css(elem, extra + which[i])) || 0;
                    } else {
                        val -= parseFloat(jQuery.css(elem, "border" + which[i] + "Width")) || 0;
                    }
                }
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, name);
        if (val < 0 || val == null) {
            val = elem.style[name] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;

        // Add padding, border, margin
        if (extra) {
            for (; i < len; i++) {
                val += parseFloat(jQuery.css(elem, "padding" + which[i])) || 0;
                if (extra !== "padding") {
                    val += parseFloat(jQuery.css(elem, "border" + which[i] + "Width")) || 0;
                }
                if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + which[i])) || 0;
                }
            }
        }

        return val + "px";
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth,
			height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    // #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

    // Keep a copy of the old load method
	_load = jQuery.fn.load,

    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

    // Document location
	ajaxLocation,

    // Document location segments
	ajaxLocParts,

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if (jQuery.isFunction(func)) {
                var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var list = structure[dataType],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = (structure === prefilters),
		selection;

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
    }

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function (jqXHR, status, responseText) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if (jqXHR.isResolved()) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function (r) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html(selector ?
                        // Create a dummy div to hold the results
						jQuery("<div>")
                        // inject the contents of the document in, removing the scripts
                        // to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

                        // Locate the specified elements
							.find(selector) :

                        // If not, just inject the full result
						responseText);
                    }

                    if (callback) {
                        self.each(callback, [responseText, status, jqXHR]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
		.filter(function () {
                return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
            })
		.map(function (i, elem) {
                var val = jQuery(this).val();

                return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map(val, function (val, i) {
                    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                }) :
                { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.on(o, f);
        };
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (settings) {
                // Building a settings object
                ajaxExtend(target, jQuery.ajaxSettings);
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend(target, settings);
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

            // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
			s = jQuery.ajaxSetup({}, options),
            // Callbacks context
			callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				(callbackContext.nodeType || callbackContext instanceof jQuery) ?
						jQuery(callbackContext) : jQuery.event,
            // Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
			statusCode = s.statusCode || {},
            // ifModified key
			ifModifiedKey,
            // Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
            // Response headers
			responseHeadersString,
			responseHeaders,
            // transport
			transport,
            // timeout handle
			timeoutTimer,
            // Cross-domain detection vars
			parts,
            // The jqXHR state
			state = 0,
            // To know if global events are to be dispatched
			fireGlobals,
            // Loop variable
			i,
            // Fake xhr
			jqXHR = {

                readyState: 0,

                // Caches the header
                setRequestHeader: function (name, value) {
                    if (!state) {
                        var lname = name.toLowerCase();
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },

                // Raw string
                getAllResponseHeaders: function () {
                    return state === 2 ? responseHeadersString : null;
                },

                // Builds headers hashtable if needed
                getResponseHeader: function (key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while ((match = rheaders.exec(responseHeadersString))) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match === undefined ? null : match;
                },

                // Overrides response content-type header
                overrideMimeType: function (type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Cancel the request
                abort: function (statusText) {
                    statusText = statusText || "abort";
                    if (transport) {
                        transport.abort(statusText);
                    }
                    done(0, statusText);
                    return this;
                }
            };

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, nativeStatusText, responses, headers) {

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,
				lastModified,
				etag;

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        if ((lastModified = jqXHR.getResponseHeader("Last-Modified"))) {
                            jQuery.lastModified[ifModifiedKey] = lastModified;
                        }
                        if ((etag = jqXHR.getResponseHeader("Etag"))) {
                            jQuery.etag[ifModifiedKey] = etag;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        try {
                            success = ajaxConvert(s, response);
                            statusText = "success";
                            isSuccess = true;
                        } catch (e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = "" + (nativeStatusText || statusText);

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
						[jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            // Status-dependent callbacks
            jqXHR.statusCode = function (map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.then(tmp, tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

            // Determine if a cross-domain request is in order
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
				(parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] ||
					(parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
						(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
			);
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefiler, stop there
            if (state === 2) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                    // try replacing _= if it is there
					ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
				s.accepts["*"]
		);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [],
			add = function (key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : value;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            // Serialize object item.
            for (var name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

    // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0]in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
        // Current and previous dataTypes
		current = dataTypes[0],
		prev,
        // Conversion expression
		conversion,
        // Conversion function
		conv,
        // Conversion functions (transitive conversion)
		conv1,
		conv2;

        // For each dataType in the chain
        for (i = 1; i < length; i++) {

            // Create converters map
            // with lowercased keys
            if (i === 1) {
                for (key in s.converters) {
                    if (typeof key === "string") {
                        converters[key.toLowerCase()] = s.converters[key];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[i];

            // If current is auto dataType, update it to prev
            if (current === "*") {
                current = prev;
                // If no auto and dataTypes are actually different
            } else if (prev !== "*" && prev !== current) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[conversion] || converters["* " + current];

                // If there is no direct converter, search transitively
                if (!conv) {
                    conv2 = undefined;
                    for (conv1 in converters) {
                        tmp = conv1.split(" ");
                        if (tmp[0] === prev || tmp[0] === "*") {
                            conv2 = converters[tmp[1] + " " + current];
                            if (conv2) {
                                conv1 = converters[conv1];
                                if (conv1 === true) {
                                    conv = conv2;
                                } else if (conv2 === true) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if (!(conv || conv2)) {
                    jQuery.error("No conversion from " + conversion.replace(" ", " to "));
                }
                // If found converter is not an equivalence
                if (conv !== true) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv(response) : conv2(conv1(response));
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            return jQuery.expando + "_" + (jsc++);
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		(typeof s.data === "string");

        if (s.dataTypes[0] === "jsonp" ||
		s.jsonp !== false && (jsre.test(s.url) ||
				inspectData && jsre.test(s.data))) {

            var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[jsonpCallback],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

            if (s.jsonp !== false) {
                url = url.replace(jsre, replace);
                if (s.url === url) {
                    if (inspectData) {
                        data = data.replace(jsre, replace);
                    }
                    if (s.data === data) {
                        // Add callback manually
                        url += (/\?/.test(url) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[jsonpCallback] = function (response) {
                responseContainer = [response];
            };

            // Clean-up function
            jqXHR.always(function () {
                // Set callback back to previous value
                window[jsonpCallback] = previous;
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(previous)) {
                    window[jsonpCallback](responseContainer[0]);
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(jsonpCallback + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Delegate to script
            return "script";
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
			head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function (_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function () {
        // Abort all pending requests
        for (var key in xhrCallbacks) {
            xhrCallbacks[key](0, 1);
        }
    } : false,
	xhrId = 0,
	xhrCallbacks;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) { }
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function () {
        return !this.isLocal && createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

    // Determine support properties
    (function (xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function (s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function (headers, complete) {

                        // Get a new xhr
                        var xhr = s.xhr(),
						handle,
						i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) { }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function (_, isAbort) {

                            var status,
							statusText,
							responseHeaders,
							responses,
							xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }
                                        responses.text = xhr.responseText;

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if (!s.async || xhr.readyState === 4) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
    // height animations
		["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
    // width animations
		["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
    // opacity animations
		["opacity"]
	],
	fxNow;

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            var elem, display;

            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!jQuery._data(elem, "olddisplay") && display === "none") {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (display === "" && jQuery.css(elem, "display") === "none") {
                            jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        if (display === "" || display === "none") {
                            elem.style.display = jQuery._data(elem, "olddisplay") || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                var elem, display,
				i = 0,
				j = this.length;

                for (; i < j; i++) {
                    elem = this[i];
                    if (elem.style) {
                        display = jQuery.css(elem, "display");

                        if (display !== "none" && !jQuery._data(elem, "olddisplay")) {
                            jQuery._data(elem, "olddisplay", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    if (this[i].style) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend({}, prop);

            function doAnimation() {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                    jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                    // property name normalization
                    name = jQuery.camelCase(p);
                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                    }

                    val = prop[name];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if (jQuery.isArray(val)) {
                        opt.animatedProperties[name] = val[1];
                        val = prop[name] = val[0];
                    } else {
                        opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                    }

                    if (val === "hide" && hidden || val === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (name === "height" || name === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height animated
                        if (jQuery.css(this, "display") === "inline" &&
							jQuery.css(this, "float") === "none") {

                            // inline-level elements accept inline-block;
                            // block-level elements need to be inline with layout
                            if (!jQuery.support.inlineBlockNeedsLayout || defaultDisplay(this.nodeName) === "inline") {
                                this.style.display = "inline-block";

                            } else {
                                this.style.zoom = 1;
                            }
                        }
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                for (p in prop) {
                    e = new jQuery.fx(this, opt, p);
                    val = prop[p];

                    if (rfxtypes.test(val)) {

                        // Tracks whether to show or hide based on private
                        // data attached to the element
                        method = jQuery._data(this, "toggle" + p) || (val === "toggle" ? hidden ? "show" : "hide" : 0);
                        if (method) {
                            jQuery._data(this, "toggle" + p, method === "show" ? "hide" : "show");
                            e[method]();
                        } else {
                            e[val]();
                        }

                    } else {
                        parts = rfxnum.exec(val);
                        start = e.cur();

                        if (parts) {
                            end = parseFloat(parts[2]);
                            unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style(this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                }

                // For JS strict compliance
                return true;
            }

            return optall.queue === false ?
			this.each(doAnimation) :
			this.queue(optall.queue, doAnimation);
        },

        stop: function (type, clearQueue, gotoEnd) {
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data(this);

                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                    jQuery._unmark(true, this);
                }

                function stopQueue(elem, data, index) {
                    var hooks = data[index];
                    jQuery.removeData(elem, index, true);
                    hooks.stop(gotoEnd);
                }

                if (type == null) {
                    for (index in data) {
                        if (data[index] && data[index].stop && index.indexOf(".run") === index.length - 4) {
                            stopQueue(this, data, index);
                        }
                    }
                } else if (data[index = type + ".run"] && data[index].stop) {
                    stopQueue(this, data, index);
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        if (gotoEnd) {

                            // force the next step to be the last
                            timers[index](true);
                        } else {
                            timers[index].saveState();
                        }
                        hadTimers = true;
                        timers.splice(index, 1);
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (!(gotoEnd && hadTimers)) {
                    jQuery.dequeue(this, type);
                }
            });
        }

    });

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(clearFxNow, 0);
        return (fxNow = jQuery.now());
    }

    function clearFxNow() {
        fxNow = undefined;
    }

    // Generate parameters to create a standard animation
    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
				jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // normalize opt.queue - true/undefined/null -> "fx"
            if (opt.queue == null || opt.queue === true) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }

                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue);
                } else if (noUnmark !== false) {
                    jQuery._unmark(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
    // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var parsed,
			r = jQuery.css(this.elem, this.prop);
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN(parsed = parseFloat(r)) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            var self = this,
			fx = jQuery.fx;

            this.startTime = fxNow || createFxNow();
            this.end = to;
            this.now = this.start = from;
            this.pos = this.state = 0;
            this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");

            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.queue = this.options.queue;
            t.elem = this.elem;
            t.saveState = function () {
                if (self.options.hide && jQuery._data(self.elem, "fxshow" + self.prop) === undefined) {
                    jQuery._data(self.elem, "fxshow" + self.prop, self.start);
                }
            };

            if (t() && jQuery.timers.push(t) && !timerId) {
                timerId = setInterval(fx.tick, fx.interval);
            }
        },

        // Simple 'show' function
        show: function () {
            var dataShow = jQuery._data(this.elem, "fxshow" + this.prop);

            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = dataShow || jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any flash of content
            if (dataShow !== undefined) {
                // This show is picking up where a previous hide or show left off
                this.custom(this.cur(), dataShow);
            } else {
                this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
            }

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery._data(this.elem, "fxshow" + this.prop) || jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

            if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (p in options.animatedProperties) {
                    if (options.animatedProperties[p] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (options.hide) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (options.hide || options.show) {
                        for (p in options.animatedProperties) {
                            jQuery.style(elem, p, options.orig[p]);
                            jQuery.removeData(elem, "fxshow" + p, true);
                            // Toggle data is no longer needed
                            jQuery.removeData(elem, "toggle" + p, true);
                        }
                    }

                    // Execute the complete function
                    // in the event that the complete function throws an exception
                    // we must ensure it won't be called twice. #5684

                    complete = options.complete;
                    if (complete) {

                        options.complete = false;
                        complete.call(elem);
                    }
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            var timer,
			timers = jQuery.timers,
			i = 0;

            for (; i < timers.length; i++) {
                timer = timers[i];
                // Checks the timer has not already been removed
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = fx.now + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    // Adds width/height step functions
    // Do not set anything below 0
    jQuery.each(["width", "height"], function (i, prop) {
        jQuery.fx.step[prop] = function (fx) {
            jQuery.style(fx.elem, prop, Math.max(0, fx.now) + fx.unit);
        };
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    // Try to restore the default display value of an element
    function defaultDisplay(nodeName) {

        if (!elemdisplay[nodeName]) {

            var body = document.body,
			elem = jQuery("<" + nodeName + ">").appendTo(body),
			display = elem.css("display");
            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if (display === "none" || display === "") {
                // No iframe to use yet, so create it
                if (!iframe) {
                    iframe = document.createElement("iframe");
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild(iframe);

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if (!iframeDoc || !iframe.createElement) {
                    iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                    iframeDoc.write((document.compatMode === "CSS1Compat" ? "<!doctype html>" : "") + "<html><body>");
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement(nodeName);

                iframeDoc.body.appendChild(elem);

                display = jQuery.css(elem, "display");
                body.removeChild(iframe);
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                box = elem.getBoundingClientRect();
            } catch (e) { }

            var doc = elem.ownerDocument,
			docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
            }

            var body = doc.body,
			win = getWindow(doc),
			clientTop = docElem.clientTop || body.clientTop || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top = box.top + scrollTop - clientTop,
			left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.support.fixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.support.fixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {

        bodyOffset: function (body) {
            var top = body.offsetTop,
			left = body.offsetLeft;

            if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css(elem, "top"),
			curCSSLeft = jQuery.css(elem, "left"),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({

        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

            // Get *real* offsetParent
		offsetParent = this.offsetParent(),

            // Get correct offsets
		offset = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem, win;

            if (val === undefined) {
                elem = this[0];

                if (!elem) {
                    return null;
                }

                win = getWindow(elem);

                // Return the scroll offset
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
				jQuery.support.boxModel && win.document.documentElement[method] ||
					win.document.body[method] :
				elem[method];
            }

            // Set the scroll offset
            return this.each(function () {
                win = getWindow(this);

                if (win) {
                    win.scrollTo(
					!i ? val : jQuery(win).scrollLeft(),
					 i ? val : jQuery(win).scrollTop()
				);

                } else {
                    this[method] = val;
                }
            });
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
    }




    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            var elem = this[0];
            return elem ?
			elem.style ?
			parseFloat(jQuery.css(elem, type, "padding")) :
			this[type]() :
			null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            var elem = this[0];
            return elem ?
			elem.style ?
			parseFloat(jQuery.css(elem, type, margin ? "margin" : "border")) :
			this[type]() :
			null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name],
				body = elem.document.body;
                return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body["client" + name] || docElemProp;

                // Get document width or height
            } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

                // Get or set width or height on the element
            } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
				ret = parseFloat(orig);

                return jQuery.isNumeric(ret) ? ret : orig;

                // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
            }
        };

    });




    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

    // Expose jQuery as an AMD module, but only for AMD loaders that
    // understand the issues with loading multiple versions of jQuery
    // in a page that all might call define(). The loader will indicate
    // they have special allowances for multiple jQuery versions by
    // specifying define.amd.jQuery = true. Register as a named module,
    // since jQuery can be concatenated with other files that may use define,
    // but not use a proper concatenation script that understands anonymous
    // AMD modules. A named AMD is safest and most robust way to register.
    // Lowercase jquery is used because AMD module names are derived from
    // file names, and jQuery is normally delivered in a lowercase file name.
    // Do this after creating the global so that if an AMD module wants to call
    // noConflict to hide this version of jQuery, it will work.
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define("jquery", [], function () { return jQuery; });
    }

})(window);

;
/*!
 * jQuery UI 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a,b){var d=a.nodeName.toLowerCase();if("area"===d){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&l(a)}return(/input|select|textarea|button|object/.test(d)?!a.disabled:"a"==d?a.href||b:b)&&l(a)}function l(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.16",
keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({propAttr:c.fn.prop||c.fn.attr,_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=
this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,
"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":
"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,m,n){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(m)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(n)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,
outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){return k(a,!isNaN(c.attr(a,"tabindex")))},tabbable:function(a){var b=c.attr(a,
"tabindex"),d=isNaN(b);return(d||b>=0)&&k(a,!d)}});c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&
a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&
c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)try{b(d).triggerHandler("remove")}catch(e){}k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){try{b(this).triggerHandler("remove")}catch(d){}});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=
function(h){return!!b.data(h,a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):
d;if(e&&d.charAt(0)==="_")return h;e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=
b.extend(true,{},this.options,this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+
"-disabled ui-state-disabled")},widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",
c);return this},enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(b){var d=false;b(document).mouseup(function(){d=false});b.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(c){return a._mouseDown(c)}).bind("click."+this.widgetName,function(c){if(true===b.data(c.target,a.widgetName+".preventClickEvent")){b.removeData(c.target,a.widgetName+".preventClickEvent");c.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+
this.widgetName)},_mouseDown:function(a){if(!d){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var c=this,f=a.which==1,g=typeof this.options.cancel=="string"&&a.target.nodeName?b(a.target).closest(this.options.cancel).length:false;if(!f||g||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){c.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=
this._mouseStart(a)!==false;if(!this._mouseStarted){a.preventDefault();return true}}true===b.data(a.target,this.widgetName+".preventClickEvent")&&b.removeData(a.target,this.widgetName+".preventClickEvent");this._mouseMoveDelegate=function(e){return c._mouseMove(e)};this._mouseUpDelegate=function(e){return c._mouseUp(e)};b(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return d=true}},_mouseMove:function(a){if(b.browser.msie&&
!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){b(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=
false;a.target==this._mouseDownEvent.target&&b.data(a.target,this.widgetName+".preventClickEvent",true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Position 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function(c){c.ui=c.ui||{};var n=/left|center|right/,o=/top|center|bottom/,t=c.fn.position,u=c.fn.offset;c.fn.position=function(b){if(!b||!b.of)return t.apply(this,arguments);b=c.extend({},b);var a=c(b.of),d=a[0],g=(b.collision||"flip").split(" "),e=b.offset?b.offset.split(" "):[0,0],h,k,j;if(d.nodeType===9){h=a.width();k=a.height();j={top:0,left:0}}else if(d.setTimeout){h=a.width();k=a.height();j={top:a.scrollTop(),left:a.scrollLeft()}}else if(d.preventDefault){b.at="left top";h=k=0;j={top:b.of.pageY,
left:b.of.pageX}}else{h=a.outerWidth();k=a.outerHeight();j=a.offset()}c.each(["my","at"],function(){var f=(b[this]||"").split(" ");if(f.length===1)f=n.test(f[0])?f.concat(["center"]):o.test(f[0])?["center"].concat(f):["center","center"];f[0]=n.test(f[0])?f[0]:"center";f[1]=o.test(f[1])?f[1]:"center";b[this]=f});if(g.length===1)g[1]=g[0];e[0]=parseInt(e[0],10)||0;if(e.length===1)e[1]=e[0];e[1]=parseInt(e[1],10)||0;if(b.at[0]==="right")j.left+=h;else if(b.at[0]==="center")j.left+=h/2;if(b.at[1]==="bottom")j.top+=
k;else if(b.at[1]==="center")j.top+=k/2;j.left+=e[0];j.top+=e[1];return this.each(function(){var f=c(this),l=f.outerWidth(),m=f.outerHeight(),p=parseInt(c.curCSS(this,"marginLeft",true))||0,q=parseInt(c.curCSS(this,"marginTop",true))||0,v=l+p+(parseInt(c.curCSS(this,"marginRight",true))||0),w=m+q+(parseInt(c.curCSS(this,"marginBottom",true))||0),i=c.extend({},j),r;if(b.my[0]==="right")i.left-=l;else if(b.my[0]==="center")i.left-=l/2;if(b.my[1]==="bottom")i.top-=m;else if(b.my[1]==="center")i.top-=
m/2;i.left=Math.round(i.left);i.top=Math.round(i.top);r={left:i.left-p,top:i.top-q};c.each(["left","top"],function(s,x){c.ui.position[g[s]]&&c.ui.position[g[s]][x](i,{targetWidth:h,targetHeight:k,elemWidth:l,elemHeight:m,collisionPosition:r,collisionWidth:v,collisionHeight:w,offset:e,my:b.my,at:b.at})});c.fn.bgiframe&&f.bgiframe();f.offset(c.extend(i,{using:b.using}))})};c.ui.position={fit:{left:function(b,a){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();b.left=
d>0?b.left-d:Math.max(b.left-a.collisionPosition.left,b.left)},top:function(b,a){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();b.top=d>0?b.top-d:Math.max(b.top-a.collisionPosition.top,b.top)}},flip:{left:function(b,a){if(a.at[0]!=="center"){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();var g=a.my[0]==="left"?-a.elemWidth:a.my[0]==="right"?a.elemWidth:0,e=a.at[0]==="left"?a.targetWidth:-a.targetWidth,h=-2*a.offset[0];b.left+=
a.collisionPosition.left<0?g+e+h:d>0?g+e+h:0}},top:function(b,a){if(a.at[1]!=="center"){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();var g=a.my[1]==="top"?-a.elemHeight:a.my[1]==="bottom"?a.elemHeight:0,e=a.at[1]==="top"?a.targetHeight:-a.targetHeight,h=-2*a.offset[1];b.top+=a.collisionPosition.top<0?g+e+h:d>0?g+e+h:0}}}};if(!c.offset.setOffset){c.offset.setOffset=function(b,a){if(/static/.test(c.curCSS(b,"position")))b.style.position="relative";var d=c(b),
g=d.offset(),e=parseInt(c.curCSS(b,"top",true),10)||0,h=parseInt(c.curCSS(b,"left",true),10)||0;g={top:a.top-g.top+e,left:a.left-g.left+h};"using"in a?a.using.call(b,g):d.css(g)};c.fn.offset=function(b){var a=this[0];if(!a||!a.ownerDocument)return null;if(b)return this.each(function(){c.offset.setOffset(this,b)});return u.call(this)}}})(jQuery);
;/*
 * jQuery UI Draggable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.draggable",d.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:true,appendTo:"parent",axis:false,connectToSortable:false,containment:false,cursor:"auto",cursorAt:false,grid:false,handle:false,helper:"original",iframeFix:false,opacity:false,refreshPositions:false,revert:false,revertDuration:500,scope:"default",scroll:true,scrollSensitivity:20,scrollSpeed:20,snap:false,snapMode:"both",snapTolerance:20,stack:false,zIndex:false},_create:function(){if(this.options.helper==
"original"&&!/^(?:r|a|f)/.test(this.element.css("position")))this.element[0].style.position="relative";this.options.addClasses&&this.element.addClass("ui-draggable");this.options.disabled&&this.element.addClass("ui-draggable-disabled");this._mouseInit()},destroy:function(){if(this.element.data("draggable")){this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");this._mouseDestroy();return this}},_mouseCapture:function(a){var b=
this.options;if(this.helper||b.disabled||d(a.target).is(".ui-resizable-handle"))return false;this.handle=this._getHandle(a);if(!this.handle)return false;if(b.iframeFix)d(b.iframeFix===true?"iframe":b.iframeFix).each(function(){d('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1E3}).css(d(this).offset()).appendTo("body")});return true},_mouseStart:function(a){var b=this.options;
this.helper=this._createHelper(a);this._cacheHelperProportions();if(d.ui.ddmanager)d.ui.ddmanager.current=this;this._cacheMargins();this.cssPosition=this.helper.css("position");this.scrollParent=this.helper.scrollParent();this.offset=this.positionAbs=this.element.offset();this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left};d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});
this.originalPosition=this.position=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);b.containment&&this._setContainment();if(this._trigger("start",a)===false){this._clear();return false}this._cacheHelperProportions();d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.helper.addClass("ui-draggable-dragging");this._mouseDrag(a,true);d.ui.ddmanager&&d.ui.ddmanager.dragStart(this,a);return true},
_mouseDrag:function(a,b){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!b){b=this._uiHash();if(this._trigger("drag",a,b)===false){this._mouseUp({});return false}this.position=b.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);return false},_mouseStop:function(a){var b=
false;if(d.ui.ddmanager&&!this.options.dropBehaviour)b=d.ui.ddmanager.drop(this,a);if(this.dropped){b=this.dropped;this.dropped=false}if((!this.element[0]||!this.element[0].parentNode)&&this.options.helper=="original")return false;if(this.options.revert=="invalid"&&!b||this.options.revert=="valid"&&b||this.options.revert===true||d.isFunction(this.options.revert)&&this.options.revert.call(this.element,b)){var c=this;d(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,
10),function(){c._trigger("stop",a)!==false&&c._clear()})}else this._trigger("stop",a)!==false&&this._clear();return false},_mouseUp:function(a){this.options.iframeFix===true&&d("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)});d.ui.ddmanager&&d.ui.ddmanager.dragStop(this,a);return d.ui.mouse.prototype._mouseUp.call(this,a)},cancel:function(){this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear();return this},_getHandle:function(a){var b=!this.options.handle||
!d(this.options.handle,this.element).length?true:false;d(this.options.handle,this.element).find("*").andSelf().each(function(){if(this==a.target)b=true});return b},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a])):b.helper=="clone"?this.element.clone().removeAttr("id"):this.element;a.parents("body").length||a.appendTo(b.appendTo=="parent"?this.element[0].parentNode:b.appendTo);a[0]!=this.element[0]&&!/(fixed|absolute)/.test(a.css("position"))&&
a.css("position","absolute");return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=
this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),
10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),
10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[a.containment=="document"?0:d(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,a.containment=="document"?0:d(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,
(a.containment=="document"?0:d(window).scrollLeft())+d(a.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a.containment=="document"?0:d(window).scrollTop())+(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)&&a.containment.constructor!=Array){a=d(a.containment);var b=a[0];if(b){a.offset();var c=d(b).css("overflow")!=
"hidden";this.containment=[(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0),(parseInt(d(b).css("borderTopWidth"),10)||0)+(parseInt(d(b).css("paddingTop"),10)||0),(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),
10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom];this.relative_container=a}}else if(a.containment.constructor==Array)this.containment=a.containment},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName);return{top:b.top+
this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&
!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName),e=a.pageX,h=a.pageY;if(this.originalPosition){var g;if(this.containment){if(this.relative_container){g=this.relative_container.offset();g=[this.containment[0]+g.left,this.containment[1]+g.top,this.containment[2]+g.left,this.containment[3]+g.top]}else g=this.containment;if(a.pageX-this.offset.click.left<g[0])e=g[0]+this.offset.click.left;
if(a.pageY-this.offset.click.top<g[1])h=g[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>g[2])e=g[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>g[3])h=g[3]+this.offset.click.top}if(b.grid){h=b.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/b.grid[1])*b.grid[1]:this.originalPageY;h=g?!(h-this.offset.click.top<g[1]||h-this.offset.click.top>g[3])?h:!(h-this.offset.click.top<g[1])?h-b.grid[1]:h+b.grid[1]:h;e=b.grid[0]?this.originalPageX+Math.round((e-this.originalPageX)/
b.grid[0])*b.grid[0]:this.originalPageX;e=g?!(e-this.offset.click.left<g[0]||e-this.offset.click.left>g[2])?e:!(e-this.offset.click.left<g[0])?e-b.grid[0]:e+b.grid[0]:e}}return{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop()),left:e-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&d.browser.version<
526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging");this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove();this.helper=null;this.cancelHelperRemoval=false},_trigger:function(a,b,c){c=c||this._uiHash();d.ui.plugin.call(this,a,[b,c]);if(a=="drag")this.positionAbs=this._convertPositionTo("absolute");return d.Widget.prototype._trigger.call(this,a,b,
c)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}});d.extend(d.ui.draggable,{version:"1.8.16"});d.ui.plugin.add("draggable","connectToSortable",{start:function(a,b){var c=d(this).data("draggable"),f=c.options,e=d.extend({},b,{item:c.element});c.sortables=[];d(f.connectToSortable).each(function(){var h=d.data(this,"sortable");if(h&&!h.options.disabled){c.sortables.push({instance:h,shouldRevert:h.options.revert});
h.refreshPositions();h._trigger("activate",a,e)}})},stop:function(a,b){var c=d(this).data("draggable"),f=d.extend({},b,{item:c.element});d.each(c.sortables,function(){if(this.instance.isOver){this.instance.isOver=0;c.cancelHelperRemoval=true;this.instance.cancelHelperRemoval=false;if(this.shouldRevert)this.instance.options.revert=true;this.instance._mouseStop(a);this.instance.options.helper=this.instance.options._helper;c.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})}else{this.instance.cancelHelperRemoval=
false;this.instance._trigger("deactivate",a,f)}})},drag:function(a,b){var c=d(this).data("draggable"),f=this;d.each(c.sortables,function(){this.instance.positionAbs=c.positionAbs;this.instance.helperProportions=c.helperProportions;this.instance.offset.click=c.offset.click;if(this.instance._intersectsWith(this.instance.containerCache)){if(!this.instance.isOver){this.instance.isOver=1;this.instance.currentItem=d(f).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",true);
this.instance.options._helper=this.instance.options.helper;this.instance.options.helper=function(){return b.helper[0]};a.target=this.instance.currentItem[0];this.instance._mouseCapture(a,true);this.instance._mouseStart(a,true,true);this.instance.offset.click.top=c.offset.click.top;this.instance.offset.click.left=c.offset.click.left;this.instance.offset.parent.left-=c.offset.parent.left-this.instance.offset.parent.left;this.instance.offset.parent.top-=c.offset.parent.top-this.instance.offset.parent.top;
c._trigger("toSortable",a);c.dropped=this.instance.element;c.currentItem=c.element;this.instance.fromOutside=c}this.instance.currentItem&&this.instance._mouseDrag(a)}else if(this.instance.isOver){this.instance.isOver=0;this.instance.cancelHelperRemoval=true;this.instance.options.revert=false;this.instance._trigger("out",a,this.instance._uiHash(this.instance));this.instance._mouseStop(a,true);this.instance.options.helper=this.instance.options._helper;this.instance.currentItem.remove();this.instance.placeholder&&
this.instance.placeholder.remove();c._trigger("fromSortable",a);c.dropped=false}})}});d.ui.plugin.add("draggable","cursor",{start:function(){var a=d("body"),b=d(this).data("draggable").options;if(a.css("cursor"))b._cursor=a.css("cursor");a.css("cursor",b.cursor)},stop:function(){var a=d(this).data("draggable").options;a._cursor&&d("body").css("cursor",a._cursor)}});d.ui.plugin.add("draggable","opacity",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("opacity"))b._opacity=
a.css("opacity");a.css("opacity",b.opacity)},stop:function(a,b){a=d(this).data("draggable").options;a._opacity&&d(b.helper).css("opacity",a._opacity)}});d.ui.plugin.add("draggable","scroll",{start:function(){var a=d(this).data("draggable");if(a.scrollParent[0]!=document&&a.scrollParent[0].tagName!="HTML")a.overflowOffset=a.scrollParent.offset()},drag:function(a){var b=d(this).data("draggable"),c=b.options,f=false;if(b.scrollParent[0]!=document&&b.scrollParent[0].tagName!="HTML"){if(!c.axis||c.axis!=
"x")if(b.overflowOffset.top+b.scrollParent[0].offsetHeight-a.pageY<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop+c.scrollSpeed;else if(a.pageY-b.overflowOffset.top<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop-c.scrollSpeed;if(!c.axis||c.axis!="y")if(b.overflowOffset.left+b.scrollParent[0].offsetWidth-a.pageX<c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft+c.scrollSpeed;else if(a.pageX-b.overflowOffset.left<
c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft-c.scrollSpeed}else{if(!c.axis||c.axis!="x")if(a.pageY-d(document).scrollTop()<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()-c.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()+c.scrollSpeed);if(!c.axis||c.axis!="y")if(a.pageX-d(document).scrollLeft()<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()-
c.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()+c.scrollSpeed)}f!==false&&d.ui.ddmanager&&!c.dropBehaviour&&d.ui.ddmanager.prepareOffsets(b,a)}});d.ui.plugin.add("draggable","snap",{start:function(){var a=d(this).data("draggable"),b=a.options;a.snapElements=[];d(b.snap.constructor!=String?b.snap.items||":data(draggable)":b.snap).each(function(){var c=d(this),f=c.offset();this!=a.element[0]&&a.snapElements.push({item:this,
width:c.outerWidth(),height:c.outerHeight(),top:f.top,left:f.left})})},drag:function(a,b){for(var c=d(this).data("draggable"),f=c.options,e=f.snapTolerance,h=b.offset.left,g=h+c.helperProportions.width,n=b.offset.top,o=n+c.helperProportions.height,i=c.snapElements.length-1;i>=0;i--){var j=c.snapElements[i].left,l=j+c.snapElements[i].width,k=c.snapElements[i].top,m=k+c.snapElements[i].height;if(j-e<h&&h<l+e&&k-e<n&&n<m+e||j-e<h&&h<l+e&&k-e<o&&o<m+e||j-e<g&&g<l+e&&k-e<n&&n<m+e||j-e<g&&g<l+e&&k-e<o&&
o<m+e){if(f.snapMode!="inner"){var p=Math.abs(k-o)<=e,q=Math.abs(m-n)<=e,r=Math.abs(j-g)<=e,s=Math.abs(l-h)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k-c.helperProportions.height,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j-c.helperProportions.width}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l}).left-c.margins.left}var t=
p||q||r||s;if(f.snapMode!="outer"){p=Math.abs(k-n)<=e;q=Math.abs(m-o)<=e;r=Math.abs(j-h)<=e;s=Math.abs(l-g)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m-c.helperProportions.height,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l-c.helperProportions.width}).left-c.margins.left}if(!c.snapElements[i].snapping&&
(p||q||r||s||t))c.options.snap.snap&&c.options.snap.snap.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=p||q||r||s||t}else{c.snapElements[i].snapping&&c.options.snap.release&&c.options.snap.release.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=false}}}});d.ui.plugin.add("draggable","stack",{start:function(){var a=d(this).data("draggable").options;a=d.makeArray(d(a.stack)).sort(function(c,f){return(parseInt(d(c).css("zIndex"),
10)||0)-(parseInt(d(f).css("zIndex"),10)||0)});if(a.length){var b=parseInt(a[0].style.zIndex)||0;d(a).each(function(c){this.style.zIndex=b+c});this[0].style.zIndex=b+a.length}}});d.ui.plugin.add("draggable","zIndex",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("zIndex"))b._zIndex=a.css("zIndex");a.css("zIndex",b.zIndex)},stop:function(a,b){a=d(this).data("draggable").options;a._zIndex&&d(b.helper).css("zIndex",a._zIndex)}})})(jQuery);
;/*
 * jQuery UI Droppable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function(d){d.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:false,addClasses:true,greedy:false,hoverClass:false,scope:"default",tolerance:"intersect"},_create:function(){var a=this.options,b=a.accept;this.isover=0;this.isout=1;this.accept=d.isFunction(b)?b:function(c){return c.is(b)};this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight};d.ui.ddmanager.droppables[a.scope]=d.ui.ddmanager.droppables[a.scope]||[];d.ui.ddmanager.droppables[a.scope].push(this);
a.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){for(var a=d.ui.ddmanager.droppables[this.options.scope],b=0;b<a.length;b++)a[b]==this&&a.splice(b,1);this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable");return this},_setOption:function(a,b){if(a=="accept")this.accept=d.isFunction(b)?b:function(c){return c.is(b)};d.Widget.prototype._setOption.apply(this,arguments)},_activate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&
this.element.addClass(this.options.activeClass);b&&this._trigger("activate",a,this.ui(b))},_deactivate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass);b&&this._trigger("deactivate",a,this.ui(b))},_over:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.addClass(this.options.hoverClass);
this._trigger("over",a,this.ui(b))}},_out:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("out",a,this.ui(b))}},_drop:function(a,b){var c=b||d.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return false;var e=false;this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var g=
d.data(this,"droppable");if(g.options.greedy&&!g.options.disabled&&g.options.scope==c.options.scope&&g.accept.call(g.element[0],c.currentItem||c.element)&&d.ui.intersect(c,d.extend(g,{offset:g.element.offset()}),g.options.tolerance)){e=true;return false}});if(e)return false;if(this.accept.call(this.element[0],c.currentItem||c.element)){this.options.activeClass&&this.element.removeClass(this.options.activeClass);this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("drop",
a,this.ui(c));return this.element}return false},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}});d.extend(d.ui.droppable,{version:"1.8.16"});d.ui.intersect=function(a,b,c){if(!b.offset)return false;var e=(a.positionAbs||a.position.absolute).left,g=e+a.helperProportions.width,f=(a.positionAbs||a.position.absolute).top,h=f+a.helperProportions.height,i=b.offset.left,k=i+b.proportions.width,j=b.offset.top,l=j+b.proportions.height;
switch(c){case "fit":return i<=e&&g<=k&&j<=f&&h<=l;case "intersect":return i<e+a.helperProportions.width/2&&g-a.helperProportions.width/2<k&&j<f+a.helperProportions.height/2&&h-a.helperProportions.height/2<l;case "pointer":return d.ui.isOver((a.positionAbs||a.position.absolute).top+(a.clickOffset||a.offset.click).top,(a.positionAbs||a.position.absolute).left+(a.clickOffset||a.offset.click).left,j,i,b.proportions.height,b.proportions.width);case "touch":return(f>=j&&f<=l||h>=j&&h<=l||f<j&&h>l)&&(e>=
i&&e<=k||g>=i&&g<=k||e<i&&g>k);default:return false}};d.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(a,b){var c=d.ui.ddmanager.droppables[a.options.scope]||[],e=b?b.type:null,g=(a.currentItem||a.element).find(":data(droppable)").andSelf(),f=0;a:for(;f<c.length;f++)if(!(c[f].options.disabled||a&&!c[f].accept.call(c[f].element[0],a.currentItem||a.element))){for(var h=0;h<g.length;h++)if(g[h]==c[f].element[0]){c[f].proportions.height=0;continue a}c[f].visible=c[f].element.css("display")!=
"none";if(c[f].visible){e=="mousedown"&&c[f]._activate.call(c[f],b);c[f].offset=c[f].element.offset();c[f].proportions={width:c[f].element[0].offsetWidth,height:c[f].element[0].offsetHeight}}}},drop:function(a,b){var c=false;d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(this.options){if(!this.options.disabled&&this.visible&&d.ui.intersect(a,this,this.options.tolerance))c=c||this._drop.call(this,b);if(!this.options.disabled&&this.visible&&this.accept.call(this.element[0],a.currentItem||
a.element)){this.isout=1;this.isover=0;this._deactivate.call(this,b)}}});return c},dragStart:function(a,b){a.element.parents(":not(body,html)").bind("scroll.droppable",function(){a.options.refreshPositions||d.ui.ddmanager.prepareOffsets(a,b)})},drag:function(a,b){a.options.refreshPositions&&d.ui.ddmanager.prepareOffsets(a,b);d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(!(this.options.disabled||this.greedyChild||!this.visible)){var c=d.ui.intersect(a,this,this.options.tolerance);
if(c=!c&&this.isover==1?"isout":c&&this.isover==0?"isover":null){var e;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");if(g.length){e=d.data(g[0],"droppable");e.greedyChild=c=="isover"?1:0}}if(e&&c=="isover"){e.isover=0;e.isout=1;e._out.call(e,b)}this[c]=1;this[c=="isout"?"isover":"isout"]=0;this[c=="isover"?"_over":"_out"].call(this,b);if(e&&c=="isout"){e.isout=0;e.isover=1;e._over.call(e,b)}}}})},dragStop:function(a,b){a.element.parents(":not(body,html)").unbind("scroll.droppable");
a.options.refreshPositions||d.ui.ddmanager.prepareOffsets(a,b)}}})(jQuery);
;/*
 * jQuery UI Resizable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.resizable",e.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:false,animate:false,animateDuration:"slow",animateEasing:"swing",aspectRatio:false,autoHide:false,containment:false,ghost:false,grid:false,handles:"e,s,se",helper:false,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1E3},_create:function(){var b=this,a=this.options;this.element.addClass("ui-resizable");e.extend(this,{_aspectRatio:!!a.aspectRatio,aspectRatio:a.aspectRatio,originalElement:this.element,
_proportionallyResizeElements:[],_helper:a.helper||a.ghost||a.animate?a.helper||"ui-resizable-helper":null});if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)){/relative/.test(this.element.css("position"))&&e.browser.opera&&this.element.css({position:"relative",top:"auto",left:"auto"});this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),
top:this.element.css("top"),left:this.element.css("left")}));this.element=this.element.parent().data("resizable",this.element.data("resizable"));this.elementIsWrapper=true;this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")});this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0});this.originalResizeStyle=
this.originalElement.css("resize");this.originalElement.css("resize","none");this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"}));this.originalElement.css({margin:this.originalElement.css("margin")});this._proportionallyResize()}this.handles=a.handles||(!e(".ui-resizable-handle",this.element).length?"e,s,se":{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",
nw:".ui-resizable-nw"});if(this.handles.constructor==String){if(this.handles=="all")this.handles="n,e,s,w,se,sw,ne,nw";var c=this.handles.split(",");this.handles={};for(var d=0;d<c.length;d++){var f=e.trim(c[d]),g=e('<div class="ui-resizable-handle '+("ui-resizable-"+f)+'"></div>');/sw|se|ne|nw/.test(f)&&g.css({zIndex:++a.zIndex});"se"==f&&g.addClass("ui-icon ui-icon-gripsmall-diagonal-se");this.handles[f]=".ui-resizable-"+f;this.element.append(g)}}this._renderAxis=function(h){h=h||this.element;for(var i in this.handles){if(this.handles[i].constructor==
String)this.handles[i]=e(this.handles[i],this.element).show();if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var j=e(this.handles[i],this.element),l=0;l=/sw|ne|nw|se|n|s/.test(i)?j.outerHeight():j.outerWidth();j=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join("");h.css(j,l);this._proportionallyResize()}e(this.handles[i])}};this._renderAxis(this.element);this._handles=e(".ui-resizable-handle",this.element).disableSelection();
this._handles.mouseover(function(){if(!b.resizing){if(this.className)var h=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=h&&h[1]?h[1]:"se"}});if(a.autoHide){this._handles.hide();e(this.element).addClass("ui-resizable-autohide").hover(function(){if(!a.disabled){e(this).removeClass("ui-resizable-autohide");b._handles.show()}},function(){if(!a.disabled)if(!b.resizing){e(this).addClass("ui-resizable-autohide");b._handles.hide()}})}this._mouseInit()},destroy:function(){this._mouseDestroy();
var b=function(c){e(c).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var a=this.element;a.after(this.originalElement.css({position:a.css("position"),width:a.outerWidth(),height:a.outerHeight(),top:a.css("top"),left:a.css("left")})).remove()}this.originalElement.css("resize",this.originalResizeStyle);b(this.originalElement);return this},_mouseCapture:function(b){var a=
false;for(var c in this.handles)if(e(this.handles[c])[0]==b.target)a=true;return!this.options.disabled&&a},_mouseStart:function(b){var a=this.options,c=this.element.position(),d=this.element;this.resizing=true;this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()};if(d.is(".ui-draggable")||/absolute/.test(d.css("position")))d.css({position:"absolute",top:c.top,left:c.left});e.browser.opera&&/relative/.test(d.css("position"))&&d.css({position:"relative",top:"auto",left:"auto"});
this._renderProxy();c=m(this.helper.css("left"));var f=m(this.helper.css("top"));if(a.containment){c+=e(a.containment).scrollLeft()||0;f+=e(a.containment).scrollTop()||0}this.offset=this.helper.offset();this.position={left:c,top:f};this.size=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalSize=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalPosition={left:c,top:f};this.sizeDiff=
{width:d.outerWidth()-d.width(),height:d.outerHeight()-d.height()};this.originalMousePosition={left:b.pageX,top:b.pageY};this.aspectRatio=typeof a.aspectRatio=="number"?a.aspectRatio:this.originalSize.width/this.originalSize.height||1;a=e(".ui-resizable-"+this.axis).css("cursor");e("body").css("cursor",a=="auto"?this.axis+"-resize":a);d.addClass("ui-resizable-resizing");this._propagate("start",b);return true},_mouseDrag:function(b){var a=this.helper,c=this.originalMousePosition,d=this._change[this.axis];
if(!d)return false;c=d.apply(this,[b,b.pageX-c.left||0,b.pageY-c.top||0]);this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)c=this._updateRatio(c,b);c=this._respectSize(c,b);this._propagate("resize",b);a.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"});!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize();this._updateCache(c);this._trigger("resize",b,this.ui());return false},
_mouseStop:function(b){this.resizing=false;var a=this.options,c=this;if(this._helper){var d=this._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName);d=f&&e.ui.hasScroll(d[0],"left")?0:c.sizeDiff.height;f=f?0:c.sizeDiff.width;f={width:c.helper.width()-f,height:c.helper.height()-d};d=parseInt(c.element.css("left"),10)+(c.position.left-c.originalPosition.left)||null;var g=parseInt(c.element.css("top"),10)+(c.position.top-c.originalPosition.top)||null;a.animate||this.element.css(e.extend(f,
{top:g,left:d}));c.helper.height(c.size.height);c.helper.width(c.size.width);this._helper&&!a.animate&&this._proportionallyResize()}e("body").css("cursor","auto");this.element.removeClass("ui-resizable-resizing");this._propagate("stop",b);this._helper&&this.helper.remove();return false},_updateVirtualBoundaries:function(b){var a=this.options,c,d,f;a={minWidth:k(a.minWidth)?a.minWidth:0,maxWidth:k(a.maxWidth)?a.maxWidth:Infinity,minHeight:k(a.minHeight)?a.minHeight:0,maxHeight:k(a.maxHeight)?a.maxHeight:
Infinity};if(this._aspectRatio||b){b=a.minHeight*this.aspectRatio;d=a.minWidth/this.aspectRatio;c=a.maxHeight*this.aspectRatio;f=a.maxWidth/this.aspectRatio;if(b>a.minWidth)a.minWidth=b;if(d>a.minHeight)a.minHeight=d;if(c<a.maxWidth)a.maxWidth=c;if(f<a.maxHeight)a.maxHeight=f}this._vBoundaries=a},_updateCache:function(b){this.offset=this.helper.offset();if(k(b.left))this.position.left=b.left;if(k(b.top))this.position.top=b.top;if(k(b.height))this.size.height=b.height;if(k(b.width))this.size.width=
b.width},_updateRatio:function(b){var a=this.position,c=this.size,d=this.axis;if(k(b.height))b.width=b.height*this.aspectRatio;else if(k(b.width))b.height=b.width/this.aspectRatio;if(d=="sw"){b.left=a.left+(c.width-b.width);b.top=null}if(d=="nw"){b.top=a.top+(c.height-b.height);b.left=a.left+(c.width-b.width)}return b},_respectSize:function(b){var a=this._vBoundaries,c=this.axis,d=k(b.width)&&a.maxWidth&&a.maxWidth<b.width,f=k(b.height)&&a.maxHeight&&a.maxHeight<b.height,g=k(b.width)&&a.minWidth&&
a.minWidth>b.width,h=k(b.height)&&a.minHeight&&a.minHeight>b.height;if(g)b.width=a.minWidth;if(h)b.height=a.minHeight;if(d)b.width=a.maxWidth;if(f)b.height=a.maxHeight;var i=this.originalPosition.left+this.originalSize.width,j=this.position.top+this.size.height,l=/sw|nw|w/.test(c);c=/nw|ne|n/.test(c);if(g&&l)b.left=i-a.minWidth;if(d&&l)b.left=i-a.maxWidth;if(h&&c)b.top=j-a.minHeight;if(f&&c)b.top=j-a.maxHeight;if((a=!b.width&&!b.height)&&!b.left&&b.top)b.top=null;else if(a&&!b.top&&b.left)b.left=
null;return b},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var b=this.helper||this.element,a=0;a<this._proportionallyResizeElements.length;a++){var c=this._proportionallyResizeElements[a];if(!this.borderDif){var d=[c.css("borderTopWidth"),c.css("borderRightWidth"),c.css("borderBottomWidth"),c.css("borderLeftWidth")],f=[c.css("paddingTop"),c.css("paddingRight"),c.css("paddingBottom"),c.css("paddingLeft")];this.borderDif=e.map(d,function(g,h){g=parseInt(g,10)||
0;h=parseInt(f[h],10)||0;return g+h})}e.browser.msie&&(e(b).is(":hidden")||e(b).parents(":hidden").length)||c.css({height:b.height()-this.borderDif[0]-this.borderDif[2]||0,width:b.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var b=this.options;this.elementOffset=this.element.offset();if(this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var a=e.browser.msie&&e.browser.version<7,c=a?1:0;a=a?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+
a,height:this.element.outerHeight()+a,position:"absolute",left:this.elementOffset.left-c+"px",top:this.elementOffset.top-c+"px",zIndex:++b.zIndex});this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(b,a){return{width:this.originalSize.width+a}},w:function(b,a){return{left:this.originalPosition.left+a,width:this.originalSize.width-a}},n:function(b,a,c){return{top:this.originalPosition.top+c,height:this.originalSize.height-c}},s:function(b,a,c){return{height:this.originalSize.height+
c}},se:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},sw:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,a,c]))},ne:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},nw:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,a,c]))}},_propagate:function(b,a){e.ui.plugin.call(this,b,[a,this.ui()]);
b!="resize"&&this._trigger(b,a,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}});e.extend(e.ui.resizable,{version:"1.8.16"});e.ui.plugin.add("resizable","alsoResize",{start:function(){var b=e(this).data("resizable").options,a=function(c){e(c).each(function(){var d=e(this);d.data("resizable-alsoresize",{width:parseInt(d.width(),
10),height:parseInt(d.height(),10),left:parseInt(d.css("left"),10),top:parseInt(d.css("top"),10),position:d.css("position")})})};if(typeof b.alsoResize=="object"&&!b.alsoResize.parentNode)if(b.alsoResize.length){b.alsoResize=b.alsoResize[0];a(b.alsoResize)}else e.each(b.alsoResize,function(c){a(c)});else a(b.alsoResize)},resize:function(b,a){var c=e(this).data("resizable");b=c.options;var d=c.originalSize,f=c.originalPosition,g={height:c.size.height-d.height||0,width:c.size.width-d.width||0,top:c.position.top-
f.top||0,left:c.position.left-f.left||0},h=function(i,j){e(i).each(function(){var l=e(this),q=e(this).data("resizable-alsoresize"),p={},r=j&&j.length?j:l.parents(a.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(r,function(n,o){if((n=(q[o]||0)+(g[o]||0))&&n>=0)p[o]=n||null});if(e.browser.opera&&/relative/.test(l.css("position"))){c._revertToRelativePosition=true;l.css({position:"absolute",top:"auto",left:"auto"})}l.css(p)})};typeof b.alsoResize=="object"&&!b.alsoResize.nodeType?
e.each(b.alsoResize,function(i,j){h(i,j)}):h(b.alsoResize)},stop:function(){var b=e(this).data("resizable"),a=b.options,c=function(d){e(d).each(function(){var f=e(this);f.css({position:f.data("resizable-alsoresize").position})})};if(b._revertToRelativePosition){b._revertToRelativePosition=false;typeof a.alsoResize=="object"&&!a.alsoResize.nodeType?e.each(a.alsoResize,function(d){c(d)}):c(a.alsoResize)}e(this).removeData("resizable-alsoresize")}});e.ui.plugin.add("resizable","animate",{stop:function(b){var a=
e(this).data("resizable"),c=a.options,d=a._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName),g=f&&e.ui.hasScroll(d[0],"left")?0:a.sizeDiff.height;f={width:a.size.width-(f?0:a.sizeDiff.width),height:a.size.height-g};g=parseInt(a.element.css("left"),10)+(a.position.left-a.originalPosition.left)||null;var h=parseInt(a.element.css("top"),10)+(a.position.top-a.originalPosition.top)||null;a.element.animate(e.extend(f,h&&g?{top:h,left:g}:{}),{duration:c.animateDuration,easing:c.animateEasing,
step:function(){var i={width:parseInt(a.element.css("width"),10),height:parseInt(a.element.css("height"),10),top:parseInt(a.element.css("top"),10),left:parseInt(a.element.css("left"),10)};d&&d.length&&e(d[0]).css({width:i.width,height:i.height});a._updateCache(i);a._propagate("resize",b)}})}});e.ui.plugin.add("resizable","containment",{start:function(){var b=e(this).data("resizable"),a=b.element,c=b.options.containment;if(a=c instanceof e?c.get(0):/parent/.test(c)?a.parent().get(0):c){b.containerElement=
e(a);if(/document/.test(c)||c==document){b.containerOffset={left:0,top:0};b.containerPosition={left:0,top:0};b.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}}else{var d=e(a),f=[];e(["Top","Right","Left","Bottom"]).each(function(i,j){f[i]=m(d.css("padding"+j))});b.containerOffset=d.offset();b.containerPosition=d.position();b.containerSize={height:d.innerHeight()-f[3],width:d.innerWidth()-f[1]};c=b.containerOffset;
var g=b.containerSize.height,h=b.containerSize.width;h=e.ui.hasScroll(a,"left")?a.scrollWidth:h;g=e.ui.hasScroll(a)?a.scrollHeight:g;b.parentData={element:a,left:c.left,top:c.top,width:h,height:g}}}},resize:function(b){var a=e(this).data("resizable"),c=a.options,d=a.containerOffset,f=a.position;b=a._aspectRatio||b.shiftKey;var g={top:0,left:0},h=a.containerElement;if(h[0]!=document&&/static/.test(h.css("position")))g=d;if(f.left<(a._helper?d.left:0)){a.size.width+=a._helper?a.position.left-d.left:
a.position.left-g.left;if(b)a.size.height=a.size.width/c.aspectRatio;a.position.left=c.helper?d.left:0}if(f.top<(a._helper?d.top:0)){a.size.height+=a._helper?a.position.top-d.top:a.position.top;if(b)a.size.width=a.size.height*c.aspectRatio;a.position.top=a._helper?d.top:0}a.offset.left=a.parentData.left+a.position.left;a.offset.top=a.parentData.top+a.position.top;c=Math.abs((a._helper?a.offset.left-g.left:a.offset.left-g.left)+a.sizeDiff.width);d=Math.abs((a._helper?a.offset.top-g.top:a.offset.top-
d.top)+a.sizeDiff.height);f=a.containerElement.get(0)==a.element.parent().get(0);g=/relative|absolute/.test(a.containerElement.css("position"));if(f&&g)c-=a.parentData.left;if(c+a.size.width>=a.parentData.width){a.size.width=a.parentData.width-c;if(b)a.size.height=a.size.width/a.aspectRatio}if(d+a.size.height>=a.parentData.height){a.size.height=a.parentData.height-d;if(b)a.size.width=a.size.height*a.aspectRatio}},stop:function(){var b=e(this).data("resizable"),a=b.options,c=b.containerOffset,d=b.containerPosition,
f=b.containerElement,g=e(b.helper),h=g.offset(),i=g.outerWidth()-b.sizeDiff.width;g=g.outerHeight()-b.sizeDiff.height;b._helper&&!a.animate&&/relative/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g});b._helper&&!a.animate&&/static/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g})}});e.ui.plugin.add("resizable","ghost",{start:function(){var b=e(this).data("resizable"),a=b.options,c=b.size;b.ghost=b.originalElement.clone();b.ghost.css({opacity:0.25,
display:"block",position:"relative",height:c.height,width:c.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof a.ghost=="string"?a.ghost:"");b.ghost.appendTo(b.helper)},resize:function(){var b=e(this).data("resizable");b.ghost&&b.ghost.css({position:"relative",height:b.size.height,width:b.size.width})},stop:function(){var b=e(this).data("resizable");b.ghost&&b.helper&&b.helper.get(0).removeChild(b.ghost.get(0))}});e.ui.plugin.add("resizable","grid",{resize:function(){var b=
e(this).data("resizable"),a=b.options,c=b.size,d=b.originalSize,f=b.originalPosition,g=b.axis;a.grid=typeof a.grid=="number"?[a.grid,a.grid]:a.grid;var h=Math.round((c.width-d.width)/(a.grid[0]||1))*(a.grid[0]||1);a=Math.round((c.height-d.height)/(a.grid[1]||1))*(a.grid[1]||1);if(/^(se|s|e)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a}else if(/^(ne)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}else{if(/^(sw)$/.test(g)){b.size.width=d.width+h;b.size.height=
d.height+a}else{b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}b.position.left=f.left-h}}});var m=function(b){return parseInt(b,10)||0},k=function(b){return!isNaN(parseInt(b,10))}})(jQuery);
;/*
 * jQuery UI Selectable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.selectable",e.ui.mouse,{options:{appendTo:"body",autoRefresh:true,distance:0,filter:"*",tolerance:"touch"},_create:function(){var c=this;this.element.addClass("ui-selectable");this.dragged=false;var f;this.refresh=function(){f=e(c.options.filter,c.element[0]);f.each(function(){var d=e(this),b=d.offset();e.data(this,"selectable-item",{element:this,$element:d,left:b.left,top:b.top,right:b.left+d.outerWidth(),bottom:b.top+d.outerHeight(),startselected:false,selected:d.hasClass("ui-selected"),
selecting:d.hasClass("ui-selecting"),unselecting:d.hasClass("ui-unselecting")})})};this.refresh();this.selectees=f.addClass("ui-selectee");this._mouseInit();this.helper=e("<div class='ui-selectable-helper'></div>")},destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item");this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable");this._mouseDestroy();return this},_mouseStart:function(c){var f=this;this.opos=[c.pageX,
c.pageY];if(!this.options.disabled){var d=this.options;this.selectees=e(d.filter,this.element[0]);this._trigger("start",c);e(d.appendTo).append(this.helper);this.helper.css({left:c.clientX,top:c.clientY,width:0,height:0});d.autoRefresh&&this.refresh();this.selectees.filter(".ui-selected").each(function(){var b=e.data(this,"selectable-item");b.startselected=true;if(!c.metaKey){b.$element.removeClass("ui-selected");b.selected=false;b.$element.addClass("ui-unselecting");b.unselecting=true;f._trigger("unselecting",
c,{unselecting:b.element})}});e(c.target).parents().andSelf().each(function(){var b=e.data(this,"selectable-item");if(b){var g=!c.metaKey||!b.$element.hasClass("ui-selected");b.$element.removeClass(g?"ui-unselecting":"ui-selected").addClass(g?"ui-selecting":"ui-unselecting");b.unselecting=!g;b.selecting=g;(b.selected=g)?f._trigger("selecting",c,{selecting:b.element}):f._trigger("unselecting",c,{unselecting:b.element});return false}})}},_mouseDrag:function(c){var f=this;this.dragged=true;if(!this.options.disabled){var d=
this.options,b=this.opos[0],g=this.opos[1],h=c.pageX,i=c.pageY;if(b>h){var j=h;h=b;b=j}if(g>i){j=i;i=g;g=j}this.helper.css({left:b,top:g,width:h-b,height:i-g});this.selectees.each(function(){var a=e.data(this,"selectable-item");if(!(!a||a.element==f.element[0])){var k=false;if(d.tolerance=="touch")k=!(a.left>h||a.right<b||a.top>i||a.bottom<g);else if(d.tolerance=="fit")k=a.left>b&&a.right<h&&a.top>g&&a.bottom<i;if(k){if(a.selected){a.$element.removeClass("ui-selected");a.selected=false}if(a.unselecting){a.$element.removeClass("ui-unselecting");
a.unselecting=false}if(!a.selecting){a.$element.addClass("ui-selecting");a.selecting=true;f._trigger("selecting",c,{selecting:a.element})}}else{if(a.selecting)if(c.metaKey&&a.startselected){a.$element.removeClass("ui-selecting");a.selecting=false;a.$element.addClass("ui-selected");a.selected=true}else{a.$element.removeClass("ui-selecting");a.selecting=false;if(a.startselected){a.$element.addClass("ui-unselecting");a.unselecting=true}f._trigger("unselecting",c,{unselecting:a.element})}if(a.selected)if(!c.metaKey&&
!a.startselected){a.$element.removeClass("ui-selected");a.selected=false;a.$element.addClass("ui-unselecting");a.unselecting=true;f._trigger("unselecting",c,{unselecting:a.element})}}}});return false}},_mouseStop:function(c){var f=this;this.dragged=false;e(".ui-unselecting",this.element[0]).each(function(){var d=e.data(this,"selectable-item");d.$element.removeClass("ui-unselecting");d.unselecting=false;d.startselected=false;f._trigger("unselected",c,{unselected:d.element})});e(".ui-selecting",this.element[0]).each(function(){var d=
e.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected");d.selecting=false;d.selected=true;d.startselected=true;f._trigger("selected",c,{selected:d.element})});this._trigger("stop",c);this.helper.remove();return false}});e.extend(e.ui.selectable,{version:"1.8.16"})})(jQuery);
;/*
 * jQuery UI Sortable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.sortable",d.ui.mouse,{widgetEventPrefix:"sort",options:{appendTo:"parent",axis:false,connectWith:false,containment:false,cursor:"auto",cursorAt:false,dropOnEmpty:true,forcePlaceholderSize:false,forceHelperSize:false,grid:false,handle:false,helper:"original",items:"> *",opacity:false,placeholder:false,revert:false,scroll:true,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1E3},_create:function(){var a=this.options;this.containerCache={};this.element.addClass("ui-sortable");
this.refresh();this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):false;this.offset=this.element.offset();this._mouseInit()},destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").removeData("sortable").unbind(".sortable");this._mouseDestroy();for(var a=this.items.length-1;a>=0;a--)this.items[a].item.removeData("sortable-item");return this},_setOption:function(a,b){if(a===
"disabled"){this.options[a]=b;this.widget()[b?"addClass":"removeClass"]("ui-sortable-disabled")}else d.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(a,b){if(this.reverting)return false;if(this.options.disabled||this.options.type=="static")return false;this._refreshItems(a);var c=null,e=this;d(a.target).parents().each(function(){if(d.data(this,"sortable-item")==e){c=d(this);return false}});if(d.data(a.target,"sortable-item")==e)c=d(a.target);if(!c)return false;if(this.options.handle&&
!b){var f=false;d(this.options.handle,c).find("*").andSelf().each(function(){if(this==a.target)f=true});if(!f)return false}this.currentItem=c;this._removeCurrentsFromItems();return true},_mouseStart:function(a,b,c){b=this.options;var e=this;this.currentContainer=this;this.refreshPositions();this.helper=this._createHelper(a);this._cacheHelperProportions();this._cacheMargins();this.scrollParent=this.helper.scrollParent();this.offset=this.currentItem.offset();this.offset={top:this.offset.top-this.margins.top,
left:this.offset.left-this.margins.left};this.helper.css("position","absolute");this.cssPosition=this.helper.css("position");d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]};
this.helper[0]!=this.currentItem[0]&&this.currentItem.hide();this._createPlaceholder();b.containment&&this._setContainment();if(b.cursor){if(d("body").css("cursor"))this._storedCursor=d("body").css("cursor");d("body").css("cursor",b.cursor)}if(b.opacity){if(this.helper.css("opacity"))this._storedOpacity=this.helper.css("opacity");this.helper.css("opacity",b.opacity)}if(b.zIndex){if(this.helper.css("zIndex"))this._storedZIndex=this.helper.css("zIndex");this.helper.css("zIndex",b.zIndex)}if(this.scrollParent[0]!=
document&&this.scrollParent[0].tagName!="HTML")this.overflowOffset=this.scrollParent.offset();this._trigger("start",a,this._uiHash());this._preserveHelperProportions||this._cacheHelperProportions();if(!c)for(c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("activate",a,e._uiHash(this));if(d.ui.ddmanager)d.ui.ddmanager.current=this;d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.dragging=true;this.helper.addClass("ui-sortable-helper");this._mouseDrag(a);
return true},_mouseDrag:function(a){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!this.lastPositionAbs)this.lastPositionAbs=this.positionAbs;if(this.options.scroll){var b=this.options,c=false;if(this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"){if(this.overflowOffset.top+this.scrollParent[0].offsetHeight-a.pageY<b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop+b.scrollSpeed;else if(a.pageY-this.overflowOffset.top<
b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop-b.scrollSpeed;if(this.overflowOffset.left+this.scrollParent[0].offsetWidth-a.pageX<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft+b.scrollSpeed;else if(a.pageX-this.overflowOffset.left<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft-b.scrollSpeed}else{if(a.pageY-d(document).scrollTop()<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()-
b.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()+b.scrollSpeed);if(a.pageX-d(document).scrollLeft()<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()-b.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()+b.scrollSpeed)}c!==false&&d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,
a)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(b=this.items.length-1;b>=0;b--){c=this.items[b];var e=c.item[0],f=this._intersectsWithPointer(c);if(f)if(e!=this.currentItem[0]&&this.placeholder[f==1?"next":"prev"]()[0]!=e&&!d.ui.contains(this.placeholder[0],e)&&(this.options.type=="semi-dynamic"?!d.ui.contains(this.element[0],
e):true)){this.direction=f==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(c))this._rearrange(a,c);else break;this._trigger("change",a,this._uiHash());break}}this._contactContainers(a);d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);this._trigger("sort",a,this._uiHash());this.lastPositionAbs=this.positionAbs;return false},_mouseStop:function(a,b){if(a){d.ui.ddmanager&&!this.options.dropBehaviour&&d.ui.ddmanager.drop(this,a);if(this.options.revert){var c=this;b=c.placeholder.offset();
c.reverting=true;d(this.helper).animate({left:b.left-this.offset.parent.left-c.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:b.top-this.offset.parent.top-c.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){c._clear(a)})}else this._clear(a,b);return false}},cancel:function(){var a=this;if(this.dragging){this._mouseUp({target:null});this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):
this.currentItem.show();for(var b=this.containers.length-1;b>=0;b--){this.containers[b]._trigger("deactivate",null,a._uiHash(this));if(this.containers[b].containerCache.over){this.containers[b]._trigger("out",null,a._uiHash(this));this.containers[b].containerCache.over=0}}}if(this.placeholder){this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove();d.extend(this,{helper:null,
dragging:false,reverting:false,_noFinalSort:null});this.domPosition.prev?d(this.domPosition.prev).after(this.currentItem):d(this.domPosition.parent).prepend(this.currentItem)}return this},serialize:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};d(b).each(function(){var e=(d(a.item||this).attr(a.attribute||"id")||"").match(a.expression||/(.+)[-=_](.+)/);if(e)c.push((a.key||e[1]+"[]")+"="+(a.key&&a.expression?e[1]:e[2]))});!c.length&&a.key&&c.push(a.key+"=");return c.join("&")},
toArray:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};b.each(function(){c.push(d(a.item||this).attr(a.attribute||"id")||"")});return c},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,e=this.positionAbs.top,f=e+this.helperProportions.height,g=a.left,h=g+a.width,i=a.top,k=i+a.height,j=this.offset.click.top,l=this.offset.click.left;j=e+j>i&&e+j<k&&b+l>g&&b+l<h;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||
this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?j:g<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<h&&i<e+this.helperProportions.height/2&&f-this.helperProportions.height/2<k},_intersectsWithPointer:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left,a.width);b=b&&a;a=this._getDragVerticalDirection();
var c=this._getDragHorizontalDirection();if(!b)return false;return this.floating?c&&c=="right"||a=="down"?2:1:a&&(a=="down"?2:1)},_intersectsWithSides:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top+a.height/2,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left+a.width/2,a.width);var c=this._getDragVerticalDirection(),e=this._getDragHorizontalDirection();return this.floating&&e?e=="right"&&a||e=="left"&&!a:c&&(c=="down"&&b||c=="up"&&!b)},
_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){this._refreshItems(a);this.refreshPositions();return this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(a){var b=[],c=[],e=this._connectWith();
if(e&&a)for(a=e.length-1;a>=0;a--)for(var f=d(e[a]),g=f.length-1;g>=0;g--){var h=d.data(f[g],"sortable");if(h&&h!=this&&!h.options.disabled)c.push([d.isFunction(h.options.items)?h.options.items.call(h.element):d(h.options.items,h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),h])}c.push([d.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):d(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),
this]);for(a=c.length-1;a>=0;a--)c[a][0].each(function(){b.push(this)});return d(b)},_removeCurrentsFromItems:function(){for(var a=this.currentItem.find(":data(sortable-item)"),b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(a){this.items=[];this.containers=[this];var b=this.items,c=[[d.isFunction(this.options.items)?this.options.items.call(this.element[0],a,{item:this.currentItem}):d(this.options.items,this.element),
this]],e=this._connectWith();if(e)for(var f=e.length-1;f>=0;f--)for(var g=d(e[f]),h=g.length-1;h>=0;h--){var i=d.data(g[h],"sortable");if(i&&i!=this&&!i.options.disabled){c.push([d.isFunction(i.options.items)?i.options.items.call(i.element[0],a,{item:this.currentItem}):d(i.options.items,i.element),i]);this.containers.push(i)}}for(f=c.length-1;f>=0;f--){a=c[f][1];e=c[f][0];h=0;for(g=e.length;h<g;h++){i=d(e[h]);i.data("sortable-item",a);b.push({item:i,instance:a,width:0,height:0,left:0,top:0})}}},refreshPositions:function(a){if(this.offsetParent&&
this.helper)this.offset.parent=this._getParentOffset();for(var b=this.items.length-1;b>=0;b--){var c=this.items[b];if(!(c.instance!=this.currentContainer&&this.currentContainer&&c.item[0]!=this.currentItem[0])){var e=this.options.toleranceElement?d(this.options.toleranceElement,c.item):c.item;if(!a){c.width=e.outerWidth();c.height=e.outerHeight()}e=e.offset();c.left=e.left;c.top=e.top}}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(b=
this.containers.length-1;b>=0;b--){e=this.containers[b].element.offset();this.containers[b].containerCache.left=e.left;this.containers[b].containerCache.top=e.top;this.containers[b].containerCache.width=this.containers[b].element.outerWidth();this.containers[b].containerCache.height=this.containers[b].element.outerHeight()}return this},_createPlaceholder:function(a){var b=a||this,c=b.options;if(!c.placeholder||c.placeholder.constructor==String){var e=c.placeholder;c.placeholder={element:function(){var f=
d(document.createElement(b.currentItem[0].nodeName)).addClass(e||b.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];if(!e)f.style.visibility="hidden";return f},update:function(f,g){if(!(e&&!c.forcePlaceholderSize)){g.height()||g.height(b.currentItem.innerHeight()-parseInt(b.currentItem.css("paddingTop")||0,10)-parseInt(b.currentItem.css("paddingBottom")||0,10));g.width()||g.width(b.currentItem.innerWidth()-parseInt(b.currentItem.css("paddingLeft")||0,10)-parseInt(b.currentItem.css("paddingRight")||
0,10))}}}}b.placeholder=d(c.placeholder.element.call(b.element,b.currentItem));b.currentItem.after(b.placeholder);c.placeholder.update(b,b.placeholder)},_contactContainers:function(a){for(var b=null,c=null,e=this.containers.length-1;e>=0;e--)if(!d.ui.contains(this.currentItem[0],this.containers[e].element[0]))if(this._intersectsWith(this.containers[e].containerCache)){if(!(b&&d.ui.contains(this.containers[e].element[0],b.element[0]))){b=this.containers[e];c=e}}else if(this.containers[e].containerCache.over){this.containers[e]._trigger("out",
a,this._uiHash(this));this.containers[e].containerCache.over=0}if(b)if(this.containers.length===1){this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}else if(this.currentContainer!=this.containers[c]){b=1E4;e=null;for(var f=this.positionAbs[this.containers[c].floating?"left":"top"],g=this.items.length-1;g>=0;g--)if(d.ui.contains(this.containers[c].element[0],this.items[g].item[0])){var h=this.items[g][this.containers[c].floating?"left":"top"];if(Math.abs(h-
f)<b){b=Math.abs(h-f);e=this.items[g]}}if(e||this.options.dropOnEmpty){this.currentContainer=this.containers[c];e?this._rearrange(a,e,null,true):this._rearrange(a,null,this.containers[c].element,true);this._trigger("change",a,this._uiHash());this.containers[c]._trigger("change",a,this._uiHash(this));this.options.placeholder.update(this.currentContainer,this.placeholder);this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}}},_createHelper:function(a){var b=
this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a,this.currentItem])):b.helper=="clone"?this.currentItem.clone():this.currentItem;a.parents("body").length||d(b.appendTo!="parent"?b.appendTo:this.currentItem[0].parentNode)[0].appendChild(a[0]);if(a[0]==this.currentItem[0])this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")};if(a[0].style.width==
""||b.forceHelperSize)a.width(this.currentItem.width());if(a[0].style.height==""||b.forceHelperSize)a.height(this.currentItem.height());return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=
this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a=
{top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),
10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,d(a.containment=="document"?
document:window).width()-this.helperProportions.width-this.margins.left,(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)){var b=d(a.containment)[0];a=d(a.containment).offset();var c=d(b).css("overflow")!="hidden";this.containment=[a.left+(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css("borderTopWidth"),
10)||0)+(parseInt(d(b).css("paddingTop"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(a,b){if(!b)b=
this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&
this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);if(this.cssPosition=="relative"&&!(this.scrollParent[0]!=document&&this.scrollParent[0]!=this.offsetParent[0]))this.offset.relative=this._getRelativeOffset();
var f=a.pageX,g=a.pageY;if(this.originalPosition){if(this.containment){if(a.pageX-this.offset.click.left<this.containment[0])f=this.containment[0]+this.offset.click.left;if(a.pageY-this.offset.click.top<this.containment[1])g=this.containment[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>this.containment[2])f=this.containment[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>this.containment[3])g=this.containment[3]+this.offset.click.top}if(b.grid){g=this.originalPageY+Math.round((g-
this.originalPageY)/b.grid[1])*b.grid[1];g=this.containment?!(g-this.offset.click.top<this.containment[1]||g-this.offset.click.top>this.containment[3])?g:!(g-this.offset.click.top<this.containment[1])?g-b.grid[1]:g+b.grid[1]:g;f=this.originalPageX+Math.round((f-this.originalPageX)/b.grid[0])*b.grid[0];f=this.containment?!(f-this.offset.click.left<this.containment[0]||f-this.offset.click.left>this.containment[2])?f:!(f-this.offset.click.left<this.containment[0])?f-b.grid[0]:f+b.grid[0]:f}}return{top:g-
this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())}},_rearrange:function(a,b,c,e){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],
this.direction=="down"?b.item[0]:b.item[0].nextSibling);this.counter=this.counter?++this.counter:1;var f=this,g=this.counter;window.setTimeout(function(){g==f.counter&&f.refreshPositions(!e)},0)},_clear:function(a,b){this.reverting=false;var c=[];!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem);this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var e in this._storedCSS)if(this._storedCSS[e]=="auto"||this._storedCSS[e]=="static")this._storedCSS[e]=
"";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!b&&c.push(function(f){this._trigger("receive",f,this._uiHash(this.fromOutside))});if((this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!b)c.push(function(f){this._trigger("update",f,this._uiHash())});if(!d.ui.contains(this.element[0],this.currentItem[0])){b||c.push(function(f){this._trigger("remove",
f,this._uiHash())});for(e=this.containers.length-1;e>=0;e--)if(d.ui.contains(this.containers[e].element[0],this.currentItem[0])&&!b){c.push(function(f){return function(g){f._trigger("receive",g,this._uiHash(this))}}.call(this,this.containers[e]));c.push(function(f){return function(g){f._trigger("update",g,this._uiHash(this))}}.call(this,this.containers[e]))}}for(e=this.containers.length-1;e>=0;e--){b||c.push(function(f){return function(g){f._trigger("deactivate",g,this._uiHash(this))}}.call(this,
this.containers[e]));if(this.containers[e].containerCache.over){c.push(function(f){return function(g){f._trigger("out",g,this._uiHash(this))}}.call(this,this.containers[e]));this.containers[e].containerCache.over=0}}this._storedCursor&&d("body").css("cursor",this._storedCursor);this._storedOpacity&&this.helper.css("opacity",this._storedOpacity);if(this._storedZIndex)this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex);this.dragging=false;if(this.cancelHelperRemoval){if(!b){this._trigger("beforeStop",
a,this._uiHash());for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}return false}b||this._trigger("beforeStop",a,this._uiHash());this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.helper[0]!=this.currentItem[0]&&this.helper.remove();this.helper=null;if(!b){for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}this.fromOutside=false;return true},_trigger:function(){d.Widget.prototype._trigger.apply(this,arguments)===false&&this.cancel()},
_uiHash:function(a){var b=a||this;return{helper:b.helper,placeholder:b.placeholder||d([]),position:b.position,originalPosition:b.originalPosition,offset:b.positionAbs,item:b.currentItem,sender:a?a.element:null}}});d.extend(d.ui.sortable,{version:"1.8.16"})})(jQuery);
;/*
 * jQuery UI Accordion 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(c){c.widget("ui.accordion",{options:{active:0,animated:"slide",autoHeight:true,clearStyle:false,collapsible:false,event:"click",fillSpace:false,header:"> li > :first-child,> :not(li):even",icons:{header:"ui-icon-triangle-1-e",headerSelected:"ui-icon-triangle-1-s"},navigation:false,navigationFilter:function(){return this.href.toLowerCase()===location.href.toLowerCase()}},_create:function(){var a=this,b=a.options;a.running=0;a.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix");
a.headers=a.element.find(b.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion",function(){b.disabled||c(this).addClass("ui-state-hover")}).bind("mouseleave.accordion",function(){b.disabled||c(this).removeClass("ui-state-hover")}).bind("focus.accordion",function(){b.disabled||c(this).addClass("ui-state-focus")}).bind("blur.accordion",function(){b.disabled||c(this).removeClass("ui-state-focus")});a.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom");
if(b.navigation){var d=a.element.find("a").filter(b.navigationFilter).eq(0);if(d.length){var h=d.closest(".ui-accordion-header");a.active=h.length?h:d.closest(".ui-accordion-content").prev()}}a.active=a._findActive(a.active||b.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top");a.active.next().addClass("ui-accordion-content-active");a._createIcons();a.resize();a.element.attr("role","tablist");a.headers.attr("role","tab").bind("keydown.accordion",
function(f){return a._keydown(f)}).next().attr("role","tabpanel");a.headers.not(a.active||"").attr({"aria-expanded":"false","aria-selected":"false",tabIndex:-1}).next().hide();a.active.length?a.active.attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}):a.headers.eq(0).attr("tabIndex",0);c.browser.safari||a.headers.find("a").attr("tabIndex",-1);b.event&&a.headers.bind(b.event.split(" ").join(".accordion ")+".accordion",function(f){a._clickHandler.call(a,f,this);f.preventDefault()})},_createIcons:function(){var a=
this.options;if(a.icons){c("<span></span>").addClass("ui-icon "+a.icons.header).prependTo(this.headers);this.active.children(".ui-icon").toggleClass(a.icons.header).toggleClass(a.icons.headerSelected);this.element.addClass("ui-accordion-icons")}},_destroyIcons:function(){this.headers.children(".ui-icon").remove();this.element.removeClass("ui-accordion-icons")},destroy:function(){var a=this.options;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("tabIndex");
this.headers.find("a").removeAttr("tabIndex");this._destroyIcons();var b=this.headers.next().css("display","").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled");if(a.autoHeight||a.fillHeight)b.css("height","");return c.Widget.prototype.destroy.call(this)},_setOption:function(a,b){c.Widget.prototype._setOption.apply(this,arguments);a=="active"&&this.activate(b);if(a=="icons"){this._destroyIcons();
b&&this._createIcons()}if(a=="disabled")this.headers.add(this.headers.next())[b?"addClass":"removeClass"]("ui-accordion-disabled ui-state-disabled")},_keydown:function(a){if(!(this.options.disabled||a.altKey||a.ctrlKey)){var b=c.ui.keyCode,d=this.headers.length,h=this.headers.index(a.target),f=false;switch(a.keyCode){case b.RIGHT:case b.DOWN:f=this.headers[(h+1)%d];break;case b.LEFT:case b.UP:f=this.headers[(h-1+d)%d];break;case b.SPACE:case b.ENTER:this._clickHandler({target:a.target},a.target);
a.preventDefault()}if(f){c(a.target).attr("tabIndex",-1);c(f).attr("tabIndex",0);f.focus();return false}return true}},resize:function(){var a=this.options,b;if(a.fillSpace){if(c.browser.msie){var d=this.element.parent().css("overflow");this.element.parent().css("overflow","hidden")}b=this.element.parent().height();c.browser.msie&&this.element.parent().css("overflow",d);this.headers.each(function(){b-=c(this).outerHeight(true)});this.headers.next().each(function(){c(this).height(Math.max(0,b-c(this).innerHeight()+
c(this).height()))}).css("overflow","auto")}else if(a.autoHeight){b=0;this.headers.next().each(function(){b=Math.max(b,c(this).height("").height())}).height(b)}return this},activate:function(a){this.options.active=a;a=this._findActive(a)[0];this._clickHandler({target:a},a);return this},_findActive:function(a){return a?typeof a==="number"?this.headers.filter(":eq("+a+")"):this.headers.not(this.headers.not(a)):a===false?c([]):this.headers.filter(":eq(0)")},_clickHandler:function(a,b){var d=this.options;
if(!d.disabled)if(a.target){a=c(a.currentTarget||b);b=a[0]===this.active[0];d.active=d.collapsible&&b?false:this.headers.index(a);if(!(this.running||!d.collapsible&&b)){var h=this.active;j=a.next();g=this.active.next();e={options:d,newHeader:b&&d.collapsible?c([]):a,oldHeader:this.active,newContent:b&&d.collapsible?c([]):j,oldContent:g};var f=this.headers.index(this.active[0])>this.headers.index(a[0]);this.active=b?c([]):a;this._toggle(j,g,e,b,f);h.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);
if(!b){a.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(d.icons.header).addClass(d.icons.headerSelected);a.next().addClass("ui-accordion-content-active")}}}else if(d.collapsible){this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);this.active.next().addClass("ui-accordion-content-active");var g=this.active.next(),
e={options:d,newHeader:c([]),oldHeader:d.active,newContent:c([]),oldContent:g},j=this.active=c([]);this._toggle(j,g,e)}},_toggle:function(a,b,d,h,f){var g=this,e=g.options;g.toShow=a;g.toHide=b;g.data=d;var j=function(){if(g)return g._completed.apply(g,arguments)};g._trigger("changestart",null,g.data);g.running=b.size()===0?a.size():b.size();if(e.animated){d={};d=e.collapsible&&h?{toShow:c([]),toHide:b,complete:j,down:f,autoHeight:e.autoHeight||e.fillSpace}:{toShow:a,toHide:b,complete:j,down:f,autoHeight:e.autoHeight||
e.fillSpace};if(!e.proxied)e.proxied=e.animated;if(!e.proxiedDuration)e.proxiedDuration=e.duration;e.animated=c.isFunction(e.proxied)?e.proxied(d):e.proxied;e.duration=c.isFunction(e.proxiedDuration)?e.proxiedDuration(d):e.proxiedDuration;h=c.ui.accordion.animations;var i=e.duration,k=e.animated;if(k&&!h[k]&&!c.easing[k])k="slide";h[k]||(h[k]=function(l){this.slide(l,{easing:k,duration:i||700})});h[k](d)}else{if(e.collapsible&&h)a.toggle();else{b.hide();a.show()}j(true)}b.prev().attr({"aria-expanded":"false",
"aria-selected":"false",tabIndex:-1}).blur();a.prev().attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}).focus()},_completed:function(a){this.running=a?0:--this.running;if(!this.running){this.options.clearStyle&&this.toShow.add(this.toHide).css({height:"",overflow:""});this.toHide.removeClass("ui-accordion-content-active");if(this.toHide.length)this.toHide.parent()[0].className=this.toHide.parent()[0].className;this._trigger("change",null,this.data)}}});c.extend(c.ui.accordion,{version:"1.8.16",
animations:{slide:function(a,b){a=c.extend({easing:"swing",duration:300},a,b);if(a.toHide.size())if(a.toShow.size()){var d=a.toShow.css("overflow"),h=0,f={},g={},e;b=a.toShow;e=b[0].style.width;b.width(parseInt(b.parent().width(),10)-parseInt(b.css("paddingLeft"),10)-parseInt(b.css("paddingRight"),10)-(parseInt(b.css("borderLeftWidth"),10)||0)-(parseInt(b.css("borderRightWidth"),10)||0));c.each(["height","paddingTop","paddingBottom"],function(j,i){g[i]="hide";j=(""+c.css(a.toShow[0],i)).match(/^([\d+-.]+)(.*)$/);
f[i]={value:j[1],unit:j[2]||"px"}});a.toShow.css({height:0,overflow:"hidden"}).show();a.toHide.filter(":hidden").each(a.complete).end().filter(":visible").animate(g,{step:function(j,i){if(i.prop=="height")h=i.end-i.start===0?0:(i.now-i.start)/(i.end-i.start);a.toShow[0].style[i.prop]=h*f[i.prop].value+f[i.prop].unit},duration:a.duration,easing:a.easing,complete:function(){a.autoHeight||a.toShow.css("height","");a.toShow.css({width:e,overflow:d});a.complete()}})}else a.toHide.animate({height:"hide",
paddingTop:"hide",paddingBottom:"hide"},a);else a.toShow.animate({height:"show",paddingTop:"show",paddingBottom:"show"},a)},bounceslide:function(a){this.slide(a,{easing:a.down?"easeOutBounce":"swing",duration:a.down?1E3:200})}}})})(jQuery);
;/*
 * jQuery UI Autocomplete 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function(d){var e=0;d.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:false,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var a=this,b=this.element[0].ownerDocument,g;this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(!(a.options.disabled||a.element.propAttr("readOnly"))){g=
false;var f=d.ui.keyCode;switch(c.keyCode){case f.PAGE_UP:a._move("previousPage",c);break;case f.PAGE_DOWN:a._move("nextPage",c);break;case f.UP:a._move("previous",c);c.preventDefault();break;case f.DOWN:a._move("next",c);c.preventDefault();break;case f.ENTER:case f.NUMPAD_ENTER:if(a.menu.active){g=true;c.preventDefault()}case f.TAB:if(!a.menu.active)return;a.menu.select(c);break;case f.ESCAPE:a.element.val(a.term);a.close(c);break;default:clearTimeout(a.searching);a.searching=setTimeout(function(){if(a.term!=
a.element.val()){a.selectedItem=null;a.search(null,c)}},a.options.delay);break}}}).bind("keypress.autocomplete",function(c){if(g){g=false;c.preventDefault()}}).bind("focus.autocomplete",function(){if(!a.options.disabled){a.selectedItem=null;a.previous=a.element.val()}}).bind("blur.autocomplete",function(c){if(!a.options.disabled){clearTimeout(a.searching);a.closing=setTimeout(function(){a.close(c);a._change(c)},150)}});this._initSource();this.response=function(){return a._response.apply(a,arguments)};
this.menu=d("<ul></ul>").addClass("ui-autocomplete").appendTo(d(this.options.appendTo||"body",b)[0]).mousedown(function(c){var f=a.menu.element[0];d(c.target).closest(".ui-menu-item").length||setTimeout(function(){d(document).one("mousedown",function(h){h.target!==a.element[0]&&h.target!==f&&!d.ui.contains(f,h.target)&&a.close()})},1);setTimeout(function(){clearTimeout(a.closing)},13)}).menu({focus:function(c,f){f=f.item.data("item.autocomplete");false!==a._trigger("focus",c,{item:f})&&/^key/.test(c.originalEvent.type)&&
a.element.val(f.value)},selected:function(c,f){var h=f.item.data("item.autocomplete"),i=a.previous;if(a.element[0]!==b.activeElement){a.element.focus();a.previous=i;setTimeout(function(){a.previous=i;a.selectedItem=h},1)}false!==a._trigger("select",c,{item:h})&&a.element.val(h.value);a.term=a.element.val();a.close(c);a.selectedItem=h},blur:function(){a.menu.element.is(":visible")&&a.element.val()!==a.term&&a.element.val(a.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu");
d.fn.bgiframe&&this.menu.element.bgiframe()},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup");this.menu.element.remove();d.Widget.prototype.destroy.call(this)},_setOption:function(a,b){d.Widget.prototype._setOption.apply(this,arguments);a==="source"&&this._initSource();if(a==="appendTo")this.menu.element.appendTo(d(b||"body",this.element[0].ownerDocument)[0]);a==="disabled"&&
b&&this.xhr&&this.xhr.abort()},_initSource:function(){var a=this,b,g;if(d.isArray(this.options.source)){b=this.options.source;this.source=function(c,f){f(d.ui.autocomplete.filter(b,c.term))}}else if(typeof this.options.source==="string"){g=this.options.source;this.source=function(c,f){a.xhr&&a.xhr.abort();a.xhr=d.ajax({url:g,data:c,dataType:"json",autocompleteRequest:++e,success:function(h){this.autocompleteRequest===e&&f(h)},error:function(){this.autocompleteRequest===e&&f([])}})}}else this.source=
this.options.source},search:function(a,b){a=a!=null?a:this.element.val();this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)!==false)return this._search(a)},_search:function(a){this.pending++;this.element.addClass("ui-autocomplete-loading");this.source({term:a},this.response)},_response:function(a){if(!this.options.disabled&&a&&a.length){a=this._normalize(a);this._suggest(a);this._trigger("open")}else this.close();
this.pending--;this.pending||this.element.removeClass("ui-autocomplete-loading")},close:function(a){clearTimeout(this.closing);if(this.menu.element.is(":visible")){this.menu.element.hide();this.menu.deactivate();this._trigger("close",a)}},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(a){if(a.length&&a[0].label&&a[0].value)return a;return d.map(a,function(b){if(typeof b==="string")return{label:b,value:b};return d.extend({label:b.label||
b.value,value:b.value||b.label},b)})},_suggest:function(a){var b=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(b,a);this.menu.deactivate();this.menu.refresh();b.show();this._resizeMenu();b.position(d.extend({of:this.element},this.options.position));this.options.autoFocus&&this.menu.next(new d.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth(),this.element.outerWidth()))},_renderMenu:function(a,b){var g=this;
d.each(b,function(c,f){g._renderItem(a,f)})},_renderItem:function(a,b){return d("<li></li>").data("item.autocomplete",b).append(d("<a></a>").text(b.label)).appendTo(a)},_move:function(a,b){if(this.menu.element.is(":visible"))if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term);this.menu.deactivate()}else this.menu[a](b);else this.search(null,b)},widget:function(){return this.menu.element}});d.extend(d.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,
"\\$&")},filter:function(a,b){var g=new RegExp(d.ui.autocomplete.escapeRegex(b),"i");return d.grep(a,function(c){return g.test(c.label||c.value||c)})}})})(jQuery);
(function(d){d.widget("ui.menu",{_create:function(){var e=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(a){if(d(a.target).closest(".ui-menu-item a").length){a.preventDefault();e.select(a)}});this.refresh()},refresh:function(){var e=this;this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem").children("a").addClass("ui-corner-all").attr("tabindex",
-1).mouseenter(function(a){e.activate(a,d(this).parent())}).mouseleave(function(){e.deactivate()})},activate:function(e,a){this.deactivate();if(this.hasScroll()){var b=a.offset().top-this.element.offset().top,g=this.element.scrollTop(),c=this.element.height();if(b<0)this.element.scrollTop(g+b);else b>=c&&this.element.scrollTop(g+b-c+a.height())}this.active=a.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end();this._trigger("focus",e,{item:a})},deactivate:function(){if(this.active){this.active.children("a").removeClass("ui-state-hover").removeAttr("id");
this._trigger("blur");this.active=null}},next:function(e){this.move("next",".ui-menu-item:first",e)},previous:function(e){this.move("prev",".ui-menu-item:last",e)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(e,a,b){if(this.active){e=this.active[e+"All"](".ui-menu-item").eq(0);e.length?this.activate(b,e):this.activate(b,this.element.children(a))}else this.activate(b,
this.element.children(a))},nextPage:function(e){if(this.hasScroll())if(!this.active||this.last())this.activate(e,this.element.children(".ui-menu-item:first"));else{var a=this.active.offset().top,b=this.element.height(),g=this.element.children(".ui-menu-item").filter(function(){var c=d(this).offset().top-a-b+d(this).height();return c<10&&c>-10});g.length||(g=this.element.children(".ui-menu-item:last"));this.activate(e,g)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.last()?":first":":last"))},previousPage:function(e){if(this.hasScroll())if(!this.active||this.first())this.activate(e,this.element.children(".ui-menu-item:last"));else{var a=this.active.offset().top,b=this.element.height();result=this.element.children(".ui-menu-item").filter(function(){var g=d(this).offset().top-a+b-d(this).height();return g<10&&g>-10});result.length||(result=this.element.children(".ui-menu-item:first"));this.activate(e,result)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[d.fn.prop?"prop":"attr"]("scrollHeight")},select:function(e){this._trigger("selected",e,{item:this.active})}})})(jQuery);
;/*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(b){var h,i,j,g,l=function(){var a=b(this).find(":ui-button");setTimeout(function(){a.button("refresh")},1)},k=function(a){var c=a.name,e=a.form,f=b([]);if(c)f=e?b(e).find("[name='"+c+"']"):b("[name='"+c+"']",a.ownerDocument).filter(function(){return!this.form});return f};b.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",l);if(typeof this.options.disabled!==
"boolean")this.options.disabled=this.element.propAttr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var a=this,c=this.options,e=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!e?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",function(){if(!c.disabled){b(this).addClass("ui-state-hover");
this===h&&b(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||b(this).removeClass(f)}).bind("click.button",function(d){if(c.disabled){d.preventDefault();d.stopImmediatePropagation()}});this.element.bind("focus.button",function(){a.buttonElement.addClass("ui-state-focus")}).bind("blur.button",function(){a.buttonElement.removeClass("ui-state-focus")});if(e){this.element.bind("change.button",function(){g||a.refresh()});this.buttonElement.bind("mousedown.button",function(d){if(!c.disabled){g=
false;i=d.pageX;j=d.pageY}}).bind("mouseup.button",function(d){if(!c.disabled)if(i!==d.pageX||j!==d.pageY)g=true})}if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).toggleClass("ui-state-active");a.buttonElement.attr("aria-pressed",a.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).addClass("ui-state-active");a.buttonElement.attr("aria-pressed","true");
var d=a.element[0];k(d).not(d).map(function(){return b(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;b(this).addClass("ui-state-active");h=this;b(document).one("mouseup",function(){h=null})}).bind("mouseup.button",function(){if(c.disabled)return false;b(this).removeClass("ui-state-active")}).bind("keydown.button",function(d){if(c.disabled)return false;if(d.keyCode==b.ui.keyCode.SPACE||
d.keyCode==b.ui.keyCode.ENTER)b(this).addClass("ui-state-active")}).bind("keyup.button",function(){b(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(d){d.keyCode===b.ui.keyCode.SPACE&&b(this).click()})}this._setOption("disabled",c.disabled);this._resetButton()},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type===
"radio"){var a=this.element.parents().filter(":last"),c="label[for='"+this.element.attr("id")+"']";this.buttonElement=a.find(c);if(!this.buttonElement.length){a=a.length?a.siblings():this.element.siblings();this.buttonElement=a.filter(c);if(!this.buttonElement.length)this.buttonElement=a.find(c)}this.element.addClass("ui-helper-hidden-accessible");(a=this.element.is(":checked"))&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",a)}else this.buttonElement=this.element},
widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||this.buttonElement.removeAttr("title");
b.Widget.prototype.destroy.call(this)},_setOption:function(a,c){b.Widget.prototype._setOption.apply(this,arguments);if(a==="disabled")c?this.element.propAttr("disabled",true):this.element.propAttr("disabled",false);else this._resetButton()},refresh:function(){var a=this.element.is(":disabled");a!==this.options.disabled&&this._setOption("disabled",a);if(this.type==="radio")k(this.element[0]).each(function(){b(this).is(":checked")?b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
"true"):b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false")},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var a=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),e=this.options.icons,f=e.primary&&e.secondary,d=[];if(e.primary||e.secondary){if(this.options.text)d.push("ui-button-text-icon"+(f?"s":e.primary?"-primary":"-secondary"));e.primary&&a.prepend("<span class='ui-button-icon-primary ui-icon "+e.primary+"'></span>");e.secondary&&a.append("<span class='ui-button-icon-secondary ui-icon "+e.secondary+"'></span>");if(!this.options.text){d.push(f?"ui-button-icons-only":
"ui-button-icon-only");this.hasTitle||a.attr("title",c)}}else d.push("ui-button-text-only");a.addClass(d.join(" "))}}});b.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(a,c){a==="disabled"&&this.buttons.button("option",a,c);b.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var a=this.element.css("direction")===
"ltr";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a?"ui-corner-left":"ui-corner-right").end().filter(":last").addClass(a?"ui-corner-right":"ui-corner-left").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
b.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Dialog 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function(c,l){var m={buttons:true,height:true,maxHeight:true,maxWidth:true,minHeight:true,minWidth:true,width:true},n={maxHeight:true,maxWidth:true,minHeight:true,minWidth:true},o=c.attrFn||{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true,click:true};c.widget("ui.dialog",{options:{autoOpen:true,buttons:{},closeOnEscape:true,closeText:"close",dialogClass:"",draggable:true,hide:null,height:"auto",maxHeight:false,maxWidth:false,minHeight:150,minWidth:150,modal:false,
position:{my:"center",at:"center",collision:"fit",using:function(a){var b=c(this).css(a).offset().top;b<0&&c(this).css("top",a.top-b)}},resizable:true,show:null,stack:true,title:"",width:300,zIndex:1E3},_create:function(){this.originalTitle=this.element.attr("title");if(typeof this.originalTitle!=="string")this.originalTitle="";this.options.title=this.options.title||this.originalTitle;var a=this,b=a.options,d=b.title||"&#160;",e=c.ui.dialog.getTitleId(a.element),g=(a.uiDialog=c("<div></div>")).appendTo(document.body).hide().addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+
b.dialogClass).css({zIndex:b.zIndex}).attr("tabIndex",-1).css("outline",0).keydown(function(i){if(b.closeOnEscape&&!i.isDefaultPrevented()&&i.keyCode&&i.keyCode===c.ui.keyCode.ESCAPE){a.close(i);i.preventDefault()}}).attr({role:"dialog","aria-labelledby":e}).mousedown(function(i){a.moveToTop(false,i)});a.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g);var f=(a.uiDialogTitlebar=c("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),
h=c('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role","button").hover(function(){h.addClass("ui-state-hover")},function(){h.removeClass("ui-state-hover")}).focus(function(){h.addClass("ui-state-focus")}).blur(function(){h.removeClass("ui-state-focus")}).click(function(i){a.close(i);return false}).appendTo(f);(a.uiDialogTitlebarCloseText=c("<span></span>")).addClass("ui-icon ui-icon-closethick").text(b.closeText).appendTo(h);c("<span></span>").addClass("ui-dialog-title").attr("id",
e).html(d).prependTo(f);if(c.isFunction(b.beforeclose)&&!c.isFunction(b.beforeClose))b.beforeClose=b.beforeclose;f.find("*").add(f).disableSelection();b.draggable&&c.fn.draggable&&a._makeDraggable();b.resizable&&c.fn.resizable&&a._makeResizable();a._createButtons(b.buttons);a._isOpen=false;c.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;a.overlay&&a.overlay.destroy();a.uiDialog.hide();a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body");
a.uiDialog.remove();a.originalTitle&&a.element.attr("title",a.originalTitle);return a},widget:function(){return this.uiDialog},close:function(a){var b=this,d,e;if(false!==b._trigger("beforeClose",a)){b.overlay&&b.overlay.destroy();b.uiDialog.unbind("keypress.ui-dialog");b._isOpen=false;if(b.options.hide)b.uiDialog.hide(b.options.hide,function(){b._trigger("close",a)});else{b.uiDialog.hide();b._trigger("close",a)}c.ui.dialog.overlay.resize();if(b.options.modal){d=0;c(".ui-dialog").each(function(){if(this!==
b.uiDialog[0]){e=c(this).css("z-index");isNaN(e)||(d=Math.max(d,e))}});c.ui.dialog.maxZ=d}return b}},isOpen:function(){return this._isOpen},moveToTop:function(a,b){var d=this,e=d.options;if(e.modal&&!a||!e.stack&&!e.modal)return d._trigger("focus",b);if(e.zIndex>c.ui.dialog.maxZ)c.ui.dialog.maxZ=e.zIndex;if(d.overlay){c.ui.dialog.maxZ+=1;d.overlay.$el.css("z-index",c.ui.dialog.overlay.maxZ=c.ui.dialog.maxZ)}a={scrollTop:d.element.scrollTop(),scrollLeft:d.element.scrollLeft()};c.ui.dialog.maxZ+=1;
d.uiDialog.css("z-index",c.ui.dialog.maxZ);d.element.attr(a);d._trigger("focus",b);return d},open:function(){if(!this._isOpen){var a=this,b=a.options,d=a.uiDialog;a.overlay=b.modal?new c.ui.dialog.overlay(a):null;a._size();a._position(b.position);d.show(b.show);a.moveToTop(true);b.modal&&d.bind("keypress.ui-dialog",function(e){if(e.keyCode===c.ui.keyCode.TAB){var g=c(":tabbable",this),f=g.filter(":first");g=g.filter(":last");if(e.target===g[0]&&!e.shiftKey){f.focus(1);return false}else if(e.target===
f[0]&&e.shiftKey){g.focus(1);return false}}});c(a.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus();a._isOpen=true;a._trigger("open");return a}},_createButtons:function(a){var b=this,d=false,e=c("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=c("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);b.uiDialog.find(".ui-dialog-buttonpane").remove();typeof a==="object"&&a!==null&&c.each(a,
function(){return!(d=true)});if(d){c.each(a,function(f,h){h=c.isFunction(h)?{click:h,text:f}:h;var i=c('<button type="button"></button>').click(function(){h.click.apply(b.element[0],arguments)}).appendTo(g);c.each(h,function(j,k){if(j!=="click")j in o?i[j](k):i.attr(j,k)});c.fn.button&&i.button()});e.appendTo(b.uiDialog)}},_makeDraggable:function(){function a(f){return{position:f.position,offset:f.offset}}var b=this,d=b.options,e=c(document),g;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",
handle:".ui-dialog-titlebar",containment:"document",start:function(f,h){g=d.height==="auto"?"auto":c(this).height();c(this).height(c(this).height()).addClass("ui-dialog-dragging");b._trigger("dragStart",f,a(h))},drag:function(f,h){b._trigger("drag",f,a(h))},stop:function(f,h){d.position=[h.position.left-e.scrollLeft(),h.position.top-e.scrollTop()];c(this).removeClass("ui-dialog-dragging").height(g);b._trigger("dragStop",f,a(h));c.ui.dialog.overlay.resize()}})},_makeResizable:function(a){function b(f){return{originalPosition:f.originalPosition,
originalSize:f.originalSize,position:f.position,size:f.size}}a=a===l?this.options.resizable:a;var d=this,e=d.options,g=d.uiDialog.css("position");a=typeof a==="string"?a:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:a,start:function(f,h){c(this).addClass("ui-dialog-resizing");d._trigger("resizeStart",f,b(h))},resize:function(f,h){d._trigger("resize",
f,b(h))},stop:function(f,h){c(this).removeClass("ui-dialog-resizing");e.height=c(this).height();e.width=c(this).width();d._trigger("resizeStop",f,b(h));c.ui.dialog.overlay.resize()}}).css("position",g).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(a){var b=[],d=[0,0],e;if(a){if(typeof a==="string"||typeof a==="object"&&"0"in a){b=a.split?a.split(" "):
[a[0],a[1]];if(b.length===1)b[1]=b[0];c.each(["left","top"],function(g,f){if(+b[g]===b[g]){d[g]=b[g];b[g]=f}});a={my:b.join(" "),at:b.join(" "),offset:d.join(" ")}}a=c.extend({},c.ui.dialog.prototype.options.position,a)}else a=c.ui.dialog.prototype.options.position;(e=this.uiDialog.is(":visible"))||this.uiDialog.show();this.uiDialog.css({top:0,left:0}).position(c.extend({of:window},a));e||this.uiDialog.hide()},_setOptions:function(a){var b=this,d={},e=false;c.each(a,function(g,f){b._setOption(g,f);
if(g in m)e=true;if(g in n)d[g]=f});e&&this._size();this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",d)},_setOption:function(a,b){var d=this,e=d.uiDialog;switch(a){case "beforeclose":a="beforeClose";break;case "buttons":d._createButtons(b);break;case "closeText":d.uiDialogTitlebarCloseText.text(""+b);break;case "dialogClass":e.removeClass(d.options.dialogClass).addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+b);break;case "disabled":b?e.addClass("ui-dialog-disabled"):
e.removeClass("ui-dialog-disabled");break;case "draggable":var g=e.is(":data(draggable)");g&&!b&&e.draggable("destroy");!g&&b&&d._makeDraggable();break;case "position":d._position(b);break;case "resizable":(g=e.is(":data(resizable)"))&&!b&&e.resizable("destroy");g&&typeof b==="string"&&e.resizable("option","handles",b);!g&&b!==false&&d._makeResizable(b);break;case "title":c(".ui-dialog-title",d.uiDialogTitlebar).html(""+(b||"&#160;"));break}c.Widget.prototype._setOption.apply(d,arguments)},_size:function(){var a=
this.options,b,d,e=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0});if(a.minWidth>a.width)a.width=a.minWidth;b=this.uiDialog.css({height:"auto",width:a.width}).height();d=Math.max(0,a.minHeight-b);if(a.height==="auto")if(c.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();a=this.element.css("height","auto").height();e||this.uiDialog.hide();this.element.height(Math.max(a,d))}else this.element.height(Math.max(a.height-
b,0));this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}});c.extend(c.ui.dialog,{version:"1.8.16",uuid:0,maxZ:0,getTitleId:function(a){a=a.attr("id");if(!a){this.uuid+=1;a=this.uuid}return"ui-dialog-title-"+a},overlay:function(a){this.$el=c.ui.dialog.overlay.create(a)}});c.extend(c.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:c.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),
create:function(a){if(this.instances.length===0){setTimeout(function(){c.ui.dialog.overlay.instances.length&&c(document).bind(c.ui.dialog.overlay.events,function(d){if(c(d.target).zIndex()<c.ui.dialog.overlay.maxZ)return false})},1);c(document).bind("keydown.dialog-overlay",function(d){if(a.options.closeOnEscape&&!d.isDefaultPrevented()&&d.keyCode&&d.keyCode===c.ui.keyCode.ESCAPE){a.close(d);d.preventDefault()}});c(window).bind("resize.dialog-overlay",c.ui.dialog.overlay.resize)}var b=(this.oldInstances.pop()||
c("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),height:this.height()});c.fn.bgiframe&&b.bgiframe();this.instances.push(b);return b},destroy:function(a){var b=c.inArray(a,this.instances);b!=-1&&this.oldInstances.push(this.instances.splice(b,1)[0]);this.instances.length===0&&c([document,window]).unbind(".dialog-overlay");a.remove();var d=0;c.each(this.instances,function(){d=Math.max(d,this.css("z-index"))});this.maxZ=d},height:function(){var a,b;if(c.browser.msie&&
c.browser.version<7){a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight);b=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight);return a<b?c(window).height()+"px":a+"px"}else return c(document).height()+"px"},width:function(){var a,b;if(c.browser.msie){a=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth);b=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth);return a<b?c(window).width()+"px":a+"px"}else return c(document).width()+
"px"},resize:function(){var a=c([]);c.each(c.ui.dialog.overlay.instances,function(){a=a.add(this)});a.css({width:0,height:0}).css({width:c.ui.dialog.overlay.width(),height:c.ui.dialog.overlay.height()})}});c.extend(c.ui.dialog.overlay.prototype,{destroy:function(){c.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var a=this,b=this.options,c=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f=b.values&&b.values.length||1,e=[];this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+
this.orientation+" ui-widget ui-widget-content ui-corner-all"+(b.disabled?" ui-slider-disabled ui-disabled":""));this.range=d([]);if(b.range){if(b.range===true){if(!b.values)b.values=[this._valueMin(),this._valueMin()];if(b.values.length&&b.values.length!==2)b.values=[b.values[0],b.values[0]]}this.range=d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(b.range==="min"||b.range==="max"?" ui-slider-range-"+b.range:""))}for(var j=c.length;j<f;j+=1)e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
this.handles=c.add(d(e.join("")).appendTo(a.element));this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(g){g.preventDefault()}).hover(function(){b.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(b.disabled)d(this).blur();else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(g){d(this).data("index.ui-slider-handle",
g)});this.handles.keydown(function(g){var k=true,l=d(this).data("index.ui-slider-handle"),i,h,m;if(!a.options.disabled){switch(g.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:k=false;if(!a._keySliding){a._keySliding=true;d(this).addClass("ui-state-active");i=a._start(g,l);if(i===false)return}break}m=a.options.step;i=a.options.values&&a.options.values.length?
(h=a.values(l)):(h=a.value());switch(g.keyCode){case d.ui.keyCode.HOME:h=a._valueMin();break;case d.ui.keyCode.END:h=a._valueMax();break;case d.ui.keyCode.PAGE_UP:h=a._trimAlignValue(i+(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:h=a._trimAlignValue(i-(a._valueMax()-a._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(i===a._valueMax())return;h=a._trimAlignValue(i+m);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(i===a._valueMin())return;h=a._trimAlignValue(i-
m);break}a._slide(g,l,h);return k}}).keyup(function(g){var k=d(this).data("index.ui-slider-handle");if(a._keySliding){a._keySliding=false;a._stop(g,k);a._change(g,k);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");this._mouseDestroy();
return this},_mouseCapture:function(a){var b=this.options,c,f,e,j,g;if(b.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:a.pageX,y:a.pageY});f=this._valueMax()-this._valueMin()+1;j=this;this.handles.each(function(k){var l=Math.abs(c-j.values(k));if(f>l){f=l;e=d(this);g=k}});if(b.range===true&&this.values(1)===b.min){g+=1;e=d(this.handles[g])}if(this._start(a,g)===false)return false;
this._mouseSliding=true;j._handleIndex=g;e.addClass("ui-state-active").focus();b=e.offset();this._clickOffset=!d(a.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:a.pageX-b.left-e.width()/2,top:a.pageY-b.top-e.height()/2-(parseInt(e.css("borderTopWidth"),10)||0)-(parseInt(e.css("borderBottomWidth"),10)||0)+(parseInt(e.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(a,g,c);return this._animateOff=true},_mouseStart:function(){return true},_mouseDrag:function(a){var b=
this._normValueFromMouse({x:a.pageX,y:a.pageY});this._slide(a,this._handleIndex,b);return false},_mouseStop:function(a){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(a,this._handleIndex);this._change(a,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b;if(this.orientation==="horizontal"){b=
this.elementSize.width;a=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{b=this.elementSize.height;a=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}b=a/b;if(b>1)b=1;if(b<0)b=0;if(this.orientation==="vertical")b=1-b;a=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+b*a)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);
c.values=this.values()}return this._trigger("start",a,c)},_slide:function(a,b,c){var f;if(this.options.values&&this.options.values.length){f=this.values(b?0:1);if(this.options.values.length===2&&this.options.range===true&&(b===0&&c>f||b===1&&c<f))c=f;if(c!==this.values(b)){f=this.values();f[b]=c;a=this._trigger("slide",a,{handle:this.handles[b],value:c,values:f});this.values(b?0:1);a!==false&&this.values(b,c,true)}}else if(c!==this.value()){a=this._trigger("slide",a,{handle:this.handles[b],value:c});
a!==false&&this.value(c)}},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(b);c.values=this.values()}this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=
this._trimAlignValue(a);this._refreshValue();this._change(null,0)}else return this._value()},values:function(a,b){var c,f,e;if(arguments.length>1){this.options.values[a]=this._trimAlignValue(b);this._refreshValue();this._change(null,a)}else if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;f=arguments[0];for(e=0;e<c.length;e+=1){c[e]=this._trimAlignValue(f[e]);this._change(null,e)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(a):
this.value();else return this._values()},_setOption:function(a,b){var c,f=0;if(d.isArray(this.options.values))f=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(a){case "disabled":if(b){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.propAttr("disabled",true);this.element.addClass("ui-disabled")}else{this.handles.propAttr("disabled",false);this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<f;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a)},_values:function(a){var b,c;if(arguments.length){b=this.options.values[a];
return b=this._trimAlignValue(b)}else{b=this.options.values.slice();for(c=0;c<b.length;c+=1)b[c]=this._trimAlignValue(b[c]);return b}},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b;a=a-c;if(Math.abs(c)*2>=b)a+=c>0?b:-b;return parseFloat(a.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var a=
this.options.range,b=this.options,c=this,f=!this._animateOff?b.animate:false,e,j={},g,k,l,i;if(this.options.values&&this.options.values.length)this.handles.each(function(h){e=(c.values(h)-c._valueMin())/(c._valueMax()-c._valueMin())*100;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";d(this).stop(1,1)[f?"animate":"css"](j,b.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(h===0)c.range.stop(1,1)[f?"animate":"css"]({left:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({width:e-
g+"%"},{queue:false,duration:b.animate})}else{if(h===0)c.range.stop(1,1)[f?"animate":"css"]({bottom:e+"%"},b.animate);if(h===1)c.range[f?"animate":"css"]({height:e-g+"%"},{queue:false,duration:b.animate})}g=e});else{k=this.value();l=this._valueMin();i=this._valueMax();e=i!==l?(k-l)/(i-l)*100:0;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";this.handle.stop(1,1)[f?"animate":"css"](j,b.animate);if(a==="min"&&this.orientation==="horizontal")this.range.stop(1,1)[f?"animate":"css"]({width:e+"%"},
b.animate);if(a==="max"&&this.orientation==="horizontal")this.range[f?"animate":"css"]({width:100-e+"%"},{queue:false,duration:b.animate});if(a==="min"&&this.orientation==="vertical")this.range.stop(1,1)[f?"animate":"css"]({height:e+"%"},b.animate);if(a==="max"&&this.orientation==="vertical")this.range[f?"animate":"css"]({height:100-e+"%"},{queue:false,duration:b.animate})}}});d.extend(d.ui.slider,{version:"1.8.16"})})(jQuery);
;/*
 * jQuery UI Tabs 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(d,p){function u(){return++v}function w(){return++x}var v=0,x=0;d.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:false,cookie:null,collapsible:false,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(true)},_setOption:function(b,e){if(b=="selected")this.options.collapsible&&
e==this.options.selected||this.select(e);else{this.options[b]=e;this._tabify()}},_tabId:function(b){return b.title&&b.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+u()},_sanitizeSelector:function(b){return b.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+w());return d.cookie.apply(null,[b].concat(d.makeArray(arguments)))},_ui:function(b,e){return{tab:b,panel:e,index:this.anchors.index(b)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=
d(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(b){function e(g,f){g.css("display","");!d.support.opacity&&f.opacity&&g[0].style.removeAttribute("filter")}var a=this,c=this.options,h=/^#.+/;this.list=this.element.find("ol,ul").eq(0);this.lis=d(" > li:has(a[href])",this.list);this.anchors=this.lis.map(function(){return d("a",this)[0]});this.panels=d([]);this.anchors.each(function(g,f){var i=d(f).attr("href"),l=i.split("#")[0],q;if(l&&(l===location.toString().split("#")[0]||
(q=d("base")[0])&&l===q.href)){i=f.hash;f.href=i}if(h.test(i))a.panels=a.panels.add(a.element.find(a._sanitizeSelector(i)));else if(i&&i!=="#"){d.data(f,"href.tabs",i);d.data(f,"load.tabs",i.replace(/#.*$/,""));i=a._tabId(f);f.href="#"+i;f=a.element.find("#"+i);if(!f.length){f=d(c.panelTemplate).attr("id",i).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(a.panels[g-1]||a.list);f.data("destroy.tabs",true)}a.panels=a.panels.add(f)}else c.disabled.push(g)});if(b){this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.lis.addClass("ui-state-default ui-corner-top");this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");if(c.selected===p){location.hash&&this.anchors.each(function(g,f){if(f.hash==location.hash){c.selected=g;return false}});if(typeof c.selected!=="number"&&c.cookie)c.selected=parseInt(a._cookie(),10);if(typeof c.selected!=="number"&&this.lis.filter(".ui-tabs-selected").length)c.selected=
this.lis.index(this.lis.filter(".ui-tabs-selected"));c.selected=c.selected||(this.lis.length?0:-1)}else if(c.selected===null)c.selected=-1;c.selected=c.selected>=0&&this.anchors[c.selected]||c.selected<0?c.selected:0;c.disabled=d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"),function(g){return a.lis.index(g)}))).sort();d.inArray(c.selected,c.disabled)!=-1&&c.disabled.splice(d.inArray(c.selected,c.disabled),1);this.panels.addClass("ui-tabs-hide");this.lis.removeClass("ui-tabs-selected ui-state-active");
if(c.selected>=0&&this.anchors.length){a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash)).removeClass("ui-tabs-hide");this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");a.element.queue("tabs",function(){a._trigger("show",null,a._ui(a.anchors[c.selected],a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash))[0]))});this.load(c.selected)}d(window).bind("unload",function(){a.lis.add(a.anchors).unbind(".tabs");a.lis=a.anchors=a.panels=null})}else c.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"));
this.element[c.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible");c.cookie&&this._cookie(c.selected,c.cookie);b=0;for(var j;j=this.lis[b];b++)d(j)[d.inArray(b,c.disabled)!=-1&&!d(j).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");c.cache===false&&this.anchors.removeData("cache.tabs");this.lis.add(this.anchors).unbind(".tabs");if(c.event!=="mouseover"){var k=function(g,f){f.is(":not(.ui-state-disabled)")&&f.addClass("ui-state-"+g)},n=function(g,f){f.removeClass("ui-state-"+
g)};this.lis.bind("mouseover.tabs",function(){k("hover",d(this))});this.lis.bind("mouseout.tabs",function(){n("hover",d(this))});this.anchors.bind("focus.tabs",function(){k("focus",d(this).closest("li"))});this.anchors.bind("blur.tabs",function(){n("focus",d(this).closest("li"))})}var m,o;if(c.fx)if(d.isArray(c.fx)){m=c.fx[0];o=c.fx[1]}else m=o=c.fx;var r=o?function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.hide().removeClass("ui-tabs-hide").animate(o,o.duration||"normal",
function(){e(f,o);a._trigger("show",null,a._ui(g,f[0]))})}:function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.removeClass("ui-tabs-hide");a._trigger("show",null,a._ui(g,f[0]))},s=m?function(g,f){f.animate(m,m.duration||"normal",function(){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");e(f,m);a.element.dequeue("tabs")})}:function(g,f){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");a.element.dequeue("tabs")};
this.anchors.bind(c.event+".tabs",function(){var g=this,f=d(g).closest("li"),i=a.panels.filter(":not(.ui-tabs-hide)"),l=a.element.find(a._sanitizeSelector(g.hash));if(f.hasClass("ui-tabs-selected")&&!c.collapsible||f.hasClass("ui-state-disabled")||f.hasClass("ui-state-processing")||a.panels.filter(":animated").length||a._trigger("select",null,a._ui(this,l[0]))===false){this.blur();return false}c.selected=a.anchors.index(this);a.abort();if(c.collapsible)if(f.hasClass("ui-tabs-selected")){c.selected=
-1;c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){s(g,i)}).dequeue("tabs");this.blur();return false}else if(!i.length){c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this));this.blur();return false}c.cookie&&a._cookie(c.selected,c.cookie);if(l.length){i.length&&a.element.queue("tabs",function(){s(g,i)});a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this))}else throw"jQuery UI Tabs: Mismatching fragment identifier.";
d.browser.msie&&this.blur()});this.anchors.bind("click.tabs",function(){return false})},_getIndex:function(b){if(typeof b=="string")b=this.anchors.index(this.anchors.filter("[href$="+b+"]"));return b},destroy:function(){var b=this.options;this.abort();this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.anchors.each(function(){var e=
d.data(this,"href.tabs");if(e)this.href=e;var a=d(this).unbind(".tabs");d.each(["href","load","cache"],function(c,h){a.removeData(h+".tabs")})});this.lis.unbind(".tabs").add(this.panels).each(function(){d.data(this,"destroy.tabs")?d(this).remove():d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")});b.cookie&&this._cookie(null,b.cookie);return this},add:function(b,
e,a){if(a===p)a=this.anchors.length;var c=this,h=this.options;e=d(h.tabTemplate.replace(/#\{href\}/g,b).replace(/#\{label\}/g,e));b=!b.indexOf("#")?b.replace("#",""):this._tabId(d("a",e)[0]);e.addClass("ui-state-default ui-corner-top").data("destroy.tabs",true);var j=c.element.find("#"+b);j.length||(j=d(h.panelTemplate).attr("id",b).data("destroy.tabs",true));j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");if(a>=this.lis.length){e.appendTo(this.list);j.appendTo(this.list[0].parentNode)}else{e.insertBefore(this.lis[a]);
j.insertBefore(this.panels[a])}h.disabled=d.map(h.disabled,function(k){return k>=a?++k:k});this._tabify();if(this.anchors.length==1){h.selected=0;e.addClass("ui-tabs-selected ui-state-active");j.removeClass("ui-tabs-hide");this.element.queue("tabs",function(){c._trigger("show",null,c._ui(c.anchors[0],c.panels[0]))});this.load(0)}this._trigger("add",null,this._ui(this.anchors[a],this.panels[a]));return this},remove:function(b){b=this._getIndex(b);var e=this.options,a=this.lis.eq(b).remove(),c=this.panels.eq(b).remove();
if(a.hasClass("ui-tabs-selected")&&this.anchors.length>1)this.select(b+(b+1<this.anchors.length?1:-1));e.disabled=d.map(d.grep(e.disabled,function(h){return h!=b}),function(h){return h>=b?--h:h});this._tabify();this._trigger("remove",null,this._ui(a.find("a")[0],c[0]));return this},enable:function(b){b=this._getIndex(b);var e=this.options;if(d.inArray(b,e.disabled)!=-1){this.lis.eq(b).removeClass("ui-state-disabled");e.disabled=d.grep(e.disabled,function(a){return a!=b});this._trigger("enable",null,
this._ui(this.anchors[b],this.panels[b]));return this}},disable:function(b){b=this._getIndex(b);var e=this.options;if(b!=e.selected){this.lis.eq(b).addClass("ui-state-disabled");e.disabled.push(b);e.disabled.sort();this._trigger("disable",null,this._ui(this.anchors[b],this.panels[b]))}return this},select:function(b){b=this._getIndex(b);if(b==-1)if(this.options.collapsible&&this.options.selected!=-1)b=this.options.selected;else return this;this.anchors.eq(b).trigger(this.options.event+".tabs");return this},
load:function(b){b=this._getIndex(b);var e=this,a=this.options,c=this.anchors.eq(b)[0],h=d.data(c,"load.tabs");this.abort();if(!h||this.element.queue("tabs").length!==0&&d.data(c,"cache.tabs"))this.element.dequeue("tabs");else{this.lis.eq(b).addClass("ui-state-processing");if(a.spinner){var j=d("span",c);j.data("label.tabs",j.html()).html(a.spinner)}this.xhr=d.ajax(d.extend({},a.ajaxOptions,{url:h,success:function(k,n){e.element.find(e._sanitizeSelector(c.hash)).html(k);e._cleanup();a.cache&&d.data(c,
"cache.tabs",true);e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.success(k,n)}catch(m){}},error:function(k,n){e._cleanup();e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.error(k,n,b,c)}catch(m){}}}));e.element.dequeue("tabs");return this}},abort:function(){this.element.queue([]);this.panels.stop(false,true);this.element.queue("tabs",this.element.queue("tabs").splice(-2,2));if(this.xhr){this.xhr.abort();delete this.xhr}this._cleanup();return this},
url:function(b,e){this.anchors.eq(b).removeData("cache.tabs").data("load.tabs",e);return this},length:function(){return this.anchors.length}});d.extend(d.ui.tabs,{version:"1.8.16"});d.extend(d.ui.tabs.prototype,{rotation:null,rotate:function(b,e){var a=this,c=this.options,h=a._rotate||(a._rotate=function(j){clearTimeout(a.rotation);a.rotation=setTimeout(function(){var k=c.selected;a.select(++k<a.anchors.length?k:0)},b);j&&j.stopPropagation()});e=a._unrotate||(a._unrotate=!e?function(j){j.clientX&&
a.rotate(null)}:function(){t=c.selected;h()});if(b){this.element.bind("tabsshow",h);this.anchors.bind(c.event+".tabs",e);h()}else{clearTimeout(a.rotation);this.element.unbind("tabsshow",h);this.anchors.unbind(c.event+".tabs",e);delete this._rotate;delete this._unrotate}return this}})})(jQuery);
;/*
 * jQuery UI Datepicker 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function(d,C){function M(){this.debug=false;this._curInst=null;this._keyEvent=false;this._disabledInputs=[];this._inDialog=this._datepickerShowing=false;this._mainDivId="ui-datepicker-div";this._inlineClass="ui-datepicker-inline";this._appendClass="ui-datepicker-append";this._triggerClass="ui-datepicker-trigger";this._dialogClass="ui-datepicker-dialog";this._disableClass="ui-datepicker-disabled";this._unselectableClass="ui-datepicker-unselectable";this._currentClass="ui-datepicker-current-day";this._dayOverClass=
"ui-datepicker-days-cell-over";this.regional=[];this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su",
"Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:false,showMonthAfterYear:false,yearSuffix:""};this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:false,hideIfNoPrevNext:false,navigationAsDateFormat:false,gotoCurrent:false,changeMonth:false,changeYear:false,yearRange:"c-10:c+10",showOtherMonths:false,selectOtherMonths:false,showWeek:false,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",
minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:true,showButtonPanel:false,autoSize:false,disabled:false};d.extend(this._defaults,this.regional[""]);this.dpDiv=N(d('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function N(a){return a.bind("mouseout",
function(b){b=d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");b.length&&b.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")}).bind("mouseover",function(b){b=d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");if(!(d.datepicker._isDisabledDatepicker(J.inline?a.parent()[0]:J.input[0])||!b.length)){b.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
b.addClass("ui-state-hover");b.hasClass("ui-datepicker-prev")&&b.addClass("ui-datepicker-prev-hover");b.hasClass("ui-datepicker-next")&&b.addClass("ui-datepicker-next-hover")}})}function H(a,b){d.extend(a,b);for(var c in b)if(b[c]==null||b[c]==C)a[c]=b[c];return a}d.extend(d.ui,{datepicker:{version:"1.8.16"}});var B=(new Date).getTime(),J;d.extend(M.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},
setDefaults:function(a){H(this._defaults,a||{});return this},_attachDatepicker:function(a,b){var c=null;for(var e in this._defaults){var f=a.getAttribute("date:"+e);if(f){c=c||{};try{c[e]=eval(f)}catch(h){c[e]=f}}}e=a.nodeName.toLowerCase();f=e=="div"||e=="span";if(!a.id){this.uuid+=1;a.id="dp"+this.uuid}var i=this._newInst(d(a),f);i.settings=d.extend({},b||{},c||{});if(e=="input")this._connectDatepicker(a,i);else f&&this._inlineDatepicker(a,i)},_newInst:function(a,b){return{id:a[0].id.replace(/([^A-Za-z0-9_-])/g,
"\\\\$1"),input:a,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:!b?this.dpDiv:N(d('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}},_connectDatepicker:function(a,b){var c=d(a);b.append=d([]);b.trigger=d([]);if(!c.hasClass(this.markerClassName)){this._attachments(c,b);c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",
function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});this._autoSize(b);d.data(a,"datepicker",b);b.settings.disabled&&this._disableDatepicker(a)}},_attachments:function(a,b){var c=this._get(b,"appendText"),e=this._get(b,"isRTL");b.append&&b.append.remove();if(c){b.append=d('<span class="'+this._appendClass+'">'+c+"</span>");a[e?"before":"after"](b.append)}a.unbind("focus",this._showDatepicker);b.trigger&&b.trigger.remove();c=this._get(b,"showOn");if(c==
"focus"||c=="both")a.focus(this._showDatepicker);if(c=="button"||c=="both"){c=this._get(b,"buttonText");var f=this._get(b,"buttonImage");b.trigger=d(this._get(b,"buttonImageOnly")?d("<img/>").addClass(this._triggerClass).attr({src:f,alt:c,title:c}):d('<button type="button"></button>').addClass(this._triggerClass).html(f==""?c:d("<img/>").attr({src:f,alt:c,title:c})));a[e?"before":"after"](b.trigger);b.trigger.click(function(){d.datepicker._datepickerShowing&&d.datepicker._lastInput==a[0]?d.datepicker._hideDatepicker():
d.datepicker._showDatepicker(a[0]);return false})}},_autoSize:function(a){if(this._get(a,"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var e=function(f){for(var h=0,i=0,g=0;g<f.length;g++)if(f[g].length>h){h=f[g].length;i=g}return i};b.setMonth(e(this._get(a,c.match(/MM/)?"monthNames":"monthNamesShort")));b.setDate(e(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,
b){var c=d(a);if(!c.hasClass(this.markerClassName)){c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});d.data(a,"datepicker",b);this._setDate(b,this._getDefaultDate(b),true);this._updateDatepicker(b);this._updateAlternate(b);b.settings.disabled&&this._disableDatepicker(a);b.dpDiv.css("display","block")}},_dialogDatepicker:function(a,b,c,e,f){a=this._dialogInst;if(!a){this.uuid+=
1;this._dialogInput=d('<input type="text" id="'+("dp"+this.uuid)+'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');this._dialogInput.keydown(this._doKeyDown);d("body").append(this._dialogInput);a=this._dialogInst=this._newInst(this._dialogInput,false);a.settings={};d.data(this._dialogInput[0],"datepicker",a)}H(a.settings,e||{});b=b&&b.constructor==Date?this._formatDate(a,b):b;this._dialogInput.val(b);this._pos=f?f.length?f:[f.pageX,f.pageY]:null;if(!this._pos)this._pos=[document.documentElement.clientWidth/
2-100+(document.documentElement.scrollLeft||document.body.scrollLeft),document.documentElement.clientHeight/2-150+(document.documentElement.scrollTop||document.body.scrollTop)];this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px");a.settings.onSelect=c;this._inDialog=true;this.dpDiv.addClass(this._dialogClass);this._showDatepicker(this._dialogInput[0]);d.blockUI&&d.blockUI(this.dpDiv);d.data(this._dialogInput[0],"datepicker",a);return this},_destroyDatepicker:function(a){var b=
d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();d.removeData(a,"datepicker");if(e=="input"){c.append.remove();c.trigger.remove();b.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)}else if(e=="div"||e=="span")b.removeClass(this.markerClassName).empty()}},_enableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=
a.nodeName.toLowerCase();if(e=="input"){a.disabled=false;c.trigger.filter("button").each(function(){this.disabled=false}).end().filter("img").css({opacity:"1.0",cursor:""})}else if(e=="div"||e=="span"){b=b.children("."+this._inlineClass);b.children().removeClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==a?null:f})}},_disableDatepicker:function(a){var b=d(a),c=d.data(a,
"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=true;c.trigger.filter("button").each(function(){this.disabled=true}).end().filter("img").css({opacity:"0.5",cursor:"default"})}else if(e=="div"||e=="span"){b=b.children("."+this._inlineClass);b.children().addClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled","disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==
a?null:f});this._disabledInputs[this._disabledInputs.length]=a}},_isDisabledDatepicker:function(a){if(!a)return false;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return true;return false},_getInst:function(a){try{return d.data(a,"datepicker")}catch(b){throw"Missing instance data for this datepicker";}},_optionDatepicker:function(a,b,c){var e=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?d.extend({},d.datepicker._defaults):e?b=="all"?
d.extend({},e.settings):this._get(e,b):null;var f=b||{};if(typeof b=="string"){f={};f[b]=c}if(e){this._curInst==e&&this._hideDatepicker();var h=this._getDateDatepicker(a,true),i=this._getMinMaxDate(e,"min"),g=this._getMinMaxDate(e,"max");H(e.settings,f);if(i!==null&&f.dateFormat!==C&&f.minDate===C)e.settings.minDate=this._formatDate(e,i);if(g!==null&&f.dateFormat!==C&&f.maxDate===C)e.settings.maxDate=this._formatDate(e,g);this._attachments(d(a),e);this._autoSize(e);this._setDate(e,h);this._updateAlternate(e);
this._updateDatepicker(e)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){(a=this._getInst(a))&&this._updateDatepicker(a)},_setDateDatepicker:function(a,b){if(a=this._getInst(a)){this._setDate(a,b);this._updateDatepicker(a);this._updateAlternate(a)}},_getDateDatepicker:function(a,b){(a=this._getInst(a))&&!a.inline&&this._setDateFromField(a,b);return a?this._getDate(a):null},_doKeyDown:function(a){var b=d.datepicker._getInst(a.target),c=true,e=b.dpDiv.is(".ui-datepicker-rtl");
b._keyEvent=true;if(d.datepicker._datepickerShowing)switch(a.keyCode){case 9:d.datepicker._hideDatepicker();c=false;break;case 13:c=d("td."+d.datepicker._dayOverClass+":not(."+d.datepicker._currentClass+")",b.dpDiv);c[0]&&d.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,c[0]);if(a=d.datepicker._get(b,"onSelect")){c=d.datepicker._formatDate(b);a.apply(b.input?b.input[0]:null,[c,b])}else d.datepicker._hideDatepicker();return false;case 27:d.datepicker._hideDatepicker();break;case 33:d.datepicker._adjustDate(a.target,
a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 34:d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 35:if(a.ctrlKey||a.metaKey)d.datepicker._clearDate(a.target);c=a.ctrlKey||a.metaKey;break;case 36:if(a.ctrlKey||a.metaKey)d.datepicker._gotoToday(a.target);c=a.ctrlKey||a.metaKey;break;case 37:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?+1:-1,"D");c=
a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 38:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,-7,"D");c=a.ctrlKey||a.metaKey;break;case 39:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?-1:+1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,
"stepMonths"),"M");break;case 40:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,+7,"D");c=a.ctrlKey||a.metaKey;break;default:c=false}else if(a.keyCode==36&&a.ctrlKey)d.datepicker._showDatepicker(this);else c=false;if(c){a.preventDefault();a.stopPropagation()}},_doKeyPress:function(a){var b=d.datepicker._getInst(a.target);if(d.datepicker._get(b,"constrainInput")){b=d.datepicker._possibleChars(d.datepicker._get(b,"dateFormat"));var c=String.fromCharCode(a.charCode==C?a.keyCode:a.charCode);
return a.ctrlKey||a.metaKey||c<" "||!b||b.indexOf(c)>-1}},_doKeyUp:function(a){a=d.datepicker._getInst(a.target);if(a.input.val()!=a.lastVal)try{if(d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),a.input?a.input.val():null,d.datepicker._getFormatConfig(a))){d.datepicker._setDateFromField(a);d.datepicker._updateAlternate(a);d.datepicker._updateDatepicker(a)}}catch(b){d.datepicker.log(b)}return true},_showDatepicker:function(a){a=a.target||a;if(a.nodeName.toLowerCase()!="input")a=d("input",
a.parentNode)[0];if(!(d.datepicker._isDisabledDatepicker(a)||d.datepicker._lastInput==a)){var b=d.datepicker._getInst(a);if(d.datepicker._curInst&&d.datepicker._curInst!=b){d.datepicker._datepickerShowing&&d.datepicker._triggerOnClose(d.datepicker._curInst);d.datepicker._curInst.dpDiv.stop(true,true)}var c=d.datepicker._get(b,"beforeShow");c=c?c.apply(a,[a,b]):{};if(c!==false){H(b.settings,c);b.lastVal=null;d.datepicker._lastInput=a;d.datepicker._setDateFromField(b);if(d.datepicker._inDialog)a.value=
"";if(!d.datepicker._pos){d.datepicker._pos=d.datepicker._findPos(a);d.datepicker._pos[1]+=a.offsetHeight}var e=false;d(a).parents().each(function(){e|=d(this).css("position")=="fixed";return!e});if(e&&d.browser.opera){d.datepicker._pos[0]-=document.documentElement.scrollLeft;d.datepicker._pos[1]-=document.documentElement.scrollTop}c={left:d.datepicker._pos[0],top:d.datepicker._pos[1]};d.datepicker._pos=null;b.dpDiv.empty();b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"});d.datepicker._updateDatepicker(b);
c=d.datepicker._checkOffset(b,c,e);b.dpDiv.css({position:d.datepicker._inDialog&&d.blockUI?"static":e?"fixed":"absolute",display:"none",left:c.left+"px",top:c.top+"px"});if(!b.inline){c=d.datepicker._get(b,"showAnim");var f=d.datepicker._get(b,"duration"),h=function(){var i=b.dpDiv.find("iframe.ui-datepicker-cover");if(i.length){var g=d.datepicker._getBorders(b.dpDiv);i.css({left:-g[0],top:-g[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex(d(a).zIndex()+1);d.datepicker._datepickerShowing=
true;d.effects&&d.effects[c]?b.dpDiv.show(c,d.datepicker._get(b,"showOptions"),f,h):b.dpDiv[c||"show"](c?f:null,h);if(!c||!f)h();b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus();d.datepicker._curInst=b}}}},_updateDatepicker:function(a){this.maxRows=4;var b=d.datepicker._getBorders(a.dpDiv);J=a;a.dpDiv.empty().append(this._generateHTML(a));var c=a.dpDiv.find("iframe.ui-datepicker-cover");c.length&&c.css({left:-b[0],top:-b[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()});
a.dpDiv.find("."+this._dayOverClass+" a").mouseover();b=this._getNumberOfMonths(a);c=b[1];a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");c>1&&a.dpDiv.addClass("ui-datepicker-multi-"+c).css("width",17*c+"em");a.dpDiv[(b[0]!=1||b[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi");a.dpDiv[(this._get(a,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl");a==d.datepicker._curInst&&d.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&
!a.input.is(":disabled")&&a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var e=a.yearshtml;setTimeout(function(){e===a.yearshtml&&a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml);e=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(c){return{thin:1,medium:2,thick:3}[c]||c};return[parseFloat(b(a.css("border-left-width"))),parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var e=a.dpDiv.outerWidth(),f=a.dpDiv.outerHeight(),
h=a.input?a.input.outerWidth():0,i=a.input?a.input.outerHeight():0,g=document.documentElement.clientWidth+d(document).scrollLeft(),j=document.documentElement.clientHeight+d(document).scrollTop();b.left-=this._get(a,"isRTL")?e-h:0;b.left-=c&&b.left==a.input.offset().left?d(document).scrollLeft():0;b.top-=c&&b.top==a.input.offset().top+i?d(document).scrollTop():0;b.left-=Math.min(b.left,b.left+e>g&&g>e?Math.abs(b.left+e-g):0);b.top-=Math.min(b.top,b.top+f>j&&j>f?Math.abs(f+i):0);return b},_findPos:function(a){for(var b=
this._get(this._getInst(a),"isRTL");a&&(a.type=="hidden"||a.nodeType!=1||d.expr.filters.hidden(a));)a=a[b?"previousSibling":"nextSibling"];a=d(a).offset();return[a.left,a.top]},_triggerOnClose:function(a){var b=this._get(a,"onClose");if(b)b.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a])},_hideDatepicker:function(a){var b=this._curInst;if(!(!b||a&&b!=d.data(a,"datepicker")))if(this._datepickerShowing){a=this._get(b,"showAnim");var c=this._get(b,"duration"),e=function(){d.datepicker._tidyDialog(b);
this._curInst=null};d.effects&&d.effects[a]?b.dpDiv.hide(a,d.datepicker._get(b,"showOptions"),c,e):b.dpDiv[a=="slideDown"?"slideUp":a=="fadeIn"?"fadeOut":"hide"](a?c:null,e);a||e();d.datepicker._triggerOnClose(b);this._datepickerShowing=false;this._lastInput=null;if(this._inDialog){this._dialogInput.css({position:"absolute",left:"0",top:"-100px"});if(d.blockUI){d.unblockUI();d("body").append(this.dpDiv)}}this._inDialog=false}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},
_checkExternalClick:function(a){if(d.datepicker._curInst){a=d(a.target);a[0].id!=d.datepicker._mainDivId&&a.parents("#"+d.datepicker._mainDivId).length==0&&!a.hasClass(d.datepicker.markerClassName)&&!a.hasClass(d.datepicker._triggerClass)&&d.datepicker._datepickerShowing&&!(d.datepicker._inDialog&&d.blockUI)&&d.datepicker._hideDatepicker()}},_adjustDate:function(a,b,c){a=d(a);var e=this._getInst(a[0]);if(!this._isDisabledDatepicker(a[0])){this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):
0),c);this._updateDatepicker(e)}},_gotoToday:function(a){a=d(a);var b=this._getInst(a[0]);if(this._get(b,"gotoCurrent")&&b.currentDay){b.selectedDay=b.currentDay;b.drawMonth=b.selectedMonth=b.currentMonth;b.drawYear=b.selectedYear=b.currentYear}else{var c=new Date;b.selectedDay=c.getDate();b.drawMonth=b.selectedMonth=c.getMonth();b.drawYear=b.selectedYear=c.getFullYear()}this._notifyChange(b);this._adjustDate(a)},_selectMonthYear:function(a,b,c){a=d(a);var e=this._getInst(a[0]);e["selected"+(c=="M"?
"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10);this._notifyChange(e);this._adjustDate(a)},_selectDay:function(a,b,c,e){var f=d(a);if(!(d(e).hasClass(this._unselectableClass)||this._isDisabledDatepicker(f[0]))){f=this._getInst(f[0]);f.selectedDay=f.currentDay=d("a",e).html();f.selectedMonth=f.currentMonth=b;f.selectedYear=f.currentYear=c;this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))}},_clearDate:function(a){a=d(a);
this._getInst(a[0]);this._selectDate(a,"")},_selectDate:function(a,b){a=this._getInst(d(a)[0]);b=b!=null?b:this._formatDate(a);a.input&&a.input.val(b);this._updateAlternate(a);var c=this._get(a,"onSelect");if(c)c.apply(a.input?a.input[0]:null,[b,a]);else a.input&&a.input.trigger("change");if(a.inline)this._updateDatepicker(a);else{this._hideDatepicker();this._lastInput=a.input[0];typeof a.input[0]!="object"&&a.input.focus();this._lastInput=null}},_updateAlternate:function(a){var b=this._get(a,"altField");
if(b){var c=this._get(a,"altFormat")||this._get(a,"dateFormat"),e=this._getDate(a),f=this.formatDate(c,e,this._getFormatConfig(a));d(b).each(function(){d(this).val(f)})}},noWeekends:function(a){a=a.getDay();return[a>0&&a<6,""]},iso8601Week:function(a){a=new Date(a.getTime());a.setDate(a.getDate()+4-(a.getDay()||7));var b=a.getTime();a.setMonth(0);a.setDate(1);return Math.floor(Math.round((b-a)/864E5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?
b.toString():b+"";if(b=="")return null;var e=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;e=typeof e!="string"?e:(new Date).getFullYear()%100+parseInt(e,10);for(var f=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,h=(c?c.dayNames:null)||this._defaults.dayNames,i=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,g=(c?c.monthNames:null)||this._defaults.monthNames,j=c=-1,l=-1,u=-1,k=false,o=function(p){(p=A+1<a.length&&a.charAt(A+1)==p)&&A++;return p},m=function(p){var D=
o(p);p=new RegExp("^\\d{1,"+(p=="@"?14:p=="!"?20:p=="y"&&D?4:p=="o"?3:2)+"}");p=b.substring(q).match(p);if(!p)throw"Missing number at position "+q;q+=p[0].length;return parseInt(p[0],10)},n=function(p,D,K){p=d.map(o(p)?K:D,function(w,x){return[[x,w]]}).sort(function(w,x){return-(w[1].length-x[1].length)});var E=-1;d.each(p,function(w,x){w=x[1];if(b.substr(q,w.length).toLowerCase()==w.toLowerCase()){E=x[0];q+=w.length;return false}});if(E!=-1)return E+1;else throw"Unknown name at position "+q;},s=
function(){if(b.charAt(q)!=a.charAt(A))throw"Unexpected literal at position "+q;q++},q=0,A=0;A<a.length;A++)if(k)if(a.charAt(A)=="'"&&!o("'"))k=false;else s();else switch(a.charAt(A)){case "d":l=m("d");break;case "D":n("D",f,h);break;case "o":u=m("o");break;case "m":j=m("m");break;case "M":j=n("M",i,g);break;case "y":c=m("y");break;case "@":var v=new Date(m("@"));c=v.getFullYear();j=v.getMonth()+1;l=v.getDate();break;case "!":v=new Date((m("!")-this._ticksTo1970)/1E4);c=v.getFullYear();j=v.getMonth()+
1;l=v.getDate();break;case "'":if(o("'"))s();else k=true;break;default:s()}if(q<b.length)throw"Extra/unparsed characters found in date: "+b.substring(q);if(c==-1)c=(new Date).getFullYear();else if(c<100)c+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c<=e?0:-100);if(u>-1){j=1;l=u;do{e=this._getDaysInMonth(c,j-1);if(l<=e)break;j++;l-=e}while(1)}v=this._daylightSavingAdjust(new Date(c,j-1,l));if(v.getFullYear()!=c||v.getMonth()+1!=j||v.getDate()!=l)throw"Invalid date";return v},ATOM:"yy-mm-dd",
COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1E7,formatDate:function(a,b,c){if(!b)return"";var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,h=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort;c=(c?c.monthNames:
null)||this._defaults.monthNames;var i=function(o){(o=k+1<a.length&&a.charAt(k+1)==o)&&k++;return o},g=function(o,m,n){m=""+m;if(i(o))for(;m.length<n;)m="0"+m;return m},j=function(o,m,n,s){return i(o)?s[m]:n[m]},l="",u=false;if(b)for(var k=0;k<a.length;k++)if(u)if(a.charAt(k)=="'"&&!i("'"))u=false;else l+=a.charAt(k);else switch(a.charAt(k)){case "d":l+=g("d",b.getDate(),2);break;case "D":l+=j("D",b.getDay(),e,f);break;case "o":l+=g("o",Math.round(((new Date(b.getFullYear(),b.getMonth(),b.getDate())).getTime()-
(new Date(b.getFullYear(),0,0)).getTime())/864E5),3);break;case "m":l+=g("m",b.getMonth()+1,2);break;case "M":l+=j("M",b.getMonth(),h,c);break;case "y":l+=i("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case "@":l+=b.getTime();break;case "!":l+=b.getTime()*1E4+this._ticksTo1970;break;case "'":if(i("'"))l+="'";else u=true;break;default:l+=a.charAt(k)}return l},_possibleChars:function(a){for(var b="",c=false,e=function(h){(h=f+1<a.length&&a.charAt(f+1)==h)&&f++;return h},f=
0;f<a.length;f++)if(c)if(a.charAt(f)=="'"&&!e("'"))c=false;else b+=a.charAt(f);else switch(a.charAt(f)){case "d":case "m":case "y":case "@":b+="0123456789";break;case "D":case "M":return null;case "'":if(e("'"))b+="'";else c=true;break;default:b+=a.charAt(f)}return b},_get:function(a,b){return a.settings[b]!==C?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()!=a.lastVal){var c=this._get(a,"dateFormat"),e=a.lastVal=a.input?a.input.val():null,f,h;f=h=this._getDefaultDate(a);
var i=this._getFormatConfig(a);try{f=this.parseDate(c,e,i)||h}catch(g){this.log(g);e=b?"":e}a.selectedDay=f.getDate();a.drawMonth=a.selectedMonth=f.getMonth();a.drawYear=a.selectedYear=f.getFullYear();a.currentDay=e?f.getDate():0;a.currentMonth=e?f.getMonth():0;a.currentYear=e?f.getFullYear():0;this._adjustInstDate(a)}},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var e=function(h){var i=new Date;
i.setDate(i.getDate()+h);return i},f=function(h){try{return d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),h,d.datepicker._getFormatConfig(a))}catch(i){}var g=(h.toLowerCase().match(/^c/)?d.datepicker._getDate(a):null)||new Date,j=g.getFullYear(),l=g.getMonth();g=g.getDate();for(var u=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,k=u.exec(h);k;){switch(k[2]||"d"){case "d":case "D":g+=parseInt(k[1],10);break;case "w":case "W":g+=parseInt(k[1],10)*7;break;case "m":case "M":l+=parseInt(k[1],10);g=
Math.min(g,d.datepicker._getDaysInMonth(j,l));break;case "y":case "Y":j+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break}k=u.exec(h)}return new Date(j,l,g)};if(b=(b=b==null||b===""?c:typeof b=="string"?f(b):typeof b=="number"?isNaN(b)?c:e(b):new Date(b.getTime()))&&b.toString()=="Invalid Date"?c:b){b.setHours(0);b.setMinutes(0);b.setSeconds(0);b.setMilliseconds(0)}return this._daylightSavingAdjust(b)},_daylightSavingAdjust:function(a){if(!a)return null;a.setHours(a.getHours()>
12?a.getHours()+2:0);return a},_setDate:function(a,b,c){var e=!b,f=a.selectedMonth,h=a.selectedYear;b=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=a.currentDay=b.getDate();a.drawMonth=a.selectedMonth=a.currentMonth=b.getMonth();a.drawYear=a.selectedYear=a.currentYear=b.getFullYear();if((f!=a.selectedMonth||h!=a.selectedYear)&&!c)this._notifyChange(a);this._adjustInstDate(a);if(a.input)a.input.val(e?"":this._formatDate(a))},_getDate:function(a){return!a.currentYear||a.input&&
a.input.val()==""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay))},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),e=this._get(a,"showButtonPanel"),f=this._get(a,"hideIfNoPrevNext"),h=this._get(a,"navigationAsDateFormat"),i=this._getNumberOfMonths(a),g=this._get(a,"showCurrentAtPos"),j=this._get(a,"stepMonths"),l=i[0]!=1||i[1]!=1,u=this._daylightSavingAdjust(!a.currentDay?
new Date(9999,9,9):new Date(a.currentYear,a.currentMonth,a.currentDay)),k=this._getMinMaxDate(a,"min"),o=this._getMinMaxDate(a,"max");g=a.drawMonth-g;var m=a.drawYear;if(g<0){g+=12;m--}if(o){var n=this._daylightSavingAdjust(new Date(o.getFullYear(),o.getMonth()-i[0]*i[1]+1,o.getDate()));for(n=k&&n<k?k:n;this._daylightSavingAdjust(new Date(m,g,1))>n;){g--;if(g<0){g=11;m--}}}a.drawMonth=g;a.drawYear=m;n=this._get(a,"prevText");n=!h?n:this.formatDate(n,this._daylightSavingAdjust(new Date(m,g-j,1)),this._getFormatConfig(a));
n=this._canAdjustMonth(a,-1,m,g)?'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_'+B+".datepicker._adjustDate('#"+a.id+"', -"+j+", 'M');\" title=\""+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>":f?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>";var s=this._get(a,"nextText");s=!h?s:this.formatDate(s,this._daylightSavingAdjust(new Date(m,
g+j,1)),this._getFormatConfig(a));f=this._canAdjustMonth(a,+1,m,g)?'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_'+B+".datepicker._adjustDate('#"+a.id+"', +"+j+", 'M');\" title=\""+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>":f?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>";j=this._get(a,"currentText");s=this._get(a,"gotoCurrent")&&
a.currentDay?u:b;j=!h?j:this.formatDate(j,s,this._getFormatConfig(a));h=!a.inline?'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_'+B+'.datepicker._hideDatepicker();">'+this._get(a,"closeText")+"</button>":"";e=e?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?h:"")+(this._isInRange(a,s)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_'+
B+".datepicker._gotoToday('#"+a.id+"');\">"+j+"</button>":"")+(c?"":h)+"</div>":"";h=parseInt(this._get(a,"firstDay"),10);h=isNaN(h)?0:h;j=this._get(a,"showWeek");s=this._get(a,"dayNames");this._get(a,"dayNamesShort");var q=this._get(a,"dayNamesMin"),A=this._get(a,"monthNames"),v=this._get(a,"monthNamesShort"),p=this._get(a,"beforeShowDay"),D=this._get(a,"showOtherMonths"),K=this._get(a,"selectOtherMonths");this._get(a,"calculateWeek");for(var E=this._getDefaultDate(a),w="",x=0;x<i[0];x++){var O=
"";this.maxRows=4;for(var G=0;G<i[1];G++){var P=this._daylightSavingAdjust(new Date(m,g,a.selectedDay)),t=" ui-corner-all",y="";if(l){y+='<div class="ui-datepicker-group';if(i[1]>1)switch(G){case 0:y+=" ui-datepicker-group-first";t=" ui-corner-"+(c?"right":"left");break;case i[1]-1:y+=" ui-datepicker-group-last";t=" ui-corner-"+(c?"left":"right");break;default:y+=" ui-datepicker-group-middle";t="";break}y+='">'}y+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+t+'">'+(/all|left/.test(t)&&
x==0?c?f:n:"")+(/all|right/.test(t)&&x==0?c?n:f:"")+this._generateMonthYearHeader(a,g,m,k,o,x>0||G>0,A,v)+'</div><table class="ui-datepicker-calendar"><thead><tr>';var z=j?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":"";for(t=0;t<7;t++){var r=(t+h)%7;z+="<th"+((t+h+6)%7>=5?' class="ui-datepicker-week-end"':"")+'><span title="'+s[r]+'">'+q[r]+"</span></th>"}y+=z+"</tr></thead><tbody>";z=this._getDaysInMonth(m,g);if(m==a.selectedYear&&g==a.selectedMonth)a.selectedDay=Math.min(a.selectedDay,
z);t=(this._getFirstDayOfMonth(m,g)-h+7)%7;z=Math.ceil((t+z)/7);this.maxRows=z=l?this.maxRows>z?this.maxRows:z:z;r=this._daylightSavingAdjust(new Date(m,g,1-t));for(var Q=0;Q<z;Q++){y+="<tr>";var R=!j?"":'<td class="ui-datepicker-week-col">'+this._get(a,"calculateWeek")(r)+"</td>";for(t=0;t<7;t++){var I=p?p.apply(a.input?a.input[0]:null,[r]):[true,""],F=r.getMonth()!=g,L=F&&!K||!I[0]||k&&r<k||o&&r>o;R+='<td class="'+((t+h+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(r.getTime()==
P.getTime()&&g==a.selectedMonth&&a._keyEvent||E.getTime()==r.getTime()&&E.getTime()==P.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!D?"":" "+I[1]+(r.getTime()==u.getTime()?" "+this._currentClass:"")+(r.getTime()==b.getTime()?" ui-datepicker-today":""))+'"'+((!F||D)&&I[2]?' title="'+I[2]+'"':"")+(L?"":' onclick="DP_jQuery_'+B+".datepicker._selectDay('#"+a.id+"',"+r.getMonth()+","+r.getFullYear()+', this);return false;"')+">"+(F&&!D?"&#xa0;":L?'<span class="ui-state-default">'+
r.getDate()+"</span>":'<a class="ui-state-default'+(r.getTime()==b.getTime()?" ui-state-highlight":"")+(r.getTime()==u.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+'" href="#">'+r.getDate()+"</a>")+"</td>";r.setDate(r.getDate()+1);r=this._daylightSavingAdjust(r)}y+=R+"</tr>"}g++;if(g>11){g=0;m++}y+="</tbody></table>"+(l?"</div>"+(i[0]>0&&G==i[1]-1?'<div class="ui-datepicker-row-break"></div>':""):"");O+=y}w+=O}w+=e+(d.browser.msie&&parseInt(d.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':
"");a._keyEvent=false;return w},_generateMonthYearHeader:function(a,b,c,e,f,h,i,g){var j=this._get(a,"changeMonth"),l=this._get(a,"changeYear"),u=this._get(a,"showMonthAfterYear"),k='<div class="ui-datepicker-title">',o="";if(h||!j)o+='<span class="ui-datepicker-month">'+i[b]+"</span>";else{i=e&&e.getFullYear()==c;var m=f&&f.getFullYear()==c;o+='<select class="ui-datepicker-month" onchange="DP_jQuery_'+B+".datepicker._selectMonthYear('#"+a.id+"', this, 'M');\" >";for(var n=0;n<12;n++)if((!i||n>=e.getMonth())&&
(!m||n<=f.getMonth()))o+='<option value="'+n+'"'+(n==b?' selected="selected"':"")+">"+g[n]+"</option>";o+="</select>"}u||(k+=o+(h||!(j&&l)?"&#xa0;":""));if(!a.yearshtml){a.yearshtml="";if(h||!l)k+='<span class="ui-datepicker-year">'+c+"</span>";else{g=this._get(a,"yearRange").split(":");var s=(new Date).getFullYear();i=function(q){q=q.match(/c[+-].*/)?c+parseInt(q.substring(1),10):q.match(/[+-].*/)?s+parseInt(q,10):parseInt(q,10);return isNaN(q)?s:q};b=i(g[0]);g=Math.max(b,i(g[1]||""));b=e?Math.max(b,
e.getFullYear()):b;g=f?Math.min(g,f.getFullYear()):g;for(a.yearshtml+='<select class="ui-datepicker-year" onchange="DP_jQuery_'+B+".datepicker._selectMonthYear('#"+a.id+"', this, 'Y');\" >";b<=g;b++)a.yearshtml+='<option value="'+b+'"'+(b==c?' selected="selected"':"")+">"+b+"</option>";a.yearshtml+="</select>";k+=a.yearshtml;a.yearshtml=null}}k+=this._get(a,"yearSuffix");if(u)k+=(h||!(j&&l)?"&#xa0;":"")+o;k+="</div>";return k},_adjustInstDate:function(a,b,c){var e=a.drawYear+(c=="Y"?b:0),f=a.drawMonth+
(c=="M"?b:0);b=Math.min(a.selectedDay,this._getDaysInMonth(e,f))+(c=="D"?b:0);e=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(e,f,b)));a.selectedDay=e.getDate();a.drawMonth=a.selectedMonth=e.getMonth();a.drawYear=a.selectedYear=e.getFullYear();if(c=="M"||c=="Y")this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");b=c&&b<c?c:b;return b=a&&b>a?a:b},_notifyChange:function(a){var b=this._get(a,"onChangeMonthYear");if(b)b.apply(a.input?
a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){a=this._get(a,"numberOfMonths");return a==null?[1,1]:typeof a=="number"?[1,a]:a},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,e){var f=this._getNumberOfMonths(a);c=this._daylightSavingAdjust(new Date(c,
e+(b<0?b:f[0]*f[1]),1));b<0&&c.setDate(this._getDaysInMonth(c.getFullYear(),c.getMonth()));return this._isInRange(a,c)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!a||b.getTime()<=a.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10);return{shortYearCutoff:b,dayNamesShort:this._get(a,"dayNamesShort"),dayNames:this._get(a,
"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,e){if(!b){a.currentDay=a.selectedDay;a.currentMonth=a.selectedMonth;a.currentYear=a.selectedYear}b=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(e,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),b,this._getFormatConfig(a))}});d.fn.datepicker=function(a){if(!this.length)return this;
if(!d.datepicker.initialized){d(document).mousedown(d.datepicker._checkExternalClick).find("body").append(d.datepicker.dpDiv);d.datepicker.initialized=true}var b=Array.prototype.slice.call(arguments,1);if(typeof a=="string"&&(a=="isDisabled"||a=="getDate"||a=="widget"))return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));if(a=="option"&&arguments.length==2&&typeof arguments[1]=="string")return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));return this.each(function(){typeof a==
"string"?d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this].concat(b)):d.datepicker._attachDatepicker(this,a)})};d.datepicker=new M;d.datepicker.initialized=false;d.datepicker.uuid=(new Date).getTime();d.datepicker.version="1.8.16";window["DP_jQuery_"+B]=d})(jQuery);
;/*
 * jQuery UI Progressbar 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function(b,d){b.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()});this.valueDiv=b("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);this.oldValue=this._value();this._refreshValue()},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
this.valueDiv.remove();b.Widget.prototype.destroy.apply(this,arguments)},value:function(a){if(a===d)return this._value();this._setOption("value",a);return this},_setOption:function(a,c){if(a==="value"){this.options.value=c;this._refreshValue();this._value()===this.options.max&&this._trigger("complete")}b.Widget.prototype._setOption.apply(this,arguments)},_value:function(){var a=this.options.value;if(typeof a!=="number")a=0;return Math.min(this.options.max,Math.max(this.min,a))},_percentage:function(){return 100*
this._value()/this.options.max},_refreshValue:function(){var a=this.value(),c=this._percentage();if(this.oldValue!==a){this.oldValue=a;this._trigger("change")}this.valueDiv.toggle(a>this.min).toggleClass("ui-corner-right",a===this.options.max).width(c.toFixed(0)+"%");this.element.attr("aria-valuenow",a)}});b.extend(b.ui.progressbar,{version:"1.8.16"})})(jQuery);
;/*
 * jQuery UI Effects 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
jQuery.effects||function(f,j){function m(c){var a;if(c&&c.constructor==Array&&c.length==3)return c;if(a=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c))return[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10)];if(a=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c))return[parseFloat(a[1])*2.55,parseFloat(a[2])*2.55,parseFloat(a[3])*2.55];if(a=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c))return[parseInt(a[1],
16),parseInt(a[2],16),parseInt(a[3],16)];if(a=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c))return[parseInt(a[1]+a[1],16),parseInt(a[2]+a[2],16),parseInt(a[3]+a[3],16)];if(/rgba\(0, 0, 0, 0\)/.exec(c))return n.transparent;return n[f.trim(c).toLowerCase()]}function s(c,a){var b;do{b=f.curCSS(c,a);if(b!=""&&b!="transparent"||f.nodeName(c,"body"))break;a="backgroundColor"}while(c=c.parentNode);return m(b)}function o(){var c=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,
a={},b,d;if(c&&c.length&&c[0]&&c[c[0]])for(var e=c.length;e--;){b=c[e];if(typeof c[b]=="string"){d=b.replace(/\-(\w)/g,function(g,h){return h.toUpperCase()});a[d]=c[b]}}else for(b in c)if(typeof c[b]==="string")a[b]=c[b];return a}function p(c){var a,b;for(a in c){b=c[a];if(b==null||f.isFunction(b)||a in t||/scrollbar/.test(a)||!/color/i.test(a)&&isNaN(parseFloat(b)))delete c[a]}return c}function u(c,a){var b={_:0},d;for(d in a)if(c[d]!=a[d])b[d]=a[d];return b}function k(c,a,b,d){if(typeof c=="object"){d=
a;b=null;a=c;c=a.effect}if(f.isFunction(a)){d=a;b=null;a={}}if(typeof a=="number"||f.fx.speeds[a]){d=b;b=a;a={}}if(f.isFunction(b)){d=b;b=null}a=a||{};b=b||a.duration;b=f.fx.off?0:typeof b=="number"?b:b in f.fx.speeds?f.fx.speeds[b]:f.fx.speeds._default;d=d||a.complete;return[c,a,b,d]}function l(c){if(!c||typeof c==="number"||f.fx.speeds[c])return true;if(typeof c==="string"&&!f.effects[c])return true;return false}f.effects={};f.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor",
"borderTopColor","borderColor","color","outlineColor"],function(c,a){f.fx.step[a]=function(b){if(!b.colorInit){b.start=s(b.elem,a);b.end=m(b.end);b.colorInit=true}b.elem.style[a]="rgb("+Math.max(Math.min(parseInt(b.pos*(b.end[0]-b.start[0])+b.start[0],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[1]-b.start[1])+b.start[1],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[2]-b.start[2])+b.start[2],10),255),0)+")"}});var n={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,
0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,
211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},q=["add","remove","toggle"],t={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};f.effects.animateClass=function(c,a,b,
d){if(f.isFunction(b)){d=b;b=null}return this.queue(function(){var e=f(this),g=e.attr("style")||" ",h=p(o.call(this)),r,v=e.attr("class");f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});r=p(o.call(this));e.attr("class",v);e.animate(u(h,r),{queue:false,duration:a,easing:b,complete:function(){f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});if(typeof e.attr("style")=="object"){e.attr("style").cssText="";e.attr("style").cssText=g}else e.attr("style",g);d&&d.apply(this,arguments);f.dequeue(this)}})})};
f.fn.extend({_addClass:f.fn.addClass,addClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{add:c},a,b,d]):this._addClass(c)},_removeClass:f.fn.removeClass,removeClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{remove:c},a,b,d]):this._removeClass(c)},_toggleClass:f.fn.toggleClass,toggleClass:function(c,a,b,d,e){return typeof a=="boolean"||a===j?b?f.effects.animateClass.apply(this,[a?{add:c}:{remove:c},b,d,e]):this._toggleClass(c,a):f.effects.animateClass.apply(this,
[{toggle:c},a,b,d])},switchClass:function(c,a,b,d,e){return f.effects.animateClass.apply(this,[{add:a,remove:c},b,d,e])}});f.extend(f.effects,{version:"1.8.16",save:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.data("ec.storage."+a[b],c[0].style[a[b]])},restore:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.css(a[b],c.data("ec.storage."+a[b]))},setMode:function(c,a){if(a=="toggle")a=c.is(":hidden")?"show":"hide";return a},getBaseline:function(c,a){var b;switch(c[0]){case "top":b=
0;break;case "middle":b=0.5;break;case "bottom":b=1;break;default:b=c[0]/a.height}switch(c[1]){case "left":c=0;break;case "center":c=0.5;break;case "right":c=1;break;default:c=c[1]/a.width}return{x:c,y:b}},createWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent();var a={width:c.outerWidth(true),height:c.outerHeight(true),"float":c.css("float")},b=f("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),
d=document.activeElement;c.wrap(b);if(c[0]===d||f.contains(c[0],d))f(d).focus();b=c.parent();if(c.css("position")=="static"){b.css({position:"relative"});c.css({position:"relative"})}else{f.extend(a,{position:c.css("position"),zIndex:c.css("z-index")});f.each(["top","left","bottom","right"],function(e,g){a[g]=c.css(g);if(isNaN(parseInt(a[g],10)))a[g]="auto"});c.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})}return b.css(a).show()},removeWrapper:function(c){var a,b=document.activeElement;
if(c.parent().is(".ui-effects-wrapper")){a=c.parent().replaceWith(c);if(c[0]===b||f.contains(c[0],b))f(b).focus();return a}return c},setTransition:function(c,a,b,d){d=d||{};f.each(a,function(e,g){unit=c.cssUnit(g);if(unit[0]>0)d[g]=unit[0]*b+unit[1]});return d}});f.fn.extend({effect:function(c){var a=k.apply(this,arguments),b={options:a[1],duration:a[2],callback:a[3]};a=b.options.mode;var d=f.effects[c];if(f.fx.off||!d)return a?this[a](b.duration,b.callback):this.each(function(){b.callback&&b.callback.call(this)});
return d.call(this,b)},_show:f.fn.show,show:function(c){if(l(c))return this._show.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="show";return this.effect.apply(this,a)}},_hide:f.fn.hide,hide:function(c){if(l(c))return this._hide.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="hide";return this.effect.apply(this,a)}},__toggle:f.fn.toggle,toggle:function(c){if(l(c)||typeof c==="boolean"||f.isFunction(c))return this.__toggle.apply(this,arguments);else{var a=k.apply(this,
arguments);a[1].mode="toggle";return this.effect.apply(this,a)}},cssUnit:function(c){var a=this.css(c),b=[];f.each(["em","px","%","pt"],function(d,e){if(a.indexOf(e)>0)b=[parseFloat(a),e]});return b}});f.easing.jswing=f.easing.swing;f.extend(f.easing,{def:"easeOutQuad",swing:function(c,a,b,d,e){return f.easing[f.easing.def](c,a,b,d,e)},easeInQuad:function(c,a,b,d,e){return d*(a/=e)*a+b},easeOutQuad:function(c,a,b,d,e){return-d*(a/=e)*(a-2)+b},easeInOutQuad:function(c,a,b,d,e){if((a/=e/2)<1)return d/
2*a*a+b;return-d/2*(--a*(a-2)-1)+b},easeInCubic:function(c,a,b,d,e){return d*(a/=e)*a*a+b},easeOutCubic:function(c,a,b,d,e){return d*((a=a/e-1)*a*a+1)+b},easeInOutCubic:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a+b;return d/2*((a-=2)*a*a+2)+b},easeInQuart:function(c,a,b,d,e){return d*(a/=e)*a*a*a+b},easeOutQuart:function(c,a,b,d,e){return-d*((a=a/e-1)*a*a*a-1)+b},easeInOutQuart:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a+b;return-d/2*((a-=2)*a*a*a-2)+b},easeInQuint:function(c,a,b,
d,e){return d*(a/=e)*a*a*a*a+b},easeOutQuint:function(c,a,b,d,e){return d*((a=a/e-1)*a*a*a*a+1)+b},easeInOutQuint:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a*a+b;return d/2*((a-=2)*a*a*a*a+2)+b},easeInSine:function(c,a,b,d,e){return-d*Math.cos(a/e*(Math.PI/2))+d+b},easeOutSine:function(c,a,b,d,e){return d*Math.sin(a/e*(Math.PI/2))+b},easeInOutSine:function(c,a,b,d,e){return-d/2*(Math.cos(Math.PI*a/e)-1)+b},easeInExpo:function(c,a,b,d,e){return a==0?b:d*Math.pow(2,10*(a/e-1))+b},easeOutExpo:function(c,
a,b,d,e){return a==e?b+d:d*(-Math.pow(2,-10*a/e)+1)+b},easeInOutExpo:function(c,a,b,d,e){if(a==0)return b;if(a==e)return b+d;if((a/=e/2)<1)return d/2*Math.pow(2,10*(a-1))+b;return d/2*(-Math.pow(2,-10*--a)+2)+b},easeInCirc:function(c,a,b,d,e){return-d*(Math.sqrt(1-(a/=e)*a)-1)+b},easeOutCirc:function(c,a,b,d,e){return d*Math.sqrt(1-(a=a/e-1)*a)+b},easeInOutCirc:function(c,a,b,d,e){if((a/=e/2)<1)return-d/2*(Math.sqrt(1-a*a)-1)+b;return d/2*(Math.sqrt(1-(a-=2)*a)+1)+b},easeInElastic:function(c,a,b,
d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);return-(h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g))+b},easeOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*a)*Math.sin((a*e-c)*2*Math.PI/g)+d+b},easeInOutElastic:function(c,a,b,d,e){c=1.70158;var g=
0,h=d;if(a==0)return b;if((a/=e/2)==2)return b+d;g||(g=e*0.3*1.5);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);if(a<1)return-0.5*h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)+b;return h*Math.pow(2,-10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)*0.5+d+b},easeInBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*(a/=e)*a*((g+1)*a-g)+b},easeOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*((a=a/e-1)*a*((g+1)*a+g)+1)+b},easeInOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;
if((a/=e/2)<1)return d/2*a*a*(((g*=1.525)+1)*a-g)+b;return d/2*((a-=2)*a*(((g*=1.525)+1)*a+g)+2)+b},easeInBounce:function(c,a,b,d,e){return d-f.easing.easeOutBounce(c,e-a,0,d,e)+b},easeOutBounce:function(c,a,b,d,e){return(a/=e)<1/2.75?d*7.5625*a*a+b:a<2/2.75?d*(7.5625*(a-=1.5/2.75)*a+0.75)+b:a<2.5/2.75?d*(7.5625*(a-=2.25/2.75)*a+0.9375)+b:d*(7.5625*(a-=2.625/2.75)*a+0.984375)+b},easeInOutBounce:function(c,a,b,d,e){if(a<e/2)return f.easing.easeInBounce(c,a*2,0,d,e)*0.5+b;return f.easing.easeOutBounce(c,
a*2-e,0,d,e)*0.5+d*0.5+b}})}(jQuery);
;/*
 * jQuery UI Effects Blind 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.blind=function(c){return this.queue(function(){var a=b(this),g=["position","top","bottom","left","right"],f=b.effects.setMode(a,c.options.mode||"hide"),d=c.options.direction||"vertical";b.effects.save(a,g);a.show();var e=b.effects.createWrapper(a).css({overflow:"hidden"}),h=d=="vertical"?"height":"width";d=d=="vertical"?e.height():e.width();f=="show"&&e.css(h,0);var i={};i[h]=f=="show"?d:0;e.animate(i,c.duration,c.options.easing,function(){f=="hide"&&a.hide();b.effects.restore(a,
g);b.effects.removeWrapper(a);c.callback&&c.callback.apply(a[0],arguments);a.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Bounce 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.bounce=function(b){return this.queue(function(){var a=e(this),l=["position","top","bottom","left","right"],h=e.effects.setMode(a,b.options.mode||"effect"),d=b.options.direction||"up",c=b.options.distance||20,m=b.options.times||5,i=b.duration||250;/show|hide/.test(h)&&l.push("opacity");e.effects.save(a,l);a.show();e.effects.createWrapper(a);var f=d=="up"||d=="down"?"top":"left";d=d=="up"||d=="left"?"pos":"neg";c=b.options.distance||(f=="top"?a.outerHeight({margin:true})/3:a.outerWidth({margin:true})/
3);if(h=="show")a.css("opacity",0).css(f,d=="pos"?-c:c);if(h=="hide")c/=m*2;h!="hide"&&m--;if(h=="show"){var g={opacity:1};g[f]=(d=="pos"?"+=":"-=")+c;a.animate(g,i/2,b.options.easing);c/=2;m--}for(g=0;g<m;g++){var j={},k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing);c=h=="hide"?c*2:c/2}if(h=="hide"){g={opacity:0};g[f]=(d=="pos"?"-=":"+=")+c;a.animate(g,i/2,b.options.easing,function(){a.hide();e.effects.restore(a,l);e.effects.removeWrapper(a);
b.callback&&b.callback.apply(this,arguments)})}else{j={};k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing,function(){e.effects.restore(a,l);e.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments)})}a.queue("fx",function(){a.dequeue()});a.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Clip 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.clip=function(e){return this.queue(function(){var a=b(this),i=["position","top","bottom","left","right","height","width"],f=b.effects.setMode(a,e.options.mode||"hide"),c=e.options.direction||"vertical";b.effects.save(a,i);a.show();var d=b.effects.createWrapper(a).css({overflow:"hidden"});d=a[0].tagName=="IMG"?d:a;var g={size:c=="vertical"?"height":"width",position:c=="vertical"?"top":"left"};c=c=="vertical"?d.height():d.width();if(f=="show"){d.css(g.size,0);d.css(g.position,
c/2)}var h={};h[g.size]=f=="show"?c:0;h[g.position]=f=="show"?0:c/2;d.animate(h,{queue:false,duration:e.duration,easing:e.options.easing,complete:function(){f=="hide"&&a.hide();b.effects.restore(a,i);b.effects.removeWrapper(a);e.callback&&e.callback.apply(a[0],arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Drop 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.drop=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right","opacity"],e=c.effects.setMode(a,d.options.mode||"hide"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a);var f=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var g=d.options.distance||(f=="top"?a.outerHeight({margin:true})/2:a.outerWidth({margin:true})/2);if(e=="show")a.css("opacity",0).css(f,b=="pos"?-g:g);var i={opacity:e==
"show"?1:0};i[f]=(e=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+g;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){e=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Explode 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(j){j.effects.explode=function(a){return this.queue(function(){var c=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3,d=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3;a.options.mode=a.options.mode=="toggle"?j(this).is(":visible")?"hide":"show":a.options.mode;var b=j(this).show().css("visibility","hidden"),g=b.offset();g.top-=parseInt(b.css("marginTop"),10)||0;g.left-=parseInt(b.css("marginLeft"),10)||0;for(var h=b.outerWidth(true),i=b.outerHeight(true),e=0;e<c;e++)for(var f=
0;f<d;f++)b.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-f*(h/d),top:-e*(i/c)}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:h/d,height:i/c,left:g.left+f*(h/d)+(a.options.mode=="show"?(f-Math.floor(d/2))*(h/d):0),top:g.top+e*(i/c)+(a.options.mode=="show"?(e-Math.floor(c/2))*(i/c):0),opacity:a.options.mode=="show"?0:1}).animate({left:g.left+f*(h/d)+(a.options.mode=="show"?0:(f-Math.floor(d/2))*(h/d)),top:g.top+
e*(i/c)+(a.options.mode=="show"?0:(e-Math.floor(c/2))*(i/c)),opacity:a.options.mode=="show"?1:0},a.duration||500);setTimeout(function(){a.options.mode=="show"?b.css({visibility:"visible"}):b.css({visibility:"visible"}).hide();a.callback&&a.callback.apply(b[0]);b.dequeue();j("div.ui-effects-explode").remove()},a.duration||500)})}})(jQuery);
;/*
 * jQuery UI Effects Fade 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.fade=function(a){return this.queue(function(){var c=b(this),d=b.effects.setMode(c,a.options.mode||"hide");c.animate({opacity:d},{queue:false,duration:a.duration,easing:a.options.easing,complete:function(){a.callback&&a.callback.apply(this,arguments);c.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Fold 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.fold=function(a){return this.queue(function(){var b=c(this),j=["position","top","bottom","left","right"],d=c.effects.setMode(b,a.options.mode||"hide"),g=a.options.size||15,h=!!a.options.horizFirst,k=a.duration?a.duration/2:c.fx.speeds._default/2;c.effects.save(b,j);b.show();var e=c.effects.createWrapper(b).css({overflow:"hidden"}),f=d=="show"!=h,l=f?["width","height"]:["height","width"];f=f?[e.width(),e.height()]:[e.height(),e.width()];var i=/([0-9]+)%/.exec(g);if(i)g=parseInt(i[1],
10)/100*f[d=="hide"?0:1];if(d=="show")e.css(h?{height:0,width:g}:{height:g,width:0});h={};i={};h[l[0]]=d=="show"?f[0]:g;i[l[1]]=d=="show"?f[1]:0;e.animate(h,k,a.options.easing).animate(i,k,a.options.easing,function(){d=="hide"&&b.hide();c.effects.restore(b,j);c.effects.removeWrapper(b);a.callback&&a.callback.apply(b[0],arguments);b.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Highlight 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.highlight=function(c){return this.queue(function(){var a=b(this),e=["backgroundImage","backgroundColor","opacity"],d=b.effects.setMode(a,c.options.mode||"show"),f={backgroundColor:a.css("backgroundColor")};if(d=="hide")f.opacity=0;b.effects.save(a,e);a.show().css({backgroundImage:"none",backgroundColor:c.options.color||"#ffff99"}).animate(f,{queue:false,duration:c.duration,easing:c.options.easing,complete:function(){d=="hide"&&a.hide();b.effects.restore(a,e);d=="show"&&!b.support.opacity&&
this.style.removeAttribute("filter");c.callback&&c.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Pulsate 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.pulsate=function(a){return this.queue(function(){var b=d(this),c=d.effects.setMode(b,a.options.mode||"show");times=(a.options.times||5)*2-1;duration=a.duration?a.duration/2:d.fx.speeds._default/2;isVisible=b.is(":visible");animateTo=0;if(!isVisible){b.css("opacity",0).show();animateTo=1}if(c=="hide"&&isVisible||c=="show"&&!isVisible)times--;for(c=0;c<times;c++){b.animate({opacity:animateTo},duration,a.options.easing);animateTo=(animateTo+1)%2}b.animate({opacity:animateTo},duration,
a.options.easing,function(){animateTo==0&&b.hide();a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()}).dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Scale 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.puff=function(b){return this.queue(function(){var a=c(this),e=c.effects.setMode(a,b.options.mode||"hide"),g=parseInt(b.options.percent,10)||150,h=g/100,i={height:a.height(),width:a.width()};c.extend(b.options,{fade:true,mode:e,percent:e=="hide"?g:100,from:e=="hide"?i:{height:i.height*h,width:i.width*h}});a.effect("scale",b.options,b.duration,b.callback);a.dequeue()})};c.effects.scale=function(b){return this.queue(function(){var a=c(this),e=c.extend(true,{},b.options),g=c.effects.setMode(a,
b.options.mode||"effect"),h=parseInt(b.options.percent,10)||(parseInt(b.options.percent,10)==0?0:g=="hide"?0:100),i=b.options.direction||"both",f=b.options.origin;if(g!="effect"){e.origin=f||["middle","center"];e.restore=true}f={height:a.height(),width:a.width()};a.from=b.options.from||(g=="show"?{height:0,width:0}:f);h={y:i!="horizontal"?h/100:1,x:i!="vertical"?h/100:1};a.to={height:f.height*h.y,width:f.width*h.x};if(b.options.fade){if(g=="show"){a.from.opacity=0;a.to.opacity=1}if(g=="hide"){a.from.opacity=
1;a.to.opacity=0}}e.from=a.from;e.to=a.to;e.mode=g;a.effect("size",e,b.duration,b.callback);a.dequeue()})};c.effects.size=function(b){return this.queue(function(){var a=c(this),e=["position","top","bottom","left","right","width","height","overflow","opacity"],g=["position","top","bottom","left","right","overflow","opacity"],h=["width","height","overflow"],i=["fontSize"],f=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],k=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],
p=c.effects.setMode(a,b.options.mode||"effect"),n=b.options.restore||false,m=b.options.scale||"both",l=b.options.origin,j={height:a.height(),width:a.width()};a.from=b.options.from||j;a.to=b.options.to||j;if(l){l=c.effects.getBaseline(l,j);a.from.top=(j.height-a.from.height)*l.y;a.from.left=(j.width-a.from.width)*l.x;a.to.top=(j.height-a.to.height)*l.y;a.to.left=(j.width-a.to.width)*l.x}var d={from:{y:a.from.height/j.height,x:a.from.width/j.width},to:{y:a.to.height/j.height,x:a.to.width/j.width}};
if(m=="box"||m=="both"){if(d.from.y!=d.to.y){e=e.concat(f);a.from=c.effects.setTransition(a,f,d.from.y,a.from);a.to=c.effects.setTransition(a,f,d.to.y,a.to)}if(d.from.x!=d.to.x){e=e.concat(k);a.from=c.effects.setTransition(a,k,d.from.x,a.from);a.to=c.effects.setTransition(a,k,d.to.x,a.to)}}if(m=="content"||m=="both")if(d.from.y!=d.to.y){e=e.concat(i);a.from=c.effects.setTransition(a,i,d.from.y,a.from);a.to=c.effects.setTransition(a,i,d.to.y,a.to)}c.effects.save(a,n?e:g);a.show();c.effects.createWrapper(a);
a.css("overflow","hidden").css(a.from);if(m=="content"||m=="both"){f=f.concat(["marginTop","marginBottom"]).concat(i);k=k.concat(["marginLeft","marginRight"]);h=e.concat(f).concat(k);a.find("*[width]").each(function(){child=c(this);n&&c.effects.save(child,h);var o={height:child.height(),width:child.width()};child.from={height:o.height*d.from.y,width:o.width*d.from.x};child.to={height:o.height*d.to.y,width:o.width*d.to.x};if(d.from.y!=d.to.y){child.from=c.effects.setTransition(child,f,d.from.y,child.from);
child.to=c.effects.setTransition(child,f,d.to.y,child.to)}if(d.from.x!=d.to.x){child.from=c.effects.setTransition(child,k,d.from.x,child.from);child.to=c.effects.setTransition(child,k,d.to.x,child.to)}child.css(child.from);child.animate(child.to,b.duration,b.options.easing,function(){n&&c.effects.restore(child,h)})})}a.animate(a.to,{queue:false,duration:b.duration,easing:b.options.easing,complete:function(){a.to.opacity===0&&a.css("opacity",a.from.opacity);p=="hide"&&a.hide();c.effects.restore(a,
n?e:g);c.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Shake 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.shake=function(a){return this.queue(function(){var b=d(this),j=["position","top","bottom","left","right"];d.effects.setMode(b,a.options.mode||"effect");var c=a.options.direction||"left",e=a.options.distance||20,l=a.options.times||3,f=a.duration||a.options.duration||140;d.effects.save(b,j);b.show();d.effects.createWrapper(b);var g=c=="up"||c=="down"?"top":"left",h=c=="up"||c=="left"?"pos":"neg";c={};var i={},k={};c[g]=(h=="pos"?"-=":"+=")+e;i[g]=(h=="pos"?"+=":"-=")+e*2;k[g]=
(h=="pos"?"-=":"+=")+e*2;b.animate(c,f,a.options.easing);for(e=1;e<l;e++)b.animate(i,f,a.options.easing).animate(k,f,a.options.easing);b.animate(i,f,a.options.easing).animate(c,f/2,a.options.easing,function(){d.effects.restore(b,j);d.effects.removeWrapper(b);a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()});b.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Slide 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.slide=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right"],f=c.effects.setMode(a,d.options.mode||"show"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a).css({overflow:"hidden"});var g=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var e=d.options.distance||(g=="top"?a.outerHeight({margin:true}):a.outerWidth({margin:true}));if(f=="show")a.css(g,b=="pos"?isNaN(e)?"-"+e:-e:e);
var i={};i[g]=(f=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+e;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){f=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Transfer 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.transfer=function(a){return this.queue(function(){var b=e(this),c=e(a.options.to),d=c.offset();c={top:d.top,left:d.left,height:c.innerHeight(),width:c.innerWidth()};d=b.offset();var f=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(a.options.className).css({top:d.top,left:d.left,height:b.innerHeight(),width:b.innerWidth(),position:"absolute"}).animate(c,a.duration,a.options.easing,function(){f.remove();a.callback&&a.callback.apply(b[0],arguments);
b.dequeue()})})}})(jQuery);
;
;
// jQuery available Plugin 1.6.1 (20101220)
// By John Terenzio | http://plugins.jquery.com/project/available | MIT License
(function ($){ var queue = [], interval, check = function (){ for (var i = 0; i < queue.length; i++){ if ($(queue[i][0])[0] && (queue[i][2] || $(queue[i][0]).next()[0] || $.isReady)){ try{ queue[i][1].apply($(queue[i][0]).eq(0)); } catch (e){ if (typeof console != 'undefined'){ console.log(e); } } queue.splice(i, 1); i--; } } if (!queue.length || $.isReady){ interval = clearInterval(interval); } }; $.fn.available = function (fn, turbo){ turbo = turbo || false; queue.push([this.selector, fn, turbo]); if (!interval){ interval = setInterval(check, 1); } return this; }; })(jQuery);
;
/*global jQuery */
/*!	
* FitText.js 1.0
*
* Copyright 2011, Dave Rupert http://daverupert.com
* Released under the WTFPL license 
* http://sam.zoy.org/wtfpl/
*
* Date: Thu May 05 14:23:00 2011 -0600
*/

(function( $ ){
	
	$.fn.fitText = function( kompressor, options ) {
	    
	    var settings = {
        'minFontSize' : Number.NEGATIVE_INFINITY,
        'maxFontSize' : Number.POSITIVE_INFINITY
      };
	
			return this.each(function(){
				var $this = $(this);              // store the object
				var compressor = kompressor || 1; // set the compressor
        
        if ( options ) { 
          $.extend( settings, options );
        }
        
        // Resizer() resizes items based on the object width divided by the compressor * 10
				var resizer = function () {
					$this.css('font-size', Math.max(Math.min($this.width() / (compressor*10), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)));
				};

				// Call once to set.
				resizer();
				
				// Call on resize. Opera debounces their resize by default. 
      	$(window).resize(resizer);
      	
			});

	};

})( jQuery );
;
/*
*   Plug-in that resizes the height of a textarea 
*   Author: David Correa (dcorrea)
*   Brown University '15
*/

jQuery.fn.autoSize = function () {
    return this.each(function () {
        //Variables
        var defaultScrollHeight = this.scrollHeight;

        //Functions
        var increase = function () {
            increaseByRef(this);
        }

        var increaseByRef = function (objct) {
            var actualScrollHeight = objct.scrollHeight;

            if (actualScrollHeight !== defaultScrollHeight) {
                objct.style.height = actualScrollHeight + "px";
                defaultScrollHeight = actualScrollHeight;
            }
        }

        //Manipulations to the DOM element
        this.style.overflow = 'hidden';
        this.onkeydown = increase;
        this.onfocus = increase;
        this.onblur = increase;
        this.onchange = increase;
        
    });
};
;
/*
 *
 * Copyright (c) 2006-2011 Sam Collett (http://www.texotela.co.uk)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * 
 * Version 1.3
 * Demo: http://www.texotela.co.uk/code/jquery/numeric/
 *
 */
(function($) {
/*
 * Allows only valid characters to be entered into input boxes.
 * Note: fixes value when pasting via Ctrl+V, but not when using the mouse to paste
  *      side-effect: Ctrl+A does not work, though you can still use the mouse to select (or double-click to select all)
 *
 * @name     numeric
 * @param    config      { decimal : "." , negative : true }
 * @param    callback     A function that runs if the number is not valid (fires onblur)
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @example  $(".numeric").numeric();
 * @example  $(".numeric").numeric(","); // use , as separater
 * @example  $(".numeric").numeric({ decimal : "," }); // use , as separator
 * @example  $(".numeric").numeric({ negative : false }); // do not allow negative values
 * @example  $(".numeric").numeric(null, callback); // use default values, pass on the 'callback' function
 *
 */
$.fn.numeric = function(config, callback)
{
	if(typeof config === 'boolean')
	{
		config = { decimal: config };
	}
	config = config || {};
	// if config.negative undefined, set to true (default is to allow negative numbers)
	if(typeof config.negative == "undefined") config.negative = true;
	// set decimal point
	var decimal = (config.decimal === false) ? "" : config.decimal || ".";
	// allow negatives
	var negative = (config.negative === true) ? true : false;
	// callback function
	var callback = typeof callback == "function" ? callback : function(){};
	// set data and methods
	return this.data("numeric.decimal", decimal).data("numeric.negative", negative).data("numeric.callback", callback).keypress($.fn.numeric.keypress).keyup($.fn.numeric.keyup).blur($.fn.numeric.blur);
}

$.fn.numeric.keypress = function(e)
{
	// get decimal character and determine if negatives are allowed
	var decimal = $.data(this, "numeric.decimal");
	var negative = $.data(this, "numeric.negative");
	// get the key that was pressed
	var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
	// allow enter/return key (only when in an input box)
	if(key == 13 && this.nodeName.toLowerCase() == "input")
	{
		return true;
	}
	else if(key == 13)
	{
		return false;
	}
	var allow = false;
	// allow Ctrl+A
	if((e.ctrlKey && key == 97 /* firefox */) || (e.ctrlKey && key == 65) /* opera */) return true;
	// allow Ctrl+X (cut)
	if((e.ctrlKey && key == 120 /* firefox */) || (e.ctrlKey && key == 88) /* opera */) return true;
	// allow Ctrl+C (copy)
	if((e.ctrlKey && key == 99 /* firefox */) || (e.ctrlKey && key == 67) /* opera */) return true;
	// allow Ctrl+Z (undo)
	if((e.ctrlKey && key == 122 /* firefox */) || (e.ctrlKey && key == 90) /* opera */) return true;
	// allow or deny Ctrl+V (paste), Shift+Ins
	if((e.ctrlKey && key == 118 /* firefox */) || (e.ctrlKey && key == 86) /* opera */
	|| (e.shiftKey && key == 45)) return true;
	// if a number was not pressed
	if(key < 48 || key > 57)
	{
		/* '-' only allowed at start and if negative numbers allowed */
		if(this.value.indexOf("-") != 0 && negative && key == 45 && (this.value.length == 0 || ($.fn.getSelectionStart(this)) == 0)) return true;
		/* only one decimal separator allowed */
		if(decimal && key == decimal.charCodeAt(0) && this.value.indexOf(decimal) != -1)
		{
			allow = false;
		}
		// check for other keys that have special purposes
		if(
			key != 8 /* backspace */ &&
			key != 9 /* tab */ &&
			key != 13 /* enter */ &&
			key != 35 /* end */ &&
			key != 36 /* home */ &&
			key != 37 /* left */ &&
			key != 39 /* right */ &&
			key != 46 /* del */
		)
		{
			allow = false;
		}
		else
		{
			// for detecting special keys (listed above)
			// IE does not support 'charCode' and ignores them in keypress anyway
			if(typeof e.charCode != "undefined")
			{
				// special keys have 'keyCode' and 'which' the same (e.g. backspace)
				if(e.keyCode == e.which && e.which != 0)
				{
					allow = true;
					// . and delete share the same code, don't allow . (will be set to true later if it is the decimal point)
					if(e.which == 46) allow = false;
				}
				// or keyCode != 0 and 'charCode'/'which' = 0
				else if(e.keyCode != 0 && e.charCode == 0 && e.which == 0)
				{
					allow = true;
				}
			}
		}
		// if key pressed is the decimal and it is not already in the field
		if(decimal && key == decimal.charCodeAt(0))
		{
			if(this.value.indexOf(decimal) == -1)
			{
				allow = true;
			}
			else
			{
				allow = false;
			}
		}
	}
	else
	{
		allow = true;
	}
	return allow;
}

$.fn.numeric.keyup = function(e)
{
	var val = this.value;
	if(val.length > 0)
	{
		// get carat (cursor) position
		var carat = $.fn.getSelectionStart(this);
		// get decimal character and determine if negatives are allowed
		var decimal = $.data(this, "numeric.decimal");
		var negative = $.data(this, "numeric.negative");
		
		// prepend a 0 if necessary
		if(decimal != "")
		{
			// find decimal point
			var dot = val.indexOf(decimal);
			// if dot at start, add 0 before
			if(dot == 0)
			{
				this.value = "0" + val;
			}
			// if dot at position 1, check if there is a - symbol before it
			if(dot == 1 && val.charAt(0) == "-")
			{
				this.value = "-0" + val.substring(1);
			}
			val = this.value;
		}
		
		// if pasted in, only allow the following characters
		var validChars = [0,1,2,3,4,5,6,7,8,9,'-',decimal];
		// get length of the value (to loop through)
		var length = val.length;
		// loop backwards (to prevent going out of bounds)
		for(var i = length - 1; i >= 0; i--)
		{
			var ch = val.charAt(i);
			// remove '-' if it is in the wrong place
			if(i != 0 && ch == "-")
			{
				val = val.substring(0, i) + val.substring(i + 1);
			}
			// remove character if it is at the start, a '-' and negatives aren't allowed
			else if(i == 0 && !negative && ch == "-")
			{
				val = val.substring(1);
			}
			var validChar = false;
			// loop through validChars
			for(var j = 0; j < validChars.length; j++)
			{
				// if it is valid, break out the loop
				if(ch == validChars[j])
				{
					validChar = true;
					break;
				}
			}
			// if not a valid character, or a space, remove
			if(!validChar || ch == " ")
			{
				val = val.substring(0, i) + val.substring(i + 1);
			}
		}
		// remove extra decimal characters
		var firstDecimal = val.indexOf(decimal);
		if(firstDecimal > 0)
		{
			for(var i = length - 1; i > firstDecimal; i--)
			{
				var ch = val.charAt(i);
				// remove decimal character
				if(ch == decimal)
				{
					val = val.substring(0, i) + val.substring(i + 1);
				}
			}
		}
		// set the value and prevent the cursor moving to the end
		this.value = val;
		$.fn.setSelection(this, carat);
	}
}

$.fn.numeric.blur = function()
{
	var decimal = $.data(this, "numeric.decimal");
	var callback = $.data(this, "numeric.callback");
	var val = this.value;
	if(val != "")
	{
		var re = new RegExp("^\\d+$|\\d*" + decimal + "\\d+");
		if(!re.exec(val))
		{
			callback.apply(this);
		}
	}
}

$.fn.removeNumeric = function()
{
	return this.data("numeric.decimal", null).data("numeric.negative", null).data("numeric.callback", null).unbind("keypress", $.fn.numeric.keypress).unbind("blur", $.fn.numeric.blur);
}

// Based on code from http://javascript.nwbox.com/cursor_position/ (Diego Perini <dperini@nwbox.com>)
$.fn.getSelectionStart = function(o)
{
	if (o.createTextRange)
	{
		var r = document.selection.createRange().duplicate();
		r.moveEnd('character', o.value.length);
		if (r.text == '') return o.value.length;
		return o.value.lastIndexOf(r.text);
	} else return o.selectionStart;
}

// set the selection, o is the object (input), p is the position ([start, end] or just start)
$.fn.setSelection = function(o, p)
{
	// if p is number, start and end are the same
	if(typeof p == "number") p = [p, p];
	// only set if p is an array of length 2
	if(p && p.constructor == Array && p.length == 2)
	{
		if (o.createTextRange)
		{
			var r = o.createTextRange();
			r.collapse(true);
			r.moveStart('character', p[0]);
			r.moveEnd('character', p[1]);
			r.select();
		}
		else if(o.setSelectionRange)
		{
			o.focus();
			o.setSelectionRange(p[0], p[1]);
		}
	}
}

})(jQuery);
;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

if (!window.Seadragon) {
    window.Seadragon = {};
}

// this line overwrites any previous window.Seadragon value in IE before this file
// executes! since this is a global variable, IE does a forward-reference check
// and deletes any global variables which are declared through var. so for now,
// every piece of code that references Seadragon will just have to implicitly
// refer to window.Seadragon and not this global variable Seadragon.
// UPDATE: re-adding this since we're now wrapping all the code in a function.
var Seadragon = window.Seadragon;

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonConfig = Seadragon.Config;

(function() {
    
    // DUPLICATION CHECK -- necessary to prevent overwriting user changes
    if (SeadragonConfig) {
        return;
    }

    SeadragonConfig = Seadragon.Config = {
        
        debugMode: false,
        
        animationTime: 1.5,
        
        blendTime: 0.5,
        
        alwaysBlend: false,
        
        autoHideControls: true,
        
        constrainDuringPan: true,
        
        immediateRender: false,
        
        logarithmicZoom: true,
        
        wrapHorizontal: false,
        
        wrapVertical: false,
        
        wrapOverlays: false,
        
        transformOverlays: false,
        
        // for backwards compatibility, keeping this around and defaulting to null.
        // if it ever has a non-null value, that means it was explicitly set.
        minZoomDimension: null,
        
        minZoomImageRatio: 0.8,
        
        maxZoomPixelRatio: 2,
        
        visibilityRatio: 0.8,
        
        springStiffness: 5.0,
        
        imageLoaderLimit: 2, 
        
        clickTimeThreshold: 200,
        
        clickDistThreshold: 25, // square of real distance
        
        zoomPerClick: 2.0,
        
        zoomPerScroll: Math.pow(2, 1/3),
        
        zoomPerSecond: 2.0,
        
        proxyUrl: null,
        
        imagePath: "img/",
        
        fps: 60

    };

})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonStrings = Seadragon.Strings;

(function() {

    if (SeadragonStrings) {
        return;     // don't overwrite any strings that may have been added or changed
    }

    SeadragonStrings = Seadragon.Strings = {
        
        Errors: {
            Failure: "Sorry, but Seadragon Ajax can't run on your browser!\n" +
                    "Please try using IE 8 or Firefox 3.\n",
            Dzc: "Sorry, we don't support Deep Zoom Collections!",
            Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            Empty: "You asked us to open nothing, so we did just that.",
            ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
            Security: "It looks like a security restriction stopped us from " +
                    "loading this Deep Zoom Image.",
            Status: "This space unintentionally left blank ({0} {1}).",
            Unknown: "Whoops, something inexplicably went wrong. Sorry!"
        },
        
        Messages: {
            Loading: "Loading..."
        },
        
        Tooltips: {
            FullPage: "Toggle full page",
            Home: "Go home",
            ZoomIn: "Zoom in (you can also use your mouse's scroll wheel)",
            ZoomOut: "Zoom out (you can also use your mouse's scroll wheel)"
        }
        
    };

    SeadragonStrings.getString = function(prop) {
        var props = prop.split('.');
        var string = SeadragonStrings;
        
        // get property, which may contain dots, meaning subproperty
        for (var i = 0; i < props.length; i++) {
            string = string[props[i]] || {};    // in case not a subproperty
        }
        
        // in case the string didn't exist
        if (typeof(string) != "string") {
            string = "";
        }
        
        // regular expression and lambda technique from:
        // http://frogsbrain.wordpress.com/2007/04/28/javascript-stringformat-method/#comment-236
        var args = arguments;
        return string.replace(/\{\d+\}/g, function(capture) {
            var i = parseInt(capture.match(/\d+/)) + 1;
            return i < args.length ? args[i] : "";
        });
    };

    SeadragonStrings.setString = function(prop, value) {
        var props = prop.split('.');
        var container = SeadragonStrings;
        
        // get property's container, up to but not after last dot
        for (var i = 0; i < props.length - 1; i++) {
            if (!container[props[i]]) {
                container[props[i]] = {};
            }
            container = container[props[i]];
        }
        
        container[props[i]] = value;
    };

})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonDebug = function () {

    // Methods

    this.log = function (msg, important) {
        var console = window.console || {};
        var debug = SeadragonConfig.debugMode;

        if (debug && console.log) {
            console.log(msg);
        } else if (debug && important) {
            alert(msg);
        }
    };

    this.error = function (msg, e) {
        var console = window.console || {};
        var debug = SeadragonConfig.debugMode;

        if (debug && console.error) {
            console.error(msg);
        } else if (debug) {
            alert(msg);
        }

        if (debug) {
            // since we're debugging, fail fast by crashing
            throw e || new Error(msg);
        }
    };

    this.fail = function (msg) {
        alert(SeadragonStrings.getString("Errors.Failure"));
        throw new Error(msg);
    };

};

// Seadragon.Debug is a static class, so make it singleton instance
SeadragonDebug = Seadragon.Debug = new SeadragonDebug();

;

//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonProfiler = Seadragon.Profiler = function() {
    
    // Fields
    
    var self = this;
    
    var midUpdate = false;
    var numUpdates = 0;
    
    var lastBeginTime = null;
    var lastEndTime = null;
    
    var minUpdateTime = Infinity;
    var avgUpdateTime = 0;
    var maxUpdateTime = 0;
    
    var minIdleTime = Infinity;
    var avgIdleTime = 0;
    var maxIdleTime = 0;
    
    // Methods -- UPDATE TIME ACCESSORS
    
    this.getAvgUpdateTime = function() {
        return avgUpdateTime;
    };
    
    this.getMinUpdateTime = function() {
        return minUpdateTime;
    };
    
    this.getMaxUpdateTime = function() {
        return maxUpdateTime;
    };
    
    // Methods -- IDLING TIME ACCESSORS
    
    this.getAvgIdleTime = function() {
        return avgIdleTime;
    };
    
    this.getMinIdleTime = function() {
        return minIdleTime;
    };
    
    this.getMaxIdleTime = function() {
        return maxIdleTime;
    };
    
    // Methods -- GENERAL ACCESSORS 
    
    this.isMidUpdate = function() {
        return midUpdate;
    };
    
    this.getNumUpdates = function() {
        return numUpdates;
    };
    
    // Methods -- MODIFIERS
    
    this.beginUpdate = function() {
        if (midUpdate) {
            self.endUpdate();
        }
        
        midUpdate = true;
        lastBeginTime = Date.now();
        
        if (numUpdates <1) {
            return;     // this is the first update
        }
        
        var time = lastBeginTime - lastEndTime;
        
        avgIdleTime = (avgIdleTime * (numUpdates - 1) + time) / numUpdates;
        
        if (time < minIdleTime) {
            minIdleTime = time;
        }
        if (time > maxIdleTime) {
            maxIdleTime = time;
        }
    };
    
    this.endUpdate = function() {
        if (!midUpdate) {
            return;
        }
        
        lastEndTime = Date.now();
        midUpdate = false;
        
        var time = lastEndTime - lastBeginTime;
        
        numUpdates++;
        avgUpdateTime = (avgUpdateTime * (numUpdates - 1) + time) / numUpdates;
        
        if (time < minUpdateTime) {
            minUpdateTime = time;
        }
        if (time > maxUpdateTime) {
            maxUpdateTime = time;
        }
    };
    
    this.clearProfile = function() {
        midUpdate = false;
        numUpdates = 0;
        
        lastBeginTime = null;
        lastEndTime = null;
        
        minUpdateTime = Infinity;
        avgUpdateTime = 0;
        maxUpdateTime = 0;
        
        minIdleTime = Infinity;
        avgIdleTime = 0;
        maxIdleTime = 0;
    };
    
};

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonPoint = Seadragon.Point;

(function() {
    
    // preventing duplicate definitions because our code checks instanceof
    // SeadragonPoint, and that breaks if Seadragon.Point is redefined!
    if (SeadragonPoint) {
        return;
    }

    SeadragonPoint = Seadragon.Point = function(x, y) {
        
        // Properties
        
        this.x = typeof(x) == "number" ? x : 0;
        this.y = typeof(y) == "number" ? y : 0;
        
    };

    // Methods
    
    var SDPointPrototype = SeadragonPoint.prototype;

    SDPointPrototype.plus = function(point) {
        return new SeadragonPoint(this.x + point.x, this.y + point.y);
    };

    SDPointPrototype.minus = function(point) {
        return new SeadragonPoint(this.x - point.x, this.y - point.y);
    };

    SDPointPrototype.times = function(factor) {
        return new SeadragonPoint(this.x * factor, this.y * factor);
    };

    SDPointPrototype.divide = function(factor) {
        return new SeadragonPoint(this.x / factor, this.y / factor);
    };

    SDPointPrototype.negate = function() {
        return new SeadragonPoint(-this.x, -this.y);
    };

    SDPointPrototype.distanceTo = function(point) {
        return Math.sqrt(Math.pow(this.x - point.x, 2) +
                        Math.pow(this.y - point.y, 2));
    };

    SDPointPrototype.distance2To = function (point) {
        return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
    }

    SDPointPrototype.apply = function(func) {
        return new SeadragonPoint(func(this.x), func(this.y));
    };

    SDPointPrototype.equals = function(point) {
        return (point instanceof SeadragonPoint) &&
                (this.x === point.x) && (this.y === point.y);
    };

    SDPointPrototype.toString = function() {
        return "(" + this.x + "," + this.y + ")";
    };

})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonRect = Seadragon.Rect;

(function () {
    
    // preventing duplicate definitions because our code checks instanceof
    // SeadragonRect, and that breaks if Seadragon.Rect is redefined!
    if (SeadragonRect) {
        return;
    }

    SeadragonRect = Seadragon.Rect = function(x, y, width, height) {
        
        // Properties
        
        this.x = typeof(x) == "number" ? x : 0;
        this.y = typeof(y) == "number" ? y : 0;
        this.width = typeof(width) == "number" ? width : 0;
        this.height = typeof(height) == "number" ? height : 0;

    };
    
    // Methods
    
    var SDRectPrototype = SeadragonRect.prototype;
    
    SDRectPrototype.getAspectRatio = function() {
        return this.width / this.height;
    };
    
    SDRectPrototype.getTopLeft = function() {
        return new SeadragonPoint(this.x, this.y);
    };
    
    SDRectPrototype.getBottomRight = function() {
        return new SeadragonPoint(this.x + this.width, this.y + this.height);
    };
    
    SDRectPrototype.getCenter = function() {
        return new SeadragonPoint(this.x + this.width / 2.0,
                        this.y + this.height / 2.0);
    };
    
    SDRectPrototype.getSize = function() {
        return new SeadragonPoint(this.width, this.height);
    };
    
    SDRectPrototype.equals = function(other) {
        return (other instanceof SeadragonRect) &&
                (this.x === other.x) && (this.y === other.y) &&
                (this.width === other.width) && (this.height === other.height);
    };
    
    SDRectPrototype.toString = function() {
        return "[" + this.x + "," + this.y + "," + this.width + "x" +
                this.height + "]";
    };

})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonSpring = Seadragon.Spring = function(initialValue) {
    
    // Fields
    
    var currentValue = typeof(initialValue) == "number" ? initialValue : 0;
    var startValue = currentValue;
    var targetValue = currentValue;
    
    var currentTime = Date.now(); // always work in milliseconds
    var startTime = currentTime;
    var targetTime = currentTime;
    
    // Helpers
    
    /**
     * Transform from linear [0,1] to spring [0,1].
     */
    function transform(x) {
        var s = SeadragonConfig.springStiffness;
        return (1.0 - Math.exp(-x * s)) / (1.0 - Math.exp(-s));
    }
    
    // Methods
    
    this.getCurrent = function() {
        return currentValue;
    };
    
    this.getTarget = function() {
        return targetValue;
    };
    
    this.resetTo = function(target) {
        targetValue = target;
        targetTime = currentTime;
        startValue = targetValue;
        startTime = targetTime;
    };
    
    this.springTo = function(target) {
        startValue = currentValue;
        startTime = currentTime;
        targetValue = target;
        targetTime = startTime + 1000 * SeadragonConfig.animationTime;
    };
    
    this.shiftBy = function(delta) {
        startValue += delta;
        targetValue += delta;
    };
    
    this.update = function() {
        currentTime = Date.now();
        currentValue = (currentTime >= targetTime) ? targetValue :
                startValue + (targetValue - startValue) *
                transform((currentTime - startTime) / (targetTime - startTime));
    };
    
};

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonBrowser = Seadragon.Browser = {
    UNKNOWN: 0,
    IE: 1,
    FIREFOX: 2,
    SAFARI: 3,
    CHROME: 4,
    OPERA: 5
};

var SeadragonUtils = function() {
    
    // Fields
    
    var self = this;
    
    var arrActiveX = ["Msxml2.XMLHTTP", "Msxml3.XMLHTTP", "Microsoft.XMLHTTP"];
    var supportedImageFormats = {
        "bmp": false,
        "jpeg": true,
        "jpg": true,
        "png": true,
        "tif": false,
        "wdp": false
    };
    
    var browser = SeadragonBrowser.UNKNOWN;
    var browserVersion = 0;
    var badAlphaBrowser = false;    // updated in constructor
    
    var urlParams = {};
    
    // Constructor
    
    (function() {
        
        // Browser detect
        
        var app = navigator.appName;
        var ver = navigator.appVersion;
        var ua = navigator.userAgent;
        
        if (app == "Microsoft Internet Explorer" &&
                !!window.attachEvent && !!window.ActiveXObject) {
            
            var ieOffset = ua.indexOf("MSIE");
            browser = SeadragonBrowser.IE;
            browserVersion = parseFloat(
                    ua.substring(ieOffset + 5, ua.indexOf(";", ieOffset)));
            
            // update: for intranet sites and compat view list sites, IE sends
            // an IE7 User-Agent to the server to be interoperable, and even if
            // the page requests a later IE version, IE will still report the
            // IE7 UA to JS. we should be robust to this.
            var docMode = document.documentMode;
            if (typeof docMode !== "undefined") {
                browserVersion = docMode;
            }
            
        } else if (app == "Netscape" && !!window.addEventListener) {
            
            var ffOffset = ua.indexOf("Firefox");
            var saOffset = ua.indexOf("Safari");
            var chOffset = ua.indexOf("Chrome");
            
            if (ffOffset >= 0) {
                browser = SeadragonBrowser.FIREFOX;
                browserVersion = parseFloat(ua.substring(ffOffset + 8));
            } else if (saOffset >= 0) {
                var slash = ua.substring(0, saOffset).lastIndexOf("/");
                browser = (chOffset >= 0) ? SeadragonBrowser.CHROME : SeadragonBrowser.SAFARI;
                browserVersion = parseFloat(ua.substring(slash + 1, saOffset));
            }
            
        } else if (app == "Opera" && !!window.opera && !!window.attachEvent) {
            
            browser = SeadragonBrowser.OPERA;
            browserVersion = parseFloat(ver);
            
        }
        
        // Url parameters
        
        var query = window.location.search.substring(1);    // ignore '?'
        var parts = query.split('&');
        
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            var sep = part.indexOf('=');
            
            if (sep > 0) {
                urlParams[part.substring(0, sep)] =
                        decodeURIComponent(part.substring(sep + 1));
            }
        }
        
        // Browser behaviors
        
        // update: chrome 2 no longer has this problem! and now same with IE9!
        badAlphaBrowser =
                (browser == SeadragonBrowser.IE && browserVersion < 9) ||
                (browser == SeadragonBrowser.CHROME && browserVersion < 2);
        
    })();
    
    // Helpers
    
    function getOffsetParent(elmt, isFixed) {
        // IE and Opera "fixed" position elements don't have offset parents.
        // regardless, if it's fixed, its offset parent is the body.
        if (isFixed && elmt != document.body) {
            return document.body;
        } else {
            return elmt.offsetParent;
        }
    }
    
    // Methods
    
    this.getBrowser = function() {
        return browser;
    };
    
    this.getBrowserVersion = function() {
        return browserVersion;
    };
    
    this.getElement = function(elmt) {
        if (typeof(elmt) == "string") {
            elmt = document.getElementById(elmt);
        }
        
        return elmt;
    };
    
    this.getElementPosition = function(elmt) {
        var elmt = self.getElement(elmt);
        var result = new SeadragonPoint();
        
        // technique from:
        // http://www.quirksmode.org/js/findpos.html
        // with special check for "fixed" elements.
        
        var isFixed = self.getElementStyle(elmt).position == "fixed";
        var offsetParent = getOffsetParent(elmt, isFixed);
        
        while (offsetParent) {
            result.x += elmt.offsetLeft;
            result.y += elmt.offsetTop;
            
            if (isFixed) {
                result = result.plus(self.getPageScroll());
            }
            
            elmt = offsetParent;
            isFixed = self.getElementStyle(elmt).position == "fixed";
            offsetParent = getOffsetParent(elmt, isFixed);
        }
        
        return result;
    };
    
    this.getElementSize = function(elmt) {
        var elmt = self.getElement(elmt);
        return new SeadragonPoint(elmt.clientWidth, elmt.clientHeight);
    };
    
    this.getElementStyle = function(elmt) {
        var elmt = self.getElement(elmt);
        
        if (elmt.currentStyle) {
            return elmt.currentStyle;
        } else if (window.getComputedStyle) {
            return window.getComputedStyle(elmt, "");
        } else {
            SeadragonDebug.fail("Unknown element style, no known technique.");
        }
    };
    
    this.getEvent = function(event) {
        return event ? event : window.event;
    };
    
    this.getMousePosition = function(event) {
        var event = self.getEvent(event);
        var result = new SeadragonPoint();
        
        // technique from:
        // http://www.quirksmode.org/js/events_properties.html
        
        if (event.type == "DOMMouseScroll" &&
                browser == SeadragonBrowser.FIREFOX && browserVersion < 3) {
            // hack for FF2 which reports incorrect position for mouse scroll
            result.x = event.screenX;
            result.y = event.screenY;
        } else if (typeof(event.pageX) == "number") {
           result.x = event.pageX;
            result.y = event.pageY;
        } else if (typeof(event.clientX) == "number") {
            result.x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            result.y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        } else {
            SeadragonDebug.fail("Unknown event mouse position, no known technique.");
        }
        
        return result;
    };
    
    this.getMouseScroll = function(event) {
        var event = self.getEvent(event);
        var delta = 0; // default value
        
        // technique from:
        // http://blog.paranoidferret.com/index.php/2007/10/31/javascript-tutorial-the-scroll-wheel/
        
        if (typeof(event.wheelDelta) == "number") {
            delta = event.wheelDelta;
        } else if (typeof(event.detail) == "number") {
            delta = event.detail * -1;
        } else {
            SeadragonDebug.fail("Unknown event mouse scroll, no known technique.");
        }
        
        // normalize value to [-1, 1]
        return delta ? delta / Math.abs(delta) : 0;
    };
    
    this.getPageScroll = function() {
        var result = new SeadragonPoint();
        var docElmt = document.documentElement || {};
        var body = document.body || {};
        
        // technique from:
        // http://www.howtocreate.co.uk/tutorials/javascript/browserwindow
        
        if (typeof(window.pageXOffset) == "number") {
            // most browsers
            result.x = window.pageXOffset;
            result.y = window.pageYOffset;
        } else if (body.scrollLeft || body.scrollTop) {
            // W3C spec, IE6+ in quirks mode
            result.x = body.scrollLeft;
            result.y = body.scrollTop;
        } else if (docElmt.scrollLeft || docElmt.scrollTop) {
            // IE6+ in standards mode
            result.x = docElmt.scrollLeft;
            result.y = docElmt.scrollTop;
        }
        
        // note: we specifically aren't testing for typeof here, because IE sets
        // the appropriate variables undefined instead of 0 under certain
        // conditions. this means we also shouldn't fail if none of the three
        // cases are hit; we'll just assume the page scroll is 0.
        
        return result;
    };
    
    this.getWindowSize = function() {
        var result = new SeadragonPoint();
        var docElmt = document.documentElement || {};
        var body = document.body || {};
        
        // technique from:
        // http://www.howtocreate.co.uk/tutorials/javascript/browserwindow
        
        // important: i originally cleaned up the second and third IE checks to
        // check if the typeof was number. but this fails for quirks mode,
        // because docElmt.clientWidth is indeed a number, but it's incorrectly
        // zero. so no longer checking typeof is number for those cases.
        
        if (typeof(window.innerWidth) == 'number') {
            // non-IE browsers
            result.x = window.innerWidth;
            result.y = window.innerHeight;
        } else if (docElmt.clientWidth || docElmt.clientHeight) {
            // IE6+ in standards mode
            result.x = docElmt.clientWidth;
            result.y = docElmt.clientHeight;
        } else if (body.clientWidth || body.clientHeight) {
            // IE6+ in quirks mode
            result.x = body.clientWidth;
            result.y = body.clientHeight;
        } else {
            SeadragonDebug.fail("Unknown window size, no known technique.");
        }
        
        return result;
    };
    
    this.imageFormatSupported = function(ext) {
        var ext = ext ? ext : "";
        return !!supportedImageFormats[ext.toLowerCase()];
    };
    
    this.makeCenteredNode = function(elmt) {
        var elmt = SeadragonUtils.getElement(elmt);
        var div = self.makeNeutralElement("div");
        var html = [];
        
        // technique for vertically centering (in IE!!!) from:
        // http://www.jakpsatweb.cz/css/css-vertical-center-solution.html
        // with explicit neutralizing of styles added by me.
        html.push('<div style="display:table; height:100%; width:100%;');
        html.push('border:none; margin:0px; padding:0px;'); // neutralizing
        html.push('#position:relative; overflow:hidden; text-align:left;">');
            // the text-align:left guards against incorrect centering in IE
        html.push('<div style="#position:absolute; #top:50%; width:100%; ');
        html.push('border:none; margin:0px; padding:0px;'); // neutralizing
        html.push('display:table-cell; vertical-align:middle;">');
        html.push('<div style="#position:relative; #top:-50%; width:100%; ');
        html.push('border:none; margin:0px; padding:0px;'); // neutralizing
        html.push('text-align:center;"></div></div></div>');
        
        div.innerHTML = html.join('');
        div = div.firstChild;
        
        // now add the element as a child to the inner-most div
        var innerDiv = div;
        var innerDivs = div.getElementsByTagName("div");
        while (innerDivs.length > 0) {
            innerDiv = innerDivs[0];
            innerDivs = innerDiv.getElementsByTagName("div");
        }
        
        innerDiv.appendChild(elmt);
        
        return div;
    };
    
    this.makeNeutralElement = function(tagName) {
        var elmt = document.createElement(tagName);
        var style = elmt.style;
        
        // TODO reset neutral element's style in a better way
        style.background = "transparent none";
        style.border = "none";
        style.margin = "0px";
        style.padding = "0px";
        style.position = "static";
        
        return elmt;
    };
    
    this.makeTransparentImage = function(src) {
        var img = self.makeNeutralElement("img");
        var elmt = null;
        
        if (browser == SeadragonBrowser.IE && browserVersion < 7) {
            elmt = self.makeNeutralElement("span");
            elmt.style.display = "inline-block";
            
            // to size span correctly, load image and get natural size,
            // but don't override any user-set CSS values
            img.onload = function() {
                elmt.style.width = elmt.style.width || img.width + "px";
                elmt.style.height = elmt.style.height || img.height + "px";
                
                img.onload = null;
                img = null;     // to prevent memory leaks in IE
            };
            
            img.src = src;
            elmt.style.filter =
                    "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" +
                    src + "', sizingMethod='scale')";
        } else {
            elmt = img;
            elmt.src = src;
        }
        
        return elmt;
    };
    
    this.setElementOpacity = function(elmt, opacity, usesAlpha) {
        var elmt = self.getElement(elmt);
        
        if (usesAlpha && badAlphaBrowser) {
            // images with alpha channels won't fade well, so round
            opacity = Math.round(opacity);
        }
        
        // for CSS opacity browsers, remove opacity value if it's unnecessary
        if (opacity < 1) {
            elmt.style.opacity = opacity;
        } else {
            elmt.style.opacity = "";
        }
        
        // for CSS filter browsers (IE), remove alpha filter if it's unnecessary.
        // update: doing this always since IE9 beta seems to have broken the
        // behavior if we rely on the programmatic filters collection.
        var prevFilter = elmt.style.filter || "";
        elmt.style.filter = prevFilter.replace(/[\s]*alpha\(.*?\)[\s]*/g, "");
                // important: note the lazy star! this protects against
                // multiple filters; we don't want to delete the other ones.
                // update: also trimming extra whitespace around filter.
        
        if (opacity >= 1) {
            return;
        }
        
        var ieOpacity = Math.round(100 * opacity);
        var ieFilter = " alpha(opacity=" + ieOpacity + ") ";
        
        elmt.style.filter += ieFilter;
        
        // old way -- seems to have broken in IE9's compatibiliy mode:
        // check if this element has filters associated with it (IE only),
        // but prevent bug where IE throws error "Member not found" sometimes.
        //try {
        //    if (elmt.filters && elmt.filters.alpha) {
        //        elmt.filters.alpha.opacity = ieOpacity;
        //    } else {
        //        elmt.style.filter += ieFilter;
        //    }
        //} catch (e) {
        //    elmt.style.filter += ieFilter;
        //}
    };
    
    this.addEvent = function(elmt, eventName, handler, useCapture) {
        var elmt = self.getElement(elmt);
        
        // technique from:
        // http://blog.paranoidferret.com/index.php/2007/08/10/javascript-working-with-events/
        
        if (elmt.addEventListener) {
            if (eventName == "mousewheel") {
                elmt.addEventListener("DOMMouseScroll", handler, useCapture);
            }
            // we are still going to add the mousewheel -- not a mistake!
            // this is for opera, since it uses onmousewheel but needs addEventListener.
            elmt.addEventListener(eventName, handler, useCapture);
        } else if (elmt.attachEvent) {
            elmt.attachEvent("on" + eventName, handler);
            if (useCapture && elmt.setCapture) {
                elmt.setCapture();
            }
        } else {
            SeadragonDebug.fail("Unable to attach event handler, no known technique.");
        }
    };
    
    this.removeEvent = function(elmt, eventName, handler, useCapture) {
        var elmt = self.getElement(elmt);
        
        // technique from:
        // http://blog.paranoidferret.com/index.php/2007/08/10/javascript-working-with-events/
        
        if (elmt.removeEventListener) {
            if (eventName == "mousewheel") {
                elmt.removeEventListener("DOMMouseScroll", handler, useCapture);
            }
            // we are still going to remove the mousewheel -- not a mistake!
            // this is for opera, since it uses onmousewheel but needs removeEventListener.
            elmt.removeEventListener(eventName, handler, useCapture);
        } else if (elmt.detachEvent) {
            elmt.detachEvent("on" + eventName, handler);
            if (useCapture && elmt.releaseCapture) {
                elmt.releaseCapture();
            }
        } else {
            SeadragonDebug.fail("Unable to detach event handler, no known technique.");
        }
    };
    
    this.cancelEvent = function(event) {
        var event = self.getEvent(event);
        
        // technique from:
        // http://blog.paranoidferret.com/index.php/2007/08/10/javascript-working-with-events/
        
        if (event.preventDefault) {
            event.preventDefault();     // W3C for preventing default
        }
        
        event.cancel = true;            // legacy for preventing default
        event.returnValue = false;      // IE for preventing default
    };
    
    this.stopEvent = function(event) {
        var event = self.getEvent(event);
        
        // technique from:
        // http://blog.paranoidferret.com/index.php/2007/08/10/javascript-working-with-events/
        
        if (event.stopPropagation) {
            event.stopPropagation();    // W3C for stopping propagation
        }
        
        event.cancelBubble = true;      // IE for stopping propagation
    };
    
    this.createCallback = function(object, method) {
        // create callback args
        var initialArgs = [];
        for (var i = 2; i < arguments.length; i++) {
            initialArgs.push(arguments[i]);
        }
        
        // create closure to apply method
        return function() {
            // concatenate new args, but make a copy of initialArgs first
            var args = initialArgs.concat([]);
            for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            
            return method.apply(object, args);
        };
    };
    
    this.getUrlParameter = function(key) {
        var value = urlParams[key];
        return value ? value : null;
    };
    
    this.makeAjaxRequest = function(url, callback) {
        var async = typeof(callback) == "function";
        var req = null;
        
        if (async) {
            var actual = callback;
            var callback = function() {
                window.setTimeout(SeadragonUtils.createCallback(null, actual, req), 1);
            };
        }
        
        if (false&&window.ActiveXObject) {
            for (var i = 0; i < arrActiveX.length; i++) {
                try {
                    req = new ActiveXObject(arrActiveX[i]);
                    break;
                } catch (e) {
                    continue;
                }
            }
        } else if (window.XMLHttpRequest) {
            req = new XMLHttpRequest();
        }
        
        if (!req) {
            SeadragonDebug.fail("Browser doesn't support XMLHttpRequest.");
        }
        
        // Proxy support
        if (SeadragonConfig.proxyUrl) {
            url = SeadragonConfig.proxyUrl + url;
        }
        
        if (async) {
            req.onreadystatechange = function() {
                if (req.readyState == 4) {
                    // prevent memory leaks by breaking circular reference now
                    req.onreadystatechange = new Function();
                    callback();
                }
            };
        }
        
        try {
            req.open("GET", url, async);
            req.send(null);
        } catch (e) {
            SeadragonDebug.log(e.name + " while making AJAX request: " + e.message);
            
            req.onreadystatechange = null;
            req = null;
            
            if (async) {
                callback();
            }
        }
        
        return async ? null : req;
    };
    
    this.parseXml = function(string) {
        var xmlDoc = null;
        
        if (window.ActiveXObject) {
            try {
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(string);
            } catch (e) {
                SeadragonDebug.log(e.name + " while parsing XML (ActiveX): " + e.message);
                console.log("error creating ActiveXObject in Seadragon.Utils parseXml");
            }
        } else if (window.DOMParser) {
            try {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(string, "text/xml");
            } catch (e) {
                SeadragonDebug.log(e.name + " while parsing XML (DOMParser): " + e.message);
            }
        } else {
            SeadragonDebug.fail("Browser doesn't support XML DOM.");
        }
        
        return xmlDoc;
    };
    
};

// Seadragon.Utils is a static class, so make it singleton instance
SeadragonUtils = Seadragon.Utils = new SeadragonUtils();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonMouseTracker = Seadragon.MouseTracker;

(function() {
    
    // DUPLICATION CHECK -- necessary here because of private static state
    if (SeadragonMouseTracker) {
        return;
    }
    
    // Constants
    
    // update: IE9 implements the W3C standard event model! =)
    var lteIE8 = SeadragonUtils.getBrowser() == SeadragonBrowser.IE &&
        SeadragonUtils.getBrowserVersion() < 9;
    
    // Static fields
    
    var buttonDownAny = false;
    
    var ieCapturingAny = false;
    var ieTrackersActive = {};      // dictionary from hash to MouseTracker
    var ieTrackersCapturing = [];   // list of trackers interested in capture
    
    // Static helpers
    
    function getMouseAbsolute(event) {
        return SeadragonUtils.getMousePosition(event);
    }
    
    function getMouseRelative(event, elmt) {
        var mouse = SeadragonUtils.getMousePosition(event);
        var offset = SeadragonUtils.getElementPosition(elmt);
        
        return mouse.minus(offset);
    }
    
    /**
     * Returns true if elmtB is a child node of elmtA, or if they're equal.
     */
    function isChild(elmtA, elmtB) {
        var body = document.body;
        while (elmtB && elmtA != elmtB && body != elmtB) {
            try {
                elmtB = elmtB.parentNode;
            } catch (e) {
                // Firefox sometimes fires events for XUL elements, which throws
                // a "permission denied" error. so this is not a child.
                return false;
            }
        }
        return elmtA == elmtB;
    }
    
    function onGlobalMouseDown() {
        buttonDownAny = true;
    }
    
    function onGlobalMouseUp() {
        buttonDownAny = false;
    }
    
    // Static constructor
    
    (function () {
        // the W3C event model lets us listen to the capture phase of events, so
        // to know if the mouse is globally up or down, we'll listen to the
        // capture phase of the window's events. we can't do this in IE, so
        // we'll give it a best effort by listening to the regular bubble phase,
        // and on the document since window isn't legal in IE for mouse events.
        if (lteIE8) {
            SeadragonUtils.addEvent(document, "mousedown", onGlobalMouseDown, false);
            SeadragonUtils.addEvent(document, "mouseup", onGlobalMouseUp, false);
        } else {
            SeadragonUtils.addEvent(window, "mousedown", onGlobalMouseDown, true);
            SeadragonUtils.addEvent(window, "mouseup", onGlobalMouseUp, true);
        }
    })();
    
    // Class
    
    SeadragonMouseTracker = Seadragon.MouseTracker = function(elmt) {
        
        // Fields
        
        var self = this;
        var ieSelf = null;
        
        var hash = Math.random();     // a unique hash for this tracker
        var elmt = SeadragonUtils.getElement(elmt);
        
        var tracking = false;
        var capturing = false;
        var buttonDownElmt = false;
        var insideElmt = false;
        
        var lastPoint = null;           // position of last mouse down/move
        var lastMouseDownTime = null;   // time of last mouse down
        var lastMouseDownPoint = null;  // position of last mouse down
        
        // Properties
        
        this.target = elmt;
        this.enterHandler = null;       // function(tracker, position, buttonDownElmt, buttonDownAny)
        this.exitHandler = null;        // function(tracker, position, buttonDownElmt, buttonDownAny)
        this.pressHandler = null;       // function(tracker, position)
        this.releaseHandler = null;     // function(tracker, position, insideElmtPress, insideElmtRelease)
        this.clickHandler = null;       // function(tracker, position, quick, shift)
        this.dragHandler = null;        // function(tracker, position, delta, shift)
        this.scrollHandler = null;      // function(tracker, position, scroll, shift)
        
        // Helpers
        
        function startTracking() {
            if (!tracking) {
                SeadragonUtils.addEvent(elmt, "mouseover", onMouseOver, false);
                SeadragonUtils.addEvent(elmt, "mouseout", onMouseOut, false);
                SeadragonUtils.addEvent(elmt, "mousedown", onMouseDown, false);
                SeadragonUtils.addEvent(elmt, "mouseup", onMouseUp, false);
                SeadragonUtils.addEvent(elmt, "mousewheel", onMouseScroll, false);
                SeadragonUtils.addEvent(elmt, "click", onMouseClick, false);
                
                tracking = true;
                ieTrackersActive[hash] = ieSelf;
            }
        }
        
        function stopTracking() {
            if (tracking) {
                SeadragonUtils.removeEvent(elmt, "mouseover", onMouseOver, false);
                SeadragonUtils.removeEvent(elmt, "mouseout", onMouseOut, false);
                SeadragonUtils.removeEvent(elmt, "mousedown", onMouseDown, false);
                SeadragonUtils.removeEvent(elmt, "mouseup", onMouseUp, false);
                SeadragonUtils.removeEvent(elmt, "mousewheel", onMouseScroll, false);
                SeadragonUtils.removeEvent(elmt, "click", onMouseClick, false);
                
                releaseMouse();
                tracking = false;
                delete ieTrackersActive[hash];
            }
        }
        
        function captureMouse() {
            if (!capturing) {
                // IE lets the element capture the mouse directly, but other
                // browsers use the capture phase on the highest element.
                if (lteIE8) {
                    // we need to capture the mouse, but we also don't want to
                    // handle mouseup like normally (special case for bubbling)
                    SeadragonUtils.removeEvent(elmt, "mouseup", onMouseUp, false);
                    SeadragonUtils.addEvent(elmt, "mouseup", onMouseUpIE, true);
                    SeadragonUtils.addEvent(elmt, "mousemove", onMouseMoveIE, true);
                } else {
                    SeadragonUtils.addEvent(window, "mouseup", onMouseUpWindow, true);
                    SeadragonUtils.addEvent(window, "mousemove", onMouseMove, true);
                }
                
                capturing = true;
            }
        }
        
        function releaseMouse() {
            if (capturing) {
                // similar reasoning as captureMouse()
                if (lteIE8) {
                    // we need to release the mouse, and also go back to handling
                    // mouseup like normal (no longer a hack for capture phase)
                    SeadragonUtils.removeEvent(elmt, "mousemove", onMouseMoveIE, true);
                    SeadragonUtils.removeEvent(elmt, "mouseup", onMouseUpIE, true);
                    SeadragonUtils.addEvent(elmt, "mouseup", onMouseUp, false);
                } else {
                    SeadragonUtils.removeEvent(window, "mousemove", onMouseMove, true);
                    SeadragonUtils.removeEvent(window, "mouseup", onMouseUpWindow, true);
                }
                
                capturing = false;
            }
        }
        
        // IE-specific helpers
        
        function triggerOthers(eventName, event) {
            // update: protecting against properties added to the Object class's
            // prototype, which can and does happen (e.g. through js libraries)
            var trackers = ieTrackersActive;
            for (var otherHash in trackers) {
                if (trackers.hasOwnProperty(otherHash) && hash != otherHash) {
                    trackers[otherHash][eventName](event);
                }
            }
        }
        
        function hasMouse() {
            return insideElmt;
        }
        
        // Listeners
        
        function onMouseOver(event) {
            var event = SeadragonUtils.getEvent(event);
            
            // IE capturing model doesn't raise or bubble the events on any
            // other element if we're capturing currently. so pass this event to
            // other elements being tracked so they can adjust if the element
            // was from them or from a child. however, IE seems to always fire
            // events originating from parents to those parents, so don't double
            // fire the event if the event originated from a parent.
            if (lteIE8 && capturing && !isChild(event.srcElement, elmt)) {
                triggerOthers("onMouseOver", event);
            }
            
            // similar to onMouseOut() tricky bubbling case...
            var to = event.target ? event.target : event.srcElement;
            var from = event.relatedTarget ? event.relatedTarget : event.fromElement;
            if (!isChild(elmt, to) || isChild(elmt, from)) {
                // the mouseover needs to end on this or a child node, and it
                // needs to start from this or an outer node.
                return;
            }
            
            insideElmt = true;
           
            if (typeof(self.enterHandler) == "function") {
                try {
                    self.enterHandler(self, getMouseRelative(event, elmt),
                            buttonDownElmt, buttonDownAny);
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing enter handler: " + e.message, e);
                }
            }
        }
        
        function onMouseOut(event) {
            var event = SeadragonUtils.getEvent(event);
            
            // similar to onMouseOver() case for IE capture model
            if (lteIE8 && capturing && !isChild(event.srcElement, elmt)) {
                triggerOthers("onMouseOut", event);
            }
            
            // we have to watch out for a tricky case: a mouseout occurs on a
            // child element, but the mouse is still inside the parent element.
            // the mouseout event will bubble up to us. this happens in all
            // browsers, so we need to correct for this. technique from:
            // http://www.quirksmode.org/js/events_mouse.html
            var from = event.target ? event.target : event.srcElement;
            var to = event.relatedTarget ? event.relatedTarget : event.toElement;
            if (!isChild(elmt, from) || isChild(elmt, to)) {
                // the mouseout needs to start from this or a child node, and it
                // needs to end on this or an outer node.
                return;
            }
            
            insideElmt = false;
            
            if (typeof(self.exitHandler) == "function") {
                try {
                    self.exitHandler(self, getMouseRelative(event, elmt),
                            buttonDownElmt, buttonDownAny);
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing exit handler: " + e.message, e);
                }
            }
        }
        
        function onMouseDown(event) {
            var event = SeadragonUtils.getEvent(event);
            
            // don't consider right-clicks (fortunately this is cross-browser)
            if (event.button == 2) {
                return;
            }
            
            buttonDownElmt = true;
            
            lastPoint = getMouseAbsolute(event);
            lastMouseDownPoint = lastPoint;
            lastMouseDownTime = Date.now();
            
           if (typeof(self.pressHandler) == "function") {
                try {
                    self.pressHandler(self, getMouseRelative(event, elmt));
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing press handler: " + e.message, e);
                }
            }
            
            if (self.pressHandler || self.dragHandler) {
                // if a press or drag handler is registered, don't drag-drop images, etc.
                SeadragonUtils.cancelEvent(event);
            }
            
            if (!lteIE8 || !ieCapturingAny) {
                captureMouse();
                ieCapturingAny = true;
                ieTrackersCapturing = [ieSelf];     // reset to empty & add us
            } else if (lteIE8) {
                ieTrackersCapturing.push(ieSelf);   // add us to the list
            }
        }
        
        function onMouseUp(event) {
            var event = SeadragonUtils.getEvent(event);
            var insideElmtPress = buttonDownElmt;
            var insideElmtRelease = insideElmt;
            
            // don't consider right-clicks (fortunately this is cross-browser)
            if (event.button == 2) {
                return;
            }
            
            buttonDownElmt = false;
            
            if (typeof(self.releaseHandler) == "function") {
                try {
                    self.releaseHandler(self, getMouseRelative(event, elmt),
                            insideElmtPress, insideElmtRelease);
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing release handler: " + e.message, e);
                }
            }
            
            // some browsers sometimes don't fire click events when we're also
            // listening for mouseup events. i'm not sure why, it could be
            // something i'm doing. in the meantime, this is a temporary fix.
            if (insideElmtPress && insideElmtRelease) {
                handleMouseClick(event);
            }
        }
        
        /**
         * Only triggered once by the deepest element that initially received
         * the mouse down event. We want to make sure THIS event doesn't bubble.
         * Instead, we want to trigger the elements that initially received the
         * mouse down event (including this one) only if the mouse is no longer
         * inside them. Then, we want to release capture, and emulate a regular
         * mouseup on the event that this event was meant for.
         */
        function onMouseUpIE(event) {
            var event = SeadragonUtils.getEvent(event);
            
            // don't consider right-clicks (fortunately this is cross-browser)
            if (event.button == 2) {
                return;
            }
            
            // first trigger those that were capturing
            for (var i = 0; i < ieTrackersCapturing.length; i++) {
                var tracker = ieTrackersCapturing[i];
                if (!tracker.hasMouse()) {
                    tracker.onMouseUp(event);
                }
            }
            
            // then release capture and emulate a regular event
            releaseMouse();
            ieCapturingAny = false;
            event.srcElement.fireEvent("on" + event.type,
                    document.createEventObject(event));
            
            // make sure to stop this event -- shouldn't bubble up
            SeadragonUtils.stopEvent(event);
        }
        
        /**
         * Only triggered in W3C browsers by elements within which the mouse was
         * initially pressed, since they are now listening to the window for
         * mouseup during the capture phase. We shouldn't handle the mouseup
         * here if the mouse is still inside this element, since the regular
         * mouseup handler will still fire.
         */
        function onMouseUpWindow(event) {
            if (!insideElmt) {
                onMouseUp(event);
            }
            
            releaseMouse();
        }
        
        function onMouseClick(event) {
            // see onMouseUp() bug -- handleClick() is already called by
            // onMouseUp() as a temporary fix, so don't duplicate the call here.
            
            if (self.clickHandler) {                
                // since a click handler was registered, don't follow href's, etc.
                SeadragonUtils.cancelEvent(event);
            }
        }
        
        function handleMouseClick(event) {
            var event = SeadragonUtils.getEvent(event);
            
            // don't consider right-clicks (fortunately this is cross-browser)
            if (event.button == 2) {
                return;
            }
            
            var time = Date.now() - lastMouseDownTime;
            var point = getMouseAbsolute(event);
            var distance = lastMouseDownPoint.distance2To(point);
            var quick = time <= SeadragonConfig.clickTimeThreshold &&
                    distance <= SeadragonConfig.clickDistThreshold;
            
            if (typeof(self.clickHandler) == "function") {
                try {
                    self.clickHandler(self, getMouseRelative(event, elmt),
                            quick, event.shiftKey);
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing click handler: " + e.message, e);
                }
            }
        }
        
        function onMouseMove(event) {
            var event = SeadragonUtils.getEvent(event);
            var point = getMouseAbsolute(event);
            var delta = point.minus(lastPoint);
            
            lastPoint = point;
            
            if (typeof(self.dragHandler) == "function") {
                try {
                    self.dragHandler(self, getMouseRelative(event, elmt),
                            delta, event.shiftKey);
                } catch (e) {
                    // handler threw an error, ignore
                    SeadragonDebug.error(e.name +
                            " while executing drag handler: " + e.message, e);
                }
                
                // since a drag handler was registered, don't allow highlighting, etc.
                SeadragonUtils.cancelEvent(event);
            }
        }
        
        /**
         * Only triggered once by the deepest element that initially received
         * the mouse down event. Since no other element has captured the mouse,
         * we want to trigger the elements that initially received the mouse
         * down event (including this one).
         */
        function onMouseMoveIE(event) {
            // manually trigger those that are capturing
            for (var i = 0; i < ieTrackersCapturing.length; i++) {
                ieTrackersCapturing[i].onMouseMove(event);
            }
            
            // make sure to stop this event -- shouldn't bubble up. note that at
            // the time of this writing, there is no harm in letting it bubble,
            // but a minor change to our implementation would necessitate this.
            SeadragonUtils.stopEvent(event);
        }
        
        function onMouseScroll(event) {
            var event = SeadragonUtils.getEvent(event);
            var delta = SeadragonUtils.getMouseScroll(event);
            
            if (typeof(self.scrollHandler) == "function") {
                // FF2 and FF3/Mac (possibly others) seem to sometimes fire
                // extraneous scroll events. check for those.
                if (delta) {
                    try {
                        self.scrollHandler(self, getMouseRelative(event, elmt),
                                delta, event.shiftKey);
                    } catch (e) {
                        // handler threw an error, ignore
                        SeadragonDebug.error(e.name +
                                " while executing scroll handler: " + e.message, e);
                    }
                }
                
                // since a scroll handler was registered, don't scroll the page, etc.
                SeadragonUtils.cancelEvent(event);
            }
        }
        
        // Constructor
        
        (function () {
            ieSelf = {
                hasMouse: hasMouse,
                onMouseOver: onMouseOver,
                onMouseOut: onMouseOut,
                onMouseUp: onMouseUp,
                onMouseMove: onMouseMove
            };
        })();
        
        // Methods
        
        this.isTracking = function() {
            return tracking;
        };
        
        this.setTracking = function(track) {
            if (track) {
                startTracking();
            } else {
                stopTracking();
            }
        };
        
    };
    
})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonEventManager = Seadragon.EventManager = function() {
    
    // Fields
    
    var listeners = {}; // dictionary of eventName --> array of handlers
    
    // Methods
    
    this.addListener = function(eventName, handler) {
        if (typeof(handler) != "function") {
            return;
        }
        
        if (!listeners[eventName]) {
            listeners[eventName] = [];
        }
        
        listeners[eventName].push(handler);
    };
    
    this.removeListener = function(eventName, handler) {
        var handlers = listeners[eventName];
        
        if (typeof(handler) != "function") {
            return;
        } else if (!handlers) {
            return;
        }
        
        for (var i = 0; i < handlers.length; i++) {
            if (handler == handlers[i]) {
                handlers.splice(i, 1);
                return;
            }
        }
    };
    
    this.clearListeners = function(eventName) {
        if (listeners[eventName]) {
            delete listeners[eventName];
        }
    };
    
    this.trigger = function(eventName) {
        var handlers = listeners[eventName];
        var args = [];
        
        if (!handlers) {
            return;
        }
        
        for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        
        for (var i = 0; i < handlers.length; i++) {
            try {
                handlers[i].apply(window, args);
            } catch (e) {
                // handler threw an error, ignore, go on to next one
                SeadragonDebug.error(e.name + " while executing " + eventName +
                        " handler: " + e.message, e);
            }
        }
    };
    
};

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonImageLoader;

(function() {
    
    var TIMEOUT = 15000;     // milliseconds after which an image times out
    
    function Job(src, callback) {
        // Fields
        this.src = src;
        this.callback = callback;
        this.image = null;
        this.timeout = null;     // IE8 fix: no finishing event raised sometimes
        this.running = false;
    }

    Job.prototype.start = function () {
        var self = this;
        if (!self.running) {
            self.running = true;
            self.image = new Image();

            var successFunc = function () { self.finish(true); };
            var failureFunc = function () { self.finish(false); };
            var timeoutFunc = function () {
                SeadragonDebug.log("Image timed out: " + self.src);
                self.finish(false);
            };

            self.image.onload = successFunc;
            self.image.onabort = failureFunc;
            self.image.onerror = failureFunc;

            // consider it a failure if the image times out.
            self.timeout = window.setTimeout(timeoutFunc, TIMEOUT);

            self.image.src = self.src;
        }
    };

    Job.prototype.finish = function (success) {
        this.image.onload = null;
        this.image.onabort = null;
        this.image.onerror = null;

        if (this.timeout) {
            window.clearTimeout(this.timeout);
        }

        // call on a timeout to ensure asynchronous behavior
        this.callback(this.src, success ? this.image : null);
    };
    
    SeadragonImageLoader = Seadragon.ImageLoader = function() {
        
        // Fields
        
        var downloading = 0,    // number of Jobs currently downloading
            downloadQueue = []; // Jobs that have yet to be started
        
        // Helpers
        
        function onComplete(callback, src, image) {
            var newdl;
            downloading--;

            // finish loading
            if (typeof (callback) === "function") {
                setTimeout(function () {
                    try {
                        callback(image);
                    } catch (e) {
                        SeadragonDebug.error(e.name + " while executing " + src +
                                " callback: " + e.message, e);
                    }
                }, 2);
            }

            // launch jobs in queue
            while (downloading < SeadragonConfig.imageLoaderLimit && downloadQueue.length > 0) {
                newdl = downloadQueue.shift();
                if (!newdl.tile.loaded) {
                    setTimeout(newdl.job.start(), 2);
                    downloading++;
                }
            }
        }
        
        // Methods
        
        this.loadImage = function(tile, callback) {
            
            var func = SeadragonUtils.createCallback(null, onComplete, callback);
            var job = new Job(tile.url, func);

            // if there are too many jobs, save job to queue
            if (downloading >= SeadragonConfig.imageLoaderLimit) {
                downloadQueue.push({ job: job, tile: tile });
            } else {
                downloading++;
                job.start();
            }
            
            // returning true for now for legacy code
            tile.loading = true;
        };

        this.clear = function () {
            downloadQueue.map(function (v) {
                v.tile.loading = false;
            });
            downloadQueue = [];
        };
        
    };

})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonButton,
    SeadragonButtonGroup;

(function() {
    
    // Enumerations
    
    var ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
    };
    
    // Button class
    
    SeadragonButton = Seadragon.Button = function(tooltip,
            srcRest, srcGroup, srcHover, srcDown,
            onPress, onRelease, onClick, onEnter, onExit) {
        
        // Fields
        
        var button = SeadragonUtils.makeNeutralElement("span");
        var currentState = ButtonState.GROUP;
        var tracker = new SeadragonMouseTracker(button);
        
        var imgRest = SeadragonUtils.makeTransparentImage(srcRest);
        var imgGroup = SeadragonUtils.makeTransparentImage(srcGroup);
        var imgHover = SeadragonUtils.makeTransparentImage(srcHover);
        var imgDown = SeadragonUtils.makeTransparentImage(srcDown);
        
        var onPress = typeof(onPress) == "function" ? onPress : null;
        var onRelease = typeof(onRelease) == "function" ? onRelease : null;
        var onClick = typeof(onClick) == "function" ? onClick : null;
        var onEnter = typeof(onEnter) == "function" ? onEnter : null;
        var onExit = typeof(onExit) == "function" ? onExit : null;
        
        var fadeDelay = 0;      // begin fading immediately
        var fadeLength = 2000;  // fade over a period of 2 seconds
        var fadeBeginTime = null;
        var shouldFade = false;
        
        // Properties
        
        this.elmt = button;
        
        // Fading helpers
        
        function scheduleFade() {
            window.setTimeout(updateFade, 20);
        }
        
        function updateFade() {
            if (shouldFade) {
                var currentTime = new Date().getTime();
                var deltaTime = currentTime - fadeBeginTime;
                var opacity = 1.0 - deltaTime / fadeLength;
                
                opacity = Math.min(1.0, opacity);
                opacity = Math.max(0.0, opacity);
                
                SeadragonUtils.setElementOpacity(imgGroup, opacity, true);
                if (opacity > 0) {
                    scheduleFade();    // fade again
                }
            }
        }
        
        function beginFading() {
            shouldFade = true;
            fadeBeginTime = new Date().getTime() + fadeDelay;
            window.setTimeout(scheduleFade, fadeDelay);
        }
        
        function stopFading() {
            shouldFade = false;
            SeadragonUtils.setElementOpacity(imgGroup, 1.0, true);
        }
        
        // State helpers
        
        function inTo(newState) {
            if (newState >= ButtonState.GROUP && currentState == ButtonState.REST) {
                stopFading();
                currentState = ButtonState.GROUP;
            }
            
            if (newState >= ButtonState.HOVER && currentState == ButtonState.GROUP) {
                // important: don't explicitly say "visibility: visible".
                // see note in Viewer.setVisible() for explanation.
                imgHover.style.visibility = "";
                currentState = ButtonState.HOVER;
            }
            
            if (newState >= ButtonState.DOWN && currentState == ButtonState.HOVER) {
                // important: don't explicitly say "visibility: visible".
                // see note in Viewer.setVisible() for explanation.
                imgDown.style.visibility = "";
                currentState = ButtonState.DOWN;
            }
        }
        
        function outTo(newState) {
            if (newState <= ButtonState.HOVER && currentState == ButtonState.DOWN) {
                imgDown.style.visibility = "hidden";
                currentState = ButtonState.HOVER;
            }
            
            if (newState <= ButtonState.GROUP && currentState == ButtonState.HOVER) {
                imgHover.style.visibility = "hidden";
                currentState = ButtonState.GROUP;
            }
            
            if (newState <= ButtonState.REST && currentState == ButtonState.GROUP) {
                //beginFading();
                currentState = ButtonState.REST;
            }
        }
        
        // Tracker helpers
        
        function enterHandler(tracker, position, buttonDownElmt, buttonDownAny) {
            if (buttonDownElmt) {
                inTo(ButtonState.DOWN);
                if (onEnter) {
                    onEnter();
                }
            } else if (!buttonDownAny) {
                inTo(ButtonState.HOVER);
            }
        }
        
        function exitHandler(tracker, position, buttonDownElmt, buttonDownAny) {
            outTo(ButtonState.GROUP);
            if (buttonDownElmt && onExit) {
                onExit();
            }
        }
        
        function pressHandler(tracker, position) {
            inTo(ButtonState.DOWN);
            if (onPress) {
                onPress();
            }
        }
        
        function releaseHandler(tracker, position, insideElmtPress, insideElmtRelease) {
            if (insideElmtPress && insideElmtRelease) {
                outTo(ButtonState.HOVER);
                if (onRelease) {
                    onRelease();
                }
            } else if (insideElmtPress) {
                outTo(ButtonState.GROUP);
            } else {
                // pressed elsewhere, but released on it. if we ignored the
                // enter event because a button was down, activate hover now
                inTo(ButtonState.HOVER);
            }
        }
        
        function clickHandler(tracker, position, quick, shift) {
            if (onClick && quick) {
                onClick();
            }
        }
        
        // Methods
        
        this.notifyGroupEnter = function() {
            inTo(ButtonState.GROUP);
        };
        
        this.notifyGroupExit = function() {
            outTo(ButtonState.REST);
        };
        
        // Constructor
        
        (function() {
            button.style.display = "inline-block";
            button.style.position = "relative";
            button.title = tooltip;
            
            button.appendChild(imgRest);
            button.appendChild(imgGroup);
            button.appendChild(imgHover);
            button.appendChild(imgDown);
            
            var styleRest = imgRest.style;
            var styleGroup = imgGroup.style;
            var styleHover = imgHover.style;
            var styleDown = imgDown.style;
            
            // DON'T position imgRest absolutely -- let it be inline so it fills
            // up the div, sizing the div appropriately
            styleGroup.position = styleHover.position = styleDown.position = "absolute";
            styleGroup.top = styleHover.top = styleDown.top = "0px";
            styleGroup.left = styleHover.left = styleDown.left = "0px";
            styleHover.visibility = styleDown.visibility = "hidden";
                    // rest and group are always visible
            
            // FF2 is very buggy with inline-block. it squashes the button div,
            // making the group-pressed states' images lower than rest. but
            // apparently, clearing the "top" style fixes this. (note that this
            // breaks the buttons in every other browser, so we're not clearing
            // the "top" style by default...)
            if (SeadragonUtils.getBrowser() == SeadragonBrowser.FIREFOX &&
                    SeadragonUtils.getBrowserVersion() < 3) {
                styleGroup.top = styleHover.top = styleDown.top = ""; 
            }
            
            tracker.enterHandler = enterHandler;
            tracker.exitHandler = exitHandler;
            tracker.pressHandler = pressHandler;
            tracker.releaseHandler = releaseHandler;
            tracker.clickHandler = clickHandler;
            
            tracker.setTracking(true);
            outTo(ButtonState.REST);
        })();
        
    };
    
    // ButtonGroup class
    
    SeadragonButtonGroup = Seadragon.ButtonGroup = function(buttons) {
        
       // Fields
        
        var group = SeadragonUtils.makeNeutralElement("span");
        var buttons = buttons.concat([]);   // copy
        var tracker = new SeadragonMouseTracker(group);
        
        // Properties
        
        this.elmt = group;
        
        // Tracker helpers
        
        function enterHandler(tracker, position, buttonDownElmt, buttonDownAny) {
            // somewhat office ribbon style -- we do this regardless of whether
            // the mouse is down from elsewhere. it's a nice soft glow effect.
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].notifyGroupEnter();
            }
        }
        
        function exitHandler(tracker, position, buttonDownElmt, buttonDownAny) {
            if (!buttonDownElmt) {
                // only go to rest if the mouse isn't down from a button
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].notifyGroupExit();
                }
            }
        }
        
        function releaseHandler(tracker, position, insideElmtPress, insideElmtRelease) {
            if (!insideElmtRelease) {
                // this means was the mouse was inside the div during press, so
                // since it's no longer inside the div during release, it left
                // the div. but onDivExit() ignored it since the mouse was down
                // from the div, so we'll go out to rest state now.
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].notifyGroupExit();
                }
            }
        }
        
        // Methods
        
        this.emulateEnter = function() {
            enterHandler();
        };
        
        this.emulateExit = function() {
            exitHandler();
        };
        
        // Constructor
        
        (function() {
            group.style.display = "inline-block";
            
            for (var i = 0; i < buttons.length; i++) {
                group.appendChild(buttons[i].elmt);
            }
            
            tracker.enterHandler = enterHandler;
            tracker.exitHandler = exitHandler;
            tracker.releaseHandler = releaseHandler;
            
            tracker.setTracking(true);
        })();
        
    };
    
})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonTileSource = Seadragon.TileSource = function(
        width, height, tileSize, tileOverlap, minLevel, maxLevel) {
    
    // Fields
    
    var self = this;
    var normHeight = height / width;
    
    // Properties
    
    this.width = width;
    this.height = height;
    this.aspectRatio = width / height;
    this.dimensions = new SeadragonPoint(width, height);
    this.minLevel = minLevel ? minLevel : 0;
    this.maxLevel = maxLevel ? maxLevel :
            Math.ceil(Math.log(Math.max(width, height)) / Math.log(2));
    this.tileSize = tileSize ? tileSize : 0;
    this.tileOverlap = tileOverlap ? tileOverlap : 0;
    
    // Methods
    
    this.getLevelScale = function(level) {
        // equivalent to Math.pow(0.5, numLevels - level);
        return 1 / (1 << (self.maxLevel - level));
    };
    
    this.getNumTiles = function(level) {
        var scale = self.getLevelScale(level);
        var x = Math.ceil(scale * width / self.tileSize);
        var y = Math.ceil(scale * height / self.tileSize);
        
        return new SeadragonPoint(x, y);
    };
    
    this.getPixelRatio = function(level) {
        var imageSizeScaled = self.dimensions.times(self.getLevelScale(level));
        var rx = 1.0 / imageSizeScaled.x;
        var ry = 1.0 / imageSizeScaled.y;
        
        return new SeadragonPoint(rx, ry);
    };
    
    this.getTileAtPoint = function(level, point) {
        // support wrapping by taking less-than-full tiles into account!
        // this is necessary in order to properly wrap low-res tiles.
        var scaledSize = self.dimensions.times(self.getLevelScale(level));
        var pixel = point.times(scaledSize.x);
        var tx, ty;
        
        // optimize for the non-wrapping case, but support wrapping
        if (point.x >= 0.0 && point.x <= 1.0) {
            tx = Math.floor(pixel.x / self.tileSize);
        } else {
            tx = Math.ceil(scaledSize.x / self.tileSize) * Math.floor(pixel.x / scaledSize.x) +
                    Math.floor(((scaledSize.x + (pixel.x % scaledSize.x)) % scaledSize.x) / self.tileSize);
        }
        
        // same thing vertically
        if (point.y >= 0.0 && point.y <= normHeight) {
            ty = Math.floor(pixel.y / self.tileSize);
        } else {
            ty = Math.ceil(scaledSize.y / self.tileSize) * Math.floor(pixel.y / scaledSize.y) +
                    Math.floor(((scaledSize.y + (pixel.y % scaledSize.y)) % scaledSize.y) / self.tileSize);
        }
        
        return new SeadragonPoint(tx, ty);
    };
    
    this.getTileBounds = function(level, x, y) {
        // work in scaled pixels for this level
        var dimensionsScaled = self.dimensions.times(self.getLevelScale(level));
        
        // find position, adjust for no overlap data on top and left edges
        var px = (x === 0) ? 0 : self.tileSize * x - self.tileOverlap;
        var py = (y === 0) ? 0 : self.tileSize * y - self.tileOverlap;
        
        // find size, adjust for no overlap data on top and left edges
        var sx = self.tileSize + (x === 0 ? 1 : 2) * self.tileOverlap;
        var sy = self.tileSize + (y === 0 ? 1 : 2) * self.tileOverlap;
        
        // adjust size for single-tile levels where the image size is smaller
        // than the regular tile size, and for tiles on the bottom and right
        // edges that would exceed the image bounds
        sx = Math.min(sx, dimensionsScaled.x - px);
        sy = Math.min(sy, dimensionsScaled.y - py);
        
        // finally, normalize...
        // note that isotropic coordinates ==> only dividing by scaled x!
        var scale = 1.0 / dimensionsScaled.x;
        return new SeadragonRect(px * scale, py * scale, sx * scale, sy * scale);
    };
    
    this.getTileUrl = function(level, x, y) {
        throw new Error("Method not implemented.");
    };
    
    this.tileExists = function(level, x, y) {
        var numTiles = self.getNumTiles(level);
        return level >= self.minLevel && level <= self.maxLevel &&
                x >= 0 && y >= 0 && x < numTiles.x && y < numTiles.y;
    };
    
};

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonDisplayRect = Seadragon.DisplayRect = function(x, y, width, height, minLevel, maxLevel) {
    
    // Inheritance
    
    SeadragonRect.apply(this, arguments);
    
    // Properties (extended)
    
    this.minLevel = minLevel;
    this.maxLevel = maxLevel;
    
};

SeadragonDisplayRect.prototype = new SeadragonRect();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonDziTileSource = Seadragon.DziTileSource = function(
        width, height, tileSize, tileOverlap, tilesUrl, tileFormat, displayRects) {
    
    // Inheritance
    
    SeadragonTileSource.apply(this, [width, height, tileSize, tileOverlap]);
    
    // Fields
    
    var self = this;
    var levelRects = {};    // 1D dictionary [level] --> array of DisplayRects
    
    // Properties
    
    this.fileFormat = tileFormat;   // deprecated old property ("file" instead of "tile")
    this.tileFormat = tileFormat;
    this.displayRects = displayRects;
    
    // Constructor
    
    (function() {
        if (!displayRects) {
            return;
        }
        
        for (var i = displayRects.length - 1; i >= 0; i--) {
            var rect = displayRects[i];
            for (var level = rect.minLevel; level <= rect.maxLevel; level++) {
                if (!levelRects[level]) {
                    levelRects[level] = [];
                }
                levelRects[level].push(rect);
            }
        }
    })();
    
    // Methods -- OVERRIDDEN
    
    this.getTileUrl = function(level, x, y) {
        // using array join because it's faster than string concatenation
        return [tilesUrl, level, '/', x, '_', y, '.', tileFormat].join('');
    };
    
    this.tileExists = function(level, x, y) {
        var rects = levelRects[level];
        
        if (!rects || !rects.length) {
            return true;
        }
        
        var scale = self.getLevelScale(level);
        
        for (var i = rects.length - 1; i >= 0; i--) {
            var rect = rects[i];
            
            // check level
            if (level < rect.minLevel || level > rect.maxLevel) {
                continue;
            }
            
            // transform rectangle coordinates to this level
            var xMin = rect.x * scale;
            var yMin = rect.y * scale;
            var xMax = xMin + rect.width * scale;
            var yMax = yMin + rect.height * scale;
            
            // convert to rows and columns -- note that we're ignoring tile
            // overlap, but it's a reasonable approximation. it errs on the side
            // of false positives, which is much better than false negatives.
            xMin = Math.floor(xMin / tileSize);
            yMin = Math.floor(yMin / tileSize);
            xMax = Math.ceil(xMax / tileSize);
            yMax = Math.ceil(yMax / tileSize);
            
            if (xMin <= x && x < xMax && yMin <= y && y < yMax) {
                return true;
            }
        }
        
        return false;
    };
    
};

SeadragonDziTileSource.prototype = new SeadragonTileSource();



(function() {
    
    // Helpers -- Errors
    
    function DziError(message) {
        Error.apply(this, arguments);
        this.message = message;
    }
    
    DziError.prototype = new Error();
    
    function getError(e) {
        if (!(e instanceof DziError)) {
            // shouldn't happen, but if it does, fail fast or at least log it
            SeadragonDebug.error(e.name + " while creating DZI from XML: " + e.message);
            e = new DziError(SeadragonStrings.getString("Errors.Unknown"));
        }
        
        return e;
    }
    
    // Helpers -- URL
    
    function getTilesUrl(xmlUrl) {
        var urlParts = xmlUrl.split('/');
        var filename = urlParts[urlParts.length - 1];
        var lastDot = filename.lastIndexOf('.');
        
        if (lastDot > -1) {
            urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
        }
        
        return urlParts.join('/') + "_files/";
    }
    
    // Helpers -- XML
    
    function processResponse(xhr, tilesUrl) {
        if (!xhr) {
            throw new DziError(SeadragonStrings.getString("Errors.Security"));
        } /*else if (xhr.status !== 200 && xhr.status !== 0) {
            // chrome has bug where it sends "OK" for 404
            var status = xhr.status;
            var statusText = (status == 404) ? "Not Found" : xhr.statusText;
            throw new DziError(SeadragonStrings.getString("Errors.Status", status, statusText));
        }*/
        
        var doc = null;
        
        if (xhr.responseXML && xhr.responseXML.documentElement) {
            doc = xhr.responseXML;
        } else if (xhr.responseText)  {
            doc = SeadragonUtils.parseXml(xhr.responseText);
        }
        
        return processXml(doc, tilesUrl);
    }
    
    function processXml(xmlDoc, tilesUrl) {
        if (!xmlDoc || !xmlDoc.documentElement) {
            throw new DziError(SeadragonStrings.getString("Errors.Xml"));
        }
        
        var root = xmlDoc.documentElement;
        var rootName = root.tagName;
        
        if (rootName == "Image") {
            try {
                return processDzi(root, tilesUrl);
            } catch (e) {
                var defMsg = SeadragonStrings.getString("Errors.Dzi");
                throw (e instanceof DziError) ? e : new DziError(defMsg);
            }
        } else if (rootName == "Collection") {
            throw new DziError(SeadragonStrings.getString("Errors.Dzc"));
        } else if (rootName == "Error") {
            return processError(root);
        }
        
        throw new DziError(SeadragonStrings.getString("Errors.Dzi"));
    }
    
    function processDzi(imageNode, tilesUrl) {
        var tileFormat = imageNode.getAttribute("Format");
        
        if (!SeadragonUtils.imageFormatSupported(tileFormat)) {
            throw new DziError(SeadragonStrings.getString("Errors.ImageFormat",
                    tileFormat.toUpperCase()));
        }
        
        var sizeNode = imageNode.getElementsByTagName("Size")[0];
        var dispRectNodes = imageNode.getElementsByTagName("DisplayRect");
        
        var width = parseInt(sizeNode.getAttribute("Width"), 10);
        var height = parseInt(sizeNode.getAttribute("Height"), 10);
        var tileSize = parseInt(imageNode.getAttribute("TileSize"));
        var tileOverlap = parseInt(imageNode.getAttribute("Overlap"));
        var dispRects = [];
        
        for (var i = 0; i < dispRectNodes.length; i++) {
            var dispRectNode = dispRectNodes[i];
            var rectNode = dispRectNode.getElementsByTagName("Rect")[0];
            
            dispRects.push(new SeadragonDisplayRect( 
                parseInt(rectNode.getAttribute("X"), 10),
                parseInt(rectNode.getAttribute("Y"), 10),
                parseInt(rectNode.getAttribute("Width"), 10),
                parseInt(rectNode.getAttribute("Height"), 10),
                // TEMP not sure why we did this -- seems like it's wrong.
                // commenting out the hardcoded 0 and using the XML's value.
                //0,  // ignore MinLevel attribute, bug in Deep Zoom Composer
                parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
            ));
        }
        
        return new SeadragonDziTileSource(width, height, tileSize, tileOverlap,
                tilesUrl, tileFormat, dispRects);
    }
    
    function processError(errorNode) {
        var messageNode = errorNode.getElementsByTagName("Message")[0];
        var message = messageNode.firstChild.nodeValue;
        
        throw new DziError(message);
    }
    
    // Methods -- FACTORIES
    
    SeadragonDziTileSource.getTilesUrl = getTilesUrl;
        // expose this publicly because it's useful for multiple clients
    
    SeadragonDziTileSource.createFromJson = function(jsonObj, callback) {
        var async = typeof(callback) == "function";
        var source, error;
        var dzi = jsonObj;
        
        if (!dzi || (!dzi.url && !dzi.tilesUrl)) {
            error = new DziError(SeadragonStrings.getString("Errors.Empty"));
            
        } else {
            
            try {
                
                var displayRects = dzi.displayRects;
                if (displayRects && displayRects.length) {
                    for (var i = 0, n = displayRects.length; i < n; i++) {
                        var dr = displayRects[i];
                        displayRects[i] = new SeadragonDisplayRect(
                            dr.x || dr[0],
                            dr.y || dr[1],
                            dr.width || dr[2],
                            dr.height || dr[3],
                            dr.minLevel || dr[4],
                            dr.maxLevel || dr[5]
                        );
                    }
                }
                
                source = new SeadragonDziTileSource(
                    dzi.width,
                    dzi.height,
                    dzi.tileSize,
                    dzi.tileOverlap,
                    dzi.tilesUrl || getTilesUrl(dzi.url),
                    dzi.tileFormat,
                    dzi.displayRects
                );
                
                source.xmlUrl = dzi.url;
                
            } catch (e) {
                error = getError(e);
            }
            
        }
        
        if (async) {
            window.setTimeout(SeadragonUtils.createCallback(null, callback, source, error && error.message), 1);
        } else if (error) {
            throw error;
        } else {
            return source;
        }
    };
    
    SeadragonDziTileSource.createFromXml = function(xmlUrl, xmlString, callback) {
        var async = typeof(callback) == "function";
        var error = null;
        
        if (!xmlUrl) {
            error = SeadragonStrings.getString("Errors.Empty");
            if (async) {
                window.setTimeout(function() {
                    callback(null, error);
                }, 1);
                return null;
            }
            throw new DziError(error);
        }
        
        var tilesUrl = getTilesUrl(xmlUrl);
        
        function finish(func, obj) {
            try {
                var source = func(obj, tilesUrl);
                source.xmlUrl = xmlUrl;
                return source;
            } catch (e) {
                if (async) {
                    error = getError(e).message;
                    return null;
                } else {
                    throw getError(e);
                }
            }
        }
        
        if (async) {
            if (xmlString) {
                window.setTimeout(function() {
                    var source = finish(processXml, SeadragonUtils.parseXml(xmlString));
                    callback(source, error);    // call after finish sets error
                }, 1);
            } else {
                SeadragonUtils.makeAjaxRequest(xmlUrl, function(xhr) {
                    var source = finish(processResponse, xhr);
                    callback(source, error);    // call after finish sets error
                });
            }
            
            return null;
        }
        
        // synchronous version
        if (xmlString) {
            return finish(processXml, SeadragonUtils.parseXml(xmlString));
        } else {
            return finish(processResponse, SeadragonUtils.makeAjaxRequest(xmlUrl));
        }
    };
    
})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonViewport = Seadragon.Viewport = function(containerSize, contentSize, seadragonViewer) {
    
    // Fields
    
    var self = this;
    
    var containerSize = new SeadragonPoint(containerSize.x, containerSize.y); // copy
    var contentAspect = contentSize.x / contentSize.y;
    var contentHeight = contentSize.y / contentSize.x;
    
    var centerSpringX = new SeadragonSpring(0);
    var centerSpringY = new SeadragonSpring(0);
    var zoomSpring = new SeadragonSpring(SeadragonConfig.logarithmicZoom ? 0 : 1);
    var zoomPoint = null;
    
    var homeBounds = new SeadragonRect(0, 0, 1, contentHeight);
    var homeCenter = homeBounds.getCenter();
    
    var LN2 = Math.LN2;
    
    // Helpers
    
    function init() {
        self.goHome(true);
        self.update();
    }
    
    function log2(x) {
        return Math.log(x) / LN2;
    }
    
    function pow2(x) {
        return Math.pow(2, x);
    }
    
    function clamp(x, min, max) {
        return Math.min(Math.max(x, min), max);
    }
    
    function clampPointToRect(point, rect) {
        var xOld = point.x,
            yOld = point.y,
            xNew = clamp(xOld, rect.x, rect.x + rect.width),
            yNew = clamp(yOld, rect.y, rect.y + rect.height);
        
        return (xOld === xNew && yOld === yNew) ? point :
                new SeadragonPoint(xNew, yNew);
    }
    
    function getCenterConstraintRect(current) {
        var zoom = self.getZoom(current),
            width = 1.0 / zoom,
            height = width / self.getAspectRatio(),
            visibilityRatio = SeadragonConfig.visibilityRatio,
            xMin = (visibilityRatio - 0.5) * width,
            yMin = (visibilityRatio - 0.5) * height,
            xDelta = 1.0 - 2 * xMin,
            yDelta = contentHeight - 2 * yMin;
        
        if (xDelta < 0) {
            xMin += (0.5 * xDelta);
            xDelta = 0;
        }
        
        if (yDelta < 0) {
            yMin += (0.5 * yDelta);
            yDelta = 0;
        }
        
        return new Seadragon.Rect(xMin, yMin, xDelta, yDelta);
    }
    
    // Methods -- CONSTRAINT HELPERS
    
    this.getHomeBounds = function () {
        // fit home bounds to viewport's aspect ratio, maintaining center.
        // this is the same logic as in fitBounds().
        
        var viewportAspect = self.getAspectRatio();
        var homeBoundsFit = new SeadragonRect(
            homeBounds.x, homeBounds.y, homeBounds.width, homeBounds.height);
        
        if (contentAspect >= viewportAspect) {
            // width is bigger relative to viewport, resize height
            homeBoundsFit.height = homeBounds.width / viewportAspect;
            homeBoundsFit.y = homeCenter.y - homeBoundsFit.height / 2;
        } else {
            // height is bigger relative to viewport, resize width
            homeBoundsFit.width = homeBounds.height * viewportAspect;
            homeBoundsFit.x = homeCenter.x - homeBoundsFit.width / 2;
        }
        
        return homeBoundsFit;
    };
    
    this.getHomeCenter = function () {
        return homeCenter;
    };

    this.getHomeZoom = function () {
        // if content is wider, we'll fit width, otherwise height
        var aspectFactor = contentAspect / self.getAspectRatio();
        return (aspectFactor >= 1) ? 1 : aspectFactor;
    };
    
    this.getMinCenter = function (current) {
        return getCenterConstraintRect(current).getTopLeft();
    };
    
    this.getMaxCenter = function (current) {
        return getCenterConstraintRect(current).getBottomRight();
    };

    this.getMinZoom = function () {
        var homeZoom = self.getHomeZoom();

        // for backwards compatibility, respect minZoomDimension if present
        if (SeadragonConfig.minZoomDimension) {
            var zoom = (contentSize.x <= contentSize.y) ?
                SeadragonConfig.minZoomDimension / containerSize.x :
                SeadragonConfig.minZoomDimension / (containerSize.x * contentHeight);
        } else {
            var zoom = SeadragonConfig.minZoomImageRatio * homeZoom;
        }

        return Math.min(zoom, homeZoom);
    };

    this.getMaxZoom = function () {
        var zoom = contentSize.x * SeadragonConfig.maxZoomPixelRatio / containerSize.x;
        return Math.max(zoom, self.getHomeZoom());
    };
        
    // Methods -- ACCESSORS

    this.getAspectRatio = function () {
        return containerSize.x / containerSize.y;
    };
    
    this.getContainerSize = function() {
        return new SeadragonPoint(containerSize.x, containerSize.y);
    };
    
    this.getBounds = function(current) {
        var center = self.getCenter(current);
        var width = 1.0 / self.getZoom(current);
        var height = width / self.getAspectRatio();
        
        return new SeadragonRect(center.x - width / 2.0, center.y - height / 2.0,
            width, height);
    };
    
    this.getCenter = function(current) {
        var centerCurrent = new SeadragonPoint(
            centerSpringX.getCurrent(), centerSpringY.getCurrent());
        var centerTarget = new SeadragonPoint(
            centerSpringX.getTarget(), centerSpringY.getTarget());
        
        if (current) {
            return centerCurrent;
        } else if (!zoomPoint) {
            // no adjustment necessary since we're not zooming
            return centerTarget;
        }
        
        // to get the target center, we need to adjust for the zoom point.
        // we'll do this in the same way as the update() method.
        
        // manually calculate bounds based on this unadjusted target center.
        // this is mostly a duplicate of getBounds() above. note that this is
        // based on the TARGET zoom but the CURRENT center.
        var zoom = self.getZoom();
        var width = 1.0 / zoom;
        var height = width / self.getAspectRatio();
        var bounds = new SeadragonRect(
            centerCurrent.x - width / 2.0,
            centerCurrent.y - height / 2.0,
            width,
            height
        );
        
        // the conversions here are identical to the pixelFromPoint() and
        // deltaPointsFromPixels() methods.
        var oldZoomPixel = self.pixelFromPoint(zoomPoint, true);
        var newZoomPixel = zoomPoint.minus(bounds.getTopLeft()).times(containerSize.x / bounds.width);
        var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
        var deltaZoomPoints = deltaZoomPixels.divide(containerSize.x * zoom);
        
        // finally, shift center to negate the change.
        return centerTarget.plus(deltaZoomPoints);
    };
    
    this.getZoom = function(current) {
        var zoom;
        if (current) {
            zoom = zoomSpring.getCurrent();
            return SeadragonConfig.logarithmicZoom ? pow2(zoom) : zoom;
        } else {
            zoom = zoomSpring.getTarget();
            return SeadragonConfig.logarithmicZoom ? pow2(zoom) : zoom;
        }
    };
    
    // Methods -- MODIFIERS
    
    this.applyConstraints = function(immediately) {
        // first, apply zoom constraints
        var oldZoom = self.getZoom();
        var newZoom = clamp(oldZoom, self.getMinZoom(), self.getMaxZoom());
        if (oldZoom != newZoom) {
            self.zoomTo(newZoom, zoomPoint, immediately);
        }
        
        // then, apply pan constraints -- but do so via fitBounds() in order to
        // account for (and adjust) the zoom point! also ignore constraints if
        // content is being wrapped! but differentiate horizontal vs. vertical.
        var oldCenter = self.getCenter();
        var newCenter = clampPointToRect(oldCenter, getCenterConstraintRect());
        if (SeadragonConfig.wrapHorizontal) {
            newCenter.x = oldCenter.x;
        }
        if (SeadragonConfig.wrapVertical) {
            newCenter.y = oldCenter.y;
        }
        
        if (!oldCenter.equals(newCenter)) {
            var width = 1.0 / newZoom,
                height = width / self.getAspectRatio();
            self.fitBounds(new SeadragonRect(
                newCenter.x - 0.5 * width,
                newCenter.y - 0.5 * height,
                width,
                height
            ), immediately);
            return true; // returns whether or not constraints were applied
        } else {return false};
    };
    
    this.ensureVisible = function(immediately) {
        // for backwards compatibility
        self.applyConstraints(immediately);
    };
    
    this.fitBounds = function(bounds, immediately) {
        var aspect = self.getAspectRatio();
        var center = bounds.getCenter();
        
        // resize bounds to match viewport's aspect ratio, maintaining center.
        // note that zoom = 1/width, and width = height*aspect.
        var newBounds = new SeadragonRect(bounds.x, bounds.y, bounds.width, bounds.height);
        if (newBounds.getAspectRatio() >= aspect) {
            // width is bigger relative to viewport, resize height
            newBounds.height = bounds.width / aspect;
            newBounds.y = center.y - newBounds.height / 2;
        } else {
            // height is bigger relative to viewport, resize width
            newBounds.width = bounds.height * aspect;
            newBounds.x = center.x - newBounds.width / 2;
        }
        
        // stop movement first! this prevents the operation from missing
        self.panTo(self.getCenter(true), true);
        self.zoomTo(self.getZoom(true), null, true);
        
        // capture old values for bounds and width. we need both, but we'll
        // also use both for redundancy, to protect against precision errors.
        // note: use target bounds, since update() hasn't been called yet!
        var oldBounds = self.getBounds();
        var oldZoom = self.getZoom();
        
        // if we're already at the correct zoom, just pan and we're done.
        // we'll check both zoom and bounds for redundancy, to protect against
        // precision errors (see note below).
        var newZoom = 1.0 / newBounds.width;
        if (newZoom == oldZoom || Math.abs(newBounds.width - oldBounds.width) < 0.000001) {
            self.panTo(center, immediately);
            return;
        }
        
        // otherwise, we need to zoom about the only point whose pixel transform
        // is constant between the old and new bounds. this is just tricky math.
        var refPoint = oldBounds.getTopLeft().times(containerSize.x / oldBounds.width).minus(
                newBounds.getTopLeft().times(containerSize.x / newBounds.width)).divide(
                containerSize.x / oldBounds.width - containerSize.x / newBounds.width);
        
        // note: that last line (cS.x / oldB.w - cS.x / newB.w) was causing a
        // divide by 0 in the case that oldBounds.width == newBounds.width.
        // that should have been picked up by the zoom check, but in certain
        // cases, the math is slightly off and the zooms are different. so now,
        // the zoom check has an extra check added.
        
        self.zoomTo(newZoom, refPoint, immediately);
    };
   
    this.goHome = function(immediately) {
        // calculate center adjusted for zooming
        var center = self.getCenter();
        
        // if we're wrapping horizontally, "unwind" the horizontal spring
        if (SeadragonConfig.wrapHorizontal) {
            // this puts center.x into the range [0, 1) always
            center.x = (1 + (center.x % 1)) % 1;
            centerSpringX.resetTo(center.x);
            centerSpringX.update();
        }
        
        // if we're wrapping vertically, "unwind" the vertical spring
        if (SeadragonConfig.wrapVertical) {
            // this puts center.y into the range e.g. [0, 0.75) always
            center.y = (contentHeight + (center.y % contentHeight)) % contentHeight;
            centerSpringY.resetTo(center.y);
            centerSpringY.update();
        }
        
        self.fitBounds(homeBounds, immediately);
    };
    
    this.panBy = function(delta, immediately) {
        self.panTo(self.getCenter().plus(delta), immediately);
    };
    
    this.panTo = function(center, immediately) {
        // we have to account for zoomPoint here, i.e. if we're in the middle
        // of a zoom about some point and panTo() is called, we should be
        // spring to some center that will get us to the specified center.
        // the logic here is thus the exact inverse of the getCenter() method.
        
        if (immediately) {
            centerSpringX.resetTo(center.x);
            centerSpringY.resetTo(center.y);
            return;
        }

        if(!zoomPoint) { // added by bleveque for tour manipulation
            zoomPoint = new Seadragon.Point(0,0);
        }
        
        // if (!zoomPoint) { // commented out by bleveque -- broke tour manipulation
        //     centerSpringX.springTo(center.x);
        //     centerSpringY.springTo(center.y);
        //     return;
        // }

                
        // manually calculate bounds based on this unadjusted target center.
        // this is mostly a duplicate of getBounds() above. note that this is
        // based on the TARGET zoom but the CURRENT center.
        var zoom = self.getZoom();
        var width = 1.0 / zoom;
        var height = width / self.getAspectRatio();
        var bounds = new SeadragonRect(
            centerSpringX.getCurrent() - width / 2.0,
            centerSpringY.getCurrent() - height / 2.0,
            width,
            height
        );
        
        // the conversions here are identical to the pixelFromPoint() and
        // deltaPointsFromPixels() methods.
        var oldZoomPixel = self.pixelFromPoint(zoomPoint, true);
        var newZoomPixel = zoomPoint.minus(bounds.getTopLeft()).times(containerSize.x / bounds.width);
        var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
        var deltaZoomPoints = deltaZoomPixels.divide(containerSize.x * zoom);
        
        // finally, shift center to negate the change.
        var centerTarget = center.minus(deltaZoomPoints);
        
        centerSpringX.springTo(centerTarget.x);
        centerSpringY.springTo(centerTarget.y);

        seadragonViewer.scheduleUpdate();
    };
    
    this.zoomBy = function(factor, refPoint, immediately) {
        self.zoomTo(self.getZoom() * factor, refPoint, immediately);
    };
    
    this.zoomTo = function(zoom, refPoint, immediately) {
        // we used to constrain zoom automatically here; now it needs to be
        // explicitly constrained, via applyConstraints().
        //zoom = clamp(zoom, self.getMinZoom(), self.getMaxZoom());
        
        if (immediately) {
            zoomSpring.resetTo(SeadragonConfig.logarithmicZoom ? log2(zoom) : zoom);
        } else {
            zoomSpring.springTo(SeadragonConfig.logarithmicZoom ? log2(zoom) : zoom);
        }
        
        zoomPoint = refPoint instanceof SeadragonPoint ? refPoint : null;

        seadragonViewer.scheduleUpdate();
    };
    
    this.resize = function(newContainerSize, maintain) {
        // default behavior: just ensure the visible content remains visible.
        // note that this keeps the center (relative to the content) constant.
        var oldBounds = self.getBounds();
        var newBounds = oldBounds;
        var widthDeltaFactor = newContainerSize.x / containerSize.x;
        
        // update container size, but make copy first
        containerSize = new SeadragonPoint(newContainerSize.x, newContainerSize.y);
        
        if (maintain) {
            // no resize relative to screen, resize relative to viewport.
            // keep origin constant, zoom out (increase bounds) by delta factor.
            newBounds.width = oldBounds.width * widthDeltaFactor;
            newBounds.height = newBounds.width / self.getAspectRatio(); 
        }
        
        self.fitBounds(newBounds, true);
    };
    
    this.update = function() {
        var oldCenterX = centerSpringX.getCurrent();
        var oldCenterY = centerSpringY.getCurrent();
        var oldZoom = zoomSpring.getCurrent();
        
        // remember position of zoom point
        if (zoomPoint) {
            var oldZoomPixel = self.pixelFromPoint(zoomPoint, true);
        }
        
        // now update zoom only, don't update pan yet
        zoomSpring.update();
        
        // adjust for change in position of zoom point, if we've zoomed
        if (zoomPoint && zoomSpring.getCurrent() != oldZoom) {
            var newZoomPixel = self.pixelFromPoint(zoomPoint, true);
            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
            var deltaZoomPoints = self.deltaPointsFromPixels(deltaZoomPixels, true);
            
            // shift pan to negate the change
            centerSpringX.shiftBy(deltaZoomPoints.x);
            centerSpringY.shiftBy(deltaZoomPoints.y);
        } else {
            // don't try to adjust next time; this improves performance
            zoomPoint = null;
        }
        
        // now after adjustment, update pan
        centerSpringX.update();
        centerSpringY.update();
        
        return centerSpringX.getCurrent() != oldCenterX ||
                centerSpringY.getCurrent() != oldCenterY ||
                zoomSpring.getCurrent() != oldZoom;
    };
    
    // Methods -- CONVERSION HELPERS
    
    this.deltaPixelsFromPoints = function(deltaPoints, current) {
        return deltaPoints.times(containerSize.x * self.getZoom(current));
    };
    
    this.deltaPointsFromPixels = function(deltaPixels, current) {
        return deltaPixels.divide(containerSize.x * self.getZoom(current));
    };
    
    this.pixelFromPoint = function(point, current) {
        var bounds = self.getBounds(current);
        return point.minus(bounds.getTopLeft()).times(containerSize.x / bounds.width);
    };
    
    this.pointFromPixel = function(pixel, current) {
        var bounds = self.getBounds(current);
        return pixel.divide(containerSize.x / bounds.width).plus(bounds.getTopLeft());
    };
    
    // Constructor
    
    init();
    
};

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonDrawer,
    SeadragonOverlayPlacement;

(function() {
    
    // Constants
    
    var QUOTA = 1500;    // the max number of images we should keep in memory
    var MIN_PIXEL_RATIO = 0.5;  // the most shrunk a tile should be
    
    // Method of drawing
    
    var browser = SeadragonUtils.getBrowser();
    var browserVer = SeadragonUtils.getBrowserVersion();
    var userAgent = navigator.userAgent;
    
    // check if browser supports <canvas>.
    // update: IE9 returns type "object" instead of "function"...
    var hasCanvas = !!(document.createElement("canvas").getContext);
    
    // we use this style for a lot of our checks, so caching it here:
    var docElmt = document.documentElement || {};
    var docElmtStyle = docElmt.style || {};
    
    // check if browser supports CSS transforms. using this technique:
    // http://www.zachstronaut.com/posts/2009/02/17/animate-css-transforms-firefox-webkit.html
    // also, the spec says translate values need to include units (e.g. "px"),
    // but webkit chokes on units. we need to check for this bug.
    var hasCssTransforms = false;
    var cssTransformProperties = ["msTransform", "WebkitTransform", "MozTransform"];
    var cssTransformProperty, cssTransformNoUnits;
    
    while (cssTransformProperty = cssTransformProperties.shift()) {
        if (typeof docElmtStyle[cssTransformProperty] !== "undefined") {
            hasCssTransforms = true;
            cssTransformNoUnits = /webkit/i.test(cssTransformProperty);
            break;
        }
    }
    
    // we'll use a similar technique to check for CSS transitions.
    // TEMP the value for CSS transition-property is the CSS name of the
    // property you want transitioned, e.g. "-webkit-transform", and NOT the
    // JavaScript name, e.g. "WebkitTransform". so for the time being, we're
    // hardcoding this stuff to just webkit instead of general checking.
    var cssTransformPropertyCssName = "-webkit-transform";
    var cssTransitionProperty = "WebkitTransition";
    var hasCssTransitions =
        typeof docElmtStyle[cssTransitionProperty] !== "undefined";
    
    // check if browser is IE, or supports IE's proprietary DirectX filters.
    // specifically, the matrix transform filter is similar to CSS transforms!
    // http://msdn.microsoft.com/en-us/library/ms533014(v=VS.85).aspx
    var IE_MATRIX_FILTER = "progid:DXImageTransform.Microsoft.Matrix";
    var IE_MATRIX_FILTER_REGEXP = new RegExp(
        IE_MATRIX_FILTER + "\\(.*?\\)", 'g');
    
    // TEMP checking for the presence of the "filters" property isn't really
    // strong feature detection, so added an explicit IE check. that's fine?
    // update: also trying catch this since IE9 throws an error here.
    var hasIeFilters = (function() {
        try {
            return (browser === SeadragonBrowser.IE) &&
                !!(document.documentElement.filters);
        } catch (e) {
            return false;
        }
    })();
    
    // in general, <canvas> is great because it's standardized and stable for
    // the functionality we need. plus, firefox, opera and safari 4 all have
    // subpixel precision inside <canvas>. CSS transforms also seem to get us
    // subpixel precision, and more broadly, across firefox, safari 4 and even
    // chrome, but it's less stable so far. both <canvas> and CSS transform
    // have potential to be hardware accelerated, so deciding between the two
    // comes down to subpixel precision and perf based on experimentation.
    // note that IE provides proprietary matrix transforms which also get us
    // subpixel precision!! for fallback, we use regular CSS position/size.
    // UPDATE: IE's matrix transforms are dog-slow, no good unfortunately.
    // but, we may still be able to use them somehow, maybe once per frame on
    // just the canvas and not multiple times per frame on each tile.
    // TODO investigate IE matrix transforms on canvas instead of per tile.
    // TEMP for now, turning off IE matrix transforms altogether.
    var badCanvas =     // due to no subpixel precision
            (browser === SeadragonBrowser.SAFARI && browserVer < 4) ||
            (browser === SeadragonBrowser.CHROME);
    var useCanvas = hasCanvas && !badCanvas;
    var useCssTransforms = !useCanvas && hasCssTransforms;
    var useIeFilters = false;
    
    // UPDATE: safari 4 on Mac OS X 10.6 (snow leopard) and safari mobile on
    // iPhone OS 3 hardware accelerate CSS transforms when combined with CSS
    // transitions, so use them there over <canvas>!
    // UPDATE: this causes flickers on the iPhone; removing support for now.
    //var acceleratedTransforms =
    //    browser == SeadragonBrowser.SAFARI && userAgent.match(/Mac OS X/) && (
    //        // case 1: safari 4 (desktop and iPad)
    //        browserVer >= 4 ||
    //        // case 2: safari mobile, might be 3
    //        userAgent.match(/Mobile\//));
    //if (hasCssTransforms && hasCssTransitions && acceleratedTransforms) {
    //    useCanvas = false;
    //    useCssTransforms = true;
    //}
    
    // regardless, in IE, we use <img> tags. unfortunately, in IE, <img> tags
    // use a crappy nearest-neighbor interpolation by default. IE7+ lets us
    // change this via a proprietary CSS property. unfortunately, changing it to
    // bicubic caused tile seams in IE7 -- but not IE8! even IE8 in compat mode
    // has no tile seams. so we need to detect IE8 regardless of mode; we do so
    // via document.documentMode, introduced in IE8 for all modes. finally, in
    // IE7, we'll explicitly say nearest-neighbor, otherwise if the user zooms
    // the page, IE7 would implicitly change it to bicubic, causing tile seams.
    var MS_INTERPOLATION_MODE = (typeof document.documentMode !== "undefined") ?
            "bicubic" : "nearest-neighbor";
    
    // Tiles
    
    function Tile(level, x, y, bounds, exists, url) {
        // Core
        this.level = level;
        this.x = x;
        this.y = y;
        this.bounds = bounds;   // where this tile fits, in normalized coordinates
        this.exists = exists;   // part of sparse image? tile hasn't failed to load?
        
        // Image
        this.url = url;         // the URL of this tile's image
        this.elmt = null;       // the HTML element for this tile
        this.image = null;      // the Image object for this tile
        this.loaded = false;    // is this tile loaded?
        this.loading = false;   // or is this tile loading?
        
        // Drawing
        this.style = null;      // alias of this.elmt.style
        this.position = null;   // this tile's position on screen, in pixels
        this.size = null;       // this tile's size on screen, in pixels
        this.blendStart = null; // the start time of this tile's blending
        this.opacity = null;    // the current opacity this tile should be
        this.distance = null;   // the distance of this tile to the viewport center
        this.visibility = null; // the visibility score of this tile
        
        // Caching
        this.beingDrawn = false;// whether this tile is currently being drawn
        this.covered = false;   // whether this tile is currently covered
        this.lastDrawnTime = 0; // when the tile was last drawn
        this.lastTouchTime = 0; // the time that tile was last touched (though not necessarily drawn)
    }
    
    Tile.prototype.toString = function() {
        return this.level + "/" + this.x + "_" + this.y;
    };
    
    Tile.prototype.drawHTML = function(container) {
        if (!this.loaded) {
            SeadragonDebug.error("Attempting to draw tile " + this.toString() +
                    " when it's not yet loaded.");
            return;
        }
        
        // initialize if first time
        if (!this.elmt) {
            this.elmt = SeadragonUtils.makeNeutralElement("img");
            this.elmt.src = this.url; 
            this.style = this.elmt.style;
            this.style.position = "absolute";
            this.style.msInterpolationMode = MS_INTERPOLATION_MODE;
                // IE only property. see note above for explanation.
            
            if (useCssTransforms) {
                this.style[cssTransformProperty + "Origin"] = "0px 0px";
                // TEMP commenting out CSS transitions for now; not stable yet.
                //if (hasCssTransitions) {
                //    this.style[cssTransitionProperty + "Property"] = cssTransformPropertyCssName;
                //    this.style[cssTransitionProperty + "Duration"] = ".01666667s";   // TEMP 1/60th of a second
                //}
            }
        }
        
        var elmt = this.elmt;
        var image = this.image;
        var style = this.style;
        var position = this.position;
        var size = this.size;
        
        if (elmt.parentNode !== container) {
            container.appendChild(elmt);
        }
        
        if (useCssTransforms) {
            
            // warning! sometimes chrome doesn't have this new <img> element
            // loaded yet, even though it's a clone of another <img> element
            // that is loaded. so we use the width and height properties of the
            // original <img> (the image variable instead of this one (elmt).
            style[cssTransformProperty] = [
                'matrix(',
                (size.x / image.width).toFixed(8),
                ',0,0,',
                (size.y / image.height).toFixed(8),
                ',',
                position.x.toFixed(8),
                cssTransformNoUnits ? ',' : 'px,',
                position.y.toFixed(8),
                cssTransformNoUnits ? ')' : 'px)'
            ].join('');
            
        } else if (useIeFilters) {
            
            var containerWidth = container.clientWidth,
                containerHeight = container.clientHeight;
            
            style.width = containerWidth + "px";
            style.height = containerHeight + "px";
            style.filter = [
                'progid:DXImageTransform.Microsoft.Matrix(',
                'M11=',
                (size.x / containerWidth).toFixed(8),
                ',M22=',
                (size.y / containerHeight).toFixed(8),
                ',Dx=',
                position.x.toFixed(8),
                ',Dy=',
                position.y.toFixed(8),
                ')'
            ].join('');
            
        } else {
            
            position = position.apply(Math.floor);
            size = size.apply(Math.ceil);
            
            style.left = position.x + "px";
            style.top = position.y + "px";
            style.width = size.x + "px";
            style.height = size.y + "px";
            
        }
        
        // TEMP because we know exactly whether we're using IE filters or not,
        // short-circuitting this utils call to optimize the logic.
        // UPDATE: we're no longer using IE filters, so reverting this logic.
        SeadragonUtils.setElementOpacity(elmt, this.opacity);
        //var opacity = this.opacity;
        //if (useIeFilters && opacity < 1) {
        //    style.filter += " alpha(opacity=" + Math.round(100 * opacity) + ")";
        //} else {
        //    style.opacity = (opacity < 1) ? opacity : '';
        //}
    };
    
    Tile.prototype.drawCanvas = function(context) {
        if (!this.loaded) {
            SeadragonDebug.error("Attempting to draw tile " + this.toString() +
                    " when it's not yet loaded.");
            return;
        }
        
        var position = this.position;
        var size = this.size;
            
        context.globalAlpha = this.opacity;
        context.drawImage(this.image, position.x, position.y, size.x, size.y);
    };
    
    Tile.prototype.unload = function () {
        if (this.elmt && this.elmt.parentNode) {
            this.elmt.parentNode.removeChild(this.elmt);
        }

        this.elmt = null;
        this.image = null;
        this.loaded = false;
        this.loading = false;
    };
    
    // Overlays
    
    SeadragonOverlayPlacement = Seadragon.OverlayPlacement = {
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8
    };
    
    /**
     * Creates an "adjustment" function for a given overlay placement that
     * adjusts an overlay's position depending on its size and placement. This
     * gives better perf during draw loop since we don't need to re-check and
     * re-calculate the adjustment every single iteration.
     */
    function createAdjustmentFunction(placement) {
        switch (placement) {
            case SeadragonOverlayPlacement.TOP_LEFT:
                return function(position, size) {
                    // no adjustment needed
                };
            case SeadragonOverlayPlacement.TOP:
                return function(position, size) {
                    position.x -= size.x / 2;
                    // no y adjustment needed
                };
            case SeadragonOverlayPlacement.TOP_RIGHT:
                return function(position, size) {
                    position.x -= size.x;
                    // no y adjustment needed
                };
            case SeadragonOverlayPlacement.RIGHT:
                return function(position, size) {
                    position.x -= size.x;
                    position.y -= size.y / 2;
                };
            case SeadragonOverlayPlacement.BOTTOM_RIGHT:
                return function(position, size) {
                    position.x -= size.x;
                    position.y -= size.y;
                };
            case SeadragonOverlayPlacement.BOTTOM:
                return function(position, size) {
                    position.x -= size.x / 2;
                    position.y -= size.y;
                };
            case SeadragonOverlayPlacement.BOTTOM_LEFT:
                return function(position, size) {
                    // no x adjustment needed
                    position.y -= size.y;
                };
            case SeadragonOverlayPlacement.LEFT:
                return function(position, size) {
                    // no x adjustment needed
                    position.y -= size.y / 2;
                };
            case SeadragonOverlayPlacement.CENTER:
            default:
                return function(position, size) {
                    position.x -= size.x / 2;
                    position.y -= size.y / 2;
                };
        }
    }
    
    function Overlay(elmt, loc, placement) {
        // Core
        this.elmt = elmt;
        this.scales = (loc instanceof SeadragonRect);
        this.bounds = new SeadragonRect(loc.x, loc.y, loc.width, loc.height);
        // Drawing
        this.adjust = createAdjustmentFunction(loc instanceof SeadragonPoint ?
                placement : SeadragonOverlayPlacement.TOP_LEFT);    // rects are always top-left
        this.position = new SeadragonPoint(loc.x, loc.y);
        this.size = new SeadragonPoint(loc.width, loc.height);
        this.style = elmt.style;
        this.naturalSize = new SeadragonPoint(elmt.clientWidth, elmt.clientHeight);
    }
    
    Overlay.prototype.destroy = function() {
        var elmt = this.elmt;
        var style = this.style;
        
        if (elmt.parentNode) {
            elmt.parentNode.removeChild(elmt);
        }
        
        style.top = "";
        style.left = "";
        style.position = "";
        
        if (this.scales) {
            style.width = "";
            style.height = "";
        }
    };
    
    Overlay.prototype.drawHTML = function(container) {
        var elmt = this.elmt;
        var style = this.style;
        var scales = this.scales;
        var naturalSize = this.naturalSize;
        
        if (elmt.parentNode !== container) {
            container.appendChild(elmt);
            style.position = "absolute";
            naturalSize.x = elmt.clientWidth;
            naturalSize.y = elmt.clientHeight;
        }
        
        var position = this.position;
        var size = this.size;
        
        // override calculated size if this element doesn't scale with image
        if (!scales) {
            size.x = naturalSize.x = naturalSize.x || elmt.clientWidth;
            size.y = naturalSize.y = naturalSize.y || elmt.clientHeight;
        }
        
        // adjust position based on placement (default is center)
        this.adjust(position, size);
        
        if (SeadragonConfig.transformOverlays && hasCssTransforms) {
            
            style[cssTransformProperty + "Origin"] = "0px 0px";
            style[cssTransformProperty] = [
                'translate(',
                position.x.toFixed(8),
                'px,',  // webkit correctly accepts length units for translate() func
                position.y.toFixed(8),
                'px)'
            ].join('');
            
            if (scales) {
                
                if (!elmt.clientWidth) {
                    style.width = "100%";
                }
                if (!elmt.clientHeight) {
                    style.height = "100%";
                }
                
                style[cssTransformProperty] += [
                    ' scale(',
                    (size.x / elmt.clientWidth).toFixed(8),
                    ',',
                    (size.y / elmt.clientHeight).toFixed(8),
                    ')'
                ].join('');
                
            }
            
        } else if (SeadragonConfig.transformOverlays && useIeFilters) {
            
            var containerWidth = container.clientWidth,
                containerHeight = container.clientHeight;
            
            style.width = containerWidth + "px";
            style.height = containerHeight + "px";
            style.filter = [
                'progid:DXImageTransform.Microsoft.Matrix(',
                'M11=',
                (size.x / containerWidth).toFixed(8),
                ',M22=',
                (size.y / containerHeight).toFixed(8),
                ',Dx=',
                position.x.toFixed(8),
                ',Dy=',
                position.y.toFixed(8),
                ')'
            ].join('');
            
        } else {
            
            position = position.apply(Math.floor);
            size = size.apply(Math.ceil);
            
            style.left = position.x + "px";
            style.top = position.y + "px";
            
            if (scales) {
                style.width = size.x + "px";
                style.height = size.y + "px";
            }
            
        }
    };
    
    Overlay.prototype.update = function(loc, placement) {
        this.scales = (loc instanceof SeadragonRect);
        this.bounds = new SeadragonRect(loc.x, loc.y, loc.width, loc.height);
        this.adjust = createAdjustmentFunction(loc instanceof SeadragonPoint ?
                placement : SeadragonOverlayPlacement.TOP_LEFT);    // rects are always top-left
    };
    
    // Drawer
    
    SeadragonDrawer = Seadragon.Drawer = function(source, viewport, elmt, viewer, ignoreConstraints) {
        
        MIN_PIXEL_RATIO = ignoreConstraints ? 0.1 : 0.5;

        // Implementation note:
        // 
        // This class draws two types of things: tiles and overlays. Currently,
        // only HTML elements are supported overlay types, so they will always
        // be inserted into the DOM. Tiles are images, which allows them to be
        // both inserted into the DOM or to be drawn onto a <canvas> element.
        // 
        // Higher-res (higher-level) tiles need to be drawn above lower-res
        // (lower-level) tiles. Overlays need to be drawn above all tiles. For
        // tiles drawn using <canvas>, this is easy. For tiles drawn as HTML,
        // and for overlays, we can use the CSS z-index property, but that has
        // issues in full page. So instead, we can achieve natural z-ordering
        // through the order of the elements in the container.
        // 
        // To do this, in the HTML mode, we add the tiles not to the container
        // directly, but to a div inside the container. This div is the first
        // child of the container. The overlays are added to the container
        // directly, after that div. This ensures that the overlays are always
        // drawn above the tiles.
        // 
        // In the below fields, the canvas field refers to the <canvas> element
        // if we're drawing with canvas, or the div that contains the tiles if
        // we're drawing with HTML.
        // 
        // Minor note: we remove and re-add tiles to the div every frame, but we
        // can't do this with overlays, as it breaks browser event behavior.
        
        // Fields
        
        var container = SeadragonUtils.getElement(elmt);
        var canvas = SeadragonUtils.makeNeutralElement(useCanvas ? "canvas" : "div");
        var context = useCanvas ? canvas.getContext("2d") : null;
        
        var imageLoader = new SeadragonImageLoader();
        var profiler = new SeadragonProfiler();
        
        var minLevel = source.minLevel;
        var maxLevel = source.maxLevel;
        var tileSize = source.tileSize;
        var tileOverlap = source.tileOverlap;
        var normHeight = source.height / source.width;
        
        var cacheNumTiles = {};     // 1d dictionary [level] --> Point
        var cachePixelRatios = {};  // 1d dictionary [level] --> Point
        var tilesMatrix = {};       // 3d dictionary [level][x][y] --> Tile
        var tilesLoaded = [];       // unordered list of Tiles with loaded images
        var coverage = {};          // 3d dictionary [level][x][y] --> Boolean
        
        var overlays = [];          // unordered list of Overlays added
        var lastDrawn = [];         // unordered list of Tiles drawn last frame
        var lastFrameTime = 0;      // the timestamp of the previous frame
        var lastResetTime = 0;
        var midUpdate = false;
        var updateAgain = true;

        // Properties
        
        this.elmt = container;
        this.profiler = profiler;
        
        // Constructor
        
        (function () {
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            canvas.style.position = "absolute";
            container.style.textAlign = "left";    // explicit left-align
            container.appendChild(canvas);
        })();
        
        // Helpers -- CACHES
        
        function getNumTiles(level) {
            if (!cacheNumTiles[level]) {
                cacheNumTiles[level] = source.getNumTiles(level);
            }
            
            return cacheNumTiles[level];
        }
        
        function getPixelRatio(level) {
            if (!cachePixelRatios[level]) {
                cachePixelRatios[level] = source.getPixelRatio(level);
            }
            
            return cachePixelRatios[level];
        }
        
        // Helpers -- TILES
        
        function getTile(level, x, y, time, numTilesX, numTilesY) {
            if (!tilesMatrix[level]) {
                tilesMatrix[level] = {};
            }
            if (!tilesMatrix[level][x]) {
                tilesMatrix[level][x] = {};
            }
            
            // initialize tile object if first time
            if (!tilesMatrix[level][x][y]) {
                // where applicable, adjust x and y to support wrapping.
                var xMod = (numTilesX + (x % numTilesX)) % numTilesX;
                var yMod = (numTilesY + (y % numTilesY)) % numTilesY;
                var bounds = source.getTileBounds(level, xMod, yMod);
                var exists = source.tileExists(level, xMod, yMod);
                var url = source.getTileUrl(level, xMod, yMod);
                
                // also adjust bounds to support wrapping.
                bounds.x += 1.0 * (x - xMod) / numTilesX;
                bounds.y += normHeight * (y - yMod) / numTilesY;
                
                tilesMatrix[level][x][y] = new Tile(level, x, y, bounds, exists, url);
            }
            
            var tile = tilesMatrix[level][x][y];
            
            // mark tile as touched so we don't reset it too soon
            tile.lastTouchTime = time;
            
            return tile;
        }
        
        function loadTile(tile, time) {
            imageLoader.loadImage(tile,
                    SeadragonUtils.createCallback(null, onTileLoad, tile, time));
        }
        
        function onTileLoad(tile, time, image) {
            tile.loading = false;
            
            if (midUpdate) {
                SeadragonDebug.error("Tile load callback in middle of drawing routine.");
                return;
            } else if (!image) {
                SeadragonDebug.log("Tile " + tile + " failed to load: " + tile.url);
                tile.exists = false;
                return;
            }
            //else if (time < lastResetTime) {
            //    SeadragonDebug.log("Ignoring tile " + tile + " loaded before reset: " + tile.url);
            //    return;
            //}
            
            tile.image = image;
            tile.loaded = true;
            
            var insertionIndex = tilesLoaded.length;
            
            if (tilesLoaded.length >= QUOTA) {
                var cutoff = Math.ceil(Math.log(tileSize) / Math.log(2));
                    // don't delete any single-tile levels. this takes priority.
                
                var worstTile = null;
                var worstTileIndex = -1;
                
                for (var i = tilesLoaded.length - 1; i >= 0; i--) {
                    var prevTile = tilesLoaded[i];
                    
                    if (prevTile.level <= cutoff || prevTile.beingDrawn) {
                        continue;
                    } else if (!worstTile) {
                        worstTile = prevTile;
                        worstTileIndex = i;
                        continue;
                    }
                    
                    var prevTime = prevTile.lastTouchTime;
                    var worstTime = worstTile.lastTouchTime;
                    var prevLevel = prevTile.level;
                    var worstLevel = worstTile.level;
                    
                    if (prevTime < worstTime ||
                            (prevTime === worstTime && prevLevel > worstLevel)) {
                        worstTile = prevTile;
                        worstTileIndex = i;
                    }
                }
                
                if (worstTile && worstTileIndex >= 0) {
                    worstTile.unload();
                    insertionIndex = worstTileIndex;
                    // note: we don't want or need to delete the actual Tile
                    // object from tilesMatrix; that's negligible memory.
                }
            }
            
            tilesLoaded[insertionIndex] = tile;
            updateAgain = true;
        }
        
        function clearTiles() {
            tilesMatrix = {};
            tilesLoaded = [];
        }
        
        // Helpers -- COVERAGE
        
        // Coverage scheme: it's required that in the draw routine, coverage for
        // every tile within the viewport is initially explicitly set to false.
        // This way, if a given level's coverage has been initialized, and a tile
        // isn't found, it means it's offscreen and thus provides coverage (since
        // there's no content needed to be covered). And if every tile that is found
        // does provide coverage, the entire visible level provides coverage.
        
        /**
         * Returns true if the given tile provides coverage to lower-level tiles of
         * lower resolution representing the same content. If neither x nor y is
         * given, returns true if the entire visible level provides coverage.
         * 
         * Note that out-of-bounds tiles provide coverage in this sense, since
         * there's no content that they would need to cover. Tiles at non-existent
         * levels that are within the image bounds, however, do not.
         */
        function providesCoverage(level, x, y) {
            if (!coverage[level]) {
                return false;
            }
            
            if (x === undefined || y === undefined) {
                // check that every visible tile provides coverage.
                // update: protecting against properties added to the Object
                // class's prototype, which can definitely (and does) happen.
                var rows = coverage[level];
                for (var i in rows) {
                    if (rows.hasOwnProperty(i)) {
                        var cols = rows[i];
                        for (var j in cols) {
                            if (cols.hasOwnProperty(j) && !cols[j]) {
                               return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            return (coverage[level][x] === undefined ||
                    coverage[level][x][y] === undefined ||
                    coverage[level][x][y] === true);
        }
        
        /**
         * Returns true if the given tile is completely covered by higher-level
         * tiles of higher resolution representing the same content. If neither x
         * nor y is given, returns true if the entire visible level is covered.
         */
        function isCovered(level, x, y) {
            if (x === undefined || y === undefined) {
                return providesCoverage(level+1);
            } else {
                return (providesCoverage(level+1, 2*x, 2*y) &&
                        providesCoverage(level+1, 2*x, 2*y + 1) &&
                        providesCoverage(level+1, 2*x + 1, 2*y) &&
                        providesCoverage(level+1, 2*x + 1, 2*y + 1));
            }
        }
        
        /**
         * Sets whether the given tile provides coverage or not.
         */
        function setCoverage(level, x, y, covers) {
            if (!coverage[level]) {
                SeadragonDebug.error("Setting coverage for a tile before its " +
                        "level's coverage has been reset: " + level);
                return;
            }
            
            if (!coverage[level][x]) {
                coverage[level][x] = {};
            }
            
            coverage[level][x][y] = covers;
        }
        
        /**
         * Resets coverage information for the given level. This should be called
         * after every draw routine. Note that at the beginning of the next draw
         * routine, coverage for every visible tile should be explicitly set. 
         */
        function resetCoverage(level) {
            coverage[level] = {};
        }
        
        // Helpers -- SCORING
        
        function compareTiles(prevBest, tile) {
            // figure out if this tile is better than the previous best tile...
            // note that if there is no prevBest, this is automatically better.
            if (!prevBest) {
                return tile;
            }
            
            if (tile.visibility > prevBest.visibility) {
                return tile;
            } else if (tile.visibility === prevBest.visibility) {
                if (tile.distance < prevBest.distance) {
                    return tile;
                }
            }
            
            return prevBest;
        }
        
        function sortTiles(a, b) {
            // helper, can be used in Array.sort to sort array of tiles
            if (a.visibility > b.visibility) {
                return -1;
            } else if (a.visibility < b.visibility) {
                return 1;
            } else { // equal
                if (a.distance < b.distance) {
                    return -1;
                } else if (a.distance > b.distance) {
                    return 1;
                }
            }

            return 0;
        }

        // Helpers -- OVERLAYS
        
        function getOverlayIndex(elmt) {
            for (var i = overlays.length - 1; i >= 0; i--) {
                if (overlays[i].elmt === elmt) {
                    return i;
                }
            }
            
            return -1;
        }
        
        // Helpers -- CORE
        /**
         * What do I need to return?
         * _lastUpdated is instance var
         * need list to load - can just load here...?
         */
        function updateTiles(fullDownload) {
            // make local references to variables & functions referenced in
            // loops in order to improve perf

            // the tiles that were drawn last frame, but won't be this frame,
            // can be cleared from the cache, so they should be marked as such.
			var i;
            for (i = 0; i < lastDrawn.length; i++) {
                lastDrawn[i].beingDrawn = false;
                lastDrawn[i].covered = false;
            }
            lastDrawn = [];
            var _lastDrawn = lastDrawn;
            imageLoader.clear();

            // if viewport is off image entirely, don't bother drawing.
            // UPDATE: logic modified to support horizontal/vertical wrapping.
            var viewportBounds = viewport.getBounds(true);
            if (isNaN(viewportBounds.x)) {
                viewport.goHome(true);
                viewportBounds = viewport.getBounds(true);
            }
            var viewportTL = viewportBounds.getTopLeft();
            var viewportBR = viewportBounds.getBottomRight();
            var wrapHorizontal = SeadragonConfig.wrapHorizontal;
            var wrapVertical = SeadragonConfig.wrapVertical;
            if (!wrapHorizontal &&
                    (viewportBR.x < 0 || viewportTL.x > 1)) {
                // we're not wrapping horizontally, and viewport is off in x
                return;
            } else if (!wrapVertical &&
                    (viewportBR.y < 0 || viewportTL.y > normHeight)) {
                // we're not wrapping vertically, and viewport is off in y
                return;
            }

            // the below section is commented out because it's more relevant to
            // collections, where you don't want 10 items to all load their xml
            // at the same time when 9 of them won't be in the viewport soon.

            //            // but even if the viewport is currently on the image, don't force
            //            // tiles to load if the viewport target is off the image
            //            var viewportTargetBounds = getViewportBounds(false);
            //            var viewportTargetTL = viewportTargetBounds.getTopLeft();
            //            var viewportTargetBR = viewportTargetBounds.getBottomRight();
            //            var willBeOff = viewportTargetBR.x < 0 || viewportTargetBR.y < 0 ||
            //                    viewportTargetTL.x > 1 || viewportTargetTL.y > normHeight;

            // make local references to functions and variables used in loops to
            // improve perf
            var _getNumTiles = getNumTiles;
            var _getPixelRatio = getPixelRatio;
            var _getTile = getTile;
            var _isCovered = isCovered;
            var _setCoverage = setCoverage;
            var _resetCoverage = resetCoverage;
            var _providesCoverage = providesCoverage;
            var _tileOverlap = tileOverlap;
            var _lastFrameTime = lastFrameTime;
            var isChrome = (browser === SeadragonBrowser.CHROME);
            // same for Math functions
            var _abs = Math.abs;
            var _floor = Math.floor;
            var _log = Math.log;
            var _max = Math.max;
            var _min = Math.min;
            // and Viewport functions
            var _deltaPixelsFromPoints = viewport.deltaPixelsFromPoints;
            var _pixelFromPoint = viewport.pixelFromPoint;
            // and TileSource functions
            var _getTileAtPoint = source.getTileAtPoint;
            // and Config properties
            var immediateRender = SeadragonConfig.immediateRender;
            var minDimension = SeadragonConfig.minZoomDimension || 64; // for backwards compatibility

            // restrain bounds of viewport relative to image.
            // UPDATE: logic modified to support horizontal/vertical wrapping.
            if (!wrapHorizontal) {
                viewportTL.x = _max(viewportTL.x, 0);
                viewportBR.x = _min(viewportBR.x, 1);
            }
            if (!wrapVertical) {
                viewportTL.y = _max(viewportTL.y, 0);
                viewportBR.y = _min(viewportBR.y, normHeight);
            }

            var currentTime = Date.now();

            // calculate values for scoring -- this is based on TARGET values
            var viewportCenterPoint = viewport.getCenter();
            var viewportCenterPixel = _pixelFromPoint(viewportCenterPoint);
            var zeroRatioT = _deltaPixelsFromPoints(_getPixelRatio(0), false).x;
            var optimalPixelRatio = immediateRender ? 1 : zeroRatioT;

            // adjust levels to iterate over -- this is based on CURRENT values
            // TODO change this logic to use minImageRatio, but for backwards
            // compatibility, use minDimension if it's been explicitly set.
            // TEMP for now, original minDimension logic with default 64.
            //minDimension = minDimension || 64;
            var minPixelRatio = (viewport.getZoom(true) < 0.8) ? MIN_PIXEL_RATIO : 0.5;
            var zeroRatioC = _deltaPixelsFromPoints(_getPixelRatio(0), true).x;
            var highestLevel = _min(maxLevel,
                    _floor(_log(zeroRatioC / minPixelRatio) / _log(2)));
            var lowestLevel = _max(minLevel, _floor(_log(minDimension) / _log(2)));
            lowestLevel = _min(lowestLevel, highestLevel); // with very small images, this edge case can occur...

            // START loading tiles
            var loadQueue = [];
            var best = null;
            var haveDrawn = false;
            for (var level = highestLevel; level >= lowestLevel; level--) {
                var drawLevel = false;
                var renderPixelRatioC = _deltaPixelsFromPoints(
                        _getPixelRatio(level), true).x;     // note the .x!

                // if we haven't drawn yet, only draw level if tiles are big enough
                if ((!haveDrawn && renderPixelRatioC >= minPixelRatio) ||
                        level === lowestLevel) {
                    drawLevel = true;
                    haveDrawn = true;
                } else if (!haveDrawn) {
                    continue;
                }

                _resetCoverage(level);

                // calculate scores applicable to all tiles on this level --
                // note that we're basing visibility on the TARGET pixel ratio
                //var levelOpacity = _min(1, (renderPixelRatioC - 0.5) / 0.5);
                //var renderPixelRatioT = _deltaPixelsFromPoints(
                //        _getPixelRatio(level), false).x;
                //var levelVisibility = optimalPixelRatio /
                //        _abs(optimalPixelRatio - renderPixelRatioT);

                // only iterate over visible tiles
                var tileTL = _getTileAtPoint(level, viewportTL);
                var tileBR = _getTileAtPoint(level, viewportBR);
                var numTiles = _getNumTiles(level);
                var numTilesX = numTiles.x;
                var numTilesY = numTiles.y;
                if (!wrapHorizontal) {
                    tileBR.x = _min(tileBR.x, numTilesX - 1);
                }
                if (!wrapVertical) {
                    tileBR.y = _min(tileBR.y, numTilesY - 1);
                }

                // create and get tiles
                // iterate from center spiraling out
                var dx = 1,
                    dy = 0,
                    segmentLength = 1,
                    width = tileBR.x - tileTL.x,
                    height = tileBR.y - tileTL.y,
                    x = tileTL.x + Math.floor(width / 2),
                    y = tileTL.y + Math.floor(height / 2),
                    segmentPassed = 0,
                    numTiles = (width + 1) * (height + 1),
                    levelLoadQueue = [],
                    minx = Infinity,
                    maxx = -Infinity,
                    miny = Infinity,
                    maxy = -Infinity,
                    k,
                    buffer;

                for (k = 0; k < numTiles; k++) {

                    // update min and max
                    minx = Math.min(x, minx);
                    maxx = Math.max(x, maxx);
                    miny = Math.min(y, miny);
                    maxy = Math.max(y, maxy);

                    // load tile
                    var tile = _getTile(level, x, y, currentTime, numTilesX, numTilesY);
                    var drawTile = drawLevel;

                    // assume this tile doesn't cover initially
                    _setCoverage(level, x, y, false);

                    // check not part of sparse image, or failed to load
                    if (tile.exists) {
                        // if we've drawn a higher-resolution level and we're not
                        // going to draw this level, then say this tile does cover
                        // if it's covered by higher-resolution tiles. if we're not
                        // covered, then we should draw this tile regardless.
                        if (haveDrawn && !drawTile) {
                            if (_isCovered(level, x, y)) {
                                _setCoverage(level, x, y, true);
                            } else {
                                drawTile = true;
                            }
                        }

                        if (drawTile) {
                            // calculate tile's position and size in pixels
                            var boundsTL = tile.bounds.getTopLeft();
                            var boundsSize = tile.bounds.getSize();
                            var positionC = _pixelFromPoint(boundsTL, true);
                            var sizeC = _deltaPixelsFromPoints(boundsSize, true);

                            // if there is no tile overlap, we need to oversize the
                            // tiles by 1px to prevent seams at imperfect zooms.
                            // fortunately, this is not an issue with regular dzi's
                            // created from Deep Zoom Composer, which uses overlap.
                            if (!_tileOverlap) {
                                sizeC = sizeC.plus(new SeadragonPoint(1, 1));
                            }

                            // update tile's scores and values
                            tile.position = positionC;
                            tile.size = sizeC;

                            // push
                            _lastDrawn.push(tile);
                            if (!tile.loaded && !tile.loading) {
                                levelLoadQueue.push(tile);
                            }
                        }
                    }

                    

                    // make a step
                    x += dx;
                    y += dy;
                    segmentPassed++;

                    var flipIter = 0;
                    while (!(tileTL.x <= x && x <= tileBR.x &&
                            tileTL.y <= y && y <= tileBR.y)) {
                        
                        flipIter++;
                        if (flipIter >= 4) {
                            //console.log('flipped all');
                            break;
                        }
                        segmentPassed = 0;

                        if (x < tileTL.x) {
                            x = tileTL.x;
                            y = miny - 1;
                            dx = 1;
                            dy = 0;
                            segmentLength = Math.max(1, maxx - tileTL.x + 1);
                        } else if (y > tileBR.y) {
                            x = minx - 1;
                            y = tileBR.y;
                            dx = 0;
                            dy = -1;
                            segmentLength = Math.max(1, tileBR.y - miny + 1);
                        } else if (x > tileBR.x) {
                            x = tileBR.x;
                            y = maxy + 1;
                            dx = -1;
                            dy = 0;
                            segmentLength = Math.max(1, tileBR.x - minx + 1);
                        } else if (y < tileTL.y) {
                            x = maxx + 1;
                            y = tileTL.y;
                            dx = 0;
                            dy = 1;
                            segmentLength = Math.max(1, maxy - tileTL.y + 1);
                        }
                    }
                    
                    // rotate?
                    if (segmentPassed === segmentLength) {
                        segmentPassed = 0;
                        buffer = dx;
                        dx = -dy;
                        dy = buffer;

                        // increase length if necessary
                        if (dy === 0) {
                            segmentLength++;
                        }
                    }
                }
                if (levelLoadQueue.length > 0) {
                    loadQueue.push(levelLoadQueue);
                }
            }
            // Finish picking tiles

            // now load (in reverse order)
            var currLevel;
            if (fullDownload) {
                for (i = (loadQueue.length - 1); i >= 0; i--) {
                    currLevel = loadQueue[i];
                    currLevel.map(loadTile);
                }
            } else if (loadQueue.length > 0) {
                currLevel = loadQueue[loadQueue.length-1];
                loadTile(currLevel[0], 10);
            }
        }

        function updateDraw() {
            // now draw the tiles, but in reverse order since we want higher-res
            // tiles to be drawn on top of lower-res ones. also mark each tile
            // as being drawn so it won't get cleared from the cache.
            var i, tile, deltaTime, opacity,
                _canvas = canvas,
                _context = context,
                alwaysBlend = SeadragonConfig.alwaysBlend,
                blendTimeMillis = 1000 * SeadragonConfig.blendTime,
                _useCanvas = useCanvas,
                _lastDrawn = lastDrawn,
                _setCoverage = setCoverage,
                _deltaPixelsFromPoints = viewport.deltaPixelsFromPoints,
                _pixelFromPoint = viewport.pixelFromPoint,
                viewportSize = viewport.getContainerSize(),
                viewportWidth = viewportSize.x,
                viewportHeight = viewportSize.y,
                _min = Math.min,
                _floor = Math.floor,
                currentTime = Date.now(),
                wrapOverlays = SeadragonConfig.wrapOverlays,
                wrapHorizontal = SeadragonConfig.wrapHorizontal,
                wrapVertical = SeadragonConfig.wrapVertical;

            updateAgain = false;

            // clear canvas, whether in <canvas> mode or HTML mode.
            // this is important as scene may be empty this frame.
            if (_useCanvas) {
                _canvas.width = viewportWidth;
                _canvas.height = viewportHeight;
                //_context.clearRect(0, 0, viewportWidth, viewportHeight);
                // this last line shouldn't be needed. setting the width and
                // height should clear <canvas>, but Firefox doesn't always.
            } else {
                _canvas.innerHTML = "";
            }

            for (i = _lastDrawn.length - 1; i >= 0; i--) {
                tile = _lastDrawn[i];

                // draw it!
                if (tile.covered || isCovered(tile.level, tile.x, tile.y)) {
                    // remove from list to draw
                    // no need to adjust i since counting down
                    //_lastDrawn.splice(i, 1); too slow
                    tile.covered = true;
                } else if (tile.loaded) {
                    // update opacity
                    if (tile.opacity < 1) {
                        if (!tile.blendStart) {
                            // image was just added, blend it
                            tile.blendStart = currentTime;
                        }

                        deltaTime = currentTime - tile.blendStart;
                        opacity = (blendTimeMillis === 0) ? 1 :
                            _min(1, deltaTime / blendTimeMillis);

                        tile.opacity = opacity;
                    }
                    // effects of opacity
                    if (tile.opacity >= 1) {
                        _setCoverage(tile.level, tile.x, tile.y, true);

                        // workaround for chrome's weird flickering issue
                        //if (isChrome && tile.lastDrawnTime !== _lastFrameTime) {
                        //    _setCoverage(tile.level, tile.x, tile.y, false);
                        //}
                    } else {
                        updateAgain = true;
                    }

                    if (_useCanvas) {
                        tile.drawCanvas(_context);
                    } else {
                        tile.drawHTML(_canvas);
                    }

                    tile.beingDrawn = true;
                } else if (tile.exists) {
                    updateAgain = true;
                }
            }

            // draw the overlays -- TODO optimize based on viewport like tiles,
            // but this is tricky for non-scaling overlays like pins...
            var overlay, bounds, overlayTL;
            for (i = 0; i < overlays.length; i++) {
                overlay = overlays[i];
                bounds = overlay.bounds;
                overlayTL = bounds.getTopLeft();    // in normalized coords

                // wrap overlays if specified
                if (wrapOverlays && wrapHorizontal) {
                    // TEMP this isn't perfect, e.g. view center is at -2.1 and
                    // overlay is at 0.1, this will use -2.9 instead of -1.9.
                    overlayTL.x += _floor(viewportCenterPoint.x);
                }
                if (wrapOverlays && wrapVertical) {
                    // TODO wrap overlays vertically
                }

                overlay.position = _pixelFromPoint(overlayTL, true);
                overlay.size = _deltaPixelsFromPoints(bounds.getSize(), true);

                overlay.drawHTML(container);
            }

            // new: save this frame's timestamp to enable comparing times
            lastFrameTime = currentTime;
        }

        // Methods -- OVERLAYS
        
        this.addOverlay = function(elmt, loc, placement) {
            elmt = SeadragonUtils.getElement(elmt);
            
            if (getOverlayIndex(elmt) >= 0) {
                return;     // they're trying to add a duplicate overlay
            }
            
            overlays.push(new Overlay(elmt, loc, placement));
            updateAgain = true;
            viewer.scheduleUpdate();
        };
        
        this.updateOverlay = function(elmt, loc, placement) {
            elmt = SeadragonUtils.getElement(elmt);
            var i = getOverlayIndex(elmt);
            
            if (i >= 0) {
                overlays[i].update(loc, placement);
                updateAgain = true;
                viewer.scheduleUpdate();
            }
        };
       
        this.removeOverlay = function(elmt) {
            elmt = SeadragonUtils.getElement(elmt);
            var i = getOverlayIndex(elmt);
            
            if (i >= 0) {
                overlays[i].destroy();
                overlays.splice(i, 1);
                updateAgain = true;     // TODO do we really need this?
                viewer.scheduleUpdate();
            }
        };
        
        this.clearOverlays = function() {
            while (overlays.length > 0) {
                overlays.pop().destroy();
                updateAgain = true;     // TODO do we really need this?
                viewer.scheduleUpdate();
                                        // TODO it also doesn't need to be in the loop.
            }
        };
        
        // Methods -- CORE
        
        this.needsUpdate = function() {
            return updateAgain;
        };
        
        this.numTilesLoaded = function() {
            return tilesLoaded.length;
        };
        
        this.reset = function() {
            clearTiles();
            lastResetTime = Date.now();
            updateAgain = true;
        };
        
        this.update = function (fullUpdate, fullDownload) {
            midUpdate = true;
            if (fullUpdate) {
                updateTiles(fullDownload);
            }
            updateDraw();
            midUpdate = false;
        };
    
        this.idle = function() {
            // TODO idling function
        };
        
    };
    
})();

;
//  This code is distributed under the included license agreement, also
//  available here: http://go.microsoft.com/fwlink/?LinkId=164943

var SeadragonViewer,
    SeadragonControlAnchor;

(function () {

    // Constants

    var SIGNAL = "----seadragon----";

    // Private static

    var browser = SeadragonUtils.getBrowser();

    // Controls

    SeadragonControlAnchor = Seadragon.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4
    };

    /**
     * Adds the given element to the given container based on the given anchor,
     * such that all new elements anchored to a right edge are shown to the left
     * of existing elements anchored to the same edge.
     */
    function addToAnchor(elmt, anchor, container) {
        if (anchor === SeadragonControlAnchor.TOP_RIGHT || anchor === SeadragonControlAnchor.BOTTOM_RIGHT) {
            container.insertBefore(elmt, container.firstChild);
        } else {
            container.appendChild(elmt);
        }
    }

    function Control(elmt, anchor, container) {
        // Fields
        var wrapper = SeadragonUtils.makeNeutralElement("span");

        // Properties
        this.elmt = elmt;
        this.anchor = anchor;
        this.container = container;
        this.wrapper = wrapper;

        // Constructor
        wrapper.style.display = "inline-block";
        wrapper.appendChild(elmt);
        if (anchor === SeadragonControlAnchor.NONE) {
            wrapper.style.width = wrapper.style.height = "100%";    // IE6 fix
        }

        addToAnchor(wrapper, anchor, container);
    }

    Control.prototype.destroy = function () {
        this.wrapper.removeChild(this.elmt);
        this.container.removeChild(this.wrapper);
    };

    Control.prototype.isVisible = function () {
        // see note in setVisible() below about using "display: none"
        return this.wrapper.style.display !== "none";
    };

    Control.prototype.setVisible = function (visible) {
        // using "display: none" instead of "visibility: hidden" so that mouse
        // events are no longer blocked by this invisible control.
        this.wrapper.style.display = visible ? "inline-block" : "none";
    };

    Control.prototype.setOpacity = function (opacity) {
        // like with setVisible() above, we really should be working with the
        // wrapper element and not the passed in element directly, so that we
        // don't conflict with the developer's own opacity settings. but this
        // doesn't work in IE always, so for our controls, use a hack for now...
        if (this.elmt[SIGNAL] && browser === SeadragonBrowser.IE) {
            SeadragonUtils.setElementOpacity(this.elmt, opacity, true);
        } else {
            SeadragonUtils.setElementOpacity(this.wrapper, opacity, true);
        }
    };

    // Navigation control

    var FULL_PAGE = "fullpage";
    var HOME = "home";
    var ZOOM_IN = "zoomin";
    var ZOOM_OUT = "zoomout";

    var REST = "_rest.png";
    var GROUP = "_grouphover.png";
    var HOVER = "_hover.png";
    var DOWN = "_pressed.png";

    function makeNavControl(viewer) {
        var group = null;
        var zooming = false;    // whether we should be continuously zooming
        var zoomFactor = null;  // how much we should be continuously zooming by
        var lastZoomTime = null;

        function onHome() {
            if (viewer.viewport) {
                viewer.viewport.goHome();
            }
        }

        function onFullPage() {
            viewer.setFullPage(!viewer.isFullPage());
            group.emulateExit();  // correct for no mouseout event on change

            if (viewer.viewport) {
                viewer.viewport.applyConstraints();
            }
        }

        function beginZoomingIn() {
            lastZoomTime = Date.now();
            zoomFactor = SeadragonConfig.zoomPerSecond;
            zooming = true;
            scheduleZoom();
        }

        function beginZoomingOut() {
            lastZoomTime = Date.now();
            zoomFactor = 1.0 / SeadragonConfig.zoomPerSecond;
            zooming = true;
            scheduleZoom();
        }

        function endZooming() {
            zooming = false;
        }

        function scheduleZoom() {
            window.setTimeout(doZoom, 10);
        }

        function doZoom() {
            if (zooming && viewer.viewport) {
                var currentTime = Date.now();
                var deltaTime = currentTime - lastZoomTime;
                var adjustedFactor = Math.pow(zoomFactor, deltaTime / 1000);

                viewer.viewport.zoomBy(adjustedFactor);
                viewer.viewport.applyConstraints();
                lastZoomTime = currentTime;
                scheduleZoom();
            }
        }

        function doSingleZoomIn() {
            if (viewer.viewport) {
                zooming = false;
                viewer.viewport.zoomBy(SeadragonConfig.zoomPerClick / 1.0);
                viewer.viewport.applyConstraints();
            }
        }

        function doSingleZoomOut() {
            if (viewer.viewport) {
                zooming = false;
                viewer.viewport.zoomBy(1.0 / SeadragonConfig.zoomPerClick);
                viewer.viewport.applyConstraints();
            }
        }

        function lightUp() {
            group.emulateEnter();
            group.emulateExit();
        }

        function url(prefix, postfix) {
            return SeadragonConfig.imagePath + prefix + postfix;
        }

        var zoomIn = new SeadragonButton(SeadragonStrings.getString("Tooltips.ZoomIn"),
                url(ZOOM_IN, REST), url(ZOOM_IN, GROUP), url(ZOOM_IN, HOVER),
                url(ZOOM_IN, DOWN), beginZoomingIn, endZooming, doSingleZoomIn,
                beginZoomingIn, endZooming);

        var zoomOut = new SeadragonButton(SeadragonStrings.getString("Tooltips.ZoomOut"),
                url(ZOOM_OUT, REST), url(ZOOM_OUT, GROUP), url(ZOOM_OUT, HOVER),
                url(ZOOM_OUT, DOWN), beginZoomingOut, endZooming, doSingleZoomOut,
                beginZoomingOut, endZooming);

        var goHome = new SeadragonButton(SeadragonStrings.getString("Tooltips.Home"),
                url(HOME, REST), url(HOME, GROUP), url(HOME, HOVER),
                url(HOME, DOWN), null, onHome, null, null, null);

        var fullPage = new SeadragonButton(SeadragonStrings.getString("Tooltips.FullPage"),
                url(FULL_PAGE, REST), url(FULL_PAGE, GROUP), url(FULL_PAGE, HOVER),
                url(FULL_PAGE, DOWN), null, onFullPage, null, null, null);

        group = new SeadragonButtonGroup([zoomIn, zoomOut, goHome, fullPage]);
        group.elmt[SIGNAL] = true;   // hack to get our controls to fade

        viewer.addEventListener("open", lightUp);

        return group.elmt;
    }

    // Viewer
    // TAG: added ignore constraints to ignore constraints for mouse in authoring mode of RIN
    SeadragonViewer = Seadragon.Viewer = function (container, ignoreConstraints) {

        // hack to decrease bounds so image doesn't disappear
        if (ignoreConstraints) {
            //Seadragon.Config.minZoomDimension = null;
            Seadragon.Config.minZoomImageRatio = 0.1;
            //Seadragon.Config.maxZoomPixelRatio = 10;
            ////Seadragon.Config.visibilityRatio = 0.8;
        } else {
            Seadragon.Config.minZoomImageRatio = 0.8;
        }

        // Fields

        var self = this;

        var parent = SeadragonUtils.getElement(container);
        container = SeadragonUtils.makeNeutralElement("div");
        self.container = container;
        var canvas = SeadragonUtils.makeNeutralElement("div");
        self.canvas = canvas;

        var controlsTL = SeadragonUtils.makeNeutralElement("div");
        var controlsTR = SeadragonUtils.makeNeutralElement("div");
        var controlsBR = SeadragonUtils.makeNeutralElement("div");
        var controlsBL = SeadragonUtils.makeNeutralElement("div");

        var source = null;
        var drawer = null;
        var viewport = null;
        var profiler = null;

        var eventManager = new SeadragonEventManager();
        var innerTracker = new SeadragonMouseTracker(canvas);
        var outerTracker = new SeadragonMouseTracker(container);

        var controls = [];
        //var controlsShouldFade = true;
        //var controlsFadeBeginTime = null;
        var navControl = null;

        var controlsFadeDelay = 1000;   // begin fading after 1 second
        var controlsFadeLength = 2000;  // fade over 2 second period
        var controlsFadeBeginTime = null;
        var controlsShouldFade = false;

        var bodyWidth = document.body.style.width;
        var bodyHeight = document.body.style.height;
        var bodyOverflow = document.body.style.overflow;
        var docOverflow = document.documentElement.style.overflow;

        var fsBoundsDelta = new SeadragonPoint(1, 1);
        var prevContainerSize = null;

        var lastOpenStartTime = 0;
        var lastOpenEndTime = 0;

        var mouseDownPixel = null;
        var mouseDownCenter = null;

        var animating = false;
        var forceRedraw = false;
        var mouseInside = false;

        // Properties

        this.container = parent;
        this.elmt = container;

        this.source = null;
        this.drawer = null;
        this.viewport = null;
        this.profiler = null;

        this.tracker = innerTracker;

        self.loopId = null;

        var requestAnimationFrame =
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function(callback) {
                var currTime = Date.now();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                  timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            }

        var cancelAnimationFrame =
            window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.mozCanelAnimationFrame ||
            window.oCancelAnimationFrame ||
            window.msCancelAnimationFrame ||
            function (id) {
                clearTimeout(id);
            };

        // Helpers -- UI

        function initialize() {
            // copy style objects to improve perf
            var canvasStyle = canvas.style;
            var containerStyle = container.style;
            var controlsTLStyle = controlsTL.style;
            var controlsTRStyle = controlsTR.style;
            var controlsBRStyle = controlsBR.style;
            var controlsBLStyle = controlsBL.style;

            containerStyle.width = "100%";
            containerStyle.height = "100%";
            containerStyle.position = "relative";
            containerStyle.left = "0px";
            containerStyle.top = "0px";
            containerStyle.textAlign = "left";  // needed to protect against
            // incorrect centering

            canvasStyle.width = "100%";
            canvasStyle.height = "100%";
            canvasStyle.overflow = "hidden";
            canvasStyle.position = "absolute";
            canvasStyle.top = "0px";
            canvasStyle.left = "0px";

            controlsTLStyle.position = controlsTRStyle.position =
                    controlsBRStyle.position = controlsBLStyle.position =
                    "absolute";

            controlsTLStyle.top = controlsTRStyle.top = "0px";
            controlsTLStyle.left = controlsBLStyle.left = "0px";
            controlsTRStyle.right = controlsBRStyle.right = "0px";
            controlsBLStyle.bottom = controlsBRStyle.bottom = "0px";

            // mouse tracker handler for canvas (pan and zoom)

            
            innerTracker.clickHandler = onCanvasClick;
            innerTracker.pressHandler = onCanvasPress;
            innerTracker.dragHandler = onCanvasDrag;
            innerTracker.releaseHandler = onCanvasRelease;
            innerTracker.scrollHandler = onCanvasScroll;
            innerTracker.setTracking(true);     // default state
            
            // create default navigation control
            navControl = makeNavControl(self);
            navControl.style.marginRight = "4px";
            navControl.style.marginBottom = "4px";
            self.addControl(navControl, SeadragonControlAnchor.BOTTOM_RIGHT);

            // mouse tracker handler for container (controls fading)
            
            outerTracker.enterHandler = onContainerEnter;
            outerTracker.exitHandler = onContainerExit;
            outerTracker.releaseHandler = onContainerRelease;
            outerTracker.setTracking(true); // always tracking
            window.setTimeout(beginControlsAutoHide, 1);    // initial fade out
            

            //append to DOM only at end
            container.appendChild(canvas);
            container.appendChild(controlsTL);
            container.appendChild(controlsTR);
            container.appendChild(controlsBR);
            container.appendChild(controlsBL);
            parent.innerHTML = "";          // clear any existing content...
            parent.appendChild(container);  // ...then add the real container
        }

        function setMessage(message) {
            var textNode = document.createTextNode(message);

            canvas.innerHTML = "";
            canvas.appendChild(document.createElement('div'));
            //canvas.appendChild(SeadragonUtils.makeCenteredNode(textNode));

            /*var textStyle = textNode.parentNode.style;

            // explicit styles for error message
            //textStyle.color = "white";    // TEMP uncommenting this; very obtrusive
            textStyle.fontFamily = "verdana";
            textStyle.fontSize = "13px";
            textStyle.fontSizeAdjust = "none";
            textStyle.fontStyle = "normal";
            textStyle.fontStretch = "normal";
            textStyle.fontVariant = "normal";
            textStyle.fontWeight = "normal";
            textStyle.lineHeight = "1em";
            textStyle.textAlign = "center";
            textStyle.textDecoration = "none";*/
        }

        // Helpers -- CORE

        function beforeOpen() {
            if (source) {
                onClose();
            }

            lastOpenStartTime = Date.now();   // to ignore earlier opens

            // show loading message after a delay if it still hasn't loaded
            window.setTimeout(function () {
                if (lastOpenStartTime > lastOpenEndTime) {
                    setMessage(SeadragonStrings.getString("Messages.Loading"));
                }
            }, 2000);

            return lastOpenStartTime;
        }

        function onOpen(time, _source, error) {
            lastOpenEndTime = Date.now();

            if (time < lastOpenStartTime) {
                SeadragonDebug.log("Ignoring out-of-date open.");
                eventManager.trigger("ignore", self);
                return;
            } else if (!_source) {
                setMessage(error);
                eventManager.trigger("error", self);
                return;
            }

            // clear any previous message
            canvas.innerHTML = "";
            prevContainerSize = SeadragonUtils.getElementSize(container);

            // UPDATE: if the container is collapsed, we should delay opening
            // since we don't know yet what the home zoom should be, so opening
            // when the container gets layout will allow us to gracefully and
            // correctly start at home. this also prevents viewport NaN values.
            // what timeout value should we use? it's arbitrary, but given that
            // this generally only occurs in embed scenarios where the image is
            // opened before the page has even finished loading, we'll use very
            // small timeout values to be crisp and responsive. note that this
            // polling is necessary; there is no good cross-browser event here.
            if (prevContainerSize.x === 0 || prevContainerSize.y === 0) {
                window.setTimeout(function () {
                    onOpen(time, _source, error);
                }, 10);
                return;
            }

            // assign fields
            source = _source;
            viewport = new SeadragonViewport(prevContainerSize, source.dimensions, self);
            drawer = new SeadragonDrawer(source, viewport, canvas, self, ignoreConstraints);
            profiler = new SeadragonProfiler();

            // assign properties
            self.source = source;
            self.viewport = viewport;
            self.drawer = drawer;
            self.profiler = profiler;

            // begin updating
            animating = false;
            forceRedraw = true;
            eventManager.trigger("open", self);
            if (!self.loopId) self.loopId = requestAnimationFrame(updateOnce);
            //scheduleUpdate(updateMulti);
        }

        function onClose() {
            // TODO need destroy() methods to prevent leaks? check for null if so.

            // nullify fields and properties
            self.source = source = null;
            self.viewport = viewport = null;
            self.drawer = drawer = null;
            self.profiler = profiler = null;

            // clear all tiles and any message
            canvas.innerHTML = "";
        }

        /**
         * Schedules a complete redraw of the image
         */
        function scheduleUpdate() {
            if (!self.loopId) {
                self.loopId = requestAnimationFrame(updateOnce);
            }
            forceRedraw = true;
        }
        this.scheduleUpdate = scheduleUpdate;

        function updateOnce() {
            self.loopId = requestAnimationFrame(updateOnce);

            if (!source) {
                return;
            }

            var containerSize = SeadragonUtils.getElementSize(container);

            // UPDATE: don't break if the viewer was collapsed or hidden!
            // in that case, go ahead still update normally as we were before,
            // but don't notify the viewport of the resize! prevents NaN bug.
            if (!containerSize.equals(prevContainerSize) &&
                    containerSize.x > 0 && containerSize.y > 0) {
                viewport.resize(containerSize, true); // maintain image position
                prevContainerSize = containerSize;
                eventManager.trigger("resize", self);
            }

            var animated = viewport.update();
            var animEnd = animating && !animated;

            if (!animating && animated) {
                // we weren't animating, and now we did ==> animation start
                eventManager.trigger("animationstart", self);
                abortControlsAutoHide();
            }

            if (animated) {
                // viewport moved
                drawer.update(true, false);
                eventManager.trigger("animation", self);
            } else if (forceRedraw || drawer.needsUpdate()) {
                // need to load or blend images, etc.
                var fullUpdate = animEnd || forceRedraw;
                drawer.update(fullUpdate, fullUpdate);
            }
            else {
                // no changes, so stop drawing
                cancelAnimationFrame(self.loopId);
                self.loopId = null;
            }

            if (animEnd) {
                // we were animating, and now we're not anymore ==> animation finish
                eventManager.trigger("animationfinish", self);

                // if the mouse has left the container, begin fading controls
                //if (!mouseInside) {
                //    beginControlsAutoHide();
                //}
            }

            animating = animated;
            forceRedraw = false;
        }

        // Controls

        function getControlIndex(elmt) {
            for (var i = controls.length - 1; i >= 0; i--) {
                if (controls[i].elmt === elmt) {
                    return i;
                }
            }

            return -1;
        }

        function scheduleControlsFade() {
            window.setTimeout(updateControlsFade, 20);
        }

        function updateControlsFade() {
            if (controlsShouldFade) {
                var currentTime = Date.now();
                var deltaTime = currentTime - controlsFadeBeginTime;
                var opacity = 1.0 - deltaTime / controlsFadeLength;

                opacity = Math.min(1.0, opacity);
                opacity = Math.max(0.0, opacity);

                for (var i = controls.length - 1; i >= 0; i--) {
                    controls[i].setOpacity(opacity);
                }

                if (opacity > 0) {
                    scheduleControlsFade();    // fade again
                }
            }
        }

        function abortControlsAutoHide() {
            controlsShouldFade = false;
            for (var i = controls.length - 1; i >= 0; i--) {
                controls[i].setOpacity(1.0);
            }
        }

        function beginControlsAutoHide() {
            if (!SeadragonConfig.autoHideControls) {
                return;
            }

            controlsShouldFade = true;
            controlsFadeBeginTime = Date.now() + controlsFadeDelay;
            window.setTimeout(scheduleControlsFade, controlsFadeDelay);
        }

        // Mouse interaction with container

        function onContainerEnter(tracker, position, buttonDownElmt, buttonDownAny) {
            mouseInside = true;
            abortControlsAutoHide();
        }

        function onContainerExit(tracker, position, buttonDownElmt, buttonDownAny) {
            // fade controls out over time, only if the mouse isn't down from
            // within the container (e.g. panning, or using a control)
            if (!buttonDownElmt) {
                mouseInside = false;
                if (!animating) {
                    //beginControlsAutoHide();
                }
            }
        }

        function onContainerRelease(tracker, position, insideElmtPress, insideElmtRelease) {
            // the mouse may have exited the container and we ignored it if the
            // mouse was down from within the container. now when the mouse is
            // released, we should fade the controls out now.
            if (!insideElmtRelease) {
                mouseInside = false;
                if (!animating) {
                    beginControlsAutoHide();
                }
            }
        }

        // Mouse interaction with canvas

        function onCanvasClick(tracker, position, quick, shift) {
            if (viewport && quick) {    // ignore clicks where mouse moved
                var zoomPerClick = SeadragonConfig.zoomPerClick;
                var factor = shift ? 1.0 / zoomPerClick : zoomPerClick;
                viewport.zoomBy(factor, viewport.pointFromPixel(position, true));
                //if (!ignoreConstraints) {
                    viewport.applyConstraints();
                //}
            }
        }

        function onCanvasPress(tracker, position) {
            if (viewport) {
                mouseDownPixel = position;
                mouseDownCenter = viewport.getCenter();
            }
        }

        function onCanvasDrag(tracker, position, delta, shift) {
            if (viewport) {
                // note that in both cases, we're negating delta pixels since
                // dragging is opposite of panning. analogy is adobe viewer,
                // dragging up scrolls down.
                if (SeadragonConfig.constrainDuringPan) {
                    var deltaPixels = position.minus(mouseDownPixel);
                    var deltaPoints = viewport.deltaPointsFromPixels(deltaPixels.negate(), true);
                    viewport.panTo(mouseDownCenter.plus(deltaPoints));
                    //if (!ignoreConstraints) {
                        viewport.applyConstraints();
                    //}
                } else {
                    viewport.panBy(viewport.deltaPointsFromPixels(delta.negate(), true));
                }
            }
        }

        function onCanvasRelease(tracker, position, insideElmtPress, insideElmtRelease) {
            if (insideElmtPress && viewport && !ignoreConstraints) {
                viewport.applyConstraints();
            }
        }

        function onCanvasScroll(tracker, position, delta, shift) {
            if (viewport) {
                var factor = Math.pow(SeadragonConfig.zoomPerScroll, delta);
                viewport.zoomBy(factor, viewport.pointFromPixel(position, true));
                //if (!ignoreConstraints) {
                    viewport.applyConstraints();
                //}
            }
        }

        // Keyboard interaction

        function onPageKeyDown(event) {
            event = SeadragonUtils.getEvent(event);
            if (event.keyCode === 27) {    // 27 means esc key
                self.setFullPage(false);
            }
        }

        // Methods -- IMAGE

        this.isOpen = function () {
            return !!source;
        };

        this.openDzi = function (xmlUrlOrJsonObj, xmlString) {
            var currentTime = beforeOpen();
            var callback = SeadragonUtils.createCallback(null, onOpen, currentTime);

            if (typeof(xmlUrlOrJsonObj) === 'string') {
                SeadragonDziTileSource.createFromXml(xmlUrlOrJsonObj, xmlString, callback);
            } else {
                SeadragonDziTileSource.createFromJson(xmlUrlOrJsonObj, callback);
            }
        };

        this.openTileSource = function (tileSource) {
            var currentTime = beforeOpen();
            window.setTimeout(function () {
                onOpen(currentTime, tileSource);
            }, 1);
        };

        this.close = function () {
            if (!source) {
                return;
            }

            onClose();
        };

        // Methods -- CONTROLS

        this.addControl = function (elmt, anchor) {
            elmt = SeadragonUtils.getElement(elmt);

            if (getControlIndex(elmt) >= 0) {
                return;     // they're trying to add a duplicate control
            }

            var div = null;

            switch (anchor) {
                case SeadragonControlAnchor.TOP_RIGHT:
                    div = controlsTR;
                    elmt.style.position = "relative";
                    break;
                case SeadragonControlAnchor.BOTTOM_RIGHT:
                    div = controlsBR;
                    elmt.style.position = "relative";
                    break;
                case SeadragonControlAnchor.BOTTOM_LEFT:
                    div = controlsBL;
                    elmt.style.position = "relative";
                    break;
                case SeadragonControlAnchor.TOP_LEFT:
                    div = controlsTL;
                    elmt.style.position = "relative";
                    break;
                case SeadragonControlAnchor.NONE:
                default:
                    div = container;
                    elmt.style.position = "absolute";
                    break;
            }

            controls.push(new Control(elmt, anchor, div));
        };

        this.removeControl = function (elmt) {
            elmt = SeadragonUtils.getElement(elmt);
            var i = getControlIndex(elmt);

            if (i >= 0) {
                controls[i].destroy();
                controls.splice(i, 1);
            }
        };

        this.clearControls = function () {
            while (controls.length > 0) {
                controls.pop().destroy();
            }
        };

        this.getNavControl = function () {
            return navControl;
        };

        // Methods -- UI

        this.isDashboardEnabled = function () {
            for (var i = controls.length - 1; i >= 0; i--) {
                if (controls[i].isVisible()) {
                    return true;
                }
            }

            return false;
        };

        this.isFullPage = function () {
            return container.parentNode === document.body;
        };

        this.isMouseNavEnabled = function () {
            return innerTracker.isTracking();
        };

        this.isVisible = function () {
            return container.style.visibility !== "hidden";
        };

        this.setDashboardEnabled = function (enabled) {
            for (var i = controls.length - 1; i >= 0; i--) {
                controls[i].setVisible(enabled);
            }
        };

        this.setFullPage = function (fullPage) {
            if (fullPage === self.isFullPage()) {
                return;
            }

            // copy locally to improve perf
            var body = document.body;
            var bodyStyle = body.style;
            var docStyle = document.documentElement.style;
            var containerStyle = container.style;
            var canvasStyle = canvas.style;

            if (fullPage) {
                // change overflow, but preserve what current values are
                bodyOverflow = bodyStyle.overflow;
                docOverflow = docStyle.overflow;
                bodyStyle.overflow = "hidden";
                docStyle.overflow = "hidden";

                // IE6 needs the body width/height to be 100% also
                bodyWidth = bodyStyle.width;
                bodyHeight = bodyStyle.height;
                bodyStyle.width = "100%";
                bodyStyle.height = "100%";

                // always show black background, etc., for fullpage
                canvasStyle.backgroundColor = "black";
                canvasStyle.color = "white";

                // make container attached to the window, immune to scrolling,
                // and above any other things with a z-index set.
                containerStyle.position = "fixed";
                containerStyle.zIndex = "99999999";

                body.appendChild(container);
                prevContainerSize = SeadragonUtils.getWindowSize();

                // add keyboard listener for esc key, to exit full page.
                // add it on document because browsers won't give an arbitrary
                // element (e.g. this viewer) keyboard focus, and adding it to
                // window doesn't work properly in IE.
                SeadragonUtils.addEvent(document, "keydown", onPageKeyDown);

                onContainerEnter();     // mouse will be inside container now
            } else {
                // restore previous values for overflow
                bodyStyle.overflow = bodyOverflow;
                docStyle.overflow = docOverflow;

                // IE6 needed to overwrite the body width/height also
                bodyStyle.width = bodyWidth;
                bodyStyle.height = bodyHeight;

                // return to inheriting style
                canvasStyle.backgroundColor = "";
                canvasStyle.color = "";

                // make container be inline on page again, and auto z-index
                containerStyle.position = "relative";
                containerStyle.zIndex = "";

                parent.appendChild(container);
                prevContainerSize = SeadragonUtils.getElementSize(parent);

                // remove keyboard listener for esc key
                SeadragonUtils.removeEvent(document, "keydown", onPageKeyDown);

                onContainerExit();      // mouse will likely be outside now
            }

            if (viewport) {
                var oldBounds = viewport.getBounds();
                viewport.resize(prevContainerSize);
                var newBounds = viewport.getBounds();

                if (fullPage) {
                    // going to fullpage, remember how much bounds changed by.
                    fsBoundsDelta = new SeadragonPoint(newBounds.width / oldBounds.width,
                        newBounds.height / oldBounds.height);
                } else {
                    // leaving fullpage, negate how much the fullpage zoomed by.
                    // note that we have to negate the bigger of the two changes.
                    // we have to zoom about the center of the new bounds, but
                    // that's NOT the zoom point. so we have to manually update
                    // first so that that center becomes the viewport center.
                    viewport.update();
                    viewport.zoomBy(Math.max(fsBoundsDelta.x, fsBoundsDelta.y),
                            null, true);
                }

                forceRedraw = true;
                eventManager.trigger("resize", self);
                updateOnce();
            }
        };

        this.setMouseNavEnabled = function (enabled) {
            innerTracker.setTracking(enabled);
        };

        this.setVisible = function (visible) {
            // important: don't explicitly say "visibility: visible", because
            // the W3C spec actually says children of hidden elements that have
            // "visibility: visible" should still be rendered. that's usually
            // not what we (or developers) want. browsers are inconsistent in
            // this regard, but IE seems to follow this spec.
            container.style.visibility = visible ? "" : "hidden";
        };

        this.showMessage = function (message, delay) {
            if (!delay) {
                setMessage(message);
                return;
            }

            window.setTimeout(function () {
                if (!self.isOpen()) {
                    setMessage(message);
                }
            }, delay);
        };

        // Methods -- EVENT HANDLING

        this.addEventListener = function (eventName, handler) {
            eventManager.addListener(eventName, handler);
        };

        this.removeEventListener = function (eventName, handler) {
            eventManager.removeListener(eventName, handler);
        };

        this.unload = function () {
            if (self.loopId) {
                cancelAnimationFrame(self.loopId);
                self.loopId = null;
            }
        }

        // Constructor

        initialize();

    };

})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
n=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,
2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},
k=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,
f)).finalize(b)}}});var s=p.algo={};return p}(Math);
(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^
k)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(g,l){var f={},k=f.lib={},h=function(){},m=k.Base={extend:function(a){h.prototype=this;var c=new h;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=k.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),t=f.enc={},s=t.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new q.init(d,c/2)}},n=t.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},j=t.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
w=k.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?g.ceil(f):g.max((f|0)-this._minBufferSize,0);a=f*e;b=g.min(4*a,b);if(a){for(var u=0;u<a;u+=e)this._doProcessBlock(d,u);u=d.splice(0,a);c.sigBytes-=b}return new q.init(u,b)},clone:function(){var a=m.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});k.Hasher=w.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){w.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new v.HMAC.init(a,
d)).finalize(c)}}});var v=f.algo={};return f}(Math);
(function(g){for(var l=CryptoJS,f=l.lib,k=f.WordArray,h=f.Hasher,f=l.algo,m=[],q=[],t=function(a){return 4294967296*(a-(a|0))|0},s=2,n=0;64>n;){var j;a:{j=s;for(var w=g.sqrt(j),v=2;v<=w;v++)if(!(j%v)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=t(g.pow(s,0.5))),q[n]=t(g.pow(s,1/3)),n++);s++}var a=[],f=f.SHA256=h.extend({_doReset:function(){this._hash=new k.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],k=b[3],h=b[4],l=b[5],m=b[6],n=b[7],p=0;64>p;p++){if(16>p)a[p]=
c[d+p]|0;else{var j=a[p-15],r=a[p-2];a[p]=((j<<25|j>>>7)^(j<<14|j>>>18)^j>>>3)+a[p-7]+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+a[p-16]}j=n+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&l^~h&m)+q[p]+a[p];r=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);n=m;m=l;l=h;h=k+j|0;k=g;g=f;f=e;e=j+r|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+k|0;b[4]=b[4]+h|0;b[5]=b[5]+l|0;b[6]=b[6]+m|0;b[7]=b[7]+n|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=g.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=h.clone.call(this);a._hash=this._hash.clone();return a}});l.SHA256=h._createHelper(f);l.HmacSHA256=h._createHmacHelper(f)})(Math);
(function(){var g=CryptoJS,l=g.lib.WordArray,f=g.algo,k=f.SHA256,f=f.SHA224=k.extend({_doReset:function(){this._hash=new l.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var f=k._doFinalize.call(this);f.sigBytes-=4;return f}});g.SHA224=k._createHelper(f);g.HmacSHA224=k._createHmacHelper(f)})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
x=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,
d)).finalize(c)}}});var w=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=
c[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(a,c){var d={},j=d.lib={},f=function(){},m=j.Base={extend:function(a){f.prototype=this;var b=new f;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
B=j.WordArray=m.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=c?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,g=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var k=0;k<a;k++)b[e+k>>>2]|=(g[k>>>2]>>>24-8*(k%4)&255)<<24-8*((e+k)%4);else if(65535<g.length)for(k=0;k<a;k+=4)b[e+k>>>2]=g[k>>>2];else b.push.apply(b,g);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<
32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],g=0;g<n;g+=4)b.push(4294967296*a.random()|0);return new B.init(b,n)}}),v=d.enc={},y=v.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++){var k=b[e>>>2]>>>24-8*(e%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join("")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e+=2)g[e>>>3]|=parseInt(a.substr(e,
2),16)<<24-4*(e%8);return new B.init(g,b/2)}},F=v.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++)g.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return g.join("")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e++)g[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new B.init(g,b)}},ha=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(F.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return F.parse(unescape(encodeURIComponent(a)))}},
Z=j.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new B.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=ha.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,g=b.words,e=b.sigBytes,k=this.blockSize,m=e/(4*k),m=n?a.ceil(m):a.max((m|0)-this._minBufferSize,0);n=m*k;e=a.min(4*n,e);if(n){for(var c=0;c<n;c+=k)this._doProcessBlock(g,c);c=g.splice(0,n);b.sigBytes-=e}return new B.init(c,e)},clone:function(){var a=m.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=Z.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){Z.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,g){return(new a.init(g)).finalize(b)}},_createHmacHelper:function(a){return function(b,g){return(new ia.HMAC.init(a,
g)).finalize(b)}}});var ia=d.algo={};return d}(Math);
(function(a){var c=CryptoJS,d=c.lib,j=d.Base,f=d.WordArray,c=c.x64={};c.Word=j.extend({init:function(a,c){this.high=a;this.low=c}});c.WordArray=j.extend({init:function(c,d){c=this.words=c||[];this.sigBytes=d!=a?d:8*c.length},toX32:function(){for(var a=this.words,c=a.length,d=[],j=0;j<c;j++){var F=a[j];d.push(F.high);d.push(F.low)}return f.create(d,this.sigBytes)},clone:function(){for(var a=j.clone.call(this),c=a.words=this.words.slice(0),d=c.length,f=0;f<d;f++)c[f]=c[f].clone();return a}})})();
(function(){function a(){return f.create.apply(f,arguments)}for(var c=CryptoJS,d=c.lib.Hasher,j=c.x64,f=j.Word,m=j.WordArray,j=c.algo,B=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],y=0;80>y;y++)v[y]=a();j=j.SHA512=d.extend({_doReset:function(){this._hash=new m.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,c){for(var d=this._hash.words,
f=d[0],j=d[1],b=d[2],g=d[3],e=d[4],k=d[5],m=d[6],d=d[7],y=f.high,M=f.low,$=j.high,N=j.low,aa=b.high,O=b.low,ba=g.high,P=g.low,ca=e.high,Q=e.low,da=k.high,R=k.low,ea=m.high,S=m.low,fa=d.high,T=d.low,s=y,p=M,G=$,D=N,H=aa,E=O,W=ba,I=P,t=ca,q=Q,U=da,J=R,V=ea,K=S,X=fa,L=T,u=0;80>u;u++){var z=v[u];if(16>u)var r=z.high=a[c+2*u]|0,h=z.low=a[c+2*u+1]|0;else{var r=v[u-15],h=r.high,w=r.low,r=(h>>>1|w<<31)^(h>>>8|w<<24)^h>>>7,w=(w>>>1|h<<31)^(w>>>8|h<<24)^(w>>>7|h<<25),C=v[u-2],h=C.high,l=C.low,C=(h>>>19|l<<
13)^(h<<3|l>>>29)^h>>>6,l=(l>>>19|h<<13)^(l<<3|h>>>29)^(l>>>6|h<<26),h=v[u-7],Y=h.high,A=v[u-16],x=A.high,A=A.low,h=w+h.low,r=r+Y+(h>>>0<w>>>0?1:0),h=h+l,r=r+C+(h>>>0<l>>>0?1:0),h=h+A,r=r+x+(h>>>0<A>>>0?1:0);z.high=r;z.low=h}var Y=t&U^~t&V,A=q&J^~q&K,z=s&G^s&H^G&H,ja=p&D^p&E^D&E,w=(s>>>28|p<<4)^(s<<30|p>>>2)^(s<<25|p>>>7),C=(p>>>28|s<<4)^(p<<30|s>>>2)^(p<<25|s>>>7),l=B[u],ka=l.high,ga=l.low,l=L+((q>>>14|t<<18)^(q>>>18|t<<14)^(q<<23|t>>>9)),x=X+((t>>>14|q<<18)^(t>>>18|q<<14)^(t<<23|q>>>9))+(l>>>0<
L>>>0?1:0),l=l+A,x=x+Y+(l>>>0<A>>>0?1:0),l=l+ga,x=x+ka+(l>>>0<ga>>>0?1:0),l=l+h,x=x+r+(l>>>0<h>>>0?1:0),h=C+ja,z=w+z+(h>>>0<C>>>0?1:0),X=V,L=K,V=U,K=J,U=t,J=q,q=I+l|0,t=W+x+(q>>>0<I>>>0?1:0)|0,W=H,I=E,H=G,E=D,G=s,D=p,p=l+h|0,s=x+z+(p>>>0<l>>>0?1:0)|0}M=f.low=M+p;f.high=y+s+(M>>>0<p>>>0?1:0);N=j.low=N+D;j.high=$+G+(N>>>0<D>>>0?1:0);O=b.low=O+E;b.high=aa+H+(O>>>0<E>>>0?1:0);P=g.low=P+I;g.high=ba+W+(P>>>0<I>>>0?1:0);Q=e.low=Q+q;e.high=ca+t+(Q>>>0<q>>>0?1:0);R=k.low=R+J;k.high=da+U+(R>>>0<J>>>0?1:0);
S=m.low=S+K;m.high=ea+V+(S>>>0<K>>>0?1:0);T=d.low=T+L;d.high=fa+X+(T>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,c=a.words,d=8*this._nDataBytes,f=8*a.sigBytes;c[f>>>5]|=128<<24-f%32;c[(f+128>>>10<<5)+30]=Math.floor(d/4294967296);c[(f+128>>>10<<5)+31]=d;a.sigBytes=4*c.length;this._process();return this._hash.toX32()},clone:function(){var a=d.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});c.SHA512=d._createHelper(j);c.HmacSHA512=d._createHmacHelper(j)})();
(function(){var a=CryptoJS,c=a.x64,d=c.Word,j=c.WordArray,c=a.algo,f=c.SHA512,c=c.SHA384=f.extend({_doReset:function(){this._hash=new j.init([new d.init(3418070365,3238371032),new d.init(1654270250,914150663),new d.init(2438529370,812702999),new d.init(355462360,4144912697),new d.init(1731405415,4290775857),new d.init(2394180231,1750603025),new d.init(3675008525,1694076839),new d.init(1203062813,3204075428)])},_doFinalize:function(){var a=f._doFinalize.call(this);a.sigBytes-=16;return a}});a.SHA384=
f._createHelper(c);a.HmacSHA384=f._createHmacHelper(c)})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(a,m){var r={},f=r.lib={},g=function(){},l=f.Base={extend:function(a){g.prototype=this;var b=new g;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
p=f.WordArray=l.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||q).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var j=0;j<a;j++)b[c+j>>>2]|=(d[j>>>2]>>>24-8*(j%4)&255)<<24-8*((c+j)%4);else if(65535<d.length)for(j=0;j<a;j+=4)b[c+j>>>2]=d[j>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<
32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],d=0;d<n;d+=4)b.push(4294967296*a.random()|0);return new p.init(b,n)}}),y=r.enc={},q=y.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var j=b[c>>>2]>>>24-8*(c%4)&255;d.push((j>>>4).toString(16));d.push((j&15).toString(16))}return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,
2),16)<<24-4*(c%8);return new p.init(d,b/2)}},G=y.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new p.init(d,b)}},fa=y.Utf8={stringify:function(a){try{return decodeURIComponent(escape(G.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return G.parse(unescape(encodeURIComponent(a)))}},
h=f.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=fa.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,d=b.words,c=b.sigBytes,j=this.blockSize,l=c/(4*j),l=n?a.ceil(l):a.max((l|0)-this._minBufferSize,0);n=l*j;c=a.min(4*n,c);if(n){for(var h=0;h<n;h+=j)this._doProcessBlock(d,h);h=d.splice(0,n);b.sigBytes-=c}return new p.init(h,c)},clone:function(){var a=l.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});f.Hasher=h.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){h.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new ga.HMAC.init(a,
d)).finalize(b)}}});var ga=r.algo={};return r}(Math);
(function(a){var m=CryptoJS,r=m.lib,f=r.Base,g=r.WordArray,m=m.x64={};m.Word=f.extend({init:function(a,p){this.high=a;this.low=p}});m.WordArray=f.extend({init:function(l,p){l=this.words=l||[];this.sigBytes=p!=a?p:8*l.length},toX32:function(){for(var a=this.words,p=a.length,f=[],q=0;q<p;q++){var G=a[q];f.push(G.high);f.push(G.low)}return g.create(f,this.sigBytes)},clone:function(){for(var a=f.clone.call(this),p=a.words=this.words.slice(0),g=p.length,q=0;q<g;q++)p[q]=p[q].clone();return a}})})();
(function(){function a(){return g.create.apply(g,arguments)}for(var m=CryptoJS,r=m.lib.Hasher,f=m.x64,g=f.Word,l=f.WordArray,f=m.algo,p=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],y=[],q=0;80>q;q++)y[q]=a();f=f.SHA512=r.extend({_doReset:function(){this._hash=new l.init([new g.init(1779033703,4089235720),new g.init(3144134277,2227873595),new g.init(1013904242,4271175723),new g.init(2773480762,1595750129),new g.init(1359893119,2917565137),new g.init(2600822924,725511199),new g.init(528734635,4215389547),new g.init(1541459225,327033209)])},_doProcessBlock:function(a,f){for(var h=this._hash.words,
g=h[0],n=h[1],b=h[2],d=h[3],c=h[4],j=h[5],l=h[6],h=h[7],q=g.high,m=g.low,r=n.high,N=n.low,Z=b.high,O=b.low,$=d.high,P=d.low,aa=c.high,Q=c.low,ba=j.high,R=j.low,ca=l.high,S=l.low,da=h.high,T=h.low,v=q,s=m,H=r,E=N,I=Z,F=O,W=$,J=P,w=aa,t=Q,U=ba,K=R,V=ca,L=S,X=da,M=T,x=0;80>x;x++){var B=y[x];if(16>x)var u=B.high=a[f+2*x]|0,e=B.low=a[f+2*x+1]|0;else{var u=y[x-15],e=u.high,z=u.low,u=(e>>>1|z<<31)^(e>>>8|z<<24)^e>>>7,z=(z>>>1|e<<31)^(z>>>8|e<<24)^(z>>>7|e<<25),D=y[x-2],e=D.high,k=D.low,D=(e>>>19|k<<13)^
(e<<3|k>>>29)^e>>>6,k=(k>>>19|e<<13)^(k<<3|e>>>29)^(k>>>6|e<<26),e=y[x-7],Y=e.high,C=y[x-16],A=C.high,C=C.low,e=z+e.low,u=u+Y+(e>>>0<z>>>0?1:0),e=e+k,u=u+D+(e>>>0<k>>>0?1:0),e=e+C,u=u+A+(e>>>0<C>>>0?1:0);B.high=u;B.low=e}var Y=w&U^~w&V,C=t&K^~t&L,B=v&H^v&I^H&I,ha=s&E^s&F^E&F,z=(v>>>28|s<<4)^(v<<30|s>>>2)^(v<<25|s>>>7),D=(s>>>28|v<<4)^(s<<30|v>>>2)^(s<<25|v>>>7),k=p[x],ia=k.high,ea=k.low,k=M+((t>>>14|w<<18)^(t>>>18|w<<14)^(t<<23|w>>>9)),A=X+((w>>>14|t<<18)^(w>>>18|t<<14)^(w<<23|t>>>9))+(k>>>0<M>>>
0?1:0),k=k+C,A=A+Y+(k>>>0<C>>>0?1:0),k=k+ea,A=A+ia+(k>>>0<ea>>>0?1:0),k=k+e,A=A+u+(k>>>0<e>>>0?1:0),e=D+ha,B=z+B+(e>>>0<D>>>0?1:0),X=V,M=L,V=U,L=K,U=w,K=t,t=J+k|0,w=W+A+(t>>>0<J>>>0?1:0)|0,W=I,J=F,I=H,F=E,H=v,E=s,s=k+e|0,v=A+B+(s>>>0<k>>>0?1:0)|0}m=g.low=m+s;g.high=q+v+(m>>>0<s>>>0?1:0);N=n.low=N+E;n.high=r+H+(N>>>0<E>>>0?1:0);O=b.low=O+F;b.high=Z+I+(O>>>0<F>>>0?1:0);P=d.low=P+J;d.high=$+W+(P>>>0<J>>>0?1:0);Q=c.low=Q+t;c.high=aa+w+(Q>>>0<t>>>0?1:0);R=j.low=R+K;j.high=ba+U+(R>>>0<K>>>0?1:0);S=l.low=
S+L;l.high=ca+V+(S>>>0<L>>>0?1:0);T=h.low=T+M;h.high=da+X+(T>>>0<M>>>0?1:0)},_doFinalize:function(){var a=this._data,f=a.words,h=8*this._nDataBytes,g=8*a.sigBytes;f[g>>>5]|=128<<24-g%32;f[(g+128>>>10<<5)+30]=Math.floor(h/4294967296);f[(g+128>>>10<<5)+31]=h;a.sigBytes=4*f.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});m.SHA512=r._createHelper(f);m.HmacSHA512=r._createHmacHelper(f)})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,l){var d={},n=d.lib={},p=function(){},s=n.Base={extend:function(a){p.prototype=this;var c=new p;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=n.WordArray=s.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,m=a.words,f=this.sigBytes;a=a.sigBytes;this.clamp();if(f%4)for(var t=0;t<a;t++)c[f+t>>>2]|=(m[t>>>2]>>>24-8*(t%4)&255)<<24-8*((f+t)%4);else if(65535<m.length)for(t=0;t<a;t+=4)c[f+t>>>2]=m[t>>>2];else c.push.apply(c,m);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=s.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],m=0;m<a;m+=4)c.push(4294967296*u.random()|0);return new q.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var m=[],f=0;f<a;f++){var t=c[f>>>2]>>>24-8*(f%4)&255;m.push((t>>>4).toString(16));m.push((t&15).toString(16))}return m.join("")},parse:function(a){for(var c=a.length,m=[],f=0;f<c;f+=2)m[f>>>3]|=parseInt(a.substr(f,
2),16)<<24-4*(f%8);return new q.init(m,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var m=[],f=0;f<a;f++)m.push(String.fromCharCode(c[f>>>2]>>>24-8*(f%4)&255));return m.join("")},parse:function(a){for(var c=a.length,m=[],f=0;f<c;f++)m[f>>>2]|=(a.charCodeAt(f)&255)<<24-8*(f%4);return new q.init(m,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
r=n.BufferedBlockAlgorithm=s.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,m=c.words,f=c.sigBytes,t=this.blockSize,b=f/(4*t),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*t;f=u.min(4*a,f);if(a){for(var e=0;e<a;e+=t)this._doProcessBlock(m,e);e=m.splice(0,a);c.sigBytes-=f}return new q.init(e,f)},clone:function(){var a=s.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});n.Hasher=r.extend({cfg:s.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){r.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,m){return(new a.init(m)).finalize(c)}},_createHmacHelper:function(a){return function(c,m){return(new e.HMAC.init(a,
m)).finalize(c)}}});var e=d.algo={};return d}(Math);
(function(){var u=CryptoJS,l=u.lib.WordArray;u.enc.Base64={stringify:function(d){var n=d.words,l=d.sigBytes,s=this._map;d.clamp();d=[];for(var q=0;q<l;q+=3)for(var w=(n[q>>>2]>>>24-8*(q%4)&255)<<16|(n[q+1>>>2]>>>24-8*((q+1)%4)&255)<<8|n[q+2>>>2]>>>24-8*((q+2)%4)&255,v=0;4>v&&q+0.75*v<l;v++)d.push(s.charAt(w>>>6*(3-v)&63));if(n=s.charAt(64))for(;d.length%4;)d.push(n);return d.join("")},parse:function(d){var n=d.length,p=this._map,s=p.charAt(64);s&&(s=d.indexOf(s),-1!=s&&(n=s));for(var s=[],q=0,w=0;w<
n;w++)if(w%4){var v=p.indexOf(d.charAt(w-1))<<2*(w%4),b=p.indexOf(d.charAt(w))>>>6-2*(w%4);s[q>>>2]|=(v|b)<<24-8*(q%4);q++}return l.create(s,q)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function l(b,e,a,c,m,f,t){b=b+(e&a|~e&c)+m+t;return(b<<f|b>>>32-f)+e}function d(b,e,a,c,m,f,t){b=b+(e&c|a&~c)+m+t;return(b<<f|b>>>32-f)+e}function n(b,e,a,c,m,f,t){b=b+(e^a^c)+m+t;return(b<<f|b>>>32-f)+e}function p(b,e,a,c,m,f,t){b=b+(a^(e|~c))+m+t;return(b<<f|b>>>32-f)+e}for(var s=CryptoJS,q=s.lib,w=q.WordArray,v=q.Hasher,q=s.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;q=q.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(r,e){for(var a=0;16>a;a++){var c=e+a,m=r[c];r[c]=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360}var a=this._hash.words,c=r[e+0],m=r[e+1],f=r[e+2],t=r[e+3],y=r[e+4],q=r[e+5],s=r[e+6],w=r[e+7],v=r[e+8],u=r[e+9],x=r[e+10],z=r[e+11],A=r[e+12],B=r[e+13],C=r[e+14],D=r[e+15],g=a[0],h=a[1],j=a[2],k=a[3],g=l(g,h,j,k,c,7,b[0]),k=l(k,g,h,j,m,12,b[1]),j=l(j,k,g,h,f,17,b[2]),h=l(h,j,k,g,t,22,b[3]),g=l(g,h,j,k,y,7,b[4]),k=l(k,g,h,j,q,12,b[5]),j=l(j,k,g,h,s,17,b[6]),h=l(h,j,k,g,w,22,b[7]),
g=l(g,h,j,k,v,7,b[8]),k=l(k,g,h,j,u,12,b[9]),j=l(j,k,g,h,x,17,b[10]),h=l(h,j,k,g,z,22,b[11]),g=l(g,h,j,k,A,7,b[12]),k=l(k,g,h,j,B,12,b[13]),j=l(j,k,g,h,C,17,b[14]),h=l(h,j,k,g,D,22,b[15]),g=d(g,h,j,k,m,5,b[16]),k=d(k,g,h,j,s,9,b[17]),j=d(j,k,g,h,z,14,b[18]),h=d(h,j,k,g,c,20,b[19]),g=d(g,h,j,k,q,5,b[20]),k=d(k,g,h,j,x,9,b[21]),j=d(j,k,g,h,D,14,b[22]),h=d(h,j,k,g,y,20,b[23]),g=d(g,h,j,k,u,5,b[24]),k=d(k,g,h,j,C,9,b[25]),j=d(j,k,g,h,t,14,b[26]),h=d(h,j,k,g,v,20,b[27]),g=d(g,h,j,k,B,5,b[28]),k=d(k,g,
h,j,f,9,b[29]),j=d(j,k,g,h,w,14,b[30]),h=d(h,j,k,g,A,20,b[31]),g=n(g,h,j,k,q,4,b[32]),k=n(k,g,h,j,v,11,b[33]),j=n(j,k,g,h,z,16,b[34]),h=n(h,j,k,g,C,23,b[35]),g=n(g,h,j,k,m,4,b[36]),k=n(k,g,h,j,y,11,b[37]),j=n(j,k,g,h,w,16,b[38]),h=n(h,j,k,g,x,23,b[39]),g=n(g,h,j,k,B,4,b[40]),k=n(k,g,h,j,c,11,b[41]),j=n(j,k,g,h,t,16,b[42]),h=n(h,j,k,g,s,23,b[43]),g=n(g,h,j,k,u,4,b[44]),k=n(k,g,h,j,A,11,b[45]),j=n(j,k,g,h,D,16,b[46]),h=n(h,j,k,g,f,23,b[47]),g=p(g,h,j,k,c,6,b[48]),k=p(k,g,h,j,w,10,b[49]),j=p(j,k,g,h,
C,15,b[50]),h=p(h,j,k,g,q,21,b[51]),g=p(g,h,j,k,A,6,b[52]),k=p(k,g,h,j,t,10,b[53]),j=p(j,k,g,h,x,15,b[54]),h=p(h,j,k,g,m,21,b[55]),g=p(g,h,j,k,v,6,b[56]),k=p(k,g,h,j,D,10,b[57]),j=p(j,k,g,h,s,15,b[58]),h=p(h,j,k,g,B,21,b[59]),g=p(g,h,j,k,y,6,b[60]),k=p(k,g,h,j,z,10,b[61]),j=p(j,k,g,h,f,15,b[62]),h=p(h,j,k,g,u,21,b[63]);a[0]=a[0]+g|0;a[1]=a[1]+h|0;a[2]=a[2]+j|0;a[3]=a[3]+k|0},_doFinalize:function(){var b=this._data,e=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;e[c>>>5]|=128<<24-c%32;var m=u.floor(a/
4294967296);e[(c+64>>>9<<4)+15]=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360;e[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(e.length+1);this._process();b=this._hash;e=b.words;for(a=0;4>a;a++)c=e[a],e[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});s.MD5=v._createHelper(q);s.HmacMD5=v._createHmacHelper(q)})(Math);
(function(){var u=CryptoJS,l=u.lib,d=l.Base,n=l.WordArray,l=u.algo,p=l.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:l.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,l){for(var p=this.cfg,v=p.hasher.create(),b=n.create(),u=b.words,r=p.keySize,p=p.iterations;u.length<r;){e&&v.update(e);var e=v.update(d).finalize(l);v.reset();for(var a=1;a<p;a++)e=v.finalize(e),v.reset();b.concat(e)}b.sigBytes=4*r;return b}});u.EvpKDF=function(d,l,n){return p.create(n).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var l=CryptoJS,d=l.lib,n=d.Base,p=d.WordArray,s=d.BufferedBlockAlgorithm,q=l.enc.Base64,w=l.algo.EvpKDF,v=d.Cipher=s.extend({cfg:n.extend(),createEncryptor:function(m,a){return this.create(this._ENC_XFORM_MODE,m,a)},createDecryptor:function(m,a){return this.create(this._DEC_XFORM_MODE,m,a)},init:function(m,a,b){this.cfg=this.cfg.extend(b);this._xformMode=m;this._key=a;this.reset()},reset:function(){s.reset.call(this);this._doReset()},process:function(a){this._append(a);return this._process()},
finalize:function(a){a&&this._append(a);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(m){return{encrypt:function(f,b,e){return("string"==typeof b?c:a).encrypt(m,f,b,e)},decrypt:function(f,b,e){return("string"==typeof b?c:a).decrypt(m,f,b,e)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=l.mode={},x=function(a,f,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var e=0;e<b;e++)a[f+e]^=
c[e]},r=(d.BlockCipherMode=n.extend({createEncryptor:function(a,f){return this.Encryptor.create(a,f)},createDecryptor:function(a,f){return this.Decryptor.create(a,f)},init:function(a,f){this._cipher=a;this._iv=f}})).extend();r.Encryptor=r.extend({processBlock:function(a,f){var b=this._cipher,c=b.blockSize;x.call(this,a,f,c);b.encryptBlock(a,f);this._prevBlock=a.slice(f,f+c)}});r.Decryptor=r.extend({processBlock:function(a,b){var c=this._cipher,e=c.blockSize,d=a.slice(b,b+e);c.decryptBlock(a,b);x.call(this,
a,b,e);this._prevBlock=d}});b=b.CBC=r;r=(l.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,e=c<<24|c<<16|c<<8|c,d=[],l=0;l<c;l+=4)d.push(e);c=p.create(d,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:r}),reset:function(){v.reset.call(this);var a=this.cfg,c=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var b=a.createEncryptor;else b=a.createDecryptor,this._minBufferSize=1;this._mode=b.call(a,
this,c&&c.words)},_doProcessBlock:function(a,c){this._mode.processBlock(a,c)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var c=this._process(!0)}else c=this._process(!0),a.unpad(c);return c},blockSize:4});var e=d.CipherParams=n.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(l.format={}).OpenSSL={stringify:function(a){var c=a.ciphertext;a=a.salt;return(a?p.create([1398893684,
1701076831]).concat(a).concat(c):c).toString(q)},parse:function(a){a=q.parse(a);var c=a.words;if(1398893684==c[0]&&1701076831==c[1]){var b=p.create(c.slice(2,4));c.splice(0,4);a.sigBytes-=16}return e.create({ciphertext:a,salt:b})}},a=d.SerializableCipher=n.extend({cfg:n.extend({format:b}),encrypt:function(a,c,b,d){d=this.cfg.extend(d);var l=a.createEncryptor(b,d);c=l.finalize(c);l=l.cfg;return e.create({ciphertext:c,key:b,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,c,b,e){e=this.cfg.extend(e);c=this._parse(c,e.format);return a.createDecryptor(b,e).finalize(c.ciphertext)},_parse:function(a,c){return"string"==typeof a?c.parse(a,this):a}}),l=(l.kdf={}).OpenSSL={execute:function(a,c,b,d){d||(d=p.random(8));a=w.create({keySize:c+b}).compute(a,d);b=p.create(a.words.slice(c),4*b);a.sigBytes=4*c;return e.create({key:a,iv:b,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:l}),encrypt:function(c,b,e,d){d=this.cfg.extend(d);e=d.kdf.execute(e,
c.keySize,c.ivSize);d.iv=e.iv;c=a.encrypt.call(this,c,b,e.key,d);c.mixIn(e);return c},decrypt:function(c,b,e,d){d=this.cfg.extend(d);b=this._parse(b,d.format);e=d.kdf.execute(e,c.keySize,c.ivSize,b.salt);d.iv=e.iv;return a.decrypt.call(this,c,b,e.key,d)}})}();
(function(){function u(b,a){var c=(this._lBlock>>>b^this._rBlock)&a;this._rBlock^=c;this._lBlock^=c<<b}function l(b,a){var c=(this._rBlock>>>b^this._lBlock)&a;this._lBlock^=c;this._rBlock^=c<<b}var d=CryptoJS,n=d.lib,p=n.WordArray,n=n.BlockCipher,s=d.algo,q=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],w=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,
55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],v=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],b=[{"0":8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,
2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,
1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{"0":1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,
75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,
276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{"0":260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,
14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,
17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{"0":2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,
98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,
1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{"0":128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,
10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,
83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{"0":268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,
2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{"0":1048576,
16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,
496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{"0":134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,
2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,
2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],x=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],r=s.DES=n.extend({_doReset:function(){for(var b=this._key.words,a=[],c=0;56>c;c++){var d=q[c]-1;a[c]=b[d>>>5]>>>31-d%32&1}b=this._subKeys=[];for(d=0;16>d;d++){for(var f=b[d]=[],l=v[d],c=0;24>c;c++)f[c/6|0]|=a[(w[c]-1+l)%28]<<31-c%6,f[4+(c/6|0)]|=a[28+(w[c+24]-1+l)%28]<<31-c%6;f[0]=f[0]<<1|f[0]>>>31;for(c=1;7>c;c++)f[c]>>>=
4*(c-1)+3;f[7]=f[7]<<5|f[7]>>>27}a=this._invSubKeys=[];for(c=0;16>c;c++)a[c]=b[15-c]},encryptBlock:function(b,a){this._doCryptBlock(b,a,this._subKeys)},decryptBlock:function(b,a){this._doCryptBlock(b,a,this._invSubKeys)},_doCryptBlock:function(e,a,c){this._lBlock=e[a];this._rBlock=e[a+1];u.call(this,4,252645135);u.call(this,16,65535);l.call(this,2,858993459);l.call(this,8,16711935);u.call(this,1,1431655765);for(var d=0;16>d;d++){for(var f=c[d],n=this._lBlock,p=this._rBlock,q=0,r=0;8>r;r++)q|=b[r][((p^
f[r])&x[r])>>>0];this._lBlock=p;this._rBlock=n^q}c=this._lBlock;this._lBlock=this._rBlock;this._rBlock=c;u.call(this,1,1431655765);l.call(this,8,16711935);l.call(this,2,858993459);u.call(this,16,65535);u.call(this,4,252645135);e[a]=this._lBlock;e[a+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});d.DES=n._createHelper(r);s=s.TripleDES=n.extend({_doReset:function(){var b=this._key.words;this._des1=r.createEncryptor(p.create(b.slice(0,2)));this._des2=r.createEncryptor(p.create(b.slice(2,4)));this._des3=
r.createEncryptor(p.create(b.slice(4,6)))},encryptBlock:function(b,a){this._des1.encryptBlock(b,a);this._des2.decryptBlock(b,a);this._des3.encryptBlock(b,a)},decryptBlock:function(b,a){this._des3.decryptBlock(b,a);this._des2.encryptBlock(b,a);this._des1.decryptBlock(b,a)},keySize:6,ivSize:2,blockSize:2});d.TripleDES=n._createHelper(s)})();

;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k<a;k++)c[j+k>>>2]|=(e[k>>>2]>>>24-8*(k%4)&255)<<24-8*((j+k)%4);else if(65535<e.length)for(k=0;k<a;k+=4)c[j+k>>>2]=e[k>>>2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();

;
/*! Copyright (c) 2008 Brandon Aaron (brandon.aaron@gmail.com || http://brandonaaron.net)
* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
* and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
*/

/**
* Gets the width of the OS scrollbar
*/
(function ($) {
    var scrollbarWidth = 0;
    $.getScrollbarWidth = function () {
        if (!scrollbarWidth) {
            if ($.browser.msie) {
                var $textarea1 = $('<textarea cols="10" rows="2"></textarea>')
                .css({ position: 'absolute', top: -1000, left: -1000 }).appendTo('body'),
                $textarea2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>')
                .css({ position: 'absolute', top: -1000, left: -1000 }).appendTo('body');
                scrollbarWidth = $textarea1.width() - $textarea2.width();
                $textarea1.add($textarea2).remove();
            } else {
                var $div = $('<div />')
                .css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: -1000 })
                .prependTo('body').append('<div />').find('div')
                .css({ width: '100%', height: 200 });
                scrollbarWidth = 100 - $div.width();
                $div.parent().remove();
            }
        }
        return scrollbarWidth;
    };
})(jQuery);
;
/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function (window, undefined) {
    '$:nomunge'; // Used by YUI compressor.

    // Since jQuery really isn't required for this plugin, use `jQuery` as the
    // namespace only if it already exists, otherwise use the `Cowboy` namespace,
    // creating it if necessary.
    var $ = window.jQuery || window.Cowboy || (window.Cowboy = {}),

      // Internal method reference.
      jq_throttle;

    // Method: jQuery.throttle
    // 
    // Throttle execution of a function. Especially useful for rate limiting
    // execution of handlers on events like resize and scroll. If you want to
    // rate-limit execution of a function to a single time, see the
    // <jQuery.debounce> method.
    // 
    // In this visualization, | is a throttled-function call and X is the actual
    // callback execution:
    // 
    // > Throttled with `no_trailing` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X    X        X    X    X    X    X    X
    // > 
    // > Throttled with `no_trailing` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X             X    X    X    X    X
    // 
    // Usage:
    // 
    // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', throttled );
    // > jQuery('selector').unbind( 'someevent', throttled );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
    //    true, callback will only execute every `delay` milliseconds while the
    //    throttled-function is being called. If no_trailing is false or
    //    unspecified, callback will be executed one final time after the last
    //    throttled-function call. (After the throttled-function has not been
    //    called for `delay` milliseconds, the internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the throttled-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, throttled, function.

    $.throttle = jq_throttle = function (delay, no_trailing, callback, debounce_mode) {
        // After wrapper has stopped being called, this timeout ensures that
        // `callback` is executed at the proper times in `throttle` and `end`
        // debounce modes.
        var timeout_id,

          // Keep track of the last time `callback` was executed.
          last_exec = 0;

        // `no_trailing` defaults to falsy.
        if (typeof no_trailing !== 'boolean') {
            debounce_mode = callback;
            callback = no_trailing;
            no_trailing = undefined;
        }

        // The `wrapper` function encapsulates all of the throttling / debouncing
        // functionality and when executed will limit the rate at which `callback`
        // is executed.
        function wrapper() {
            var that = this,
              elapsed = +new Date() - last_exec,
              args = arguments;

            // Execute `callback` and update the `last_exec` timestamp.
            function exec() {
                last_exec = +new Date();
                callback.apply(that, args);
            };

            // If `debounce_mode` is true (at_begin) this is used to clear the flag
            // to allow future `callback` executions.
            function clear() {
                timeout_id = undefined;
            };

            if (debounce_mode && !timeout_id) {
                // Since `wrapper` is being called for the first time and
                // `debounce_mode` is true (at_begin), execute `callback`.
                exec();
            }

            // Clear any existing timeout.
            timeout_id && clearTimeout(timeout_id);

            if (debounce_mode === undefined && elapsed > delay) {
                // In throttle mode, if `delay` time has been exceeded, execute
                // `callback`.
                exec();

            } else if (no_trailing !== true) {
                // In trailing throttle mode, since `delay` time has not been
                // exceeded, schedule `callback` to execute `delay` ms after most
                // recent execution.
                // 
                // If `debounce_mode` is true (at_begin), schedule `clear` to execute
                // after `delay` ms.
                // 
                // If `debounce_mode` is false (at end), schedule `callback` to
                // execute after `delay` ms.
                timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
            }
        };

        // Set the guid of `wrapper` function to the same of original callback, so
        // it can be removed in jQuery 1.4+ .unbind or .die by using the original
        // callback as a reference.
        if ($.guid) {
            wrapper.guid = callback.guid = callback.guid || $.guid++;
        }

        // Return the wrapper function.
        return wrapper;
    };

    // Method: jQuery.debounce
    // 
    // Debounce execution of a function. Debouncing, unlike throttling,
    // guarantees that a function is only executed a single time, either at the
    // very beginning of a series of calls, or at the very end. If you want to
    // simply rate-limit execution of a function, see the <jQuery.throttle>
    // method.
    // 
    // In this visualization, | is a debounced-function call and X is the actual
    // callback execution:
    // 
    // > Debounced with `at_begin` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // >                          X                                 X
    // > 
    // > Debounced with `at_begin` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X                                 X
    // 
    // Usage:
    // 
    // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', debounced );
    // > jQuery('selector').unbind( 'someevent', debounced );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
    //    unspecified, callback will only be executed `delay` milliseconds after
    //    the last debounced-function call. If at_begin is true, callback will be
    //    executed only at the first debounced-function call. (After the
    //    throttled-function has not been called for `delay` milliseconds, the
    //    internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the debounced-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, debounced, function.

    $.debounce = function (delay, at_begin, callback) {
        return callback === undefined
          ? jq_throttle(delay, at_begin, false)
          : jq_throttle(delay, callback, at_begin !== false);
    };

})(this);


;
(function ($) {
    // Monkey patch jQuery 1.3.1+ css() method to support CSS 'transform'
    // property uniformly across Safari/Chrome/Webkit, Firefox 3.5+, IE 9+, and Opera 11+.
    // 2009-2011 Zachary Johnson www.zachstronaut.com
    // Updated 2011.05.04 (May the fourth be with you!)
    function getTransformProperty(element) {
        // Try transform first for forward compatibility
        // In some versions of IE9, it is critical for msTransform to be in
        // this list before MozTranform.
        var properties = ['transform', 'WebkitTransform', 'msTransform', 'MozTransform', 'OTransform'];
        var p;
        while (p = properties.shift()) {
            if (element && typeof element.style[p] != 'undefined') { // Added null check on element
                return p;
            }
        }

        // Default to transform also
        return 'transform';
    }

    var _propsObj = null;

    var proxied = $.fn.css;
    $.fn.css = function (arg, val) {
        // Temporary solution for current 1.6.x incompatibility, while
        // preserving 1.3.x compatibility, until I can rewrite using CSS Hooks
        if (_propsObj === null) {
            if (typeof $.cssProps != 'undefined') {
                _propsObj = $.cssProps;
            }
            else if (typeof $.props != 'undefined') {
                _propsObj = $.props;
            }
            else {
                _propsObj = {}
            }
        }

        // Find the correct browser specific property and setup the mapping using
        // $.props which is used internally by jQuery.attr() when setting CSS
        // properties via either the css(name, value) or css(properties) method.
        // The problem with doing this once outside of css() method is that you
        // need a DOM node to find the right CSS property, and there is some risk
        // that somebody would call the css() method before body has loaded or any
        // DOM-is-ready events have fired.
        if 
        (
            typeof _propsObj['transform'] == 'undefined'
            &&
            (
                arg == 'transform'
                ||
                (
                    typeof arg == 'object'
                    && typeof arg['transform'] != 'undefined'
                )
            )
        ) {
            _propsObj['transform'] = getTransformProperty(this.get(0));
        }

        // We force the property mapping here because jQuery.attr() does
        // property mapping with jQuery.props when setting a CSS property,
        // but curCSS() does *not* do property mapping when *getting* a
        // CSS property. (It probably should since it manually does it
        // for 'float' now anyway... but that'd require more testing.)
        //
        // But, only do the forced mapping if the correct CSS property
        // is not 'transform' and is something else.
        if (_propsObj['transform'] != 'transform') {
            // Call in form of css('transform' ...)
            if (arg == 'transform') {
                arg = _propsObj['transform'];

                // User wants to GET the transform CSS, and in jQuery 1.4.3
                // calls to css() for transforms return a matrix rather than
                // the actual string specified by the user... avoid that
                // behavior and return the string by calling jQuery.style()
                // directly
                if (typeof val == 'undefined' && jQuery.style) {
                    return jQuery.style(this.get(0), arg);
                }
            }

            // Call in form of css({'transform': ...})
            else if 
            (
                typeof arg == 'object'
                && typeof arg['transform'] != 'undefined'
            ) {
                arg[_propsObj['transform']] = arg['transform'];
                delete arg['transform'];
            }
        }

        return proxied.apply(this, arguments);
    };
})(jQuery);


;
(function ($) {
    // Monkey patch jQuery 1.3.1+ to add support for setting or animating CSS
    // scale and rotation independently.
    // 2009-2010 Zachary Johnson www.zachstronaut.com
    // Updated 2010.11.06
    var rotateUnits = 'deg';

    $.fn.rotate = function (val) {
        var style = $(this).css('transform') || 'none';

        if (typeof val == 'undefined') {
            if (style) {
                var m = style.match(/rotate\(([^)]+)\)/);
                if (m && m[1]) {
                    return m[1];
                }
            }

            return 0;
        }

        var m = val.toString().match(/^(-?\d+(\.\d+)?)(.+)?$/);
        if (m) {
            if (m[3]) {
                rotateUnits = m[3];
            }

            $(this).css(
                'transform',
                style.replace(/none|rotate\([^)]*\)/, '') + 'rotate(' + m[1] + rotateUnits + ')'
            );
        }

        return this;
    }

    // Note that scale is unitless.
    $.fn.scale = function (val, duration, options) {
        var style = $(this).css('transform');

        if (typeof val == 'undefined') {
            if (style) {
                var m = style.match(/scale\(([^)]+)\)/);
                if (m && m[1]) {
                    return m[1];
                }
            }

            return 1;
        }

        $(this).css(
            'transform',
            style.replace(/none|scale\([^)]*\)/, '') + 'scale(' + val + ')'
        );

        return this;
    }

    // fx.cur() must be monkey patched because otherwise it would always
    // return 0 for current rotate and scale values
    var curProxied = $.fx.prototype.cur;
    $.fx.prototype.cur = function () {
        if (this.prop == 'rotate') {
            return parseFloat($(this.elem).rotate());
        }
        else if (this.prop == 'scale') {
            return parseFloat($(this.elem).scale());
        }

        return curProxied.apply(this, arguments);
    }

    $.fx.step.rotate = function (fx) {
        $(fx.elem).rotate(fx.now + rotateUnits);
    }

    $.fx.step.scale = function (fx) {
        $(fx.elem).scale(fx.now);
    }

    /*
Starting on line 3905 of jquery-1.3.2.js we have this code:
// We need to compute starting value
if ( unit != "px" ) {
self.style[ name ] = (end || 1) + unit;
start = ((end || 1) / e.cur(true)) * start;
self.style[ name ] = start + unit;
}
This creates a problem where we cannot give units to our custom animation
because if we do then this code will execute and because self.style[name]
does not exist where name is our custom animation's name then e.cur(true)
will likely return zero and create a divide by zero bug which will set
start to NaN.
The following monkey patch for animate() gets around this by storing the
units used in the rotation definition and then stripping the units off.
*/

    var animateProxied = $.fn.animate;
    $.fn.animate = function (prop) {
        if (typeof prop['rotate'] != 'undefined') {
            var m = prop['rotate'].toString().match(/^(([+-]=)?(-?\d+(\.\d+)?))(.+)?$/);
            if (m && m[5]) {
                rotateUnits = m[5];
            }

            prop['rotate'] = m[1];
        }

        return animateProxied.apply(this, arguments);
    }
})(jQuery);
;
/*
 ### jQuery XML to JSON Plugin v1.1 - 2008-07-01 ###
 * http://www.fyneworks.com/ - diego@fyneworks.com
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 ###
 Website: http://www.fyneworks.com/jquery/xml-to-json/
*//*
 # INSPIRED BY: http://www.terracoder.com/
           AND: http://www.thomasfrank.se/xml_to_json.html
											AND: http://www.kawa.net/works/js/xml/objtree-e.html
*//*
 This simple script converts XML (document of code) into a JSON object. It is the combination of 2
 'xml to json' great parsers (see below) which allows for both 'simple' and 'extended' parsing modes.
*/
// Avoid collisions
;if(window.jQuery) (function($){
 
 // Add function to jQuery namespace
 $.extend({
  
  // converts xml documents and xml text to json object
  xml2json: function(xml, extended) {
   if(!xml) return {}; // quick fail
   
   //### PARSER LIBRARY
   // Core function
   function parseXML(node, simple){
    if(!node) return null;
    var txt = '', obj = null, att = null;
    var nt = node.nodeType, nn = jsVar(node.localName || node.nodeName);
    var nv = node.text || node.nodeValue || '';
    /*DBG*/ //if(window.console) console.log(['x2j',nn,nt,nv.length+' bytes']);
    if(node.childNodes){
     if(node.childNodes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'CHILDREN',node.childNodes]);
      $.each(node.childNodes, function(n,cn){
       var cnt = cn.nodeType, cnn = jsVar(cn.localName || cn.nodeName);
       var cnv = cn.text || cn.nodeValue || '';
       /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>a',cnn,cnt,cnv]);
       if(cnt == 8){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>b',cnn,'COMMENT (ignore)']);
        return; // ignore comment node
       }
       else if(cnt == 3 || cnt == 4 || !cnn){
        // ignore white-space in between tags
        if(cnv.match(/^\s+$/)){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>c',cnn,'WHITE-SPACE (ignore)']);
         return;
        };
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>d',cnn,'TEXT']);
        txt += cnv.replace(/^\s+/,'').replace(/\s+$/,'');
								// make sure we ditch trailing spaces from markup
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>e',cnn,'OBJECT']);
        obj = obj || {};
        if(obj[cnn]){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>f',cnn,'ARRAY']);
         
									// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
									if(!obj[cnn].length) obj[cnn] = myArr(obj[cnn]);
									obj[cnn] = myArr(obj[cnn]);
         
									obj[cnn][ obj[cnn].length ] = parseXML(cn, true/* simple */);
         obj[cnn].length = obj[cnn].length;
        }
        else{
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>g',cnn,'dig deeper...']);
         obj[cnn] = parseXML(cn);
        };
       };
      });
     };//node.childNodes.length>0
    };//node.childNodes
    if(node.attributes){
     if(node.attributes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'ATTRIBUTES',node.attributes])
      att = {}; obj = obj || {};
      $.each(node.attributes, function(a,at){
       var atn = jsVar(at.name), atv = at.value;
       att[atn] = atv;
       if(obj[atn]){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'ARRAY']);
        
								// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
								//if(!obj[atn].length) obj[atn] = myArr(obj[atn]);//[ obj[ atn ] ];
        obj[cnn] = myArr(obj[cnn]);
								
								obj[atn][ obj[atn].length ] = atv;
        obj[atn].length = obj[atn].length;
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'TEXT']);
        obj[atn] = atv;
       };
      });
      //obj['attributes'] = att;
     };//node.attributes.length>0
    };//node.attributes
    if(obj){
     obj = $.extend( (txt!='' ? new String(txt) : {}),/* {text:txt},*/ obj || {}/*, att || {}*/);
     txt = (obj.text) ? (typeof(obj.text)=='object' ? obj.text : [obj.text || '']).concat([txt]) : txt;
     if(txt) obj.text = txt;
     txt = '';
    };
    var out = obj || txt;
    //console.log([extended, simple, out]);
    if(extended){
     if(txt) out = {};//new String(out);
     txt = out.text || txt || '';
     if(txt) out.text = txt;
     if(!simple) out = myArr(out);
    };
    return out;
   };// parseXML
   // Core Function End
   // Utility functions
   var jsVar = function(s){ return String(s || '').replace(/-/g,"_"); };
   
			// NEW isNum function: 01/09/2010
			// Thanks to Emile Grau, GigaTecnologies S.L., www.gigatransfer.com, www.mygigamail.com
			function isNum(s){
				// based on utility function isNum from xml2json plugin (http://www.fyneworks.com/ - diego@fyneworks.com)
				// few bugs corrected from original function :
				// - syntax error : regexp.test(string) instead of string.test(reg)
				// - regexp modified to accept  comma as decimal mark (latin syntax : 25,24 )
				// - regexp modified to reject if no number before decimal mark  : ".7" is not accepted
				// - string is "trimmed", allowing to accept space at the beginning and end of string
				var regexp=/^((-)?([0-9]+)(([\.\,]{0,1})([0-9]+))?$)/
				return (typeof s == "number") || regexp.test(String((s && typeof s == "string") ? jQuery.trim(s) : ''));
			};
			// OLD isNum function: (for reference only)
			//var isNum = function(s){ return (typeof s == "number") || String((s && typeof s == "string") ? s : '').test(/^((-)?([0-9]*)((\.{0,1})([0-9]+))?$)/); };
																
   var myArr = function(o){
    
				// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
				//if(!o.length) o = [ o ]; o.length=o.length;
    if(!$.isArray(o)) o = [ o ]; o.length=o.length;
				
				// here is where you can attach additional functionality, such as searching and sorting...
    return o;
   };
   // Utility functions End
   //### PARSER LIBRARY END
   
   // Convert plain text to xml
   if(typeof xml=='string') xml = $.text2xml(xml);
   
   // Quick fail if not xml (or if this is a node)
   if(!xml.nodeType) return;
   if(xml.nodeType == 3 || xml.nodeType == 4) return xml.nodeValue;
   
   // Find xml root node
   var root = (xml.nodeType == 9) ? xml.documentElement : xml;
   
   // Convert xml to json
   var out = parseXML(root, true /* simple */);
   
   // Clean-up memory
   xml = null; root = null;
   
   // Send output
   return out;
  },
  
  // Convert text to XML DOM
  text2xml: function(str) {
   // NOTE: I'd like to use jQuery for this, but jQuery makes all tags uppercase
   //return $(xml)[0];
   var out;
   try{
    var xml = ($.browser.msie)?new ActiveXObject("Microsoft.XMLDOM"):new DOMParser();
    xml.async = false;
   }catch(e){ throw new Error("XML Parser could not be instantiated") };
   try{
    if($.browser.msie) out = (xml.loadXML(str))?xml:false;
    else out = xml.parseFromString(str, "text/xml");
   }catch(e){ throw new Error("Error parsing XML string") };
   return out;
  }
		
 }); // extend $

})(jQuery);

;
/*	This work is licensed under Creative Commons GNU LGPL License.

	License: http://creativecommons.org/licenses/LGPL/2.1/
   Version: 0.9
	Author:  Stefan Goessner/2006
	Web:     http://goessner.net/ 
*/
function json2xml(o, tab) {
   var toXml = function(v, name, ind) {
      var xml = "";
      if (v instanceof Array) {
         for (var i=0, n=v.length; i<n; i++)
            xml += ind + toXml(v[i], name, ind+"\t") + "\n";
      }
      else if (typeof(v) == "object") {
         var hasChild = false;
         xml += ind + "<" + name;
         for (var m in v) {
            if (m.charAt(0) == "@")
               xml += " " + m.substr(1) + "=\"" + v[m].toString() + "\"";
            else
               hasChild = true;
         }
         xml += hasChild ? ">" : "/>";
         if (hasChild) {
            for (var m in v) {
               if (m == "#text")
                  xml += v[m];
               else if (m == "#cdata")
                  xml += "<![CDATA[" + v[m] + "]]>";
               else if (m.charAt(0) != "@")
                  xml += toXml(v[m], m, ind+"\t");
            }
            xml += (xml.charAt(xml.length-1)=="\n"?ind:"") + "</" + name + ">";
         }
      }
      else {
         xml += ind + "<" + name + ">" + v.toString() +  "</" + name + ">";
      }
      return xml;
   }, xml="";
   for (var m in o)
      xml += toXml(o[m], m, "");
   return tab ? xml.replace(/\t/g, tab) : xml.replace(/\t|\n/g, "");
}

;
/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
    'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
    // add styles and attributes to the element to prevent the browser from doing
    // its native behavior. this doesnt prevent the scrolling, but cancels
    // the contextmenu, tap highlighting etc
    // set to false to disable this
    stop_browser_behavior: {
		// this also triggers onselectstart=false for IE
        userSelect: 'none',
		// this makes the element blocking in IE10 >, you could experiment with the value
		// see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
        touchAction: 'none',
		touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    }

    // more settings are defined per gesture at gestures.js
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = document;

// plugins namespace
Hammer.plugins = {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
        if(Hammer.gestures.hasOwnProperty(name)) {
            Hammer.detection.register(Hammer.gestures[name]);
        }
    }

    // Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    this.element = element;

    // start/stop detection option
    this.enabled = true;

    // merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    // start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
        if(self.enabled) {
            Hammer.detection.startDetect(self, ev);
        }
    });

    // return instance
    return this;
};


Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    on: function onEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    off: function offEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     */
    trigger: function triggerEvent(gesture, eventData){
        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
		event.initEvent(gesture, true, true);
		event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Hammer.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },


    /**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    }
};

/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
    /**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     */
    bindDom: function(element, type, handler) {
        var types = type.split(' ');
        for(var t=0; t<types.length; t++) {
            element.addEventListener(types[t], handler, false);
        }
    },


    /**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     */
    onTouch: function onTouch(element, eventType, handler) {
		var self = this;

        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();

            // onmouseup, but when touchend has been fired we do nothing.
            // this is for touchdevices which also fire a mouseup on touchend
            if(sourceEventType.match(/mouse/) && touch_triggered) {
                return;
            }

            // mousebutton must be down or a touch event
            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen
                sourceEventType.match(/pointerdown/) || // pointerevents touch
                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
            ){
                enable_detect = true;
            }

            // we are in a touch event, set the touch triggered bool to true,
            // this for the conflicts that may occur on ios and android
            if(sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
            }

            // count the total touches on the screen
            var count_touches = 0;

            // when touch has been triggered in this detection session
            // and we are now handling a mouse event, we stop that to prevent conflicts
            if(enable_detect) {
                // update pointerevent
                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
                // touch
                else if(sourceEventType.match(/touch/)) {
                    count_touches = ev.touches.length;
                }
                // mouse
                else if(!touch_triggered) {
                    count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }

                // if we are in a end event, but when we remove one touch and
                // we still have enough, set eventType to move
                if(count_touches > 0 && eventType == Hammer.EVENT_END) {
                    eventType = Hammer.EVENT_MOVE;
                }
                // no touches, force the end event
                else if(!count_touches) {
                    eventType = Hammer.EVENT_END;
                }

                // because touchend has no touches, and we often want to use these in our gestures,
                // we send the last move event as our eventData in touchend
                if(!count_touches && last_move_event !== null) {
                    ev = last_move_event;
                }
                // store the last move event
                else {
                    last_move_event = ev;
                }

                // trigger the handler
                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                // remove pointerevent from list
                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
            }

            //debug(sourceEventType +" "+ eventType);

            // on the end we reset everything
            if(!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                Hammer.PointerEvent.reset();
            }
        });
    },


    /**
     * we have different events for each device/browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     */
    determineEventTypes: function determineEventTypes() {
        // determine the eventtype we want to set
        var types;

        // pointerEvents magic
        if(Hammer.HAS_POINTEREVENTS) {
            types = Hammer.PointerEvent.getEvents();
        }
        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
        else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'];
        }
        // for non pointer events browsers and mixed browsers,
        // like chrome on windows8 touch laptop
        else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'];
        }

        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    /**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     */
    getTouchList: function getTouchList(ev/*, eventType*/) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return Hammer.PointerEvent.getTouchList();
        }
        // get the touchlist
        else if(ev.touches) {
            return ev.touches;
        }
        // make fake touchlist from mouse position
        else {
            return [{
                identifier: 1,
                pageX: ev.pageX,
                pageY: ev.pageY,
                target: ev.target
            }];
        }
    },


    /**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     */
    collectEventData: function collectEventData(element, eventType, ev) {
        var touches = this.getTouchList(ev, eventType);

        // find out pointerType
        var pointerType = Hammer.POINTER_TOUCH;
        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
            pointerType = Hammer.POINTER_MOUSE;
        }

        return {
            center      : Hammer.utils.getCenter(touches),
            timeStamp   : new Date().getTime(),
            target      : ev.target,
            touches     : touches,
            eventType   : eventType,
            pointerType : pointerType,
            srcEvent    : ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                if(this.srcEvent.preventManipulation) {
                    this.srcEvent.preventManipulation();
                }

                if(this.srcEvent.preventDefault) {
                    this.srcEvent.preventDefault();
                }
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Hammer.detection.stopDetect();
            }
        };
    }
};

Hammer.PointerEvent = {
    /**
     * holds all pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get a list of pointers
     * @returns {Array}     touchlist
     */
    getTouchList: function() {
        var self = this;
        var touchlist = [];

        // we can use forEach since pointerEvents only is in IE10
        Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     */
    updatePointer: function(type, pointerEvent) {
        if(type == Hammer.EVENT_END) {
            this.pointers = {};
        }
        else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }

        return Object.keys(this.pointers).length;
    },

    /**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     */
    matchType: function(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var types = {};
        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
        return types[pointerType];
    },


    /**
     * get events
     */
    getEvents: function() {
        return [
            'pointerdown MSPointerDown',
            'pointermove MSPointerMove',
            'pointerup pointercancel MSPointerUp MSPointerCancel'
        ];
    },

    /**
     * reset the list
     */
    reset: function() {
        this.pointers = {};
    }
};


Hammer.utils = {
    /**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
	 * @parm	{Boolean}	merge		do a merge
     * @returns {Object}    dest
     */
    extend: function extend(dest, src, merge) {
        for (var key in src) {
			if(dest[key] !== undefined && merge) {
				continue;
			}
            dest[key] = src[key];
        }
        return dest;
    },


    /**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     */
    hasParent: function(node, parent) {
        while(node){
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },


    /**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     */
    getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];

        for(var t= 0,len=touches.length; t<len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
        }

        return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
        };
    },


    /**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     */
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
            x: Math.abs(delta_x / delta_time) || 0,
            y: Math.abs(delta_y / delta_time) || 0
        };
    },


    /**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY,
            x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 / Math.PI;
    },


    /**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX),
            y = Math.abs(touch1.pageY - touch2.pageY);

        if(x >= y) {
            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
        }
        else {
            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
        }
    },


    /**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX,
            y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x*x) + (y*y));
    },


    /**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) /
                this.getDistance(start[0], start[1]);
        }
        return 1;
    },


    /**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) -
                this.getAngle(start[1], start[0]);
        }
        return 0;
    },


    /**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     */
    isVertical: function isVertical(direction) {
        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    /**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     */
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
        var prop,
            vendors = ['webkit','khtml','moz','ms','o',''];

        if(!css_props || !element.style) {
            return;
        }

        // with css properties for modern browsers
        for(var i = 0; i < vendors.length; i++) {
            for(var p in css_props) {
                if(css_props.hasOwnProperty(p)) {
                    prop = p;

                    // vender prefix at the property
                    if(vendors[i]) {
                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                    }

                    // set the style
                    element.style[prop] = css_props[p];
                }
            }
        }

        // also the disable onselectstart
        if(css_props.userSelect == 'none') {
            element.onselectstart = function() {
                return false;
            };
        }
    }
};

Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,


    /**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        this.current = {
            inst        : inst, // reference to HammerInstance we're working for
            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent   : false, // last eventData
            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },


    /**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // instance options
        var inst_options = this.current.inst.options;

        // call Hammer.gesture handlers
        for(var g=0,len=this.gestures.length; g<len; g++) {
            var gesture = this.gestures[g];

            // only when the instance options have enabled this gesture
            if(!this.stopped && inst_options[gesture.name] !== false) {
                // if a handler returns false, we stop with the detection
                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                    this.stopDetect();
                    break;
                }
            }
        }

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        // endevent, but not the last touch, so dont stop
        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {
            this.stopDetect();
        }

        return eventData;
    },


    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Hammer.utils.extend({}, this.current);

        // reset the current
        this.current = null;

        // stopped!
        this.stopped = true;
    },


    /**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     */
    extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;

        // if the touches change, set the new touches over the startEvent touches
        // this because touchevents don't have all the touches on touchstart, or the
        // user must place his fingers at the EXACT same time on the screen, which is not realistic
        // but, sometimes it happens that both fingers are touching at the EXACT same time
        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            // extend 1 level deep to get the touchlist with the touch objects
            startEv.touches = [];
            for(var i=0,len=ev.touches.length; i<len; i++) {
                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
            }
        }

        var delta_time = ev.timeStamp - startEv.timeStamp,
            delta_x = ev.center.pageX - startEv.center.pageX,
            delta_y = ev.center.pageY - startEv.center.pageY,
            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

        Hammer.utils.extend(ev, {
            deltaTime   : delta_time,

            deltaX      : delta_x,
            deltaY      : delta_y,

            velocityX   : velocity.x,
            velocityY   : velocity.y,

            distance    : Hammer.utils.getDistance(startEv.center, ev.center),
            angle       : Hammer.utils.getAngle(startEv.center, ev.center),
            direction   : Hammer.utils.getDirection(startEv.center, ev.center),

            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

            startEvent  : startEv
        });

        return ev;
    },


    /**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Hammer.utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if (a.index < b.index) {
                return -1;
            }
            if (a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


Hammer.gestures = Hammer.gestures || {};

/**
 * Custom gestures
 * ==============================
 *
 * Gesture object
 * --------------------
 * The object structure of a gesture:
 *
 * { name: 'mygesture',
 *   index: 1337,
 *   defaults: {
 *     mygesture_option: true
 *   }
 *   handler: function(type, ev, inst) {
 *     // trigger gesture event
 *     inst.trigger(this.name, ev);
 *   }
 * }

 * @param   {String}    name
 * this should be the name of the gesture, lowercase
 * it is also being used to disable/enable the gesture per instance config.
 *
 * @param   {Number}    [index=1000]
 * the index of the gesture, where it is going to be in the stack of gestures detection
 * like when you build an gesture that depends on the drag gesture, it is a good
 * idea to place it after the index of the drag gesture.
 *
 * @param   {Object}    [defaults={}]
 * the default settings of the gesture. these are added to the instance settings,
 * and can be overruled per instance. you can also add the name of the gesture,
 * but this is also added by default (and set to true).
 *
 * @param   {Function}  handler
 * this handles the gesture detection of your custom gesture and receives the
 * following arguments:
 *
 *      @param  {Object}    eventData
 *      event data containing the following properties:
 *          timeStamp   {Number}        time the event occurred
 *          target      {HTMLElement}   target element
 *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
 *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
 *          center      {Object}        center position of the touches. contains pageX and pageY
 *          deltaTime   {Number}        the total time of the touches in the screen
 *          deltaX      {Number}        the delta on x axis we haved moved
 *          deltaY      {Number}        the delta on y axis we haved moved
 *          velocityX   {Number}        the velocity on the x
 *          velocityY   {Number}        the velocity on y
 *          angle       {Number}        the angle we are moving
 *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
 *          distance    {Number}        the distance we haved moved
 *          scale       {Number}        scaling of the touches, needs 2 touches
 *          rotation    {Number}        rotation of the touches, needs 2 touches *
 *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
 *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
 *          startEvent  {Object}        contains the same properties as above,
 *                                      but from the first touch. this is used to calculate
 *                                      distances, deltaTime, scaling etc
 *
 *      @param  {Hammer.Instance}    inst
 *      the instance we are doing the detection for. you can get the options from
 *      the inst.options object and trigger the gesture event by calling inst.trigger
 *
 *
 * Handle gestures
 * --------------------
 * inside the handler you can get/set Hammer.detection.current. This is the current
 * detection session. It has the following properties
 *      @param  {String}    name
 *      contains the name of the gesture we have detected. it has not a real function,
 *      only to check in other gestures if something is detected.
 *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
 *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
 *
 *      @readonly
 *      @param  {Hammer.Instance}    inst
 *      the instance we do the detection for
 *
 *      @readonly
 *      @param  {Object}    startEvent
 *      contains the properties of the first gesture detection in this session.
 *      Used for calculations about timing, distance, etc.
 *
 *      @readonly
 *      @param  {Object}    lastEvent
 *      contains all the properties of the last gesture detect in this session.
 *
 * after the gesture detection session has been completed (user has released the screen)
 * the Hammer.detection.current object is copied into Hammer.detection.previous,
 * this is usefull for gestures like doubletap, where you need to know if the
 * previous gesture was a tap
 *
 * options that have been set by the instance can be received by calling inst.options
 *
 * You can trigger a gesture event by calling inst.trigger("mygesture", event).
 * The first param is the name of your gesture, the second the event argument
 *
 *
 * Register gestures
 * --------------------
 * When an gesture is added to the Hammer.gestures object, it is auto registered
 * at the setup of the first Hammer instance. You can also call Hammer.detection.register
 * manually and pass your gesture object as a param
 *
 */

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
    name: 'hold',
    index: 10,
    defaults: {
        hold_timeout	: 500,
        hold_threshold	: 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
        switch(ev.eventType) {
            case Hammer.EVENT_START:
                // clear any running timers
                clearTimeout(this.timer);

                // set the gesture so we can check in the timeout if it still is
                Hammer.detection.current.name = this.name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                this.timer = setTimeout(function() {
                    if(Hammer.detection.current.name == 'hold') {
                        inst.trigger('hold', ev);
                    }
                }, inst.options.hold_timeout);
                break;

            // when you move or end we clear the timer
            case Hammer.EVENT_MOVE:
                if(ev.distance > inst.options.hold_threshold) {
                    clearTimeout(this.timer);
                }
                break;

            case Hammer.EVENT_END:
                clearTimeout(this.timer);
                break;
        }
    }
};


/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
    name: 'tap',
    index: 100,
    defaults: {
        tap_max_touchtime	: 250,
        tap_max_distance	: 10,
		tap_always			: true,
        doubletap_distance	: 20,
        doubletap_interval	: 300
    },
    handler: function tapGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // previous gesture, for the double tap since these are two different gesture detections
            var prev = Hammer.detection.previous,
				did_doubletap = false;

            // when the touchtime is higher then the max touch time
            // or when the moving distance is too much
            if(ev.deltaTime > inst.options.tap_max_touchtime ||
                ev.distance > inst.options.tap_max_distance) {
                return;
            }

            // check if double tap
            if(prev && prev.name == 'tap' &&
                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
                ev.distance < inst.options.doubletap_distance) {
				inst.trigger('doubletap', ev);
				did_doubletap = true;
            }

			// do a single tap
			if(!did_doubletap || inst.options.tap_always) {
				Hammer.detection.current.name = 'tap';
				inst.trigger(Hammer.detection.current.name, ev);
			}
        }
    }
};


/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        // set 0 for unlimited, but this can conflict with transform
        swipe_max_touches  : 1,
        swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // max touches
            if(inst.options.swipe_max_touches > 0 &&
                ev.touches.length > inst.options.swipe_max_touches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > inst.options.swipe_velocity ||
                ev.velocityY > inst.options.swipe_velocity) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
    name: 'drag',
    index: 50,
    defaults: {
        drag_min_distance : 10,
        // set 0 for unlimited, but this can conflict with transform
        drag_max_touches  : 1,
        // prevent default browser behavior when dragging occurs
        // be careful with it, it makes the element a blocking element
        // when you are using the drag gesture, it is a good practice to set this true
        drag_block_horizontal   : false,
        drag_block_vertical     : false,
        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
        // It disallows vertical directions if the initial direction was horizontal, and vice versa.
        drag_lock_to_axis       : false,
        // drag lock only kicks in when distance > drag_lock_min_distance
        // This way, locking occurs only when the distance has become large enough to reliably determine the direction
        drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // max touches
        if(inst.options.drag_max_touches > 0 &&
            ev.touches.length > inst.options.drag_max_touches) {
            return;
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.drag_min_distance &&
                    Hammer.detection.current.name != this.name) {
                    return;
                }

                // we are dragging!
                Hammer.detection.current.name = this.name;

                // lock drag to axis?
                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {
                    ev.drag_locked_to_axis = true;
                }
                var last_direction = Hammer.detection.current.lastEvent.direction;
                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
                    // keep direction on the axis that the drag gesture started on
                    if(Hammer.utils.isVertical(last_direction)) {
                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                    }
                    else {
                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                // trigger normal event
                inst.trigger(this.name, ev);

                // direction event, like dragdown
                inst.trigger(this.name + ev.direction, ev);

                // block the browser events
                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
                    ev.preventDefault();
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
    name: 'transform',
    index: 45,
    defaults: {
        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
        transform_min_scale     : 0.01,
        // rotation in degrees
        transform_min_rotation  : 1,
        // prevent default browser behavior when two touches are on the screen
        // but it makes the element a blocking element
        // when you are using the transform gesture, it is a good practice to set this true
        transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // atleast multitouch
        if(ev.touches.length < 2) {
            return;
        }

        // prevent default when two fingers are on the screen
        if(inst.options.transform_always_block) {
            ev.preventDefault();
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                var scale_threshold = Math.abs(1-ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scale_threshold < inst.options.transform_min_scale &&
                    rotation_threshold < inst.options.transform_min_rotation) {
                    return;
                }

                // we are transforming!
                Hammer.detection.current.name = this.name;

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                inst.trigger(this.name, ev); // basic transform event

                // trigger rotate event
                if(rotation_threshold > inst.options.transform_min_rotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scale_threshold > inst.options.transform_min_scale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        // call preventDefault at touchstart, and makes the element blocking by
        // disabling the scrolling of the page, but it improves gestures like
        // transforming and dragging.
        // be careful with using this, it can be very annoying for users to be stuck
        // on the page
        prevent_default: false,

        // disable mouse events, so only touch (or pen!) input triggers events
        prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.prevent_default) {
            ev.preventDefault();
        }

        if(ev.eventType ==  Hammer.EVENT_START) {
            inst.trigger(this.name, ev);
        }
    }
};


/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

// node export
if(typeof module === 'object' && typeof module.exports === 'object'){
    module.exports = Hammer;
}
// just window export
else {
    window.Hammer = Hammer;

    // requireJS module definition
    if(typeof window.define === 'function' && window.define.amd) {
        window.define('hammer', [], function() {
            return Hammer;
        });
    }
}
})(this);

(function($, undefined) {
    'use strict';

    // no jQuery or Zepto!
    if($ === undefined) {
        return;
    }

    /**
     * bind dom events
     * this overwrites addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        eventTypes
     * @param   {Function}      handler
     */
    Hammer.event.bindDom = function(element, eventTypes, handler) {
        $(element).on(eventTypes, function(ev) {
            var data = ev.originalEvent || ev;

            // IE pageX fix
            if(data.pageX === undefined) {
                data.pageX = ev.pageX;
                data.pageY = ev.pageY;
            }

            // IE target fix
            if(!data.target) {
                data.target = ev.target;
            }

            // IE button fix
            if(data.which === undefined) {
                data.which = data.button;
            }

            // IE preventDefault
            if(!data.preventDefault) {
                data.preventDefault = ev.preventDefault;
            }

            // IE stopPropagation
            if(!data.stopPropagation) {
                data.stopPropagation = ev.stopPropagation;
            }

            handler.call(this, data);
        });
    };

    /**
     * the methods are called by the instance, but with the jquery plugin
     * we use the jquery event methods instead.
     * @this    {Hammer.Instance}
     * @return  {jQuery}
     */
    Hammer.Instance.prototype.on = function(types, handler) {
        return $(this.element).on(types, handler);
    };
    Hammer.Instance.prototype.off = function(types, handler) {
        return $(this.element).off(types, handler);
    };


    /**
     * trigger events
     * this is called by the gestures to trigger an event like 'tap'
     * @this    {Hammer.Instance}
     * @param   {String}    gesture
     * @param   {Object}    eventData
     * @return  {jQuery}
     */
    Hammer.Instance.prototype.trigger = function(gesture, eventData){
        var el = $(this.element);
        if(el.has(eventData.target).length) {
            el = $(eventData.target);
        }

        return el.trigger({
            type: gesture,
            gesture: eventData
        });
    };


    /**
     * jQuery plugin
     * create instance of Hammer and watch for gestures,
     * and when called again you can change the options
     * @param   {Object}    [options={}]
     * @return  {jQuery}
     */
    $.fn.hammer = function(options) {
        return this.each(function() {
            var el = $(this);
            var inst = el.data('hammer');
            // start new hammer instance
            if(!inst) {
                el.data('hammer', new Hammer(this, options || {}));
            }
            // change the options
            else if(inst && options) {
                Hammer.utils.extend(inst.options, options);
            }
        });
    };

})(window.jQuery || window.Zepto);

;
/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
    'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
    // add styles and attributes to the element to prevent the browser from doing
    // its native behavior. this doesnt prevent the scrolling, but cancels
    // the contextmenu, tap highlighting etc
    // set to false to disable this
    stop_browser_behavior: {
		// this also triggers onselectstart=false for IE
        userSelect: 'none',
		// this makes the element blocking in IE10 >, you could experiment with the value
		// see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
        touchAction: 'none',
		touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    }

    // more settings are defined per gesture at gestures.js
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = document;

// plugins namespace
Hammer.plugins = {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
        if(Hammer.gestures.hasOwnProperty(name)) {
            Hammer.detection.register(Hammer.gestures[name]);
        }
    }

    // Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);
	Hammer.event.onTouch(window.top, Hammer.EVENT_END, Hammer.detection.detect);
    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    this.element = element;

    // start/stop detection option
    this.enabled = true;

    // merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    // start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
        if(self.enabled) {
            Hammer.detection.startDetect(self, ev);
        }
    });

    // return instance
    return this;
};


Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    on: function onEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    off: function offEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     */
    trigger: function triggerEvent(gesture, eventData){
        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
		event.initEvent(gesture, true, true);
		event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Hammer.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }
        
        element.dispatchEvent(event);
        return this;
    },


    /**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    }
};

/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
    /**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     */
    bindDom: function(element, type, handler) {
        var types = type.split(' ');
        for(var t=0; t<types.length; t++) {
            element.addEventListener(types[t], handler, false);
        }
    },


    /**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     */
    onTouch: function onTouch(element, eventType, handler) {
		var self = this;

        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();

            // onmouseup, but when touchend has been fired we do nothing.
            // this is for touchdevices which also fire a mouseup on touchend
            if(sourceEventType.match(/mouse/) && touch_triggered) {
                return;
            }

            // mousebutton must be down or a touch event
            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen
                sourceEventType.match(/pointerdown/) || // pointerevents touch
                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
            ){
                enable_detect = true;
            }

            // we are in a touch event, set the touch triggered bool to true,
            // this for the conflicts that may occur on ios and android
            if(sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
            }

            // count the total touches on the screen
            var count_touches = 0;

            // when touch has been triggered in this detection session
            // and we are now handling a mouse event, we stop that to prevent conflicts
            if(enable_detect) {
                // update pointerevent
                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
                // touch
                else if(sourceEventType.match(/touch/)) {
                    count_touches = ev.touches.length;
                }
                // mouse
                else if(!touch_triggered) {
                    count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }

                // if we are in a end event, but when we remove one touch and
                // we still have enough, set eventType to move
                if(count_touches > 0 && eventType == Hammer.EVENT_END) {
                    eventType = Hammer.EVENT_MOVE;
                }
                // no touches, force the end event
                else if(!count_touches) {
                    eventType = Hammer.EVENT_END;
                }

                // because touchend has no touches, and we often want to use these in our gestures,
                // we send the last move event as our eventData in touchend
                if(!count_touches && last_move_event !== null) {
                    ev = last_move_event;
                }
                // store the last move event
                else {
                    last_move_event = ev;
                }

                // trigger the handler
                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                // remove pointerevent from list
                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
            }

            //debug(sourceEventType +" "+ eventType);

            // on the end we reset everything
            if(!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                Hammer.PointerEvent.reset();
            }
        });
    },


    /**
     * we have different events for each device/browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     */
    determineEventTypes: function determineEventTypes() {
        // determine the eventtype we want to set
        var types;

        // pointerEvents magic
        if(Hammer.HAS_POINTEREVENTS) {
            types = Hammer.PointerEvent.getEvents();
        }
        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
        else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'];
        }
        // for non pointer events browsers and mixed browsers,
        // like chrome on windows8 touch laptop
        else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'];
        }

        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    /**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     */
    getTouchList: function getTouchList(ev/*, eventType*/) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return Hammer.PointerEvent.getTouchList();
        }
        // get the touchlist
        else if(ev.touches) {
            return ev.touches;
        }
        // make fake touchlist from mouse position
        else {
            return [{
                identifier: 1,
                pageX: ev.pageX,
                pageY: ev.pageY,
                target: ev.target
            }];
        }
    },


    /**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     */
    collectEventData: function collectEventData(element, eventType, ev) {
        var touches = this.getTouchList(ev, eventType);

        // find out pointerType
        var pointerType = Hammer.POINTER_TOUCH;
        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
            pointerType = Hammer.POINTER_MOUSE;
        }

        return {
            center      : Hammer.utils.getCenter(touches),
            timeStamp   : new Date().getTime(),
            target      : ev.target,
            touches     : touches,
            eventType   : eventType,
            pointerType : pointerType,
            srcEvent    : ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                if(this.srcEvent.preventManipulation) {
                    this.srcEvent.preventManipulation();
                }

                if(this.srcEvent.preventDefault) {
                    this.srcEvent.preventDefault();
                }
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Hammer.detection.stopDetect();
            }
        };
    }
};

Hammer.PointerEvent = {
    /**
     * holds all pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get a list of pointers
     * @returns {Array}     touchlist
     */
    getTouchList: function() {
        var self = this;
        var touchlist = [];

        // we can use forEach since pointerEvents only is in IE10
        Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     */
    updatePointer: function(type, pointerEvent) {
        if(type == Hammer.EVENT_END) {
            this.pointers = {};
        }
        else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }

        return Object.keys(this.pointers).length;
    },

    /**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     */
    matchType: function(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var types = {};
        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
        return types[pointerType];
    },


    /**
     * get events
     */
    getEvents: function() {
        return [
            'pointerdown MSPointerDown',
            'pointermove MSPointerMove',
            'pointerup pointercancel MSPointerUp MSPointerCancel'
        ];
    },

    /**
     * reset the list
     */
    reset: function() {
        this.pointers = {};
    }
};


Hammer.utils = {
    /**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
	 * @parm	{Boolean}	merge		do a merge
     * @returns {Object}    dest
     */
    extend: function extend(dest, src, merge) {
        for (var key in src) {
			if(dest[key] !== undefined && merge) {
				continue;
			}
            dest[key] = src[key];
        }
        return dest;
    },


    /**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     */
    hasParent: function(node, parent) {
        while(node){
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },


    /**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     */
    getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];

        for(var t= 0,len=touches.length; t<len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
        }

        return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
        };
    },


    /**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     */
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
            x: Math.abs(delta_x / delta_time) || 0,
            y: Math.abs(delta_y / delta_time) || 0
        };
    },


    /**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY,
            x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 / Math.PI;
    },


    /**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX),
            y = Math.abs(touch1.pageY - touch2.pageY);

        if(x >= y) {
            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
        }
        else {
            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
        }
    },


    /**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX,
            y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x*x) + (y*y));
    },


    /**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) /
                this.getDistance(start[0], start[1]);
        }
        return 1;
    },


    /**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) -
                this.getAngle(start[1], start[0]);
        }
        return 0;
    },


    /**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     */
    isVertical: function isVertical(direction) {
        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    /**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     */
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
        var prop,
            vendors = ['webkit','khtml','moz','ms','o',''];

        if(!css_props || !element.style) {
            return;
        }

        // with css properties for modern browsers
        for(var i = 0; i < vendors.length; i++) {
            for(var p in css_props) {
                if(css_props.hasOwnProperty(p)) {
                    prop = p;

                    // vender prefix at the property
                    if(vendors[i]) {
                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                    }

                    // set the style
                    element.style[prop] = css_props[p];
                }
            }
        }

        // also the disable onselectstart
        if(css_props.userSelect == 'none') {
            element.onselectstart = function() {
                return false;
            };
        }
    }
};

Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,


    /**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        this.current = {
            inst        : inst, // reference to HammerInstance we're working for
            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent   : false, // last eventData
            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },


    /**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // instance options
        var inst_options = this.current.inst.options;

        // call Hammer.gesture handlers
        for(var g=0,len=this.gestures.length; g<len; g++) {
            var gesture = this.gestures[g];

            // only when the instance options have enabled this gesture
            if(!this.stopped && inst_options[gesture.name] !== false) {
                // if a handler returns false, we stop with the detection
                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                    this.stopDetect();
                    break;
                }
            }
        }

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        // endevent, but not the last touch, so dont stop
        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {
            this.stopDetect();
        }

        return eventData;
    },


    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Hammer.utils.extend({}, this.current);

        // reset the current
        this.current = null;

        // stopped!
        this.stopped = true;
    },


    /**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     */
    extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;

        // if the touches change, set the new touches over the startEvent touches
        // this because touchevents don't have all the touches on touchstart, or the
        // user must place his fingers at the EXACT same time on the screen, which is not realistic
        // but, sometimes it happens that both fingers are touching at the EXACT same time
        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            // extend 1 level deep to get the touchlist with the touch objects
            startEv.touches = [];
            for(var i=0,len=ev.touches.length; i<len; i++) {
                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
            }
        }

        var delta_time = ev.timeStamp - startEv.timeStamp,
            delta_x = ev.center.pageX - startEv.center.pageX,
            delta_y = ev.center.pageY - startEv.center.pageY,
            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

        Hammer.utils.extend(ev, {
            deltaTime   : delta_time,

            deltaX      : delta_x,
            deltaY      : delta_y,

            velocityX   : velocity.x,
            velocityY   : velocity.y,

            distance    : Hammer.utils.getDistance(startEv.center, ev.center),
            angle       : Hammer.utils.getAngle(startEv.center, ev.center),
            direction   : Hammer.utils.getDirection(startEv.center, ev.center),

            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

            startEvent  : startEv
        });

        return ev;
    },


    /**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Hammer.utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if (a.index < b.index) {
                return -1;
            }
            if (a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


Hammer.gestures = Hammer.gestures || {};

/**
 * Custom gestures
 * ==============================
 *
 * Gesture object
 * --------------------
 * The object structure of a gesture:
 *
 * { name: 'mygesture',
 *   index: 1337,
 *   defaults: {
 *     mygesture_option: true
 *   }
 *   handler: function(type, ev, inst) {
 *     // trigger gesture event
 *     inst.trigger(this.name, ev);
 *   }
 * }

 * @param   {String}    name
 * this should be the name of the gesture, lowercase
 * it is also being used to disable/enable the gesture per instance config.
 *
 * @param   {Number}    [index=1000]
 * the index of the gesture, where it is going to be in the stack of gestures detection
 * like when you build an gesture that depends on the drag gesture, it is a good
 * idea to place it after the index of the drag gesture.
 *
 * @param   {Object}    [defaults={}]
 * the default settings of the gesture. these are added to the instance settings,
 * and can be overruled per instance. you can also add the name of the gesture,
 * but this is also added by default (and set to true).
 *
 * @param   {Function}  handler
 * this handles the gesture detection of your custom gesture and receives the
 * following arguments:
 *
 *      @param  {Object}    eventData
 *      event data containing the following properties:
 *          timeStamp   {Number}        time the event occurred
 *          target      {HTMLElement}   target element
 *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
 *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
 *          center      {Object}        center position of the touches. contains pageX and pageY
 *          deltaTime   {Number}        the total time of the touches in the screen
 *          deltaX      {Number}        the delta on x axis we haved moved
 *          deltaY      {Number}        the delta on y axis we haved moved
 *          velocityX   {Number}        the velocity on the x
 *          velocityY   {Number}        the velocity on y
 *          angle       {Number}        the angle we are moving
 *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
 *          distance    {Number}        the distance we haved moved
 *          scale       {Number}        scaling of the touches, needs 2 touches
 *          rotation    {Number}        rotation of the touches, needs 2 touches *
 *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
 *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
 *          startEvent  {Object}        contains the same properties as above,
 *                                      but from the first touch. this is used to calculate
 *                                      distances, deltaTime, scaling etc
 *
 *      @param  {Hammer.Instance}    inst
 *      the instance we are doing the detection for. you can get the options from
 *      the inst.options object and trigger the gesture event by calling inst.trigger
 *
 *
 * Handle gestures
 * --------------------
 * inside the handler you can get/set Hammer.detection.current. This is the current
 * detection session. It has the following properties
 *      @param  {String}    name
 *      contains the name of the gesture we have detected. it has not a real function,
 *      only to check in other gestures if something is detected.
 *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
 *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
 *
 *      @readonly
 *      @param  {Hammer.Instance}    inst
 *      the instance we do the detection for
 *
 *      @readonly
 *      @param  {Object}    startEvent
 *      contains the properties of the first gesture detection in this session.
 *      Used for calculations about timing, distance, etc.
 *
 *      @readonly
 *      @param  {Object}    lastEvent
 *      contains all the properties of the last gesture detect in this session.
 *
 * after the gesture detection session has been completed (user has released the screen)
 * the Hammer.detection.current object is copied into Hammer.detection.previous,
 * this is usefull for gestures like doubletap, where you need to know if the
 * previous gesture was a tap
 *
 * options that have been set by the instance can be received by calling inst.options
 *
 * You can trigger a gesture event by calling inst.trigger("mygesture", event).
 * The first param is the name of your gesture, the second the event argument
 *
 *
 * Register gestures
 * --------------------
 * When an gesture is added to the Hammer.gestures object, it is auto registered
 * at the setup of the first Hammer instance. You can also call Hammer.detection.register
 * manually and pass your gesture object as a param
 *
 */

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
    name: 'hold',
    index: 10,
    defaults: {
        hold_timeout	: 500,
        hold_threshold	: 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
        switch(ev.eventType) {
            case Hammer.EVENT_START:
                // clear any running timers
                clearTimeout(this.timer);

                // set the gesture so we can check in the timeout if it still is
                Hammer.detection.current.name = this.name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                this.timer = setTimeout(function() {
                    if(Hammer.detection.current.name == 'hold') {
                        inst.trigger('hold', ev);
                    }
                }, inst.options.hold_timeout);
                break;

            // when you move or end we clear the timer
            case Hammer.EVENT_MOVE:
                if(ev.distance > inst.options.hold_threshold) {
                    clearTimeout(this.timer);
                }
                break;

            case Hammer.EVENT_END:
                clearTimeout(this.timer);
                break;
        }
    }
};


/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
    name: 'tap',
    index: 100,
    defaults: {
        tap_max_touchtime	: 250,
        tap_max_distance	: 10,
		tap_always			: true,
        doubletap_distance	: 20,
        doubletap_interval	: 300
    },
    handler: function tapGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // previous gesture, for the double tap since these are two different gesture detections
            var prev = Hammer.detection.previous,
				did_doubletap = false;

            // when the touchtime is higher then the max touch time
            // or when the moving distance is too much
            if(ev.deltaTime > inst.options.tap_max_touchtime ||
                ev.distance > inst.options.tap_max_distance) {
                return;
            }

            // check if double tap
            if(prev && prev.name == 'tap' &&
                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
                ev.distance < inst.options.doubletap_distance) {
				inst.trigger('doubletap', ev);
				did_doubletap = true;
            }

			// do a single tap
			if(!did_doubletap || inst.options.tap_always) {
				Hammer.detection.current.name = 'tap';
				inst.trigger(Hammer.detection.current.name, ev);
			}
        }
    }
};


/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        // set 0 for unlimited, but this can conflict with transform
        swipe_max_touches  : 1,
        swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // max touches
            if(inst.options.swipe_max_touches > 0 &&
                ev.touches.length > inst.options.swipe_max_touches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > inst.options.swipe_velocity ||
                ev.velocityY > inst.options.swipe_velocity) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
    name: 'drag',
    index: 50,
    defaults: {
        drag_min_distance : 10,
        // set 0 for unlimited, but this can conflict with transform
        drag_max_touches  : 1,
        // prevent default browser behavior when dragging occurs
        // be careful with it, it makes the element a blocking element
        // when you are using the drag gesture, it is a good practice to set this true
        drag_block_horizontal   : false,
        drag_block_vertical     : false,
        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
        // It disallows vertical directions if the initial direction was horizontal, and vice versa.
        drag_lock_to_axis       : false,
        // drag lock only kicks in when distance > drag_lock_min_distance
        // This way, locking occurs only when the distance has become large enough to reliably determine the direction
        drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // max touches
        if(inst.options.drag_max_touches > 0 &&
            ev.touches.length > inst.options.drag_max_touches) {
            return;
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.drag_min_distance &&
                    Hammer.detection.current.name != this.name) {
                    return;
                }

                // we are dragging!
                Hammer.detection.current.name = this.name;

                // lock drag to axis?
                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {
                    ev.drag_locked_to_axis = true;
                }
                var last_direction = Hammer.detection.current.lastEvent.direction;
                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
                    // keep direction on the axis that the drag gesture started on
                    if(Hammer.utils.isVertical(last_direction)) {
                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                    }
                    else {
                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                // trigger normal event
                inst.trigger(this.name, ev);

                // direction event, like dragdown
                inst.trigger(this.name + ev.direction, ev);

                // block the browser events
                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
                    ev.preventDefault();
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
    name: 'transform',
    index: 45,
    defaults: {
        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
        transform_min_scale     : 0.01,
        // rotation in degrees
        transform_min_rotation  : 1,
        // prevent default browser behavior when two touches are on the screen
        // but it makes the element a blocking element
        // when you are using the transform gesture, it is a good practice to set this true
        transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // atleast multitouch
        if(ev.touches.length < 2) {
            return;
        }

        // prevent default when two fingers are on the screen
        if(inst.options.transform_always_block) {
            ev.preventDefault();
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                var scale_threshold = Math.abs(1-ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scale_threshold < inst.options.transform_min_scale &&
                    rotation_threshold < inst.options.transform_min_rotation) {
                    return;
                }

                // we are transforming!
                Hammer.detection.current.name = this.name;

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                inst.trigger(this.name, ev); // basic transform event

                // trigger rotate event
                if(rotation_threshold > inst.options.transform_min_rotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scale_threshold > inst.options.transform_min_scale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        // call preventDefault at touchstart, and makes the element blocking by
        // disabling the scrolling of the page, but it improves gestures like
        // transforming and dragging.
        // be careful with using this, it can be very annoying for users to be stuck
        // on the page
        prevent_default: false,

        // disable mouse events, so only touch (or pen!) input triggers events
        prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.prevent_default) {
            ev.preventDefault();
        }

        if(ev.eventType ==  Hammer.EVENT_START) {
            inst.trigger(this.name, ev);
        }
    }
};


/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

// node export
if(typeof module === 'object' && typeof module.exports === 'object'){
    module.exports = Hammer;
}
// just window export
else {
    window.Hammer = Hammer;

    // requireJS module definition
    if(typeof window.define === 'function' && window.define.amd) {
        window.define('hammer', [], function() {
            return Hammer;
        });
    }
}
})(this);
;
/* 
 * dz - AVL Tree implementation
 *
 * An AVL tree is a self-balancing binary search tree with average and 
 * worst case O(log n) for all basic operations, including min, max, and 
 * lookup. This makes it highly favorable for our purposes in storing 
 * displays and keyframes as they must be kept sorted but also be faster 
 * than O(n) for lookup since many interactions revolve around an 
 * arbitarily selected object of the larger set of all such objects, as 
 * determined by user interaction. 
 * 
 * This implementation requires that you define a comparator function
 * that is then passed in, which it will use to sort your nodes. The 
 * comparator should take nodes a and b and, using their properties, 
 * return either -1 if a < b, 1 if a > b, and 0 if they have equal value. 
 * The AVLNode will adopt this comparison function so that nodes may be 
 * compared by their keys.
 * 
 * Example comparator:
 * var comparator = function (a, b) {
 *   if (a.key < b.key) {
 *       return -1;
 *   } else if (a.key > b.key) {
 *       return 1;
 *   } else {
 *       return 0;
 *   }
 * };
 *
 * The implementation also requires that you define a valuation function,
 * which works kinda like a comparator except it is lopsided. The first 
 * parameter should be a raw value of the comparison property (i.e. a 
 * raw key value) and the second should be an object posessing the 
 * comparison property. In short, it's a comparator that compares a raw
 * value to an extracted property.
 * 
 * Example valuation function:
 * var valuation = function (value, compareToNode) {
 *    if (!compareToNode) {
 *        return null;
 *    } else if (value < compareToNode.key) {
 *        return -1;
 *    } else if (value > compareToNode.key) {
 *        return 1;
 *    } else {
 *        return 0;
 *    }
 * }
 * 
 */

function AVLTree(comparator, valuation) {
    "use strict";
    this._comparator = comparator;
    this._root = null; // the root node
    this._intermediates = []; // used to track intermediate steps while doing traversals; used for finding previous/next nodes
    this._current = null; // the current node being evaluated
    this._valuation = valuation; // IMPORTANT: _valuation must return null/false/some falsey value if the node is null/undefined.
}

// public add
AVLTree.prototype.add = function (toAdd) {
    // if first node, make the root node and return it
    if (!this._root) {
        this._root = new AVLNode(toAdd, this._comparator);
        return this._root;
    } else {
        // otherwise add the node and let the AVL mechanism balance + sort the tree
        var added = this._root.add(toAdd);
        this._root = added[0];
        if (!added[1] || !added[0]) {
            console.log("failed to add data");
        }
        return added[1];
    }
};

// public remove
AVLTree.prototype.remove = function (toRemove) {
    if (this._root) {
        var removed = this._root.remove(toRemove)
        this._root = removed[0];
        return removed[1];
    } else {
        return null;
    }
}

// public find
AVLTree.prototype.find = function (toFind) {
    var found = this._find(toFind);

    return (found) ? found._value : null;
};

// isEmpty
AVLTree.prototype.isEmpty = function () {
    return this._root === null || this._root === undefined;
};

AVLTree.prototype.map = function (forEach) {
    var contents = this.getContents();
    var i;
    for (i = 0; i < contents.length; i++) {
        forEach(contents[i]);
    }
};

AVLTree.prototype.getContents = function () {
    var contents = [];
    var temp = [];
    if (!this._root) {
        return [];
    }
    var node = this._root;
    while (temp.length > 0 || node != null) {
        if (node) {
            temp.push(node);
            node = node._left;
        } else {
            node = temp.pop();
            contents.push(node._value);
            node = node._right;
        }
    }

    return contents;
};

/*******testing purposes only*******/
AVLTree.prototype.printAVL = function () {
    var contents = this.getContents();
    
    for (var i=0; i<contents.length; i++){
        console.log(contents[i].key);
    }
};

// deep clone
AVLTree.prototype.clone = function (cont) {
    var contents = cont || this.getContents();
    var i;
    var dClone = new AVLTree(this._comparator, this._valuation);
    for (i = 0; i < contents.length; i++) {
        dClone.add(contents[i]);
    }
    return dClone;
};

AVLTree.prototype.clear = function (onEach) {
    var nodes = this.getNodesPostorder();
    if (onEach) {
        nodes.map(onEach);
    }
    nodes.map(function (node) {
        node._left = null;
        node._right = null;
    });

    this._current = null;
    this._root = null;
    this._intermediates = [];
};

AVLTree.prototype.getNodesPostorder = function () {
    var contents = [];
    if (!this._root) {
        return [];
    }
    var node = this._root;
    this.postorderHelper(node, contents);
    return contents;
};

AVLTree.prototype.postorderHelper = function (node, container) {
    if (!node) { 
        return;
    }
    this.postorderHelper(node._left, container);
    this.postorderHelper(node._right, container);
    container.push(node);
};

/* 
 * public nearestNeighbors - pass in a position and use stored valuation function 
 * (modified comparator that compares a specified key to a node's key)
 * 
 * "direction" is used iff the position you are searching for exists already in 
 * the tree. It indicates which direction (in a linear scale) the constraint 
 * should "face". Leaving it blank will return the previous and next of the node 
 * matching your specified key. Specifying -1 makes it left-facing, which means
 * it will return the previous and the current 
 * 
 */
AVLTree.prototype.nearestNeighbors = function (position, direction) {
    var current = this._root;
    var leftbound, rightbound;

    while (current) {
        var compare = this._valuation(position, current._value);
        if (compare === 0) {
            if (direction === -1) {
                return [this.findPrevious(current._value), current._value];
            } else if (direction === 1) {
                return [current._value, this.findNext(current._value)]
            } else {
                return [this.findPrevious(current._value), this.findNext(current._value)];
            }
        } else if (compare > 0) {
            leftbound = current._value;
            current = current._right;
        } else {
            rightbound = current._value;
            current = current._left;
        }
    }
    return [leftbound, rightbound];
};

// debug function for nearestNeighbors
AVLTree.prototype.debugNN = function (value) {
    var result = this.nearestNeighbors(value);
    var a = (result[0]) ? result[0].key : "is null";
    var b = (result[1]) ? result[1].key : "is null";
    console.log(a + ", " + b);
}

// public findnext
AVLTree.prototype.findNext = function (current) {
    var currentNode = this._find(current, true);
    var next = this._next(currentNode);
    return (next) ? next._value : null;
};

// public findprevious
AVLTree.prototype.findPrevious = function (current) {
    var currentNode = this._find(current, true);
    var previous = this._previous(currentNode);
    return (previous) ? previous._value : null;
};

// public max
AVLTree.prototype.max = function () {
    var maximum = this._max();
    return (maximum) ? maximum._value : null;
};

// public min
AVLTree.prototype.min = function () {
    var minimum = this._min();
    return (minimum) ? minimum._value : null;
};

// public next (relative to current)
AVLTree.prototype.next = function () {
    this._current = this._next(this._current);
    return (this._current) ? this._current._value : null;
};

// public previous (relative to current)
AVLTree.prototype.previous = function () {
    this._current = this._previous(this._current);
    return (this._current) ? this._current._value : null;
};

AVLTree.prototype.isSolo = function () {
    if (!this._root._left && !this._root._right) {
        return true;
    } else {
        return false;
    }
};


/////////////////////////////
// Private functions below //
/////////////////////////////

// search for a specific node
AVLTree.prototype._find = function (toFind, saveSteps) {
    saveSteps = saveSteps || false;

    var found = this._root;
    if (saveSteps) {
        this._intermediates = [];
    }

    while (found !== null) {
        // find the outcome of the compare function
        var compare = this._comparator(toFind, found._value);

        // if not 0, then they are not identical and therefore we continue searching based upon the comparator's output
        // and the AVL tree's sorted characteristics
        if (compare !== 0) {
            // first save step if necessary 
            if (saveSteps) {
                this._intermediates.push(found);
            }
            
            // decide which way to go on the tree
            if (compare < 0) {
                found = found._left;
            } else {
                found = found._right;
            }
        } else {
            // if identical then we break the while loop because we've found what we wanted
            break;
        }
    }
    return found;
};

// find the node with minimum value, with optional choice to search only the subtree starting at a given node
AVLTree.prototype._min = function (start, saveSteps) {
    var current = start || this._root;
    saveSteps = saveSteps || false;

    // to find min we just have to find the leftmost node (not necessarily in the lowest layer)
    if (current) {
        while (current._left) {
            if (saveSteps) {
                this._intermediates.push(start)
            }
            current = current._left;
        }
    }
    return current;
};

// find the node with maximum value, with optional choice to search only the subtree starting at a given node
AVLTree.prototype._max = function (start, saveSteps) {
    var current = start || this._root;
    saveSteps = saveSteps || false;

    // to find max we just have to find the rightmost node (not necessarily in the lowest layer)
    if (current) {
        while (current._right) {
            if (saveSteps) {
                this._intermediates.push(start)
            }
            current = current._right;
        }
    }
    return current;
};

// find the subsequent node of the specified node as determined by key value order
AVLTree.prototype._next = function (current) {
    // if a node is specified, we find the subsequent node
    if (current) {
        // if there is a right child, we find the minimum node of the subtree beginning at the specified node
        if (current._right) {
            this._intermediates.push(current);
            current = this._min(current._right, true);
        } else {
            // if there is no right child we have to backtrack up the tree
            var intermediates = this._intermediates;
            var previous = intermediates.pop();

            // backtrack until we have left the immediate subtree containing the specified node
            while (previous && previous._right === current) {
                current = previous;
                previous = intermediates.pop();
            }
            
            // and then store that parent node as the next
            current = previous;
        }
    } else {
        // if node is unspecified we return the minimum node of the AVL tree.
        this._intermediates = [];
        current = this._min(this._root, true);
    }

    return current;
};

// find the previous node of the specified node as determined by key value order
AVLTree.prototype._previous = function (current) {
    // if a node is specified, we find the subsequent node
    if (current) {
        // if there is a left child, we find the minimum node of the subtree beginning at the specified node
        if (current._left) {
            this._intermediates.push(current);
            current = this._max(current._left, true);
        } else {
            // if there is no left child we have to backtrack up the tree
            var intermediates = this._intermediates;
            var previous = intermediates.pop();

            // backtrack until we have left the immediate subtree containing the specified node
            while (previous && previous._left === current) {
                current = previous;
                previous = intermediates.pop();
            }

            // and then store that parent node as the next
            current = previous;
        }
    } else {
        // if node is unspecified we return the maximum node of the AVL tree.
        this._intermediates = [];
        current = this._max(this._root, true);
    }

    return current;
};
;
/*
 * dz - AVL Tree Node for AVL Tree implementation
 * 
 * This AVLNode performs various things like tree rebalancing, node 
 * removal, etc. among other things. You should never have to deal 
 * with the nodes directly if you are just using the AVL tree.
 * 
 */

function AVLNode(value, comparator) {
    "use strict";
    this._comparator = comparator;
    this._left = null;
    this._right = null;
    this._value = value;
    this._height = 1;
}

// adds new node
AVLNode.prototype.add = function (toAdd) {
    var compare = this._comparator(toAdd, this._value);
    var added; // array with (potentially) new child node after balancing + newly added node
    var addedNode;

    if (compare !== 0) {
        if (compare < 0) {
            if (this._left) {
                added = this._left.add(toAdd);
                this._left = added[0];
                addedNode = added[1];
            } else {
                this._left = new AVLNode(toAdd, this._comparator);
                addedNode = this._left;
            }
        } else if (compare > 0) {
            if (this._right) {
                added = this._right.add(toAdd);
                this._right = added[0];
                addedNode = added[1];
            } else {
                this._right = new AVLNode(toAdd, this._comparator);
                addedNode = this._right;
            }
        }
        return [this.balanceTree(), addedNode];
    } else {
        return [this, this];
    }
};

// remove node from tree
AVLNode.prototype.remove = function (toRemove) {
    var compare = this._comparator(toRemove, this._value);
    var removed;
    var removedNode;
    var newTree;

    if (compare) {
        if (compare < 0) {
            if (this._left) {
                removed = this._left.remove(toRemove);
                this._left = removed[0];
                removedNode = removed[1];
            } else {
                removedNode = null;
            }
        } else {
            if (this._right) {
                removed = this._right.remove(toRemove);
                this._right = removed[0];
                removedNode = removed[1];
            } else {
                removedNode = null;
            }
        }
        newTree = this;
    } else {
        removedNode = this;
        if (this._left == null) {
            newTree = this._right;
        } else if (this._right == null) {
            newTree = this._left;
        } else {
            newTree = this._left.merge(this._right);
            this._left = null;
            this._right = null;
        }
    }

    if (removedNode) {
        if (newTree) {
            return [newTree.balanceTree(), removedNode];
        } else {
            return [newTree, removedNode];
        }
    } else {
        return [this, null];
    }
};

// balances the AVL tree so that it maintains optimal properties.
AVLNode.prototype.balanceTree = function () {
    var leftHeight = (this._left != null) ? this._left._height : 0;
    var rightHeight = (this._right != null) ? this._right._height : 0;

    if (leftHeight > rightHeight + 1) {
        return this.swingRight();
    } else if (rightHeight > leftHeight + 1) {
        return this.swingLeft();
    } else {
        this.setHeight();
        return this;
    }

    return result;
};

// merges two trees into one
AVLNode.prototype.merge = function (toMerge) {
    if (toMerge == null) {
        return this;
    } else {
        var top;
        if (this._height > toMerge._height) {
            top = this;
            top._right = toMerge.merge(top._right);
        } else {
            top = toMerge;
            top._left = this.merge(top._left);
        }
        return top.balanceTree();
    }
};

// move nodes towards the left subtree
AVLNode.prototype.moveLeft = function () {
    var right = this._right;
    var rightLeft = right._left;

    this._right = rightLeft;
    right._left = this;
    this.setHeight();
    right.setHeight();
    return right;
};

// move nodes towards the right subtree
AVLNode.prototype.moveRight = function () {
    var left = this._left;
    var leftRight = left._right;

    this._left = leftRight;
    left._right = this;
    this.setHeight();
    left.setHeight();
    return left;
};


// set height of the node to be 1 + that of its children.
AVLNode.prototype.setHeight = function () {
    var leftHeight = (this._left) ? this._left._height : 0;
    var rightHeight = (this._right) ? this._right._height : 0;

    this._height = (leftHeight < rightHeight) ? rightHeight + 1 : leftHeight + 1;
};


// swing tree to the left 
AVLNode.prototype.swingLeft = function () {
    var right = this._right;
    var rightLeft = right._left;
    var rightRight = right._right;
    var left = this._left;

    var leftHeight = (left) ? left._height : 0;
    var rightLeftHeight = (rightLeft) ? rightLeft._height : 0;
    var rightRightHeight = (rightRight) ? rightRight._height : 0;

    if (rightLeftHeight > rightRightHeight) {
        this._right = right.moveRight();
    }

    return this.moveLeft();
};


// swing tree to the right
AVLNode.prototype.swingRight = function () {
    var left = this._left;
    var leftRight = left._right;
    var leftLeft = left._left;
    var right = this._right;

    var rightHeight = (right != null) ? right._height : 0;
    var leftRightHeight = (leftRight != null) ? leftRight._height : 0;
    var leftLeftHeight = (leftLeft != null) ? leftLeft._height : 0;

    if (leftRightHeight > leftLeftHeight) {
        this._left = left.moveLeft();
    }

    return this.moveRight();
};


// traverse entire tree
AVLNode.prototype.traverse = function (func) {
    if (this._left) {
        this._left.traverse(func);
    }

    func(this);

    if (this._right) {
        this._right.traverse(func);
    }
};


// toString for debugging printlines
AVLNode.prototype.toString = function () {
    return this._value.toString();
};
;
/*
* dz - speedy array-based implementation of a binary heap
* can select maxheap or minheap by passing in a scoring function.
* first item of array is the min/max
*/

function binaryHeap(scoreFunction) {
    "use strict";
    this.content = [];
    this.scoreFunction = scoreFunction || function (a) {
        return a;
    };
}

binaryHeap.prototype = {
    push: function (element) {
        // Add the new element to the end of the array.
        this.content.push(element);
        // Allow it to bubble up.
        this.bubbleUp(this.content.length - 1);
    },

    pop: function () {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it sink down.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
        }
        return result;
    },

    peek: function () {
        // show the top of the heap without removing it
        return this.content[0];
    },

    remove: function (node) {
        var length = this.content.length;
        // To remove a value, we must search through the array to find
        // it.
        for (var i = 0; i < length; i++) {
            if (this.content[i] !== node) {
                continue; 
            }

            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();

            // If the element we popped was the one we needed to remove,
            // we're done.
            if (i == length - 1) { 
                break; 
            }

            // Otherwise, we replace the removed element with the popped
            // one, and allow it to float up or sink down as appropriate.
            this.content[i] = end;
            this.bubbleUp(i);
            this.sinkDown(i);
            break;
        }
    },

    size: function () {
        return this.content.length;
    },

    // Finds a node with the specified value. A valuation function that indicates
    // how to find the value of the objects being stored must be passed in.
    findValue: function(value, valuation) {
        var length = this.content.length;
        var found;
        // To remove a value, we must search through the array to find
        // it.
        for (var i = 0; i < length; i++) {
            if (valuation(this.content[i]) !== value) {
                continue;
            }

            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();

            // If the element we popped was the one we needed to remove,
            // we're done.
            if (i == length - 1) {
                found = end;
                break;
            }

            // Otherwise, we replace the removed element with the popped
            // one, and allow it to float up or sink down as appropriate.
            this.content[i] = end;
            this.bubbleUp(i);
            this.sinkDown(i);
            break;
        }
        return found;
    },

    bubbleUp: function (n) {
        // Fetch the element that has to be moved.
        var element = this.content[n],
            score = this.scoreFunction(element);
        // When at 0, an element can not go up any further.
        while (n > 0) {
            // Compute the parent element's index, and fetch it.
            var parentN = Math.floor((n + 1) / 2) - 1,
                parent = this.content[parentN];
            // If the parent has a lesser score, things are in order and we
            // are done.
            if (score >= this.scoreFunction(parent)) break;

            // Otherwise, swap the parent with the current element and
            // continue.
            this.content[parentN] = element;
            this.content[n] = parent;
            n = parentN;
        }
    },

    sinkDown: function (n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while (true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) * 2,
                child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N],
                    child1Score = this.scoreFunction(child1);
                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore) swap = child1N;
            }
            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;
            }

            // No need to swap further, we are done.
            if (swap == null) break;

            // Otherwise, swap and continue.
            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
        }
    },

    find: function (node) {
        var length = this.content.length;
        var found;
        // To remove a value, we must search through the array to find
        // it.
        for (var i = 0; i < length; i++) {
            if (this.content[i] !== node) {
                continue;
            }

            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();

            // If the element we popped was the one we needed to remove,
            // we're done.
            if (i == length - 1) {
                found = end;
                break;
            }

            // Otherwise, we replace the removed element with the popped
            // one, and allow it to float up or sink down as appropriate.
            this.content[i] = end;
            this.bubbleUp(i);
            this.sinkDown(i);
            break;
        }
        return found;
    },
};
;
/*
 * dz/lz - DataHolder
 * 
 * DataHolder is designed to be a centralized place to store all tour authoring data.
 */

function DataHolder() {
    "use strict";
    this._trackArray = [];
    this._scoreFunctionMin = function (a) {
        return a.bound;
    };
    this._selectedTrack;

    //multi-select heaps used for storing the movement constraints
    this._leftExternal = new binaryHeap(this._scoreFunctionMin);
    this._leftInternal = new binaryHeap(this._scoreFunctionMin);
    this._rightExternal = new binaryHeap(this._scoreFunctionMin);
    this._rightInternal = new binaryHeap(this._scoreFunctionMin);

    this._dispComparator = function (a, b) {
        if (a.display.getStart() < b.display.getStart()) {
            return -1;
        } else if (a.display.getStart() > b.display.getStart()) {
            return 1;
        } else {
            return 0;
        }
    };

    this._kfComparator = function (a, b) {
        if (a.getTime() < b.getTime()) {
            return -1;
        } else if (a.getTime() > b.getTime()) {
            return 1;
        } else {
            return 0;
        }
    };

    this._dispValuation = function (value, container) {
        if (!container) {
            return false;
        } else if (value < container.display.getStart()) {
            return -1;
        } else if (value > container.display.getStart()) {
            return 1;
        } else {
            return 0;
        }
    }

    this._kfValuation = function (value, keyframe) {
        if (!keyframe) {
            return false;
        } else if (value < keyframe.getTime()) {
            return -1;
        } else if (value > keyframe.getTime()) {
            return 1;
        } else {
            return 0;
        }
    }
};

DataHolder.prototype.reInitHeaps = function () {
    this._leftExternal = new binaryHeap(this._scoreFunctionMin);
    this._leftInternal = new binaryHeap(this._scoreFunctionMin);
    this._rightExternal = new binaryHeap(this._scoreFunctionMin);
    this._rightInternal = new binaryHeap(this._scoreFunctionMin);
}

/* TRACKS */
DataHolder.prototype.insertTrack = function (trackObj, index) {

    // DEBUG
    //var dupCheck = [];
    //for (var i = 0; i < this._trackArray.length; i++) {
    //    dupCheck.push(this._trackArray[i]);
    //}

    //if (dupCheck.indexOf(trackObj) >= 0) {
    //    console.log("DUPLICATE TRACK!");
    //}
    // end debug

    var newTrack = {
        track: trackObj,
        displays: new AVLTree(this._dispComparator, this._dispValuation),
    }
    trackObj.setStorageContainer(newTrack);


    if (typeof index === "undefined" || index === null) {
        this._trackArray.push(newTrack);
    } else {
        // if index is specified we are inserting before the track at the specified index
        this._trackArray.splice(index, 0, newTrack);
    }

    // step 2: sort track array and update tracks with array indices for positional awareness
    this.mapTracks(function (current, i) {
        current.track.updatePos(i);
    });
    // make sure the position record is within the trackObj - this is essential for O(1) lookup
    return newTrack;
};

DataHolder.prototype.removeTrack = function (trackObj) {
    // find track dataholder object using its array index, stored by the track object
    var toRemove = this._trackArray[trackObj.getPos()];

    // remove track from array
    this._trackArray.splice(trackObj.getPos(), 1);
    // update array
    this.mapTracks(function (current, i) {
        current.track.updatePos(i);
    });

    // return the dataholder object
    return toRemove;
};

// ----- for selectTrack and getSelectedTrack -----
// NOTE: takes in a TRACK OBJECT - this is not the same as the container object that is inserted
// into this._trackArray!
//
// It is the same as the .track object stored within the container, e.g. this._trackArray[5].track
DataHolder.prototype.selectTrack = function (trackObj) {
    this._selectedTrack = trackObj;
};

DataHolder.prototype.getSelectedTrack = function () {
    return this._selectedTrack;
};

DataHolder.prototype.indexOfTrack = function (trackObj) {
    var i;
    for (i = 0; i < this._trackArray.length; i++) {
        var current = this._trackArray[i];
        if (current.track = trackObj) {
            return i;
        }
    }
    return false;
};

DataHolder.prototype.mapTracks = function (action) {
    this._trackArray.map(action);
};

//note: display also calls getType(), on my.getType(), so look to replace there if possible?
DataHolder.prototype.getType = function (trackObj) {
    return trackObj.getType();
};

DataHolder.prototype.getInkEnabled = function (trackObj) {
    return trackObj.getInkEnabled();
};

DataHolder.prototype.getInkLink = function (trackObj) {
    return trackObj.getInkLink();
};

DataHolder.prototype.getTracks = function () {
    return this._trackArray;
};

DataHolder.prototype.numTracks = function () {
    return this._trackArray.length;
};

DataHolder.prototype.findTrackByTitle = function (title) {
    var i;
    for (i = 0; i < this._trackArray.length; i++) {
        if (this._trackArray[i].track.getTitle() === title) {
            return this._trackArray[i].track;
        }
    }
    return null;
}


/* 
    * DISPLAYS 
    * Displays are stored in a container along with a sub-AVL tree for the display's keyframes.
    * They are aware of their own container for O(1) access to a display's keyframes as well as 
    * to facilitate searching within the AVL tree.
    * 
    */
DataHolder.prototype.addDisplay = function (trackNum, displayObj) {
    var parentTrack = this._trackArray[trackNum];
    var keyframes = new AVLTree(this._kfComparator, this._kfValuation);
    var newDisplay = {
        display: displayObj,
        keyframes: keyframes,
        displayTree: parentTrack.displays,
        hostTrack: parentTrack.track,
    }
    parentTrack.displays.add(newDisplay);
    displayObj.setStorageContainer(newDisplay);
    displayObj.setKeyframeTree(keyframes);
    this.mapDisplays(parentTrack, function (disp, i) {
        disp.display.setID(i);
    });

    return newDisplay;
};

DataHolder.prototype.mapDisplays = function (track, action) {
    track.displays.map(action);
}

DataHolder.prototype.removeDisplay = function (trackNum, displayObj) {
    var parentTrack = this._trackArray[trackNum];
    var toRemove = displayObj.getStorageContainer();
    return parentTrack.displays.remove(toRemove);
};

DataHolder.prototype.findDisplay = function (trackNum, displayObj) {
    var parentTrack = this._trackArray[trackNum];
    var toFind = displayObj.getStorageContainer();
    return parentTrack.displays.find(toFind);
};

DataHolder.prototype.findPreviousDisplay = function (trackNum, displayObj) {
    var parentTrack = this._trackArray[trackNum];
    var toFind = displayObj.getStorageContainer();
    return parentTrack.displays.findPrevious(toFind);
};

DataHolder.prototype.findNextDisplay = function (trackNum, displayObj) {
    var parentTrack = this._trackArray[trackNum];
    var toFind = displayObj.getStorageContainer();
    return parentTrack.displays.findNext(toFind);
};

DataHolder.prototype.minDisplay = function (trackNum) {
    var parentTrack = this._trackArray[trackNum];
    return parentTrack.displays.min();
};

DataHolder.prototype.maxDisplay = function (trackNum) {
    var parentTrack = this._trackArray[trackNum];
    return parentTrack.displays.max();
};

DataHolder.prototype.replaceKeyframes = function (displayObj, kfClone) {
    displayObj.getStorageContainer().keyframes = kfClone;
};

DataHolder.prototype.getDisplays = function (trackNum) {
    return this._trackArray[trackNum] && this._trackArray[trackNum].displays;
};


/* 
    * KEYFRAMES 
    * These don't need a container object because they are the lowest "unit"
    *
    */
DataHolder.prototype.addKeyframe = function (displayObj, keyframe) {
    var parentDisplay = displayObj.getStorageContainer();
    parentDisplay.keyframes.add(keyframe);
    return newKeyframe;
};

DataHolder.prototype.removeKeyframe = function (displayObj, keyframe) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.remove(keyframe);
};

DataHolder.prototype.findKeyframe = function (displayObj, keyframe) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.find(keyframe);
};

DataHolder.prototype.findPrevKeyframe = function (displayObj, keyframe) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.findPrevious(keyframe);
};

DataHolder.prototype.findNextKeyframe = function (displayObj, keyframe) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.findNext(keyframe);
};

DataHolder.prototype.firstKeyframe = function (displayObj) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.min();
};

DataHolder.prototype.lastKeyframe = function (displayObj) {
    var parentDisplay = displayObj.getStorageContainer();
    return parentDisplay.keyframes.max();
};

DataHolder.prototype.mapKeyframes = function (display, action) {
    display.keyframes.map(action);
};

DataHolder.prototype.getKeyframes = function (display) {
    return display.keyframes;
};
;
function DoublyLinkedList() {
    "use strict";
    // pointer to first item
    this._head = null;
    // pointer to the last item
    this._tail = null;
    // length of list
    this._length = 0;
}

// Wraps data in a node object.
DoublyLinkedList.prototype._createNewNode = function (data) {
    var node = {
        data: data,
        next: null,
        prev: null
    };
    return node;
};

/*
    * Appends a node to the end of the list.
*/
DoublyLinkedList.prototype.append = function (data) {
    var node = this._createNewNode(data);

    if (this._length === 0) {

        // first node, so all pointers to this
        this._head = node;
        this._tail = node;
    } else {

        // put on the tail
        this._tail.next = node;
        node.prev = this._tail;
        this._tail = node;
    }

    // update count
    this._length++;

    return node;
};

/*
    * Prepends a node to the end of the list.
*/
DoublyLinkedList.prototype.prepend = function (data) {
    var node = this._createNewNode(data);

    if (this.first === null) {

        // we are empty, so this is the first node
        // use the same logic as append
        this.append(node);
        return;
    } else {

        // place before head
        this._head.prev = node;
        node.next = this._head;
        this._head = node;
    }

    // update count
    this._length++;

    return node;
};

/*
    * Returns the node at the specified index. The index starts at 0.
*/
DoublyLinkedList.prototype.item = function (index) {
    if (index >= 0 && index < this._length) {
        var node = this._head;
        while (index--) {
            node = node.next;
        }
        return node;
    }
};

DoublyLinkedList.prototype.search = function (key) {
    var node = this._head;
    while (node != null) {
        if (node.data === key) {
            return node;
        }
        node = node.next;
    }
    return null;
};

DoublyLinkedList.prototype.findNext = function (key) {
    var node = this._head;
    while (node != null) {
        if (node.data >= key) {
            return node;
        }
        node = node.next;
    }
    return null;
};
DoublyLinkedList.prototype.findPrev = function (key) {
    var node = this._head;
    while (node != null) {
        if (node.data >= key) {
            if (node.prev === null) {
                return null;
            } else {
                return node.prev;
            }
        }
        node = node.next;
    }
    return null;
};
/*
    * Returns the node at the head of the list.
*/
DoublyLinkedList.prototype.head = function () {
    return this._head;
};

/*
    * Returns the node at the tail of the list.
*/
DoublyLinkedList.prototype.tail = function () {
    return this._tail;
};

/*
    * Returns the size of the list.
*/
DoublyLinkedList.prototype.size = function () {
    return this._length;
};

/*******testing purposes only********/
DoublyLinkedList.prototype.printList = function () {
    var curNode = this._head;
    if (curNode === null) {
        console.log("Empty List\n");
    } else {
        console.log("Printing List...");
        for (var i = 0; i < this._length; i++) {
            console.log(curNode.data + " ");
            curNode = curNode.next;
        }
        console.log("\n");
    }
};


/*
    * Removes the item at the index.
*/
DoublyLinkedList.prototype.remove = function (index) {
    if (index < 0 || index >= this._length || this._length === 0) {
        console.log("index is out of bounds");
    } else {

        var curNode = this.item(index);
        var nxtNode = curNode.next;
        var prevNode = curNode.prev;

        if (nxtNode != null && prevNode != null) {
            prevNode.next = nxtNode;
            nxtNode.prev = prevNode;
        } else if (nxtNode === null && prevNode != null) {
            prevNode.next = null;
            this._tail = prevNode;
        } else if (prevNode === null && nxtNode != null) {
            nxtNode.prev = null;
            this._head = nxtNode;
        } else {
            this._head = null;
            this._tail = null;
        }

        this._length--;
        return curNode;
    }
};
;
function HashTable() {
    this._length = 0;
    this._items = {};
   
}

    HashTable.prototype.insert = function (key, value) {
        var previous = undefined;
        if (this._hasItem(key)) {
            previous = this._items[key];
        }
        else {
            this._length++;
        }
        this._items[key] = value;
        return previous;
    }

    HashTable.prototype.getLength = function (key) {
        return this._length;
    }

    HashTable.prototype.lookup = function (key) {
        return this._hasItem(key) ? this._items[key] : undefined;
    }

    HashTable.prototype._hasItem = function (key) {
        return this._items.hasOwnProperty(key);
    }

    HashTable.prototype.removeItem = function (key) {
        if (this._hasItem(key)) {
            previous = this._items[key];
            this._length--;
            delete this._items[key];
            return previous;
        }
        else {
            return undefined;
        }
    }

    HashTable.prototype.keys = function () {
        var keys = [];
        for (var k in this._items) {
            if (this._hasItem(k)) {
                keys.push(k);
            }
        }
        return keys;
    }

    HashTable.prototype.values = function () {
        var values = [];
        for (var k in this._items) {
            if (this._hasItem(k)) {
                values.push(this._items[k]);
            }
        }
        return values;
    }

    HashTable.prototype.each = function (fn) {
        for (var k in this._items) {
            if (this._hasItem(k)) {
                fn(k, this._items[k]);
            }
        }
    }

    HashTable.prototype.clear = function () {
        this._items = {}
        this._length = 0;
    }

;
(function(){if (!Date.now) Date.now = function() {
  return +new Date;
};
try {
  document.createElement("div").style.setProperty("opacity", 0, "");
} catch (error) {
  var d3_style_prototype = CSSStyleDeclaration.prototype,
      d3_style_setProperty = d3_style_prototype.setProperty;
  d3_style_prototype.setProperty = function(name, value, priority) {
    d3_style_setProperty.call(this, name, value + "", priority);
  };
}
d3 = {version: "2.9.6"}; // semver
function d3_class(ctor, properties) {
  try {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  } catch (e) {
    ctor.prototype = properties;
  }
}
var d3_array = d3_arraySlice; // conversion for NodeLists

function d3_arrayCopy(pseudoarray) {
  var i = -1, n = pseudoarray.length, array = [];
  while (++i < n) array.push(pseudoarray[i]);
  return array;
}

function d3_arraySlice(pseudoarray) {
  return Array.prototype.slice.call(pseudoarray);
}

try {
  d3_array(document.documentElement.childNodes)[0].nodeType;
} catch(e) {
  d3_array = d3_arrayCopy;
}

var d3_arraySubclass = [].__proto__?

// Until ECMAScript supports array subclassing, prototype injection works well.
function(array, prototype) {
  array.__proto__ = prototype;
}:

// And if your browser doesn't support __proto__, we'll use direct extension.
function(array, prototype) {
  for (var property in prototype) array[property] = prototype[property];
};
d3.map = function(object) {
  var map = new d3_Map;
  for (var key in object) map.set(key, object[key]);
  return map;
};

function d3_Map() {}

d3_class(d3_Map, {
  has: function(key) {
    return d3_map_prefix + key in this;
  },
  get: function(key) {
    return this[d3_map_prefix + key];
  },
  set: function(key, value) {
    return this[d3_map_prefix + key] = value;
  },
  remove: function(key) {
    key = d3_map_prefix + key;
    return key in this && delete this[key];
  },
  keys: function() {
    var keys = [];
    this.forEach(function(key) { keys.push(key); });
    return keys;
  },
  values: function() {
    var values = [];
    this.forEach(function(key, value) { values.push(value); });
    return values;
  },
  entries: function() {
    var entries = [];
    this.forEach(function(key, value) { entries.push({key: key, value: value}); });
    return entries;
  },
  forEach: function(f) {
    for (var key in this) {
      if (key.charCodeAt(0) === d3_map_prefixCode) {
        f.call(this, key.substring(1), this[key]);
      }
    }
  }
});

var d3_map_prefix = "\0", // prevent collision with built-ins
    d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
function d3_identity(d) {
  return d;
}
function d3_this() {
  return this;
}
function d3_true() {
  return true;
}
function d3_functor(v) {
  return typeof v === "function" ? v : function() { return v; };
}

d3.functor = d3_functor;
// Copies a variable number of methods from source to target.
d3.rebind = function(target, source) {
  var i = 1, n = arguments.length, method;
  while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  return target;
};

// Method is assumed to be a standard D3 getter-setter:
// If passed with no arguments, gets the value.
// If passed with arguments, sets the value and returns the target.
function d3_rebind(target, source, method) {
  return function() {
    var value = method.apply(source, arguments);
    return arguments.length ? target : value;
  };
}
d3.ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};
d3.descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};
d3.mean = function(array, f) {
  var n = array.length,
      a,
      m = 0,
      i = -1,
      j = 0;
  if (arguments.length === 1) {
    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
  } else {
    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
  }
  return j ? m : undefined;
};
d3.median = function(array, f) {
  if (arguments.length > 1) array = array.map(f);
  array = array.filter(d3_number);
  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
};
d3.min = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && a > b) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
  }
  return a;
};
d3.max = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && b > a) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
  }
  return a;
};
d3.extent = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b,
      c;
  if (arguments.length === 1) {
    while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  } else {
    while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  }
  return [a, c];
};
d3.random = {
  normal: function(mean, deviation) {
    if (arguments.length < 2) deviation = 1;
    if (arguments.length < 1) mean = 0;
    return function() {
      var x, y, r;
      do {
        x = Math.random() * 2 - 1;
        y = Math.random() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);
      return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
};
function d3_number(x) {
  return x != null && !isNaN(x);
}
d3.sum = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1;

  if (arguments.length === 1) {
    while (++i < n) if (!isNaN(a = +array[i])) s += a;
  } else {
    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
  }

  return s;
};
// R-7 per <http://en.wikipedia.org/wiki/Quantile>
d3.quantile = function(values, p) {
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = values[h - 1],
      e = H - h;
  return e ? v + e * (values[h] - v) : v;
};
d3.transpose = function(matrix) {
  return d3.zip.apply(d3, matrix);
};
d3.zip = function() {
  if (!(n = arguments.length)) return [];
  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {
    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {
      zip[j] = arguments[j][i];
    }
  }
  return zips;
};

function d3_zipLength(d) {
  return d.length;
}
d3.bisector = function(f) {
  return {
    left: function(a, x, lo, hi) {
      if (arguments.length < 3) lo = 0;
      if (arguments.length < 4) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >> 1;
        if (f.call(a, a[mid], mid) < x) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (arguments.length < 3) lo = 0;
      if (arguments.length < 4) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >> 1;
        if (x < f.call(a, a[mid], mid)) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

var d3_bisector = d3.bisector(function(d) { return d; });
d3.bisectLeft = d3_bisector.left;
d3.bisect = d3.bisectRight = d3_bisector.right;
d3.first = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) > 0) {
      a = b;
    }
  }
  return a;
};
d3.last = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) <= 0) {
      a = b;
    }
  }
  return a;
};
d3.nest = function() {
  var nest = {},
      keys = [],
      sortKeys = [],
      sortValues,
      rollup;

  function map(array, depth) {
    if (depth >= keys.length) return rollup
        ? rollup.call(nest, array) : (sortValues
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        object,
        valuesByKey = new d3_Map,
        values,
        o = {};

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
        values.push(object);
      } else {
        valuesByKey.set(keyValue, [object]);
      }
    }

    valuesByKey.forEach(function(keyValue) {
      o[keyValue] = map(valuesByKey.get(keyValue), depth);
    });

    return o;
  }

  function entries(map, depth) {
    if (depth >= keys.length) return map;

    var a = [],
        sortKey = sortKeys[depth++],
        key;

    for (key in map) {
      a.push({key: key, values: entries(map[key], depth)});
    }

    if (sortKey) a.sort(function(a, b) {
      return sortKey(a.key, b.key);
    });

    return a;
  }

  nest.map = function(array) {
    return map(array, 0);
  };

  nest.entries = function(array) {
    return entries(map(array, 0), 0);
  };

  nest.key = function(d) {
    keys.push(d);
    return nest;
  };

  // Specifies the order for the most-recently specified key.
  // Note: only applies to entries. Map keys are unordered!
  nest.sortKeys = function(order) {
    sortKeys[keys.length - 1] = order;
    return nest;
  };

  // Specifies the order for leaf values.
  // Applies to both maps and entries array.
  nest.sortValues = function(order) {
    sortValues = order;
    return nest;
  };

  nest.rollup = function(f) {
    rollup = f;
    return nest;
  };

  return nest;
};
d3.keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};
d3.values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};
d3.entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};
d3.permute = function(array, indexes) {
  var permutes = [],
      i = -1,
      n = indexes.length;
  while (++i < n) permutes[i] = array[indexes[i]];
  return permutes;
};
d3.merge = function(arrays) {
  return Array.prototype.concat.apply([], arrays);
};
d3.split = function(array, f) {
  var arrays = [],
      values = [],
      value,
      i = -1,
      n = array.length;
  if (arguments.length < 2) f = d3_splitter;
  while (++i < n) {
    if (f.call(values, value = array[i], i)) {
      values = [];
    } else {
      if (!values.length) arrays.push(values);
      values.push(value);
    }
  }
  return arrays;
};

function d3_splitter(d) {
  return d == null;
}
function d3_collapse(s) {
  return s.replace(/^\s+|\s+$/g, "").replace(/\s+/g, " ");
}
d3.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step === Infinity) throw new Error("infinite range");
  var range = [],
       k = d3_range_integerScale(Math.abs(step)),
       i = -1,
       j;
  start *= k, stop *= k, step *= k;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);
  else while ((j = start + step * ++i) < stop) range.push(j / k);
  return range;
};

function d3_range_integerScale(x) {
  var k = 1;
  while (x * k % 1) k *= 10;
  return k;
}
d3.requote = function(s) {
  return s.replace(d3_requote_re, "\\$&");
};

var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
d3.round = function(x, n) {
  return n
      ? Math.round(x * (n = Math.pow(10, n))) / n
      : Math.round(x);
};
d3.xhr = function(url, mime, callback) {
  var req = new XMLHttpRequest;
  if (arguments.length < 3) callback = mime, mime = null;
  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);
  req.open("GET", url, true);
  if (mime) req.setRequestHeader("Accept", mime);
  req.onreadystatechange = function() {
    if (req.readyState === 4) {
      var s = req.status;
      callback(!s && req.response || s >= 200 && s < 300 || s === 304 ? req : null);
    }
  };
  req.send(null);
};
d3.text = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseText);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
d3.json = function(url, callback) {
  d3.text(url, "application/json", function(text) {
    callback(text ? JSON.parse(text) : null);
  });
};
d3.html = function(url, callback) {
  d3.text(url, "text/html", function(text) {
    if (text != null) { // Treat empty string as valid HTML.
      var range = document.createRange();
      range.selectNode(document.body);
      text = range.createContextualFragment(text);
    }
    callback(text);
  });
};
d3.xml = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseXML);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
var d3_nsPrefix = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

d3.ns = {
  prefix: d3_nsPrefix,
  qualify: function(name) {
    var i = name.indexOf(":"),
        prefix = name;
    if (i >= 0) {
      prefix = name.substring(0, i);
      name = name.substring(i + 1);
    }
    return d3_nsPrefix.hasOwnProperty(prefix)
        ? {space: d3_nsPrefix[prefix], local: name}
        : name;
  }
};
d3.dispatch = function() {
  var dispatch = new d3_dispatch,
      i = -1,
      n = arguments.length;
  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
  return dispatch;
};

function d3_dispatch() {}

d3_dispatch.prototype.on = function(type, listener) {
  var i = type.indexOf("."),
      name = "";

  // Extract optional namespace, e.g., "click.foo"
  if (i > 0) {
    name = type.substring(i + 1);
    type = type.substring(0, i);
  }

  return arguments.length < 2
      ? this[type].on(name)
      : this[type].on(name, listener);
};

function d3_dispatch_event(dispatch) {
  var listeners = [],
      listenerByName = new d3_Map;

  function event() {
    var z = listeners, // defensive reference
        i = -1,
        n = z.length,
        l;
    while (++i < n) if (l = z[i].on) l.apply(this, arguments);
    return dispatch;
  }

  event.on = function(name, listener) {
    var l = listenerByName.get(name),
        i;

    // return the current listener, if any
    if (arguments.length < 2) return l && l.on;

    // remove the old listener, if any (with copy-on-write)
    if (l) {
      l.on = null;
      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
      listenerByName.remove(name);
    }

    // add the new listener, if any
    if (listener) listeners.push(listenerByName.set(name, {on: listener}));

    return dispatch;
  };

  return event;
}
// TODO align
d3.format = function(specifier) {
  var match = d3_format_re.exec(specifier),
      fill = match[1] || " ",
      sign = match[3] || "",
      zfill = match[5],
      width = +match[6],
      comma = match[7],
      precision = match[8],
      type = match[9],
      scale = 1,
      suffix = "",
      integer = false;

  if (precision) precision = +precision.substring(1);

  if (zfill) {
    fill = "0"; // TODO align = "=";
    if (comma) width -= Math.floor((width - 1) / 4);
  }

  switch (type) {
    case "n": comma = true; type = "g"; break;
    case "%": scale = 100; suffix = "%"; type = "f"; break;
    case "p": scale = 100; suffix = "%"; type = "r"; break;
    case "d": integer = true; precision = 0; break;
    case "s": scale = -1; type = "r"; break;
  }

  // If no precision is specified for r, fallback to general notation.
  if (type == "r" && !precision) type = "g";

  type = d3_format_types.get(type) || d3_format_typeDefault;

  return function(value) {

    // Return the empty string for floats formatted as ints.
    if (integer && (value % 1)) return "";

    // Convert negative to positive, and record the sign prefix.
    var negative = (value < 0) && (value = -value) ? "\u2212" : sign;

    // Apply the scale, computing it from the value's exponent for si format.
    if (scale < 0) {
      var prefix = d3.formatPrefix(value, precision);
      value = prefix.scale(value);
      suffix = prefix.symbol;
    } else {
      value *= scale;
    }

    // Convert to the desired precision.
    value = type(value, precision);

    // If the fill character is 0, the sign and group is applied after the fill.
    if (zfill) {
      var length = value.length + negative.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
      if (comma) value = d3_format_group(value);
      value = negative + value;
    }

    // Otherwise (e.g., space-filling), the sign and group is applied before.
    else {
      if (comma) value = d3_format_group(value);
      value = negative + value;
      var length = value.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
    }

    return value + suffix;
  };
};

// [[fill]align][sign][#][0][width][,][.precision][type]
var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;

var d3_format_types = d3.map({
  g: function(x, p) { return x.toPrecision(p); },
  e: function(x, p) { return x.toExponential(p); },
  f: function(x, p) { return x.toFixed(p); },
  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }
});

function d3_format_precision(x, p) {
  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);
}

function d3_format_typeDefault(x) {
  return x + "";
}

// Apply comma grouping for thousands.
function d3_format_group(value) {
  var i = value.lastIndexOf("."),
      f = i >= 0 ? value.substring(i) : (i = value.length, ""),
      t = [];
  while (i > 0) t.push(value.substring(i -= 3, i + 3));
  return t.reverse().join(",") + f;
}
var d3_formatPrefixes = ["y","z","a","f","p","n","μ","m","","k","M","G","T","P","E","Z","Y"].map(d3_formatPrefix);

d3.formatPrefix = function(value, precision) {
  var i = 0;
  if (value) {
    if (value < 0) value *= -1;
    if (precision) value = d3.round(value, d3_format_precision(value, precision));
    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
  }
  return d3_formatPrefixes[8 + i / 3];
};

function d3_formatPrefix(d, i) {
  var k = Math.pow(10, Math.abs(8 - i) * 3);
  return {
    scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; },
    symbol: d
  };
}
/*
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var d3_ease_quad = d3_ease_poly(2),
    d3_ease_cubic = d3_ease_poly(3),
    d3_ease_default = function() { return d3_ease_identity; };

var d3_ease = d3.map({
  linear: d3_ease_default,
  poly: d3_ease_poly,
  quad: function() { return d3_ease_quad; },
  cubic: function() { return d3_ease_cubic; },
  sin: function() { return d3_ease_sin; },
  exp: function() { return d3_ease_exp; },
  circle: function() { return d3_ease_circle; },
  elastic: d3_ease_elastic,
  back: d3_ease_back,
  bounce: function() { return d3_ease_bounce; }
});

var d3_ease_mode = d3.map({
  "in": d3_ease_identity,
  "out": d3_ease_reverse,
  "in-out": d3_ease_reflect,
  "out-in": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }
});

d3.ease = function(name) {
  var i = name.indexOf("-"),
      t = i >= 0 ? name.substring(0, i) : name,
      m = i >= 0 ? name.substring(i + 1) : "in";
  t = d3_ease.get(t) || d3_ease_default;
  m = d3_ease_mode.get(m) || d3_ease_identity;
  return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
};

function d3_ease_clamp(f) {
  return function(t) {
    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
  };
}

function d3_ease_reverse(f) {
  return function(t) {
    return 1 - f(1 - t);
  };
}

function d3_ease_reflect(f) {
  return function(t) {
    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));
  };
}

function d3_ease_identity(t) {
  return t;
}

function d3_ease_poly(e) {
  return function(t) {
    return Math.pow(t, e);
  };
}

function d3_ease_sin(t) {
  return 1 - Math.cos(t * Math.PI / 2);
}

function d3_ease_exp(t) {
  return Math.pow(2, 10 * (t - 1));
}

function d3_ease_circle(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function d3_ease_elastic(a, p) {
  var s;
  if (arguments.length < 2) p = 0.45;
  if (arguments.length < 1) { a = 1; s = p / 4; }
  else s = p / (2 * Math.PI) * Math.asin(1 / a);
  return function(t) {
    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);
  };
}

function d3_ease_back(s) {
  if (!s) s = 1.70158;
  return function(t) {
    return t * t * ((s + 1) * t - s);
  };
}

function d3_ease_bounce(t) {
  return t < 1 / 2.75 ? 7.5625 * t * t
      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75
      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375
      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
}
d3.event = null;

function d3_eventCancel() {
  d3.event.stopPropagation();
  d3.event.preventDefault();
}

function d3_eventSource() {
  var e = d3.event, s;
  while (s = e.sourceEvent) e = s;
  return e;
}

// Like d3.dispatch, but for custom events abstracting native UI events. These
// events have a target component (such as a brush), a target element (such as
// the svg:g element containing the brush) and the standard arguments `d` (the
// target element's data) and `i` (the selection index of the target element).
function d3_eventDispatch(target) {
  var dispatch = new d3_dispatch,
      i = 0,
      n = arguments.length;

  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);

  // Creates a dispatch context for the specified `thiz` (typically, the target
  // DOM element that received the source event) and `argumentz` (typically, the
  // data `d` and index `i` of the target element). The returned function can be
  // used to dispatch an event to any registered listeners; the function takes a
  // single argument as input, being the event to dispatch. The event must have
  // a "type" attribute which corresponds to a type registered in the
  // constructor. This context will automatically populate the "sourceEvent" and
  // "target" attributes of the event, as well as setting the `d3.event` global
  // for the duration of the notification.
  dispatch.of = function(thiz, argumentz) {
    return function(e1) {
      try {
        var e0 =
        e1.sourceEvent = d3.event;
        e1.target = target;
        d3.event = e1;
        dispatch[e1.type].apply(thiz, argumentz);
      } finally {
        d3.event = e0;
      }
    };
  };

  return dispatch;
}
d3.interpolate = function(a, b) {
  var i = d3.interpolators.length, f;
  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
  return f;
};

d3.interpolateNumber = function(a, b) {
  b -= a;
  return function(t) { return a + b * t; };
};

d3.interpolateRound = function(a, b) {
  b -= a;
  return function(t) { return Math.round(a + b * t); };
};

d3.interpolateString = function(a, b) {
  var m, // current match
      i, // current index
      j, // current index (for coallescing)
      s0 = 0, // start index of current string prefix
      s1 = 0, // end index of current string prefix
      s = [], // string constants and placeholders
      q = [], // number interpolators
      n, // q.length
      o;

  // Reset our regular expression!
  d3_interpolate_number.lastIndex = 0;

  // Find all numbers in b.
  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
    if (m.index) s.push(b.substring(s0, s1 = m.index));
    q.push({i: s.length, x: m[0]});
    s.push(null);
    s0 = d3_interpolate_number.lastIndex;
  }
  if (s0 < b.length) s.push(b.substring(s0));

  // Find all numbers in a.
  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
    o = q[i];
    if (o.x == m[0]) { // The numbers match, so coallesce.
      if (o.i) {
        if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i - 1] += o.x;
          s.splice(o.i, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i - 1] += o.x + s[o.i + 1];
          s.splice(o.i, 2);
          for (j = i + 1; j < n; ++j) q[j].i -= 2;
        }
      } else {
          if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i] = o.x;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i] = o.x + s[o.i + 1];
          s.splice(o.i + 1, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        }
      }
      q.splice(i, 1);
      n--;
      i--;
    } else {
      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
    }
  }

  // Remove any numbers in b not found in a.
  while (i < n) {
    o = q.pop();
    if (s[o.i + 1] == null) { // This match is followed by another number.
      s[o.i] = o.x;
    } else { // This match is followed by a string, so coallesce twice.
      s[o.i] = o.x + s[o.i + 1];
      s.splice(o.i + 1, 1);
    }
    n--;
  }

  // Special optimization for only a single match.
  if (s.length === 1) {
    return s[0] == null ? q[0].x : function() { return b; };
  }

  // Otherwise, interpolate each of the numbers and rejoin the string.
  return function(t) {
    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  };
};

d3.interpolateTransform = function(a, b) {
  var s = [], // string constants and placeholders
      q = [], // number interpolators
      n,
      A = d3.transform(a),
      B = d3.transform(b),
      ta = A.translate,
      tb = B.translate,
      ra = A.rotate,
      rb = B.rotate,
      wa = A.skew,
      wb = B.skew,
      ka = A.scale,
      kb = B.scale;

  if (ta[0] != tb[0] || ta[1] != tb[1]) {
    s.push("translate(", null, ",", null, ")");
    q.push({i: 1, x: d3.interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3.interpolateNumber(ta[1], tb[1])});
  } else if (tb[0] || tb[1]) {
    s.push("translate(" + tb + ")");
  } else {
    s.push("");
  }

  if (ra != rb) {
    if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360; // shortest path
    q.push({i: s.push(s.pop() + "rotate(", null, ")") - 2, x: d3.interpolateNumber(ra, rb)});
  } else if (rb) {
    s.push(s.pop() + "rotate(" + rb + ")");
  }

  if (wa != wb) {
    q.push({i: s.push(s.pop() + "skewX(", null, ")") - 2, x: d3.interpolateNumber(wa, wb)});
  } else if (wb) {
    s.push(s.pop() + "skewX(" + wb + ")");
  }

  if (ka[0] != kb[0] || ka[1] != kb[1]) {
    n = s.push(s.pop() + "scale(", null, ",", null, ")");
    q.push({i: n - 4, x: d3.interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3.interpolateNumber(ka[1], kb[1])});
  } else if (kb[0] != 1 || kb[1] != 1) {
    s.push(s.pop() + "scale(" + kb + ")");
  }

  n = q.length;
  return function(t) {
    var i = -1, o;
    while (++i < n) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  };
};

d3.interpolateRgb = function(a, b) {
  a = d3.rgb(a);
  b = d3.rgb(b);
  var ar = a.r,
      ag = a.g,
      ab = a.b,
      br = b.r - ar,
      bg = b.g - ag,
      bb = b.b - ab;
  return function(t) {
    return "#"
        + d3_rgb_hex(Math.round(ar + br * t))
        + d3_rgb_hex(Math.round(ag + bg * t))
        + d3_rgb_hex(Math.round(ab + bb * t));
  };
};

// interpolates HSL space, but outputs RGB string (for compatibility)
d3.interpolateHsl = function(a, b) {
  a = d3.hsl(a);
  b = d3.hsl(b);
  var h0 = a.h,
      s0 = a.s,
      l0 = a.l,
      h1 = b.h - h0,
      s1 = b.s - s0,
      l1 = b.l - l0;
  if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360; // shortest path
  return function(t) {
    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();
  };
};

d3.interpolateArray = function(a, b) {
  var x = [],
      c = [],
      na = a.length,
      nb = b.length,
      n0 = Math.min(a.length, b.length),
      i;
  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
  for (; i < na; ++i) c[i] = a[i];
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < n0; ++i) c[i] = x[i](t);
    return c;
  };
};

d3.interpolateObject = function(a, b) {
  var i = {},
      c = {},
      k;
  for (k in a) {
    if (k in b) {
      i[k] = d3_interpolateByName(k)(a[k], b[k]);
    } else {
      c[k] = a[k];
    }
  }
  for (k in b) {
    if (!(k in a)) {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;

function d3_interpolateByName(n) {
  return n == "transform"
      ? d3.interpolateTransform
      : d3.interpolate;
}

d3.interpolators = [
  d3.interpolateObject,
  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },
  function(a, b) { return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + ""); },
  function(a, b) { return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(a, b); },
  function(a, b) { return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b); }
];
function d3_uninterpolateNumber(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return (x - a) * b; };
}

function d3_uninterpolateClamp(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };
}
d3.rgb = function(r, g, b) {
  return arguments.length === 1
      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)
      : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb))
      : d3_rgb(~~r, ~~g, ~~b);
};

function d3_rgb(r, g, b) {
  return new d3_Rgb(r, g, b);
}

function d3_Rgb(r, g, b) {
  this.r = r;
  this.g = g;
  this.b = b;
}

d3_Rgb.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  var r = this.r,
      g = this.g,
      b = this.b,
      i = 30;
  if (!r && !g && !b) return d3_rgb(i, i, i);
  if (r && r < i) r = i;
  if (g && g < i) g = i;
  if (b && b < i) b = i;
  return d3_rgb(
      Math.min(255, Math.floor(r / k)),
      Math.min(255, Math.floor(g / k)),
      Math.min(255, Math.floor(b / k)));
};

d3_Rgb.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_rgb(
      Math.floor(k * this.r),
      Math.floor(k * this.g),
      Math.floor(k * this.b));
};

d3_Rgb.prototype.hsl = function() {
  return d3_rgb_hsl(this.r, this.g, this.b);
};

d3_Rgb.prototype.toString = function() {
  return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
};

function d3_rgb_hex(v) {
  return v < 0x10
      ? "0" + Math.max(0, v).toString(16)
      : Math.min(255, v).toString(16);
}

function d3_rgb_parse(format, rgb, hsl) {
  var r = 0, // red channel; int in [0, 255]
      g = 0, // green channel; int in [0, 255]
      b = 0, // blue channel; int in [0, 255]
      m1, // CSS color specification match
      m2, // CSS color specification type (e.g., rgb)
      name;

  /* Handle hsl, rgb. */
  m1 = /([a-z]+)\((.*)\)/i.exec(format);
  if (m1) {
    m2 = m1[2].split(",");
    switch (m1[1]) {
      case "hsl": {
        return hsl(
          parseFloat(m2[0]), // degrees
          parseFloat(m2[1]) / 100, // percentage
          parseFloat(m2[2]) / 100 // percentage
        );
      }
      case "rgb": {
        return rgb(
          d3_rgb_parseNumber(m2[0]),
          d3_rgb_parseNumber(m2[1]),
          d3_rgb_parseNumber(m2[2])
        );
      }
    }
  }

  /* Named colors. */
  if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);

  /* Hexadecimal colors: #rgb and #rrggbb. */
  if (format != null && format.charAt(0) === "#") {
    if (format.length === 4) {
      r = format.charAt(1); r += r;
      g = format.charAt(2); g += g;
      b = format.charAt(3); b += b;
    } else if (format.length === 7) {
      r = format.substring(1, 3);
      g = format.substring(3, 5);
      b = format.substring(5, 7);
    }
    r = parseInt(r, 16);
    g = parseInt(g, 16);
    b = parseInt(b, 16);
  }

  return rgb(r, g, b);
}

function d3_rgb_hsl(r, g, b) {
  var min = Math.min(r /= 255, g /= 255, b /= 255),
      max = Math.max(r, g, b),
      d = max - min,
      h,
      s,
      l = (max + min) / 2;
  if (d) {
    s = l < .5 ? d / (max + min) : d / (2 - max - min);
    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
    else if (g == max) h = (b - r) / d + 2;
    else h = (r - g) / d + 4;
    h *= 60;
  } else {
    s = h = 0;
  }
  return d3_hsl(h, s, l);
}

function d3_rgb_parseNumber(c) { // either integer or percentage
  var f = parseFloat(c);
  return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
}

var d3_rgb_names = d3.map({
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
});

d3_rgb_names.forEach(function(key, value) {
  d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
});
d3.hsl = function(h, s, l) {
  return arguments.length === 1
      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)
      : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl))
      : d3_hsl(+h, +s, +l);
};

function d3_hsl(h, s, l) {
  return new d3_Hsl(h, s, l);
}

function d3_Hsl(h, s, l) {
  this.h = h;
  this.s = s;
  this.l = l;
}

d3_Hsl.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, this.l / k);
};

d3_Hsl.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, k * this.l);
};

d3_Hsl.prototype.rgb = function() {
  return d3_hsl_rgb(this.h, this.s, this.l);
};

d3_Hsl.prototype.toString = function() {
  return this.rgb().toString();
};

function d3_hsl_rgb(h, s, l) {
  var m1,
      m2;

  /* Some simple corrections for h, s and l. */
  h = h % 360; if (h < 0) h += 360;
  s = s < 0 ? 0 : s > 1 ? 1 : s;
  l = l < 0 ? 0 : l > 1 ? 1 : l;

  /* From FvD 13.37, CSS Color Module Level 3 */
  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
  m1 = 2 * l - m2;

  function v(h) {
    if (h > 360) h -= 360;
    else if (h < 0) h += 360;
    if (h < 60) return m1 + (m2 - m1) * h / 60;
    if (h < 180) return m2;
    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
    return m1;
  }

  function vv(h) {
    return Math.round(v(h) * 255);
  }

  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
}
function d3_selection(groups) {
  d3_arraySubclass(groups, d3_selectionPrototype);
  return groups;
}

var d3_select = function(s, n) { return n.querySelector(s); },
    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },
    d3_selectRoot = document.documentElement,
    d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,
    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };

// Prefer Sizzle, if available.
if (typeof Sizzle === "function") {
  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };
  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };
  d3_selectMatches = Sizzle.matchesSelector;
}

var d3_selectionPrototype = [];

d3.selection = function() {
  return d3_selectionRoot;
};

d3.selection.prototype = d3_selectionPrototype;
d3_selectionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      group,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(subnode = selector.call(node, node.__data__, i));
        if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selector(selector) {
  return function() {
    return d3_select(selector, this);
  };
}
d3_selectionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
        subgroup.parentNode = node;
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selectorAll(selector) {
  return function() {
    return d3_selectAll(selector, this);
  };
}
d3_selectionPrototype.attr = function(name, value) {
  name = d3.ns.qualify(name);

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    return name.local
        ? node.getAttributeNS(name.space, name.local)
        : node.getAttribute(name);
  }

  function attrNull() {
    this.removeAttribute(name);
  }

  function attrNullNS() {
    this.removeAttributeNS(name.space, name.local);
  }

  function attrConstant() {
    this.setAttribute(name, value);
  }

  function attrConstantNS() {
    this.setAttributeNS(name.space, name.local, value);
  }

  function attrFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttribute(name);
    else this.setAttribute(name, x);
  }

  function attrFunctionNS() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttributeNS(name.space, name.local);
    else this.setAttributeNS(name.space, name.local, x);
  }

  return this.each(value == null
      ? (name.local ? attrNullNS : attrNull) : (typeof value === "function"
      ? (name.local ? attrFunctionNS : attrFunction)
      : (name.local ? attrConstantNS : attrConstant)));
};
d3_selectionPrototype.classed = function(name, value) {
  var names = d3_collapse(name).split(" "),
      n = names.length,
      i = -1;
  if (arguments.length > 1) {
    while (++i < n) d3_selection_classed.call(this, names[i], value);
    return this;
  } else {
    while (++i < n) if (!d3_selection_classed.call(this, names[i])) return false;
    return true;
  }
};

function d3_selection_classed(name, value) {
  var re = new RegExp("(^|\\s+)" + d3.requote(name) + "(\\s+|$)", "g");

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    if (c = node.classList) return c.contains(name);
    var c = node.className;
    re.lastIndex = 0;
    return re.test(c.baseVal != null ? c.baseVal : c);
  }

  function classedAdd() {
    if (c = this.classList) return c.add(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    re.lastIndex = 0;
    if (!re.test(cv)) {
      cv = d3_collapse(cv + " " + name);
      if (cb) c.baseVal = cv;
      else this.className = cv;
    }
  }

  function classedRemove() {
    if (c = this.classList) return c.remove(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    cv = d3_collapse(cv.replace(re, " "));
    if (cb) c.baseVal = cv;
    else this.className = cv;
  }

  function classedFunction() {
    (value.apply(this, arguments)
        ? classedAdd
        : classedRemove).call(this);
  }

  return this.each(typeof value === "function"
      ? classedFunction : value
      ? classedAdd
      : classedRemove);
}
d3_selectionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";

  // If no value is specified, return the first value.
  if (arguments.length < 2) return window
      .getComputedStyle(this.node(), null)
      .getPropertyValue(name);

  function styleNull() {
    this.style.removeProperty(name);
  }

  function styleConstant() {
    this.style.setProperty(name, value, priority);
  }

  function styleFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.style.removeProperty(name);
    else this.style.setProperty(name, x, priority);
  }

  return this.each(value == null
      ? styleNull : (typeof value === "function"
      ? styleFunction : styleConstant));
};
d3_selectionPrototype.property = function(name, value) {

  // If no value is specified, return the first value.
  if (arguments.length < 2) return this.node()[name];

  function propertyNull() {
    delete this[name];
  }

  function propertyConstant() {
    this[name] = value;
  }

  function propertyFunction() {
    var x = value.apply(this, arguments);
    if (x == null) delete this[name];
    else this[name] = x;
  }

  return this.each(value == null
      ? propertyNull : (typeof value === "function"
      ? propertyFunction : propertyConstant));
};
d3_selectionPrototype.text = function(value) {
  return arguments.length < 1
      ? this.node().textContent : this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? "" : v; } : value == null
      ? function() { this.textContent = ""; }
      : function() { this.textContent = value; });
};
d3_selectionPrototype.html = function(value) {
  return arguments.length < 1
      ? this.node().innerHTML : this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? "" : v; } : value == null
      ? function() { this.innerHTML = ""; }
      : function() { this.innerHTML = value; });
};
// TODO append(node)?
// TODO append(function)?
d3_selectionPrototype.append = function(name) {
  name = d3.ns.qualify(name);

  function append() {
    return this.appendChild(document.createElementNS(this.namespaceURI, name));
  }

  function appendNS() {
    return this.appendChild(document.createElementNS(name.space, name.local));
  }

  return this.select(name.local ? appendNS : append);
};
// TODO insert(node, function)?
// TODO insert(function, string)?
// TODO insert(function, function)?
d3_selectionPrototype.insert = function(name, before) {
  name = d3.ns.qualify(name);

  function insert() {
    return this.insertBefore(
        document.createElementNS(this.namespaceURI, name),
        d3_select(before, this));
  }

  function insertNS() {
    return this.insertBefore(
        document.createElementNS(name.space, name.local),
        d3_select(before, this));
  }

  return this.select(name.local ? insertNS : insert);
};
// TODO remove(selector)?
// TODO remove(node)?
// TODO remove(function)?
d3_selectionPrototype.remove = function() {
  return this.each(function() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  });
};
d3_selectionPrototype.data = function(value, key) {
  var i = -1,
      n = this.length,
      group,
      node;

  // If no value is specified, return the first value.
  if (!arguments.length) {
    value = new Array(n = (group = this[0]).length);
    while (++i < n) {
      if (node = group[i]) {
        value[i] = node.__data__;
      }
    }
    return value;
  }

  function bind(group, groupData) {
    var i,
        n = group.length,
        m = groupData.length,
        n0 = Math.min(n, m),
        n1 = Math.max(n, m),
        updateNodes = [],
        enterNodes = [],
        exitNodes = [],
        node,
        nodeData;

    if (key) {
      var nodeByKeyValue = new d3_Map,
          keyValues = [],
          keyValue,
          j = groupData.length;

      for (i = -1; ++i < n;) {
        keyValue = key.call(node = group[i], node.__data__, i);
        if (nodeByKeyValue.has(keyValue)) {
          exitNodes[j++] = node; // duplicate key
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
        keyValues.push(keyValue);
      }

      for (i = -1; ++i < m;) {
        keyValue = key.call(groupData, nodeData = groupData[i], i)
        if (nodeByKeyValue.has(keyValue)) {
          updateNodes[i] = node = nodeByKeyValue.get(keyValue);
          node.__data__ = nodeData;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
        nodeByKeyValue.remove(keyValue);
      }

      for (i = -1; ++i < n;) {
        if (nodeByKeyValue.has(keyValues[i])) {
          exitNodes[i] = group[i];
        }
      }
    } else {
      for (i = -1; ++i < n0;) {
        node = group[i];
        nodeData = groupData[i];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
      }
      for (; i < m; ++i) {
        enterNodes[i] = d3_selection_dataNode(groupData[i]);
        updateNodes[i] = exitNodes[i] = null;
      }
      for (; i < n1; ++i) {
        exitNodes[i] = group[i];
        enterNodes[i] = updateNodes[i] = null;
      }
    }

    enterNodes.update
        = updateNodes;

    enterNodes.parentNode
        = updateNodes.parentNode
        = exitNodes.parentNode
        = group.parentNode;

    enter.push(enterNodes);
    update.push(updateNodes);
    exit.push(exitNodes);
  }

  var enter = d3_selection_enter([]),
      update = d3_selection([]),
      exit = d3_selection([]);

  if (typeof value === "function") {
    while (++i < n) {
      bind(group = this[i], value.call(group, group.parentNode.__data__, i));
    }
  } else {
    while (++i < n) {
      bind(group = this[i], value);
    }
  }

  update.enter = function() { return enter; };
  update.exit = function() { return exit; };
  return update;
};

function d3_selection_dataNode(data) {
  return {__data__: data};
}
d3_selectionPrototype.datum =
d3_selectionPrototype.map = function(value) {
  return arguments.length < 1
      ? this.property("__data__")
      : this.property("__data__", value);
};
d3_selectionPrototype.filter = function(filter) {
  var subgroups = [],
      subgroup,
      group,
      node;

  if (typeof filter !== "function") filter = d3_selection_filter(filter);

  for (var j = 0, m = this.length; j < m; j++) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = 0, n = group.length; i < n; i++) {
      if ((node = group[i]) && filter.call(node, node.__data__, i)) {
        subgroup.push(node);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_filter(selector) {
  return function() {
    return d3_selectMatches(this, selector);
  };
}
d3_selectionPrototype.order = function() {
  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
};
d3_selectionPrototype.sort = function(comparator) {
  comparator = d3_selection_sortComparator.apply(this, arguments);
  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);
  return this.order();
};

function d3_selection_sortComparator(comparator) {
  if (!arguments.length) comparator = d3.ascending;
  return function(a, b) {
    return comparator(a && a.__data__, b && b.__data__);
  };
}
// type can be namespaced, e.g., "click.foo"
// listener can be null for removal
d3_selectionPrototype.on = function(type, listener, capture) {
  if (arguments.length < 3) capture = false;

  // parse the type specifier
  var name = "__on" + type, i = type.indexOf(".");
  if (i > 0) type = type.substring(0, i);

  // if called with only one argument, return the current listener
  if (arguments.length < 2) return (i = this.node()[name]) && i._;

  // remove the old event listener, and add the new event listener
  return this.each(function(d, i) {
    var node = this,
        o = node[name];

    // remove the old listener, if any (using the previously-set capture)
    if (o) {
      node.removeEventListener(type, o, o.$);
      delete node[name];
    }

    // add the new listener, if any (remembering the capture flag)
    if (listener) {
      node.addEventListener(type, node[name] = l, l.$ = capture);
      l._ = listener; // stash the unwrapped listener for get
    }

    // wrapped event listener that preserves i
    function l(e) {
      var o = d3.event; // Events can be reentrant (e.g., focus).
      d3.event = e;
      try {
        listener.call(node, node.__data__, i);
      } finally {
        d3.event = o;
      }
    }
  });
};
d3_selectionPrototype.each = function(callback) {
  return d3_selection_each(this, function(node, i, j) {
    callback.call(node, node.__data__, i, j);
  });
};

function d3_selection_each(groups, callback) {
  for (var j = 0, m = groups.length; j < m; j++) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
      if (node = group[i]) callback(node, i, j);
    }
  }
  return groups;
}
//
// Note: assigning to the arguments array simultaneously changes the value of
// the corresponding argument!
//
// TODO The `this` argument probably shouldn't be the first argument to the
// callback, anyway, since it's redundant. However, that will require a major
// version bump due to backwards compatibility, so I'm not changing it right
// away.
//
d3_selectionPrototype.call = function(callback) {
  callback.apply(this, (arguments[0] = this, arguments));
  return this;
};
d3_selectionPrototype.empty = function() {
  return !this.node();
};
d3_selectionPrototype.node = function(callback) {
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
};
d3_selectionPrototype.transition = function() {
  var subgroups = [],
      subgroup,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      subgroup.push((node = group[i]) ? {node: node, delay: d3_transitionDelay, duration: d3_transitionDuration} : null);
    }
  }

  return d3_transition(subgroups, d3_transitionId || ++d3_transitionNextId, Date.now());
};
var d3_selectionRoot = d3_selection([[document]]);

d3_selectionRoot[0].parentNode = d3_selectRoot;

// TODO fast singleton implementation!
// TODO select(function)
d3.select = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.select(selector)
      : d3_selection([[selector]]); // assume node
};

// TODO selectAll(function)
d3.selectAll = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.selectAll(selector)
      : d3_selection([d3_array(selector)]); // assume node[]
};
function d3_selection_enter(selection) {
  d3_arraySubclass(selection, d3_selection_enterPrototype);
  return selection;
}

var d3_selection_enterPrototype = [];

d3.selection.enter = d3_selection_enter;
d3.selection.enter.prototype = d3_selection_enterPrototype;

d3_selection_enterPrototype.append = d3_selectionPrototype.append;
d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
d3_selection_enterPrototype.node = d3_selectionPrototype.node;
d3_selection_enterPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      upgroup,
      group,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    upgroup = (group = this[j]).update;
    subgroups.push(subgroup = []);
    subgroup.parentNode = group.parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
        subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};
function d3_transition(groups, id, time) {
  d3_arraySubclass(groups, d3_transitionPrototype);

  var tweens = new d3_Map,
      event = d3.dispatch("start", "end"),
      ease = d3_transitionEase;

  groups.id = id;

  groups.time = time;

  groups.tween = function(name, tween) {
    if (arguments.length < 2) return tweens.get(name);
    if (tween == null) tweens.remove(name);
    else tweens.set(name, tween);
    return groups;
  };

  groups.ease = function(value) {
    if (!arguments.length) return ease;
    ease = typeof value === "function" ? value : d3.ease.apply(d3, arguments);
    return groups;
  };

  groups.each = function(type, listener) {
    if (arguments.length < 2) return d3_transition_each.call(groups, type);
    event.on(type, listener);
    return groups;
  };

  d3.timer(function(elapsed) {
    return d3_selection_each(groups, function(node, i, j) {
      var tweened = [],
          delay = node.delay,
          duration = node.duration,
          lock = (node = node.node).__transition__ || (node.__transition__ = {active: 0, count: 0}),
          d = node.__data__;

      ++lock.count;

      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);

      function start(elapsed) {
        if (lock.active > id) return stop();
        lock.active = id;

        tweens.forEach(function(key, value) {
          if (value = value.call(node, d, i)) {
            tweened.push(value);
          }
        });

        event.start.call(node, d, i);
        if (!tick(elapsed)) d3.timer(tick, 0, time);
        return 1;
      }

      function tick(elapsed) {
        if (lock.active !== id) return stop();

        var t = (elapsed - delay) / duration,
            e = ease(t),
            n = tweened.length;

        while (n > 0) {
          tweened[--n].call(node, e);
        }

        if (t >= 1) {
          stop();
          d3_transitionId = id;
          event.end.call(node, d, i);
          d3_transitionId = 0;
          return 1;
        }
      }

      function stop() {
        if (!--lock.count) delete node.__transition__;
        return 1;
      }
    });
  }, 0, time);

  return groups;
}

var d3_transitionRemove = {};

function d3_transitionNull(d, i, a) {
  return a != "" && d3_transitionRemove;
}

function d3_transitionTween(name, b) {
  var interpolate = d3_interpolateByName(name);

  function transitionFunction(d, i, a) {
    var v = b.call(this, d, i);
    return v == null
        ? a != "" && d3_transitionRemove
        : a != v && interpolate(a, v);
  }

  function transitionString(d, i, a) {
    return a != b && interpolate(a, b);
  }

  return typeof b === "function" ? transitionFunction
      : b == null ? d3_transitionNull
      : (b += "", transitionString);
}

var d3_transitionPrototype = [],
    d3_transitionNextId = 0,
    d3_transitionId = 0,
    d3_transitionDefaultDelay = 0,
    d3_transitionDefaultDuration = 250,
    d3_transitionDefaultEase = d3.ease("cubic-in-out"),
    d3_transitionDelay = d3_transitionDefaultDelay,
    d3_transitionDuration = d3_transitionDefaultDuration,
    d3_transitionEase = d3_transitionDefaultEase;

d3_transitionPrototype.call = d3_selectionPrototype.call;

d3.transition = function(selection) {
  return arguments.length
      ? (d3_transitionId ? selection.transition() : selection)
      : d3_selectionRoot.transition();
};

d3.transition.prototype = d3_transitionPrototype;
d3_transitionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {
        if ("__data__" in node.node) subnode.__data__ = node.node.__data__;
        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      subnodes,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subnodes = selector.call(node.node, node.node.__data__, i);
        subgroups.push(subgroup = []);
        for (var k = -1, o = subnodes.length; ++k < o;) {
          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});
        }
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.attr = function(name, value) {
  return this.attrTween(name, d3_transitionTween(name, value));
};

d3_transitionPrototype.attrTween = function(nameNS, tween) {
  var name = d3.ns.qualify(nameNS);

  function attrTween(d, i) {
    var f = tween.call(this, d, i, this.getAttribute(name));
    return f === d3_transitionRemove
        ? (this.removeAttribute(name), null)
        : f && function(t) { this.setAttribute(name, f(t)); };
  }

  function attrTweenNS(d, i) {
    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
    return f === d3_transitionRemove
        ? (this.removeAttributeNS(name.space, name.local), null)
        : f && function(t) { this.setAttributeNS(name.space, name.local, f(t)); };
  }

  return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
};
d3_transitionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";
  return this.styleTween(name, d3_transitionTween(name, value), priority);
};

d3_transitionPrototype.styleTween = function(name, tween, priority) {
  if (arguments.length < 3) priority = "";
  return this.tween("style." + name, function(d, i) {
    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
    return f === d3_transitionRemove
        ? (this.style.removeProperty(name), null)
        : f && function(t) { this.style.setProperty(name, f(t), priority); };
  });
};
d3_transitionPrototype.text = function(value) {
  return this.tween("text", function(d, i) {
    this.textContent = typeof value === "function"
        ? value.call(this, d, i)
        : value;
  });
};
d3_transitionPrototype.remove = function() {
  return this.each("end.transition", function() {
    var p;
    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
  });
};
d3_transitionPrototype.delay = function(value) {
  return d3_selection_each(this, typeof value === "function"
      ? function(node, i, j) { node.delay = value.call(node = node.node, node.__data__, i, j) | 0; }
      : (value = value | 0, function(node) { node.delay = value; }));
};
d3_transitionPrototype.duration = function(value) {
  return d3_selection_each(this, typeof value === "function"
      ? function(node, i, j) { node.duration = Math.max(1, value.call(node = node.node, node.__data__, i, j) | 0); }
      : (value = Math.max(1, value | 0), function(node) { node.duration = value; }));
};
function d3_transition_each(callback) {
  var id = d3_transitionId,
      ease = d3_transitionEase,
      delay = d3_transitionDelay,
      duration = d3_transitionDuration;

  d3_transitionId = this.id;
  d3_transitionEase = this.ease();
  d3_selection_each(this, function(node, i, j) {
    d3_transitionDelay = node.delay;
    d3_transitionDuration = node.duration;
    callback.call(node = node.node, node.__data__, i, j);
  });

  d3_transitionId = id;
  d3_transitionEase = ease;
  d3_transitionDelay = delay;
  d3_transitionDuration = duration;
  return this;
}
d3_transitionPrototype.transition = function() {
  return this.select(d3_this);
};
var d3_timer_queue = null,
    d3_timer_interval, // is an interval (or frame) active?
    d3_timer_timeout; // is a timeout active?

// The timer will continue to fire until callback returns true.
d3.timer = function(callback, delay, then) {
  var found = false,
      t0,
      t1 = d3_timer_queue;

  if (arguments.length < 3) {
    if (arguments.length < 2) delay = 0;
    else if (!isFinite(delay)) return;
    then = Date.now();
  }

  // See if the callback's already in the queue.
  while (t1) {
    if (t1.callback === callback) {
      t1.then = then;
      t1.delay = delay;
      found = true;
      break;
    }
    t0 = t1;
    t1 = t1.next;
  }

  // Otherwise, add the callback to the queue.
  if (!found) d3_timer_queue = {
    callback: callback,
    then: then,
    delay: delay,
    next: d3_timer_queue
  };

  // Start animatin'!
  if (!d3_timer_interval) {
    d3_timer_timeout = clearTimeout(d3_timer_timeout);
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

function d3_timer_step() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  var delay = d3_timer_flush() - now;
  if (delay > 24) {
    if (isFinite(delay)) {
      clearTimeout(d3_timer_timeout);
      d3_timer_timeout = setTimeout(d3_timer_step, delay);
    }
    d3_timer_interval = 0;
  } else {
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

d3.timer.flush = function() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (!t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  d3_timer_flush();
};

// Flush after callbacks, to avoid concurrent queue modification.
function d3_timer_flush() {
  var t0 = null,
      t1 = d3_timer_queue,
      then = Infinity;
  while (t1) {
    if (t1.flush) {
      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
    } else {
      then = Math.min(then, t1.then + t1.delay);
      t1 = (t0 = t1).next;
    }
  }
  return then;
}

var d3_timer_frame = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.oRequestAnimationFrame
    || window.msRequestAnimationFrame
    || function(callback) { setTimeout(callback, 17); };
d3.transform = function(string) {
  var g = document.createElementNS(d3.ns.prefix.svg, "g"),
      identity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
  return (d3.transform = function(string) {
    g.setAttribute("transform", string);
    var t = g.transform.baseVal.consolidate();
    return new d3_transform(t ? t.matrix : identity);
  })(string);
};

// Compute x-scale and normalize the first row.
// Compute shear and make second row orthogonal to first.
// Compute y-scale and normalize the second row.
// Finally, compute the rotation.
function d3_transform(m) {
  var r0 = [m.a, m.b],
      r1 = [m.c, m.d],
      kx = d3_transformNormalize(r0),
      kz = d3_transformDot(r0, r1),
      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
  if (r0[0] * r1[1] < r1[0] * r0[1]) {
    r0[0] *= -1;
    r0[1] *= -1;
    kx *= -1;
    kz *= -1;
  }
  this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;
  this.translate = [m.e, m.f];
  this.scale = [kx, ky];
  this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;
};

d3_transform.prototype.toString = function() {
  return "translate(" + this.translate
      + ")rotate(" + this.rotate
      + ")skewX(" + this.skew
      + ")scale(" + this.scale
      + ")";
};

function d3_transformDot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function d3_transformNormalize(a) {
  var k = Math.sqrt(d3_transformDot(a, a));
  if (k) {
    a[0] /= k;
    a[1] /= k;
  }
  return k;
}

function d3_transformCombine(a, b, k) {
  a[0] += k * b[0];
  a[1] += k * b[1];
  return a;
}

var d3_transformDegrees = 180 / Math.PI;
d3.mouse = function(container) {
  return d3_mousePoint(container, d3_eventSource());
};

// https://bugs.webkit.org/show_bug.cgi?id=44083
var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;

function d3_mousePoint(container, e) {
  var svg = container.ownerSVGElement || container;
  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {
      svg = d3.select(document.body)
        .append("svg")
          .style("position", "absolute")
          .style("top", 0)
          .style("left", 0);
      var ctm = svg[0][0].getScreenCTM();
      d3_mouse_bug44083 = !(ctm.f || ctm.e);
      svg.remove();
    }
    if (d3_mouse_bug44083) {
      point.x = e.pageX;
      point.y = e.pageY;
    } else {
      point.x = e.clientX;
      point.y = e.clientY;
    }
    point = point.matrixTransform(container.getScreenCTM().inverse());
    return [point.x, point.y];
  }
  var rect = container.getBoundingClientRect();
  return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
};
d3.touches = function(container, touches) {
  if (arguments.length < 2) touches = d3_eventSource().touches;
  return touches ? d3_array(touches).map(function(touch) {
    var point = d3_mousePoint(container, touch);
    point.identifier = touch.identifier;
    return point;
  }) : [];
};
function d3_noop() {}
d3.scale = {};

function d3_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function d3_scaleRange(scale) {
  return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
}
function d3_scale_nice(domain, nice) {
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      dx;

  if (x1 < x0) {
    dx = i0; i0 = i1; i1 = dx;
    dx = x0; x0 = x1; x1 = dx;
  }

  if (dx = x1 - x0) {
    nice = nice(dx);
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
  }

  return domain;
}

function d3_scale_niceDefault() {
  return Math;
}
d3.scale.linear = function() {
  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);
};

function d3_scale_linear(domain, range, interpolate, clamp) {
  var output,
      input;

  function rescale() {
    var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
    output = linear(domain, range, uninterpolate, interpolate);
    input = linear(range, domain, uninterpolate, d3.interpolate);
    return scale;
  }

  function scale(x) {
    return output(x);
  }

  // Note: requires range is coercible to number!
  scale.invert = function(y) {
    return input(y);
  };

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(Number);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.rangeRound = function(x) {
    return scale.range(x).interpolate(d3.interpolateRound);
  };

  scale.clamp = function(x) {
    if (!arguments.length) return clamp;
    clamp = x;
    return rescale();
  };

  scale.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    interpolate = x;
    return rescale();
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  scale.nice = function() {
    d3_scale_nice(domain, d3_scale_linearNice);
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_linear(domain, range, interpolate, clamp);
  };

  return rescale();
}

function d3_scale_linearRebind(scale, linear) {
  return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
}

function d3_scale_linearNice(dx) {
  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
  return {
    floor: function(x) { return Math.floor(x / dx) * dx; },
    ceil: function(x) { return Math.ceil(x / dx) * dx; }
  };
}

function d3_scale_linearTickRange(domain, m) {
  var extent = d3_scaleExtent(domain),
      span = extent[1] - extent[0],
      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
      err = m / span * step;

  // Filter ticks to get closer to the desired count.
  if (err <= .15) step *= 10;
  else if (err <= .35) step *= 5;
  else if (err <= .75) step *= 2;

  // Round start and stop values to step interval.
  extent[0] = Math.ceil(extent[0] / step) * step;
  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive
  extent[2] = step;
  return extent;
}

function d3_scale_linearTicks(domain, m) {
  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
}

function d3_scale_linearTickFormat(domain, m) {
  return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
}
function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
  var u = uninterpolate(domain[0], domain[1]),
      i = interpolate(range[0], range[1]);
  return function(x) {
    return i(u(x));
  };
}
function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
  var u = [],
      i = [],
      j = 0,
      k = Math.min(domain.length, range.length) - 1;

  // Handle descending domains.
  if (domain[k] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++j <= k) {
    u.push(uninterpolate(domain[j - 1], domain[j]));
    i.push(interpolate(range[j - 1], range[j]));
  }

  return function(x) {
    var j = d3.bisect(domain, x, 1, k) - 1;
    return i[j](u[j](x));
  };
}
d3.scale.log = function() {
  return d3_scale_log(d3.scale.linear(), d3_scale_logp);
};

function d3_scale_log(linear, log) {
  var pow = log.pow;

  function scale(x) {
    return linear(log(x));
  }

  scale.invert = function(x) {
    return pow(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(pow);
    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
    pow = log.pow;
    linear.domain(x.map(log));
    return scale;
  };

  scale.nice = function() {
    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
    return scale;
  };

  scale.ticks = function() {
    var extent = d3_scaleExtent(linear.domain()),
        ticks = [];
    if (extent.every(isFinite)) {
      var i = Math.floor(extent[0]),
          j = Math.ceil(extent[1]),
          u = pow(extent[0]),
          v = pow(extent[1]);
      if (log === d3_scale_logn) {
        ticks.push(pow(i));
        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
      } else {
        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
        ticks.push(pow(i));
      }
      for (i = 0; ticks[i] < u; i++) {} // strip small values
      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values
      ticks = ticks.slice(i, j);
    }
    return ticks;
  };

  scale.tickFormat = function(n, format) {
    if (arguments.length < 2) format = d3_scale_logFormat;
    if (arguments.length < 1) return format;
    var k = Math.max(.1, n / scale.ticks().length),
        f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),
        e;
    return function(d) {
      return d / pow(f(log(d) + e)) <= k ? format(d) : "";
    };
  };

  scale.copy = function() {
    return d3_scale_log(linear.copy(), log);
  };

  return d3_scale_linearRebind(scale, linear);
}

var d3_scale_logFormat = d3.format(".0e");

function d3_scale_logp(x) {
  return Math.log(x < 0 ? 0 : x) / Math.LN10;
}

function d3_scale_logn(x) {
  return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
}

d3_scale_logp.pow = function(x) {
  return Math.pow(10, x);
};

d3_scale_logn.pow = function(x) {
  return -Math.pow(10, -x);
};
d3.scale.pow = function() {
  return d3_scale_pow(d3.scale.linear(), 1);
};

function d3_scale_pow(linear, exponent) {
  var powp = d3_scale_powPow(exponent),
      powb = d3_scale_powPow(1 / exponent);

  function scale(x) {
    return linear(powp(x));
  }

  scale.invert = function(x) {
    return powb(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(powb);
    linear.domain(x.map(powp));
    return scale;
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(scale.domain(), m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(scale.domain(), m);
  };

  scale.nice = function() {
    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
  };

  scale.exponent = function(x) {
    if (!arguments.length) return exponent;
    var domain = scale.domain();
    powp = d3_scale_powPow(exponent = x);
    powb = d3_scale_powPow(1 / exponent);
    return scale.domain(domain);
  };

  scale.copy = function() {
    return d3_scale_pow(linear.copy(), exponent);
  };

  return d3_scale_linearRebind(scale, linear);
}

function d3_scale_powPow(e) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
  };
}
d3.scale.sqrt = function() {
  return d3.scale.pow().exponent(.5);
};
d3.scale.ordinal = function() {
  return d3_scale_ordinal([], {t: "range", x: []});
};

function d3_scale_ordinal(domain, ranger) {
  var index,
      range,
      rangeBand;

  function scale(x) {
    return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
  }

  function steps(start, step) {
    return d3.range(domain.length).map(function(i) { return start + step * i; });
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = [];
    index = new d3_Map;
    var i = -1, n = x.length, xi;
    while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
    return scale[ranger.t](ranger.x, ranger.p);
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    rangeBand = 0;
    ranger = {t: "range", x: x};
    return scale;
  };

  scale.rangePoints = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length - 1 + padding);
    range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
    rangeBand = 0;
    ranger = {t: "rangePoints", x: x, p: padding};
    return scale;
  };

  scale.rangeBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var reverse = x[1] < x[0],
        start = x[reverse - 0],
        stop = x[1 - reverse],
        step = (stop - start) / (domain.length + padding);
    range = steps(start + step * padding, step);
    if (reverse) range.reverse();
    rangeBand = step * (1 - padding);
    ranger = {t: "rangeBands", x: x, p: padding};
    return scale;
  };

  scale.rangeRoundBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var reverse = x[1] < x[0],
        start = x[reverse - 0],
        stop = x[1 - reverse],
        step = Math.floor((stop - start) / (domain.length + padding)),
        error = stop - start - (domain.length - padding) * step;
    range = steps(start + Math.round(error / 2), step);
    if (reverse) range.reverse();
    rangeBand = Math.round(step * (1 - padding));
    ranger = {t: "rangeRoundBands", x: x, p: padding};
    return scale;
  };

  scale.rangeBand = function() {
    return rangeBand;
  };

  scale.rangeExtent = function() {
    return d3_scaleExtent(ranger.x);
  };

  scale.copy = function() {
    return d3_scale_ordinal(domain, ranger);
  };

  return scale.domain(domain);
}
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.
 */

d3.scale.category10 = function() {
  return d3.scale.ordinal().range(d3_category10);
};

d3.scale.category20 = function() {
  return d3.scale.ordinal().range(d3_category20);
};

d3.scale.category20b = function() {
  return d3.scale.ordinal().range(d3_category20b);
};

d3.scale.category20c = function() {
  return d3.scale.ordinal().range(d3_category20c);
};

var d3_category10 = [
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
];

var d3_category20 = [
  "#1f77b4", "#aec7e8",
  "#ff7f0e", "#ffbb78",
  "#2ca02c", "#98df8a",
  "#d62728", "#ff9896",
  "#9467bd", "#c5b0d5",
  "#8c564b", "#c49c94",
  "#e377c2", "#f7b6d2",
  "#7f7f7f", "#c7c7c7",
  "#bcbd22", "#dbdb8d",
  "#17becf", "#9edae5"
];

var d3_category20b = [
  "#393b79", "#5254a3", "#6b6ecf", "#9c9ede",
  "#637939", "#8ca252", "#b5cf6b", "#cedb9c",
  "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94",
  "#843c39", "#ad494a", "#d6616b", "#e7969c",
  "#7b4173", "#a55194", "#ce6dbd", "#de9ed6"
];

var d3_category20c = [
  "#3182bd", "#6baed6", "#9ecae1", "#c6dbef",
  "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2",
  "#31a354", "#74c476", "#a1d99b", "#c7e9c0",
  "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb",
  "#636363", "#969696", "#bdbdbd", "#d9d9d9"
];
d3.scale.quantile = function() {
  return d3_scale_quantile([], []);
};

function d3_scale_quantile(domain, range) {
  var thresholds;

  function rescale() {
    var k = 0,
        n = domain.length,
        q = range.length;
    thresholds = [];
    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
    return scale;
  }

  function scale(x) {
    if (isNaN(x = +x)) return NaN;
    return range[d3.bisect(thresholds, x)];
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.quantiles = function() {
    return thresholds;
  };

  scale.copy = function() {
    return d3_scale_quantile(domain, range); // copy on write!
  };

  return rescale();
}
d3.scale.quantize = function() {
  return d3_scale_quantize(0, 1, [0, 1]);
};

function d3_scale_quantize(x0, x1, range) {
  var kx, i;

  function scale(x) {
    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
  }

  function rescale() {
    kx = range.length / (x1 - x0);
    i = range.length - 1;
    return scale;
  }

  scale.domain = function(x) {
    if (!arguments.length) return [x0, x1];
    x0 = +x[0];
    x1 = +x[x.length - 1];
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_quantize(x0, x1, range); // copy on write
  };

  return rescale();
}
d3.scale.identity = function() {
  return d3_scale_identity([0, 1]);
};

function d3_scale_identity(domain) {

  function identity(x) { return +x; }

  identity.invert = identity;

  identity.domain = identity.range = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(identity);
    return identity;
  };

  identity.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  identity.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  identity.copy = function() {
    return d3_scale_identity(domain);
  };

  return identity;
}
d3.svg = {};
d3.svg.arc = function() {
  var innerRadius = d3_svg_arcInnerRadius,
      outerRadius = d3_svg_arcOuterRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  function arc() {
    var r0 = innerRadius.apply(this, arguments),
        r1 = outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,
        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,
        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),
        df = da < Math.PI ? "0" : "1",
        c0 = Math.cos(a0),
        s0 = Math.sin(a0),
        c1 = Math.cos(a1),
        s1 = Math.sin(a1);
    return da >= d3_svg_arcMax
      ? (r0
      ? "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "M0," + r0
      + "A" + r0 + "," + r0 + " 0 1,0 0," + (-r0)
      + "A" + r0 + "," + r0 + " 0 1,0 0," + r0
      + "Z"
      : "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "Z")
      : (r0
      ? "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L" + r0 * c1 + "," + r0 * s1
      + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0
      + "Z"
      : "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L0,0"
      + "Z");
  }

  arc.innerRadius = function(v) {
    if (!arguments.length) return innerRadius;
    innerRadius = d3_functor(v);
    return arc;
  };

  arc.outerRadius = function(v) {
    if (!arguments.length) return outerRadius;
    outerRadius = d3_functor(v);
    return arc;
  };

  arc.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3_functor(v);
    return arc;
  };

  arc.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3_functor(v);
    return arc;
  };

  arc.centroid = function() {
    var r = (innerRadius.apply(this, arguments)
        + outerRadius.apply(this, arguments)) / 2,
        a = (startAngle.apply(this, arguments)
        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  return arc;
};

var d3_svg_arcOffset = -Math.PI / 2,
    d3_svg_arcMax = 2 * Math.PI - 1e-6;

function d3_svg_arcInnerRadius(d) {
  return d.innerRadius;
}

function d3_svg_arcOuterRadius(d) {
  return d.outerRadius;
}

function d3_svg_arcStartAngle(d) {
  return d.startAngle;
}

function d3_svg_arcEndAngle(d) {
  return d.endAngle;
}
function d3_svg_line(projection) {
  var x = d3_svg_lineX,
      y = d3_svg_lineY,
      defined = d3_true,
      interpolate = d3_svg_lineInterpolatorDefault,
      interpolator = d3_svg_lineLinear,
      tension = .7;

  function line(data) {
    var segments = [],
        points = [],
        i = -1,
        n = data.length,
        d,
        fx = d3_functor(x),
        fy = d3_functor(y);

    function segment() {
      segments.push("M", interpolator(projection(points), tension));
    }

    while (++i < n) {
      if (defined.call(this, d = data[i], i)) {
        points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
      } else if (points.length) {
        segment();
        points = [];
      }
    }

    if (points.length) segment();

    return segments.length ? segments.join("") : null;
  }

  line.x = function(_) {
    if (!arguments.length) return x;
    x = _;
    return line;
  };

  line.y = function(_) {
    if (!arguments.length) return y;
    y = _;
    return line;
  };

  line.defined  = function(_) {
    if (!arguments.length) return defined;
    defined = _;
    return line;
  };

  line.interpolate = function(_) {
    if (!arguments.length) return interpolate;
    if (!d3_svg_lineInterpolators.has(_ += "")) _ = d3_svg_lineInterpolatorDefault;
    interpolator = d3_svg_lineInterpolators.get(interpolate = _);
    return line;
  };

  line.tension = function(_) {
    if (!arguments.length) return tension;
    tension = _;
    return line;
  };

  return line;
}

d3.svg.line = function() {
  return d3_svg_line(d3_identity);
};

// The default `x` property, which references d[0].
function d3_svg_lineX(d) {
  return d[0];
}

// The default `y` property, which references d[1].
function d3_svg_lineY(d) {
  return d[1];
}

var d3_svg_lineInterpolatorDefault = "linear";

// The various interpolators supported by the `line` class.
var d3_svg_lineInterpolators = d3.map({
  "linear": d3_svg_lineLinear,
  "step-before": d3_svg_lineStepBefore,
  "step-after": d3_svg_lineStepAfter,
  "basis": d3_svg_lineBasis,
  "basis-open": d3_svg_lineBasisOpen,
  "basis-closed": d3_svg_lineBasisClosed,
  "bundle": d3_svg_lineBundle,
  "cardinal": d3_svg_lineCardinal,
  "cardinal-open": d3_svg_lineCardinalOpen,
  "cardinal-closed": d3_svg_lineCardinalClosed,
  "monotone": d3_svg_lineMonotone
});

// Linear interpolation; generates "L" commands.
function d3_svg_lineLinear(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("L", (p = points[i])[0], ",", p[1]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepBefore(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepAfter(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
  return path.join("");
}

// Open cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalOpen(points, tension) {
  return points.length < 4
      ? d3_svg_lineLinear(points)
      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),
        d3_svg_lineCardinalTangents(points, tension));
}

// Closed cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalClosed(points, tension) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),
        d3_svg_lineCardinalTangents([points[points.length - 2]]
        .concat(points, [points[1]]), tension));
}

// Cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinal(points, tension, closed) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points,
        d3_svg_lineCardinalTangents(points, tension));
}

// Hermite spline construction; generates "C" commands.
function d3_svg_lineHermite(points, tangents) {
  if (tangents.length < 1
      || (points.length != tangents.length
      && points.length != tangents.length + 2)) {
    return d3_svg_lineLinear(points);
  }

  var quad = points.length != tangents.length,
      path = "",
      p0 = points[0],
      p = points[1],
      t0 = tangents[0],
      t = t0,
      pi = 1;

  if (quad) {
    path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3)
        + "," + p[0] + "," + p[1];
    p0 = points[1];
    pi = 2;
  }

  if (tangents.length > 1) {
    t = tangents[1];
    p = points[pi];
    pi++;
    path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1])
        + "," + (p[0] - t[0]) + "," + (p[1] - t[1])
        + "," + p[0] + "," + p[1];
    for (var i = 2; i < tangents.length; i++, pi++) {
      p = points[pi];
      t = tangents[i];
      path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1])
          + "," + p[0] + "," + p[1];
    }
  }

  if (quad) {
    var lp = points[pi];
    path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3)
        + "," + lp[0] + "," + lp[1];
  }

  return path;
}

// Generates tangents for a cardinal spline.
function d3_svg_lineCardinalTangents(points, tension) {
  var tangents = [],
      a = (1 - tension) / 2,
      p0,
      p1 = points[0],
      p2 = points[1],
      i = 1,
      n = points.length;
  while (++i < n) {
    p0 = p1;
    p1 = p2;
    p2 = points[i];
    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
  }
  return tangents;
}

// B-spline interpolation; generates "C" commands.
function d3_svg_lineBasis(points) {
  if (points.length < 3) return d3_svg_lineLinear(points);
  var i = 1,
      n = points.length,
      pi = points[0],
      x0 = pi[0],
      y0 = pi[1],
      px = [x0, x0, x0, (pi = points[1])[0]],
      py = [y0, y0, y0, pi[1]],
      path = [x0, ",", y0];
  d3_svg_lineBasisBezier(path, px, py);
  while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  i = -1;
  while (++i < 2) {
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Open B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisOpen(points) {
  if (points.length < 4) return d3_svg_lineLinear(points);
  var path = [],
      i = -1,
      n = points.length,
      pi,
      px = [0],
      py = [0];
  while (++i < 3) {
    pi = points[i];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)
    + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
  --i; while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Closed B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisClosed(points) {
  var path,
      i = -1,
      n = points.length,
      m = n + 4,
      pi,
      px = [],
      py = [];
  while (++i < 4) {
    pi = points[i % n];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path = [
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",",
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
  ];
  --i; while (++i < m) {
    pi = points[i % n];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

function d3_svg_lineBundle(points, tension) {
  var n = points.length - 1;
  if (n) {
    var x0 = points[0][0],
        y0 = points[0][1],
        dx = points[n][0] - x0,
        dy = points[n][1] - y0,
        i = -1,
        p,
        t;
    while (++i <= n) {
      p = points[i];
      t = i / n;
      p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
      p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
    }
  }
  return d3_svg_lineBasis(points);
}

// Returns the dot product of the given four-element vectors.
function d3_svg_lineDot4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

// Matrix to transform basis (b-spline) control points to bezier
// control points. Derived from FvD 11.2.8.
var d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],
    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],
    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];

// Pushes a "C" Bézier curve onto the specified path array, given the
// two specified four-element arrays which define the control points.
function d3_svg_lineBasisBezier(path, x, y) {
  path.push(
      "C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
}

// Computes the slope from points p0 to p1.
function d3_svg_lineSlope(p0, p1) {
  return (p1[1] - p0[1]) / (p1[0] - p0[0]);
}

// Compute three-point differences for the given points.
// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference
function d3_svg_lineFiniteDifferences(points) {
  var i = 0,
      j = points.length - 1,
      m = [],
      p0 = points[0],
      p1 = points[1],
      d = m[0] = d3_svg_lineSlope(p0, p1);
  while (++i < j) {
    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));
  }
  m[i] = d;
  return m;
}

// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite
// interpolation. Returns an array of tangent vectors. For details, see
// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
function d3_svg_lineMonotoneTangents(points) {
  var tangents = [],
      d,
      a,
      b,
      s,
      m = d3_svg_lineFiniteDifferences(points),
      i = -1,
      j = points.length - 1;

  // The first two steps are done by computing finite-differences:
  // 1. Compute the slopes of the secant lines between successive points.
  // 2. Initialize the tangents at every point as the average of the secants.

  // Then, for each segment…
  while (++i < j) {
    d = d3_svg_lineSlope(points[i], points[i + 1]);

    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set
    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to
    // preserve monotonicity. Ignore step 4 and 5 for those k.

    if (Math.abs(d) < 1e-6) {
      m[i] = m[i + 1] = 0;
    } else {
      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.
      a = m[i] / d;
      b = m[i + 1] / d;

      // 5. Prevent overshoot and ensure monotonicity by restricting the
      // magnitude of vector <ak, bk> to a circle of radius 3.
      s = a * a + b * b;
      if (s > 9) {
        s = d * 3 / Math.sqrt(s);
        m[i] = s * a;
        m[i + 1] = s * b;
      }
    }
  }

  // Compute the normalized tangent vector from the slopes. Note that if x is
  // not monotonic, it's possible that the slope will be infinite, so we protect
  // against NaN by setting the coordinate to zero.
  i = -1; while (++i <= j) {
    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
    tangents.push([s || 0, m[i] * s || 0]);
  }

  return tangents;
}

function d3_svg_lineMonotone(points) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
}
d3.svg.line.radial = function() {
  var line = d3_svg_line(d3_svg_lineRadial);
  line.radius = line.x, delete line.x;
  line.angle = line.y, delete line.y;
  return line;
};

function d3_svg_lineRadial(points) {
  var point,
      i = -1,
      n = points.length,
      r,
      a;
  while (++i < n) {
    point = points[i];
    r = point[0];
    a = point[1] + d3_svg_arcOffset;
    point[0] = r * Math.cos(a);
    point[1] = r * Math.sin(a);
  }
  return points;
}
function d3_svg_area(projection) {
  var x0 = d3_svg_lineX,
      x1 = d3_svg_lineX,
      y0 = 0,
      y1 = d3_svg_lineY,
      defined = d3_true,
      interpolate = d3_svg_lineInterpolatorDefault,
      i0 = d3_svg_lineLinear,
      i1 = d3_svg_lineLinear,
      L = "L",
      tension = .7;

  function area(data) {
    var segments = [],
        points0 = [],
        points1 = [],
        i = -1,
        n = data.length,
        d,
        fx0 = d3_functor(x0),
        fy0 = d3_functor(y0),
        fx1 = x0 === x1 ? function() { return x; } : d3_functor(x1),
        fy1 = y0 === y1 ? function() { return y; } : d3_functor(y1),
        x,
        y;

    function segment() {
      segments.push("M", i0(projection(points1), tension),
          L, i1(projection(points0.reverse()), tension),
          "Z");
    }

    while (++i < n) {
      if (defined.call(this, d = data[i], i)) {
        points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
        points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
      } else if (points0.length) {
        segment();
        points0 = [];
        points1 = [];
      }
    }

    if (points0.length) segment();

    return segments.length ? segments.join("") : null;
  }

  area.x = function(_) {
    if (!arguments.length) return x1;
    x0 = x1 = _;
    return area;
  };

  area.x0 = function(_) {
    if (!arguments.length) return x0;
    x0 = _;
    return area;
  };

  area.x1 = function(_) {
    if (!arguments.length) return x1;
    x1 = _;
    return area;
  };

  area.y = function(_) {
    if (!arguments.length) return y1;
    y0 = y1 = _;
    return area;
  };

  area.y0 = function(_) {
    if (!arguments.length) return y0;
    y0 = _;
    return area;
  };

  area.y1 = function(_) {
    if (!arguments.length) return y1;
    y1 = _;
    return area;
  };

  area.defined  = function(_) {
    if (!arguments.length) return defined;
    defined = _;
    return area;
  };

  area.interpolate = function(_) {
    if (!arguments.length) return interpolate;
    if (!d3_svg_lineInterpolators.has(_ += "")) _ = d3_svg_lineInterpolatorDefault;
    i0 = d3_svg_lineInterpolators.get(interpolate = _);
    i1 = i0.reverse || i0;
    L = /-closed$/.test(_) ? "M" : "L";
    return area;
  };

  area.tension = function(_) {
    if (!arguments.length) return tension;
    tension = _;
    return area;
  };

  return area;
}

d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;

d3.svg.area = function() {
  return d3_svg_area(Object);
};
d3.svg.area.radial = function() {
  var area = d3_svg_area(d3_svg_lineRadial);
  area.radius = area.x, delete area.x;
  area.innerRadius = area.x0, delete area.x0;
  area.outerRadius = area.x1, delete area.x1;
  area.angle = area.y, delete area.y;
  area.startAngle = area.y0, delete area.y0;
  area.endAngle = area.y1, delete area.y1;
  return area;
};
d3.svg.chord = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      radius = d3_svg_chordRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  // TODO Allow control point to be customized.

  function chord(d, i) {
    var s = subgroup(this, source, d, i),
        t = subgroup(this, target, d, i);
    return "M" + s.p0
      + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)
      ? curve(s.r, s.p1, s.r, s.p0)
      : curve(s.r, s.p1, t.r, t.p0)
      + arc(t.r, t.p1, t.a1 - t.a0)
      + curve(t.r, t.p1, s.r, s.p0))
      + "Z";
  }

  function subgroup(self, f, d, i) {
    var subgroup = f.call(self, d, i),
        r = radius.call(self, subgroup, i),
        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,
        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
    return {
      r: r,
      a0: a0,
      a1: a1,
      p0: [r * Math.cos(a0), r * Math.sin(a0)],
      p1: [r * Math.cos(a1), r * Math.sin(a1)]
    };
  }

  function equals(a, b) {
    return a.a0 == b.a0 && a.a1 == b.a1;
  }

  function arc(r, p, a) {
    return "A" + r + "," + r + " 0 " + +(a > Math.PI) + ",1 " + p;
  }

  function curve(r0, p0, r1, p1) {
    return "Q 0,0 " + p1;
  }

  chord.radius = function(v) {
    if (!arguments.length) return radius;
    radius = d3_functor(v);
    return chord;
  };

  chord.source = function(v) {
    if (!arguments.length) return source;
    source = d3_functor(v);
    return chord;
  };

  chord.target = function(v) {
    if (!arguments.length) return target;
    target = d3_functor(v);
    return chord;
  };

  chord.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3_functor(v);
    return chord;
  };

  chord.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3_functor(v);
    return chord;
  };

  return chord;
};

function d3_svg_chordSource(d) {
  return d.source;
}

function d3_svg_chordTarget(d) {
  return d.target;
}

function d3_svg_chordRadius(d) {
  return d.radius;
}

function d3_svg_chordStartAngle(d) {
  return d.startAngle;
}

function d3_svg_chordEndAngle(d) {
  return d.endAngle;
}
d3.svg.diagonal = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      projection = d3_svg_diagonalProjection;

  function diagonal(d, i) {
    var p0 = source.call(this, d, i),
        p3 = target.call(this, d, i),
        m = (p0.y + p3.y) / 2,
        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
    p = p.map(projection);
    return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
  }

  diagonal.source = function(x) {
    if (!arguments.length) return source;
    source = d3_functor(x);
    return diagonal;
  };

  diagonal.target = function(x) {
    if (!arguments.length) return target;
    target = d3_functor(x);
    return diagonal;
  };

  diagonal.projection = function(x) {
    if (!arguments.length) return projection;
    projection = x;
    return diagonal;
  };

  return diagonal;
};

function d3_svg_diagonalProjection(d) {
  return [d.x, d.y];
}
d3.svg.diagonal.radial = function() {
  var diagonal = d3.svg.diagonal(),
      projection = d3_svg_diagonalProjection,
      projection_ = diagonal.projection;

  diagonal.projection = function(x) {
    return arguments.length
        ? projection_(d3_svg_diagonalRadialProjection(projection = x))
        : projection;
  };

  return diagonal;
};

function d3_svg_diagonalRadialProjection(projection) {
  return function() {
    var d = projection.apply(this, arguments),
        r = d[0],
        a = d[1] + d3_svg_arcOffset;
    return [r * Math.cos(a), r * Math.sin(a)];
  };
}
d3.svg.mouse = d3.mouse;
d3.svg.touches = d3.touches;
d3.svg.symbol = function() {
  var type = d3_svg_symbolType,
      size = d3_svg_symbolSize;

  function symbol(d, i) {
    return (d3_svg_symbols.get(type.call(this, d, i))
        || d3_svg_symbolCircle)
        (size.call(this, d, i));
  }

  symbol.type = function(x) {
    if (!arguments.length) return type;
    type = d3_functor(x);
    return symbol;
  };

  // size of symbol in square pixels
  symbol.size = function(x) {
    if (!arguments.length) return size;
    size = d3_functor(x);
    return symbol;
  };

  return symbol;
};

function d3_svg_symbolSize() {
  return 64;
}

function d3_svg_symbolType() {
  return "circle";
}

function d3_svg_symbolCircle(size) {
  var r = Math.sqrt(size / Math.PI);
  return "M0," + r
      + "A" + r + "," + r + " 0 1,1 0," + (-r)
      + "A" + r + "," + r + " 0 1,1 0," + r
      + "Z";
}

// TODO cross-diagonal?
var d3_svg_symbols = d3.map({
  "circle": d3_svg_symbolCircle,
  "cross": function(size) {
    var r = Math.sqrt(size / 5) / 2;
    return "M" + -3 * r + "," + -r
        + "H" + -r
        + "V" + -3 * r
        + "H" + r
        + "V" + -r
        + "H" + 3 * r
        + "V" + r
        + "H" + r
        + "V" + 3 * r
        + "H" + -r
        + "V" + r
        + "H" + -3 * r
        + "Z";
  },
  "diamond": function(size) {
    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
        rx = ry * d3_svg_symbolTan30;
    return "M0," + -ry
        + "L" + rx + ",0"
        + " 0," + ry
        + " " + -rx + ",0"
        + "Z";
  },
  "square": function(size) {
    var r = Math.sqrt(size) / 2;
    return "M" + -r + "," + -r
        + "L" + r + "," + -r
        + " " + r + "," + r
        + " " + -r + "," + r
        + "Z";
  },
  "triangle-down": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + ry
        + "L" + rx +"," + -ry
        + " " + -rx + "," + -ry
        + "Z";
  },
  "triangle-up": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + -ry
        + "L" + rx +"," + ry
        + " " + -rx + "," + ry
        + "Z";
  }
});

d3.svg.symbolTypes = d3_svg_symbols.keys();

var d3_svg_symbolSqrt3 = Math.sqrt(3),
    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);
d3.svg.axis = function() {
  var scale = d3.scale.linear(),
      orient = "bottom",
      tickMajorSize = 6,
      tickMinorSize = 6,
      tickEndSize = 6,
      tickPadding = 3,
      tickArguments_ = [10],
      tickValues = null,
      tickFormat_,
      tickSubdivide = 0;

  function axis(g) {
    g.each(function() {
      var g = d3.select(this);

      // Ticks, or domain values for ordinal scales.
      var ticks = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues,
          tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_;

      // Minor ticks.
      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
          subtick = g.selectAll(".minor").data(subticks, String),
          subtickEnter = subtick.enter().insert("line", "g").attr("class", "tick minor").style("opacity", 1e-6),
          subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(),
          subtickUpdate = d3.transition(subtick).style("opacity", 1);

      // Major ticks.
      var tick = g.selectAll("g").data(ticks, String),
          tickEnter = tick.enter().insert("g", "path").style("opacity", 1e-6),
          tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(),
          tickUpdate = d3.transition(tick).style("opacity", 1),
          tickTransform;

      // Domain.
      var range = d3_scaleRange(scale),
          path = g.selectAll(".domain").data([0]),
          pathEnter = path.enter().append("path").attr("class", "domain"),
          pathUpdate = d3.transition(path);

      // Stash a snapshot of the new scale, and retrieve the old snapshot.
      var scale1 = scale.copy(),
          scale0 = this.__chart__ || scale1;
      this.__chart__ = scale1;

      tickEnter.append("line").attr("class", "tick");
      tickEnter.append("text");

      var lineEnter = tickEnter.select("line"),
          lineUpdate = tickUpdate.select("line"),
          text = tick.select("text").text(tickFormat),
          textEnter = tickEnter.select("text"),
          textUpdate = tickUpdate.select("text");

      switch (orient) {
        case "bottom": {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr("y2", tickMinorSize);
          subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
          lineEnter.attr("y2", tickMajorSize);
          textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
          lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
          textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
          text.attr("dy", ".71em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
          break;
        }
        case "top": {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr("y2", -tickMinorSize);
          subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
          lineEnter.attr("y2", -tickMajorSize);
          textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
          lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
          textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
          text.attr("dy", "0em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
          break;
        }
        case "left": {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr("x2", -tickMinorSize);
          subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
          lineEnter.attr("x2", -tickMajorSize);
          textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
          lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
          textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
          text.attr("dy", ".32em").attr("text-anchor", "end");
          pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
          break;
        }
        case "right": {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr("x2", tickMinorSize);
          subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
          lineEnter.attr("x2", tickMajorSize);
          textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
          lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
          textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
          text.attr("dy", ".32em").attr("text-anchor", "start");
          pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
          break;
        }
      }

      // For quantitative scales:
      // - enter new ticks from the old scale
      // - exit old ticks to the new scale
      if (scale.ticks) {
        tickEnter.call(tickTransform, scale0);
        tickUpdate.call(tickTransform, scale1);
        tickExit.call(tickTransform, scale1);
        subtickEnter.call(tickTransform, scale0);
        subtickUpdate.call(tickTransform, scale1);
        subtickExit.call(tickTransform, scale1);
      }

      // For ordinal scales:
      // - any entering ticks are undefined in the old scale
      // - any exiting ticks are undefined in the new scale
      // Therefore, we only need to transition updating ticks.
      else {
        var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };
        tickEnter.call(tickTransform, x);
        tickUpdate.call(tickTransform, x);
      }
    });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    scale = x;
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x;
    return axis;
  };

  axis.ticks = function() {
    if (!arguments.length) return tickArguments_;
    tickArguments_ = arguments;
    return axis;
  };

  axis.tickValues = function(x) {
    if (!arguments.length) return tickValues;
    tickValues = x;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormat_;
    tickFormat_ = x;
    return axis;
  };

  axis.tickSize = function(x, y, z) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1;
    tickMajorSize = +x;
    tickMinorSize = n > 1 ? +y : tickMajorSize;
    tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    tickPadding = +x;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };

  return axis;
};

function d3_svg_axisX(selection, x) {
  selection.attr("transform", function(d) { return "translate(" + x(d) + ",0)"; });
}

function d3_svg_axisY(selection, y) {
  selection.attr("transform", function(d) { return "translate(0," + y(d) + ")"; });
}

function d3_svg_axisSubdivide(scale, ticks, m) {
  subticks = [];
  if (m && ticks.length > 1) {
    var extent = d3_scaleExtent(scale.domain()),
        subticks,
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i < n) {
      for (j = m; --j > 0;) {
        if ((v = +ticks[i] - j * d) >= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}
d3.svg.brush = function() {
  var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
      x = null, // x-scale, optional
      y = null, // y-scale, optional
      resizes = d3_svg_brushResizes[0],
      extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1], in pixels (integers)
      extentDomain; // the extent in data space, lazily created

  function brush(g) {
    g.each(function() {
      var g = d3.select(this),
          bg = g.selectAll(".background").data([0]),
          fg = g.selectAll(".extent").data([0]),
          tz = g.selectAll(".resize").data(resizes, String),
          e;

      // Prepare the brush container for events.
      g
          .style("pointer-events", "all")
          .on("mousedown.brush", brushstart)
          .on("touchstart.brush", brushstart);

      // An invisible, mouseable area for starting a new brush.
      bg.enter().append("rect")
          .attr("class", "background")
          .style("visibility", "hidden")
          .style("cursor", "crosshair");

      // The visible brush extent; style this as you like!
      fg.enter().append("rect")
          .attr("class", "extent")
          .style("cursor", "move");

      // More invisible rects for resizing the extent.
      tz.enter().append("g")
          .attr("class", function(d) { return "resize " + d; })
          .style("cursor", function(d) { return d3_svg_brushCursor[d]; })
        .append("rect")
          .attr("x", function(d) { return /[ew]$/.test(d) ? -3 : null; })
          .attr("y", function(d) { return /^[ns]/.test(d) ? -3 : null; })
          .attr("width", 6)
          .attr("height", 6)
          .style("visibility", "hidden");

      // Show or hide the resizers.
      tz.style("display", brush.empty() ? "none" : null);

      // Remove any superfluous resizers.
      tz.exit().remove();

      // Initialize the background to fill the defined range.
      // If the range isn't defined, you can post-process.
      if (x) {
        e = d3_scaleRange(x);
        bg.attr("x", e[0]).attr("width", e[1] - e[0]);
        redrawX(g);
      }
      if (y) {
        e = d3_scaleRange(y);
        bg.attr("y", e[0]).attr("height", e[1] - e[0]);
        redrawY(g);
      }
      redraw(g);
    });
  }

  function redraw(g) {
    g.selectAll(".resize").attr("transform", function(d) {
      return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
    });
  }

  function redrawX(g) {
    g.select(".extent").attr("x", extent[0][0]);
    g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
  }

  function redrawY(g) {
    g.select(".extent").attr("y", extent[0][1]);
    g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
  }

  function brushstart() {
    var target = this,
        eventTarget = d3.select(d3.event.target),
        event_ = event.of(target, arguments),
        g = d3.select(target),
        resizing = eventTarget.datum(),
        resizingX = !/^(n|s)$/.test(resizing) && x,
        resizingY = !/^(e|w)$/.test(resizing) && y,
        dragging = eventTarget.classed("extent"),
        center,
        origin = mouse(),
        offset;

    var w = d3.select(window)
        .on("mousemove.brush", brushmove)
        .on("mouseup.brush", brushend)
        .on("touchmove.brush", brushmove)
        .on("touchend.brush", brushend)
        .on("keydown.brush", keydown)
        .on("keyup.brush", keyup);

    // If the extent was clicked on, drag rather than brush;
    // store the point between the mouse and extent origin instead.
    if (dragging) {
      origin[0] = extent[0][0] - origin[0];
      origin[1] = extent[0][1] - origin[1];
    }

    // If a resizer was clicked on, record which side is to be resized.
    // Also, set the origin to the opposite side.
    else if (resizing) {
      var ex = +/w$/.test(resizing),
          ey = +/^n/.test(resizing);
      offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];
      origin[0] = extent[ex][0];
      origin[1] = extent[ey][1];
    }

    // If the ALT key is down when starting a brush, the center is at the mouse.
    else if (d3.event.altKey) center = origin.slice();

    // Propagate the active cursor to the body for the drag duration.
    g.style("pointer-events", "none").selectAll(".resize").style("display", null);
    d3.select("body").style("cursor", eventTarget.style("cursor"));

    // Notify listeners.
    event_({type: "brushstart"});
    brushmove();
    d3_eventCancel();

    function mouse() {
      var touches = d3.event.changedTouches;
      return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
    }

    function keydown() {
      if (d3.event.keyCode == 32) {
        if (!dragging) {
          center = null;
          origin[0] -= extent[1][0];
          origin[1] -= extent[1][1];
          dragging = 2;
        }
        d3_eventCancel();
      }
    }

    function keyup() {
      if (d3.event.keyCode == 32 && dragging == 2) {
        origin[0] += extent[1][0];
        origin[1] += extent[1][1];
        dragging = 0;
        d3_eventCancel();
      }
    }

    function brushmove() {
      var point = mouse(),
          moved = false;

      // Preserve the offset for thick resizers.
      if (offset) {
        point[0] += offset[0];
        point[1] += offset[1];
      }

      if (!dragging) {

        // If needed, determine the center from the current extent.
        if (d3.event.altKey) {
          if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];

          // Update the origin, for when the ALT key is released.
          origin[0] = extent[+(point[0] < center[0])][0];
          origin[1] = extent[+(point[1] < center[1])][1];
        }

        // When the ALT key is released, we clear the center.
        else center = null;
      }

      // Update the brush extent for each dimension.
      if (resizingX && move1(point, x, 0)) {
        redrawX(g);
        moved = true;
      }
      if (resizingY && move1(point, y, 1)) {
        redrawY(g);
        moved = true;
      }

      // Final redraw and notify listeners.
      if (moved) {
        redraw(g);
        event_({type: "brush", mode: dragging ? "move" : "resize"});
      }
    }

    function move1(point, scale, i) {
      var range = d3_scaleRange(scale),
          r0 = range[0],
          r1 = range[1],
          position = origin[i],
          size = extent[1][i] - extent[0][i],
          min,
          max;

      // When dragging, reduce the range by the extent size and position.
      if (dragging) {
        r0 -= position;
        r1 -= size + position;
      }

      // Clamp the point so that the extent fits within the range extent.
      min = Math.max(r0, Math.min(r1, point[i]));

      // Compute the new extent bounds.
      if (dragging) {
        max = (min += position) + size;
      } else {

        // If the ALT key is pressed, then preserve the center of the extent.
        if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));

        // Compute the min and max of the position and point.
        if (position < min) {
          max = min;
          min = position;
        } else {
          max = position;
        }
      }

      // Update the stored bounds.
      if (extent[0][i] !== min || extent[1][i] !== max) {
        extentDomain = null;
        extent[0][i] = min;
        extent[1][i] = max;
        return true;
      }
    }

    function brushend() {
      brushmove();

      // reset the cursor styles
      g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
      d3.select("body").style("cursor", null);

      w .on("mousemove.brush", null)
        .on("mouseup.brush", null)
        .on("touchmove.brush", null)
        .on("touchend.brush", null)
        .on("keydown.brush", null)
        .on("keyup.brush", null);

      event_({type: "brushend"});
      d3_eventCancel();
    }
  }

  brush.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
    return brush;
  };

  brush.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
    return brush;
  };

  brush.extent = function(z) {
    var x0, x1, y0, y1, t;

    // Invert the pixel extent to data-space.
    if (!arguments.length) {
      z = extentDomain || extent;
      if (x) {
        x0 = z[0][0], x1 = z[1][0];
        if (!extentDomain) {
          x0 = extent[0][0], x1 = extent[1][0];
          if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
          if (x1 < x0) t = x0, x0 = x1, x1 = t;
        }
      }
      if (y) {
        y0 = z[0][1], y1 = z[1][1];
        if (!extentDomain) {
          y0 = extent[0][1], y1 = extent[1][1];
          if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
          if (y1 < y0) t = y0, y0 = y1, y1 = t;
        }
      }
      return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
    }

    // Scale the data-space extent to pixels.
    extentDomain = [[0, 0], [0, 0]];
    if (x) {
      x0 = z[0], x1 = z[1];
      if (y) x0 = x0[0], x1 = x1[0];
      extentDomain[0][0] = x0, extentDomain[1][0] = x1;
      if (x.invert) x0 = x(x0), x1 = x(x1);
      if (x1 < x0) t = x0, x0 = x1, x1 = t;
      extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
    }
    if (y) {
      y0 = z[0], y1 = z[1];
      if (x) y0 = y0[1], y1 = y1[1];
      extentDomain[0][1] = y0, extentDomain[1][1] = y1;
      if (y.invert) y0 = y(y0), y1 = y(y1);
      if (y1 < y0) t = y0, y0 = y1, y1 = t;
      extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
    }

    return brush;
  };

  brush.clear = function() {
    extentDomain = null;
    extent[0][0] =
    extent[0][1] =
    extent[1][0] =
    extent[1][1] = 0;
    return brush;
  };

  brush.empty = function() {
    return (x && extent[0][0] === extent[1][0])
        || (y && extent[0][1] === extent[1][1]);
  };

  return d3.rebind(brush, event, "on");
};

var d3_svg_brushCursor = {
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var d3_svg_brushResizes = [
  ["n", "e", "s", "w", "nw", "ne", "se", "sw"],
  ["e", "w"],
  ["n", "s"],
  []
];
d3.behavior = {};
// TODO Track touch points by identifier.

d3.behavior.drag = function() {
  var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
      origin = null;

  function drag() {
    this.on("mousedown.drag", mousedown)
        .on("touchstart.drag", mousedown);
  }

  function mousedown() {
    var target = this,
        event_ = event.of(target, arguments),
        eventTarget = d3.event.target,
        offset,
        origin_ = point(),
        moved = 0;

    var w = d3.select(window)
        .on("mousemove.drag", dragmove)
        .on("touchmove.drag", dragmove)
        .on("mouseup.drag", dragend, true)
        .on("touchend.drag", dragend, true);

    if (origin) {
      offset = origin.apply(target, arguments);
      offset = [offset.x - origin_[0], offset.y - origin_[1]];
    } else {
      offset = [0, 0];
    }

    d3_eventCancel();
    event_({type: "dragstart"});

    function point() {
      var p = target.parentNode,
          t = d3.event.changedTouches;
      return t ? d3.touches(p, t)[0] : d3.mouse(p);
    }

    function dragmove() {
      if (!target.parentNode) return dragend(); // target removed from DOM

      var p = point(),
          dx = p[0] - origin_[0],
          dy = p[1] - origin_[1];

      moved |= dx | dy;
      origin_ = p;
      d3_eventCancel();

      event_({type: "drag", x: p[0] + offset[0], y: p[1] + offset[1], dx: dx, dy: dy});
    }

    function dragend() {
      event_({type: "dragend"});

      // if moved, prevent the mouseup (and possibly click) from propagating
      if (moved) {
        d3_eventCancel();
        if (d3.event.target === eventTarget) w.on("click.drag", click, true);
      }

      w .on("mousemove.drag", null)
        .on("touchmove.drag", null)
        .on("mouseup.drag", null)
        .on("touchend.drag", null);
    }

    // prevent the subsequent click from propagating (e.g., for anchors)
    function click() {
      d3_eventCancel();
      w.on("click.drag", null);
    }
  }

  drag.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return drag;
  };

  return d3.rebind(drag, event, "on");
};
d3.behavior.zoom = function() {
  var translate = [0, 0],
      translate0, // translate when we started zooming (to avoid drift)
      scale = 1,
      scale0, // scale when we started touching
      scaleExtent = d3_behavior_zoomInfinity,
      event = d3_eventDispatch(zoom, "zoom"),
      x0,
      x1,
      y0,
      y1,
      touchtime; // time of last touchstart (to detect double-tap)

  function zoom() {
    this
        .on("mousedown.zoom", mousedown)
        .on("mousewheel.zoom", mousewheel)
        .on("mousemove.zoom", mousemove)
        .on("DOMMouseScroll.zoom", mousewheel)
        .on("dblclick.zoom", dblclick)
        .on("touchstart.zoom", touchstart)
        .on("touchmove.zoom", touchmove)
        .on("touchend.zoom", touchstart);
  }

  zoom.translate = function(x) {
    if (!arguments.length) return translate;
    translate = x.map(Number);
    return zoom;
  };

  zoom.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return zoom;
  };

  zoom.scaleExtent = function(x) {
    if (!arguments.length) return scaleExtent;
    scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
    return zoom;
  };

  zoom.x = function(z) {
    if (!arguments.length) return x1;
    x1 = z;
    x0 = z.copy();
    return zoom;
  };

  zoom.y = function(z) {
    if (!arguments.length) return y1;
    y1 = z;
    y0 = z.copy();
    return zoom;
  };

  function location(p) {
    return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];
  }

  function point(l) {
    return [l[0] * scale + translate[0], l[1] * scale + translate[1]];
  }

  function scaleTo(s) {
    scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
  }

  function translateTo(p, l) {
    l = point(l);
    translate[0] += p[0] - l[0];
    translate[1] += p[1] - l[1];
  }

  function dispatch(event) {
    if (x1) x1.domain(x0.range().map(function(x) { return (x - translate[0]) / scale; }).map(x0.invert));
    if (y1) y1.domain(y0.range().map(function(y) { return (y - translate[1]) / scale; }).map(y0.invert));
    d3.event.preventDefault();
    event({type: "zoom", scale: scale, translate: translate});
  }

  function mousedown() {
    var target = this,
        event_ = event.of(target, arguments),
        eventTarget = d3.event.target,
        moved = 0,
        w = d3.select(window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup),
        l = location(d3.mouse(target));

    window.focus();
    d3_eventCancel();

    function mousemove() {
      moved = 1;
      translateTo(d3.mouse(target), l);
      dispatch(event_);
    }

    function mouseup() {
      if (moved) d3_eventCancel();
      w.on("mousemove.zoom", null).on("mouseup.zoom", null);
      if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
    }

    function click() {
      d3_eventCancel();
      w.on("click.zoom", null);
    }
  }

  function mousewheel() {
    if (!translate0) translate0 = location(d3.mouse(this));
    scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
    translateTo(d3.mouse(this), translate0);
    dispatch(event.of(this, arguments));
  }

  function mousemove() {
    translate0 = null;
  }

  function dblclick() {
    var p = d3.mouse(this), l = location(p);
    scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);
    translateTo(p, l);
    dispatch(event.of(this, arguments));
  }

  function touchstart() {
    var touches = d3.touches(this),
        now = Date.now();

    scale0 = scale;
    translate0 = {};
    touches.forEach(function(t) { translate0[t.identifier] = location(t); });
    d3_eventCancel();

    if ((touches.length === 1) && (now - touchtime < 500)) { // dbltap
      var p = touches[0], l = location(touches[0]);
      scaleTo(scale * 2);
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    touchtime = now;
  }

  function touchmove() {
    var touches = d3.touches(this),
        p0 = touches[0],
        l0 = translate0[p0.identifier];
    if (p1 = touches[1]) {
      var p1, l1 = translate0[p1.identifier];
      p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      scaleTo(d3.event.scale * scale0);
    }
    translateTo(p0, l0);
    dispatch(event.of(this, arguments));
  }

  return d3.rebind(zoom, event, "on");
};

var d3_behavior_zoomDiv, // for interpreting mousewheel events
    d3_behavior_zoomInfinity = [0, Infinity]; // default scale extent

function d3_behavior_zoomDelta() {

  // mousewheel events are totally broken!
  // https://bugs.webkit.org/show_bug.cgi?id=40441
  // not only that, but Chrome and Safari differ in re. to acceleration!
  if (!d3_behavior_zoomDiv) {
    d3_behavior_zoomDiv = d3.select("body").append("div")
        .style("visibility", "hidden")
        .style("top", 0)
        .style("height", 0)
        .style("width", 0)
        .style("overflow-y", "scroll")
      .append("div")
        .style("height", "2000px")
      .node().parentNode;
  }

  var e = d3.event, delta;
  try {
    d3_behavior_zoomDiv.scrollTop = 1000;
    d3_behavior_zoomDiv.dispatchEvent(e);
    delta = 1000 - d3_behavior_zoomDiv.scrollTop;
  } catch (error) {
    delta = e.wheelDelta || (-e.detail * 5);
  }

  return delta;
}
d3.layout = {};
// Implements hierarchical edge bundling using Holten's algorithm. For each
// input link, a path is computed that travels through the tree, up the parent
// hierarchy to the least common ancestor, and then back down to the destination
// node. Each path is simply an array of nodes.
d3.layout.bundle = function() {
  return function(links) {
    var paths = [],
        i = -1,
        n = links.length;
    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
    return paths;
  };
};

function d3_layout_bundlePath(link) {
  var start = link.source,
      end = link.target,
      lca = d3_layout_bundleLeastCommonAncestor(start, end),
      points = [start];
  while (start !== lca) {
    start = start.parent;
    points.push(start);
  }
  var k = points.length;
  while (end !== lca) {
    points.splice(k, 0, end);
    end = end.parent;
  }
  return points;
}

function d3_layout_bundleAncestors(node) {
  var ancestors = [],
      parent = node.parent;
  while (parent != null) {
    ancestors.push(node);
    node = parent;
    parent = parent.parent;
  }
  ancestors.push(node);
  return ancestors;
}

function d3_layout_bundleLeastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = d3_layout_bundleAncestors(a),
      bNodes = d3_layout_bundleAncestors(b),
      aNode = aNodes.pop(),
      bNode = bNodes.pop(),
      sharedNode = null;
  while (aNode === bNode) {
    sharedNode = aNode;
    aNode = aNodes.pop();
    bNode = bNodes.pop();
  }
  return sharedNode;
}
d3.layout.chord = function() {
  var chord = {},
      chords,
      groups,
      matrix,
      n,
      padding = 0,
      sortGroups,
      sortSubgroups,
      sortChords;

  function relayout() {
    var subgroups = {},
        groupSums = [],
        groupIndex = d3.range(n),
        subgroupIndex = [],
        k,
        x,
        x0,
        i,
        j;

    chords = [];
    groups = [];

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3.range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) {
      groupIndex.sort(function(a, b) {
        return sortGroups(groupSums[a], groupSums[b]);
      });
    }

    // Sort subgroups…
    if (sortSubgroups) {
      subgroupIndex.forEach(function(d, i) {
        d.sort(function(a, b) {
          return sortSubgroups(matrix[i][a], matrix[i][b]);
        });
      });
    }

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified.
    // TODO Allow padding to be specified as percentage?
    k = (2 * Math.PI - padding * n) / k;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[di + "-" + dj] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: (x - x0) / k
      };
      x += padding;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[i + "-" + j],
            target = subgroups[j + "-" + i];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    if (sortChords) resort();
  }

  function resort() {
    chords.sort(function(a, b) {
      return sortChords(
          (a.source.value + a.target.value) / 2,
          (b.source.value + b.target.value) / 2);
    });
  }

  chord.matrix = function(x) {
    if (!arguments.length) return matrix;
    n = (matrix = x) && matrix.length;
    chords = groups = null;
    return chord;
  };

  chord.padding = function(x) {
    if (!arguments.length) return padding;
    padding = x;
    chords = groups = null;
    return chord;
  };

  chord.sortGroups = function(x) {
    if (!arguments.length) return sortGroups;
    sortGroups = x;
    chords = groups = null;
    return chord;
  };

  chord.sortSubgroups = function(x) {
    if (!arguments.length) return sortSubgroups;
    sortSubgroups = x;
    chords = null;
    return chord;
  };

  chord.sortChords = function(x) {
    if (!arguments.length) return sortChords;
    sortChords = x;
    if (chords) resort();
    return chord;
  };

  chord.chords = function() {
    if (!chords) relayout();
    return chords;
  };

  chord.groups = function() {
    if (!groups) relayout();
    return groups;
  };

  return chord;
};
// A rudimentary force layout using Gauss-Seidel.
d3.layout.force = function() {
  var force = {},
      event = d3.dispatch("start", "tick", "end"),
      size = [1, 1],
      drag,
      alpha,
      friction = .9,
      linkDistance = d3_layout_forceLinkDistance,
      linkStrength = d3_layout_forceLinkStrength,
      charge = -30,
      gravity = .1,
      theta = .8,
      interval,
      nodes = [],
      links = [],
      distances,
      strengths,
      charges;

  function repulse(node) {
    return function(quad, x1, y1, x2, y2) {
      if (quad.point !== node) {
        var dx = quad.cx - node.x,
            dy = quad.cy - node.y,
            dn = 1 / Math.sqrt(dx * dx + dy * dy);

        /* Barnes-Hut criterion. */
        if ((x2 - x1) * dn < theta) {
          var k = quad.charge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
          return true;
        }

        if (quad.point && isFinite(dn)) {
          var k = quad.pointCharge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
        }
      }
      return !quad.charge;
    };
  }

  force.tick = function() {
    // simulated annealing, basically
    if ((alpha *= .99) < .005) {
      event.end({type: "end", alpha: alpha = 0});
      return true;
    }

    var n = nodes.length,
        m = links.length,
        q,
        i, // current index
        o, // current object
        s, // current source
        t, // current target
        l, // current distance
        k, // current force
        x, // x-distance
        y; // y-distance

    // gauss-seidel relaxation for links
    for (i = 0; i < m; ++i) {
      o = links[i];
      s = o.source;
      t = o.target;
      x = t.x - s.x;
      y = t.y - s.y;
      if (l = (x * x + y * y)) {
        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
        x *= l;
        y *= l;
        t.x -= x * (k = s.weight / (t.weight + s.weight));
        t.y -= y * k;
        s.x += x * (k = 1 - k);
        s.y += y * k;
      }
    }

    // apply gravity forces
    if (k = alpha * gravity) {
      x = size[0] / 2;
      y = size[1] / 2;
      i = -1; if (k) while (++i < n) {
        o = nodes[i];
        o.x += (x - o.x) * k;
        o.y += (y - o.y) * k;
      }
    }

    // compute quadtree center of mass and apply charge forces
    if (charge) {
      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
      i = -1; while (++i < n) {
        if (!(o = nodes[i]).fixed) {
          q.visit(repulse(o));
        }
      }
    }

    // position verlet integration
    i = -1; while (++i < n) {
      o = nodes[i];
      if (o.fixed) {
        o.x = o.px;
        o.y = o.py;
      } else {
        o.x -= (o.px - (o.px = o.x)) * friction;
        o.y -= (o.py - (o.py = o.y)) * friction;
      }
    }

    event.tick({type: "tick", alpha: alpha});
  };

  force.nodes = function(x) {
    if (!arguments.length) return nodes;
    nodes = x;
    return force;
  };

  force.links = function(x) {
    if (!arguments.length) return links;
    links = x;
    return force;
  };

  force.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return force;
  };

  force.linkDistance = function(x) {
    if (!arguments.length) return linkDistance;
    linkDistance = d3_functor(x);
    return force;
  };

  // For backwards-compatibility.
  force.distance = force.linkDistance;

  force.linkStrength = function(x) {
    if (!arguments.length) return linkStrength;
    linkStrength = d3_functor(x);
    return force;
  };

  force.friction = function(x) {
    if (!arguments.length) return friction;
    friction = x;
    return force;
  };

  force.charge = function(x) {
    if (!arguments.length) return charge;
    charge = typeof x === "function" ? x : +x;
    return force;
  };

  force.gravity = function(x) {
    if (!arguments.length) return gravity;
    gravity = x;
    return force;
  };

  force.theta = function(x) {
    if (!arguments.length) return theta;
    theta = x;
    return force;
  };

  force.alpha = function(x) {
    if (!arguments.length) return alpha;

    if (alpha) { // if we're already running
      if (x > 0) alpha = x; // we might keep it hot
      else alpha = 0; // or, next tick will dispatch "end"
    } else if (x > 0) { // otherwise, fire it up!
      event.start({type: "start", alpha: alpha = x});
      d3.timer(force.tick);
    }

    return force;
  };

  force.start = function() {
    var i,
        j,
        n = nodes.length,
        m = links.length,
        w = size[0],
        h = size[1],
        neighbors,
        o;

    for (i = 0; i < n; ++i) {
      (o = nodes[i]).index = i;
      o.weight = 0;
    }

    distances = [];
    strengths = [];
    for (i = 0; i < m; ++i) {
      o = links[i];
      if (typeof o.source == "number") o.source = nodes[o.source];
      if (typeof o.target == "number") o.target = nodes[o.target];
      distances[i] = linkDistance.call(this, o, i);
      strengths[i] = linkStrength.call(this, o, i);
      ++o.source.weight;
      ++o.target.weight;
    }

    for (i = 0; i < n; ++i) {
      o = nodes[i];
      if (isNaN(o.x)) o.x = position("x", w);
      if (isNaN(o.y)) o.y = position("y", h);
      if (isNaN(o.px)) o.px = o.x;
      if (isNaN(o.py)) o.py = o.y;
    }

    charges = [];
    if (typeof charge === "function") {
      for (i = 0; i < n; ++i) {
        charges[i] = +charge.call(this, nodes[i], i);
      }
    } else {
      for (i = 0; i < n; ++i) {
        charges[i] = charge;
      }
    }

    // initialize node position based on first neighbor
    function position(dimension, size) {
      var neighbors = neighbor(i),
          j = -1,
          m = neighbors.length,
          x;
      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
      return Math.random() * size;
    }

    // initialize neighbors lazily
    function neighbor() {
      if (!neighbors) {
        neighbors = [];
        for (j = 0; j < n; ++j) {
          neighbors[j] = [];
        }
        for (j = 0; j < m; ++j) {
          var o = links[j];
          neighbors[o.source.index].push(o.target);
          neighbors[o.target.index].push(o.source);
        }
      }
      return neighbors[i];
    }

    return force.resume();
  };

  force.resume = function() {
    return force.alpha(.1);
  };

  force.stop = function() {
    return force.alpha(0);
  };

  // use `node.call(force.drag)` to make nodes draggable
  force.drag = function() {
    if (!drag) drag = d3.behavior.drag()
        .origin(d3_identity)
        .on("dragstart", dragstart)
        .on("drag", d3_layout_forceDrag)
        .on("dragend", d3_layout_forceDragEnd);

    this.on("mouseover.force", d3_layout_forceDragOver)
        .on("mouseout.force", d3_layout_forceDragOut)
        .call(drag);
  };

  function dragstart(d) {
    d3_layout_forceDragOver(d3_layout_forceDragNode = d);
    d3_layout_forceDragForce = force;
  }

  return d3.rebind(force, event, "on");
};

var d3_layout_forceDragForce,
    d3_layout_forceDragNode;

function d3_layout_forceDragOver(d) {
  d.fixed |= 2;
}

function d3_layout_forceDragOut(d) {
  if (d !== d3_layout_forceDragNode) d.fixed &= 1;
}

function d3_layout_forceDragEnd() {
  d3_layout_forceDragNode.fixed &= 1;
  d3_layout_forceDragForce = d3_layout_forceDragNode = null;
}

function d3_layout_forceDrag() {
  d3_layout_forceDragNode.px = d3.event.x;
  d3_layout_forceDragNode.py = d3.event.y;
  d3_layout_forceDragForce.resume(); // restart annealing
}

function d3_layout_forceAccumulate(quad, alpha, charges) {
  var cx = 0,
      cy = 0;
  quad.charge = 0;
  if (!quad.leaf) {
    var nodes = quad.nodes,
        n = nodes.length,
        i = -1,
        c;
    while (++i < n) {
      c = nodes[i];
      if (c == null) continue;
      d3_layout_forceAccumulate(c, alpha, charges);
      quad.charge += c.charge;
      cx += c.charge * c.cx;
      cy += c.charge * c.cy;
    }
  }
  if (quad.point) {
    // jitter internal nodes that are coincident
    if (!quad.leaf) {
      quad.point.x += Math.random() - .5;
      quad.point.y += Math.random() - .5;
    }
    var k = alpha * charges[quad.point.index];
    quad.charge += quad.pointCharge = k;
    cx += k * quad.point.x;
    cy += k * quad.point.y;
  }
  quad.cx = cx / quad.charge;
  quad.cy = cy / quad.charge;
}

function d3_layout_forceLinkDistance(link) {
  return 20;
}

function d3_layout_forceLinkStrength(link) {
  return 1;
}
d3.layout.partition = function() {
  var hierarchy = d3.layout.hierarchy(),
      size = [1, 1]; // width, height

  function position(node, x, dx, dy) {
    var children = node.children;
    node.x = x;
    node.y = node.depth * dy;
    node.dx = dx;
    node.dy = dy;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          c,
          d;
      dx = node.value ? dx / node.value : 0;
      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy);
        x += d;
      }
    }
  }

  function depth(node) {
    var children = node.children,
        d = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n;
      while (++i < n) d = Math.max(d, depth(children[i]));
    }
    return 1 + d;
  }

  function partition(d, i) {
    var nodes = hierarchy.call(this, d, i);
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
    return nodes;
  }

  partition.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return partition;
  };

  return d3_layout_hierarchyRebind(partition, hierarchy);
};
d3.layout.pie = function() {
  var value = Number,
      sort = d3_layout_pieSortByValue,
      startAngle = 0,
      endAngle = 2 * Math.PI;

  function pie(data, i) {

    // Compute the numeric values for each data element.
    var values = data.map(function(d, i) { return +value.call(pie, d, i); });

    // Compute the start angle.
    var a = +(typeof startAngle === "function"
        ? startAngle.apply(this, arguments)
        : startAngle);

    // Compute the angular scale factor: from value to radians.
    var k = ((typeof endAngle === "function"
        ? endAngle.apply(this, arguments)
        : endAngle) - startAngle)
        / d3.sum(values);

    // Optionally sort the data.
    var index = d3.range(data.length);
    if (sort != null) index.sort(sort === d3_layout_pieSortByValue
        ? function(i, j) { return values[j] - values[i]; }
        : function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs!
    // They are stored in the original data's order.
    var arcs = [];
    index.forEach(function(i) {
      var d;
      arcs[i] = {
        data: data[i],
        value: d = values[i],
        startAngle: a,
        endAngle: a += d * k
      };
    });
    return arcs;
  }

  /**
   * Specifies the value function *x*, which returns a nonnegative numeric value
   * for each datum. The default value function is `Number`. The value function
   * is passed two arguments: the current datum and the current index.
   */
  pie.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return pie;
  };

  /**
   * Specifies a sort comparison operator *x*. The comparator is passed two data
   * elements from the data array, a and b; it returns a negative value if a is
   * less than b, a positive value if a is greater than b, and zero if a equals
   * b.
   */
  pie.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return pie;
  };

  /**
   * Specifies the overall start angle of the pie chart. Defaults to 0. The
   * start angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.startAngle = function(x) {
    if (!arguments.length) return startAngle;
    startAngle = x;
    return pie;
  };

  /**
   * Specifies the overall end angle of the pie chart. Defaults to 2π. The
   * end angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.endAngle = function(x) {
    if (!arguments.length) return endAngle;
    endAngle = x;
    return pie;
  };

  return pie;
};

var d3_layout_pieSortByValue = {};
// data is two-dimensional array of x,y; we populate y0
d3.layout.stack = function() {
  var values = d3_identity,
      order = d3_layout_stackOrderDefault,
      offset = d3_layout_stackOffsetZero,
      out = d3_layout_stackOut,
      x = d3_layout_stackX,
      y = d3_layout_stackY;

  function stack(data, index) {

    // Convert series to canonical two-dimensional representation.
    var series = data.map(function(d, i) {
      return values.call(stack, d, i);
    });

    // Convert each series to canonical [[x,y]] representation.
    var points = series.map(function(d, i) {
      return d.map(function(v, i) {
        return [x.call(stack, v, i), y.call(stack, v, i)];
      });
    });

    // Compute the order of series, and permute them.
    var orders = order.call(stack, points, index);
    series = d3.permute(series, orders);
    points = d3.permute(points, orders);

    // Compute the baseline…
    var offsets = offset.call(stack, points, index);

    // And propagate it to other series.
    var n = series.length,
        m = series[0].length,
        i,
        j,
        o;
    for (j = 0; j < m; ++j) {
      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
      for (i = 1; i < n; ++i) {
        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
      }
    }

    return data;
  }

  stack.values = function(x) {
    if (!arguments.length) return values;
    values = x;
    return stack;
  };

  stack.order = function(x) {
    if (!arguments.length) return order;
    order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
    return stack;
  };

  stack.offset = function(x) {
    if (!arguments.length) return offset;
    offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
    return stack;
  };

  stack.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    return stack;
  };

  stack.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    return stack;
  };

  stack.out = function(z) {
    if (!arguments.length) return out;
    out = z;
    return stack;
  };

  return stack;
}

function d3_layout_stackX(d) {
  return d.x;
}

function d3_layout_stackY(d) {
  return d.y;
}

function d3_layout_stackOut(d, y0, y) {
  d.y0 = y0;
  d.y = y;
}

var d3_layout_stackOrders = d3.map({

  "inside-out": function(data) {
    var n = data.length,
        i,
        j,
        max = data.map(d3_layout_stackMaxIndex),
        sums = data.map(d3_layout_stackReduceSum),
        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),
        top = 0,
        bottom = 0,
        tops = [],
        bottoms = [];
    for (i = 0; i < n; ++i) {
      j = index[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  },

  "reverse": function(data) {
    return d3.range(data.length).reverse();
  },

  "default": d3_layout_stackOrderDefault

});

var d3_layout_stackOffsets = d3.map({

  "silhouette": function(data) {
    var n = data.length,
        m = data[0].length,
        sums = [],
        max = 0,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o > max) max = o;
      sums.push(o);
    }
    for (j = 0; j < m; ++j) {
      y0[j] = (max - sums[j]) / 2;
    }
    return y0;
  },

  "wiggle": function(data) {
    var n = data.length,
        x = data[0],
        m = x.length,
        max = 0,
        i,
        j,
        k,
        s1,
        s2,
        s3,
        dx,
        o,
        o0,
        y0 = [];
    y0[0] = o = o0 = 0;
    for (j = 1; j < m; ++j) {
      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
        }
        s2 += s3 * data[i][j][1];
      }
      y0[j] = o -= s1 ? s2 / s1 * dx : 0;
      if (o < o0) o0 = o;
    }
    for (j = 0; j < m; ++j) y0[j] -= o0;
    return y0;
  },

  "expand": function(data) {
    var n = data.length,
        m = data[0].length,
        k = 1 / n,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
      else for (i = 0; i < n; i++) data[i][j][1] = k;
    }
    for (j = 0; j < m; ++j) y0[j] = 0;
    return y0;
  },

  "zero": d3_layout_stackOffsetZero

});

function d3_layout_stackOrderDefault(data) {
  return d3.range(data.length);
}

function d3_layout_stackOffsetZero(data) {
  var j = -1,
      m = data[0].length,
      y0 = [];
  while (++j < m) y0[j] = 0;
  return y0;
}

function d3_layout_stackMaxIndex(array) {
  var i = 1,
      j = 0,
      v = array[0][1],
      k,
      n = array.length;
  for (; i < n; ++i) {
    if ((k = array[i][1]) > v) {
      j = i;
      v = k;
    }
  }
  return j;
}

function d3_layout_stackReduceSum(d) {
  return d.reduce(d3_layout_stackSum, 0);
}

function d3_layout_stackSum(p, d) {
  return p + d[1];
}
d3.layout.histogram = function() {
  var frequency = true,
      valuer = Number,
      ranger = d3_layout_histogramRange,
      binner = d3_layout_histogramBinSturges;

  function histogram(data, i) {
    var bins = [],
        values = data.map(valuer, this),
        range = ranger.call(this, values, i),
        thresholds = binner.call(this, range, values, i),
        bin,
        i = -1,
        n = values.length,
        m = thresholds.length - 1,
        k = frequency ? 1 : 1 / n,
        x;

    // Initialize the bins.
    while (++i < m) {
      bin = bins[i] = [];
      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
      bin.y = 0;
    }

    // Fill the bins, ignoring values outside the range.
    if (m > 0) {
      i = -1; while(++i < n) {
        x = values[i];
        if ((x >= range[0]) && (x <= range[1])) {
          bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
          bin.y += k;
          bin.push(data[i]);
        }
      }
    }

    return bins;
  }

  // Specifies how to extract a value from the associated data. The default
  // value function is `Number`, which is equivalent to the identity function.
  histogram.value = function(x) {
    if (!arguments.length) return valuer;
    valuer = x;
    return histogram;
  };

  // Specifies the range of the histogram. Values outside the specified range
  // will be ignored. The argument `x` may be specified either as a two-element
  // array representing the minimum and maximum value of the range, or as a
  // function that returns the range given the array of values and the current
  // index `i`. The default range is the extent (minimum and maximum) of the
  // values.
  histogram.range = function(x) {
    if (!arguments.length) return ranger;
    ranger = d3_functor(x);
    return histogram;
  };

  // Specifies how to bin values in the histogram. The argument `x` may be
  // specified as a number, in which case the range of values will be split
  // uniformly into the given number of bins. Or, `x` may be an array of
  // threshold values, defining the bins; the specified array must contain the
  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`
  // may be a function which is evaluated, being passed the range, the array of
  // values, and the current index `i`, returning an array of thresholds. The
  // default bin function will divide the values into uniform bins using
  // Sturges' formula.
  histogram.bins = function(x) {
    if (!arguments.length) return binner;
    binner = typeof x === "number"
        ? function(range) { return d3_layout_histogramBinFixed(range, x); }
        : d3_functor(x);
    return histogram;
  };

  // Specifies whether the histogram's `y` value is a count (frequency) or a
  // probability (density). The default value is true.
  histogram.frequency = function(x) {
    if (!arguments.length) return frequency;
    frequency = !!x;
    return histogram;
  };

  return histogram;
};

function d3_layout_histogramBinSturges(range, values) {
  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
}

function d3_layout_histogramBinFixed(range, n) {
  var x = -1,
      b = +range[0],
      m = (range[1] - b) / n,
      f = [];
  while (++x <= n) f[x] = m * x + b;
  return f;
}

function d3_layout_histogramRange(values) {
  return [d3.min(values), d3.max(values)];
}
d3.layout.hierarchy = function() {
  var sort = d3_layout_hierarchySort,
      children = d3_layout_hierarchyChildren,
      value = d3_layout_hierarchyValue;

  // Recursively compute the node depth and value.
  // Also converts the data representation into a standard hierarchy structure.
  function recurse(data, depth, nodes) {
    var childs = children.call(hierarchy, data, depth),
        node = d3_layout_hierarchyInline ? data : {data: data};
    node.depth = depth;
    nodes.push(node);
    if (childs && (n = childs.length)) {
      var i = -1,
          n,
          c = node.children = [],
          v = 0,
          j = depth + 1,
          d;
      while (++i < n) {
        d = recurse(childs[i], j, nodes);
        d.parent = node;
        c.push(d);
        v += d.value;
      }
      if (sort) c.sort(sort);
      if (value) node.value = v;
    } else if (value) {
      node.value = +value.call(hierarchy, data, depth) || 0;
    }
    return node;
  }

  // Recursively re-evaluates the node value.
  function revalue(node, depth) {
    var children = node.children,
        v = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          j = depth + 1;
      while (++i < n) v += revalue(children[i], j);
    } else if (value) {
      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;
    }
    if (value) node.value = v;
    return v;
  }

  function hierarchy(d) {
    var nodes = [];
    recurse(d, 0, nodes);
    return nodes;
  }

  hierarchy.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return hierarchy;
  };

  hierarchy.children = function(x) {
    if (!arguments.length) return children;
    children = x;
    return hierarchy;
  };

  hierarchy.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return hierarchy;
  };

  // Re-evaluates the `value` property for the specified hierarchy.
  hierarchy.revalue = function(root) {
    revalue(root, 0);
    return root;
  };

  return hierarchy;
};

// A method assignment helper for hierarchy subclasses.
function d3_layout_hierarchyRebind(object, hierarchy) {
  d3.rebind(object, hierarchy, "sort", "children", "value");

  // Add an alias for links, for convenience.
  object.links = d3_layout_hierarchyLinks;

  // If the new API is used, enabling inlining.
  object.nodes = function(d) {
    d3_layout_hierarchyInline = true;
    return (object.nodes = object)(d);
  };

  return object;
}

function d3_layout_hierarchyChildren(d) {
  return d.children;
}

function d3_layout_hierarchyValue(d) {
  return d.value;
}

function d3_layout_hierarchySort(a, b) {
  return b.value - a.value;
}

// Returns an array source+target objects for the specified nodes.
function d3_layout_hierarchyLinks(nodes) {
  return d3.merge(nodes.map(function(parent) {
    return (parent.children || []).map(function(child) {
      return {source: parent, target: child};
    });
  }));
}

// For backwards-compatibility, don't enable inlining by default.
var d3_layout_hierarchyInline = false;
d3.layout.pack = function() {
  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
      size = [1, 1];

  function pack(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    // Recursively compute the layout.
    root.x = 0;
    root.y = 0;
    d3_layout_packTree(root);

    // Scale the layout to fit the requested size.
    var w = size[0],
        h = size[1],
        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);
    d3_layout_packTransform(root, w / 2, h / 2, k);

    return nodes;
  }

  pack.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return pack;
  };

  return d3_layout_hierarchyRebind(pack, hierarchy);
};

function d3_layout_packSort(a, b) {
  return a.value - b.value;
}

function d3_layout_packInsert(a, b) {
  var c = a._pack_next;
  a._pack_next = b;
  b._pack_prev = a;
  b._pack_next = c;
  c._pack_prev = b;
}

function d3_layout_packSplice(a, b) {
  a._pack_next = b;
  b._pack_prev = a;
}

function d3_layout_packIntersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - dx * dx - dy * dy > .001; // within epsilon
}

function d3_layout_packCircle(nodes) {
  var xMin = Infinity,
      xMax = -Infinity,
      yMin = Infinity,
      yMax = -Infinity,
      n = nodes.length,
      a, b, c, j, k;

  function bound(node) {
    xMin = Math.min(node.x - node.r, xMin);
    xMax = Math.max(node.x + node.r, xMax);
    yMin = Math.min(node.y - node.r, yMin);
    yMax = Math.max(node.y + node.r, yMax);
  }

  // Create node links.
  nodes.forEach(d3_layout_packLink);

  // Create first node.
  a = nodes[0];
  a.x = -a.r;
  a.y = 0;
  bound(a);

  // Create second node.
  if (n > 1) {
    b = nodes[1];
    b.x = b.r;
    b.y = 0;
    bound(b);

    // Create third node and build chain.
    if (n > 2) {
      c = nodes[2];
      d3_layout_packPlace(a, b, c);
      bound(c);
      d3_layout_packInsert(a, c);
      a._pack_prev = c;
      d3_layout_packInsert(c, b);
      b = a._pack_next;

      // Now iterate through the rest.
      for (var i = 3; i < n; i++) {
        d3_layout_packPlace(a, b, c = nodes[i]);

        // Search for the closest intersection.
        var isect = 0, s1 = 1, s2 = 1;
        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
          if (d3_layout_packIntersects(j, c)) {
            isect = 1;
            break;
          }
        }
        if (isect == 1) {
          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
            if (d3_layout_packIntersects(k, c)) {
              break;
            }
          }
        }

        // Update node chain.
        if (isect) {
          if (s1 < s2 || (s1 == s2 && b.r < a.r)) d3_layout_packSplice(a, b = j);
          else d3_layout_packSplice(a = k, b);
          i--;
        } else {
          d3_layout_packInsert(a, c);
          b = c;
          bound(c);
        }
      }
    }
  }

  // Re-center the circles and return the encompassing radius.
  var cx = (xMin + xMax) / 2,
      cy = (yMin + yMax) / 2,
      cr = 0;
  for (var i = 0; i < n; i++) {
    var node = nodes[i];
    node.x -= cx;
    node.y -= cy;
    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));
  }

  // Remove node links.
  nodes.forEach(d3_layout_packUnlink);

  return cr;
}

function d3_layout_packLink(node) {
  node._pack_next = node._pack_prev = node;
}

function d3_layout_packUnlink(node) {
  delete node._pack_next;
  delete node._pack_prev;
}

function d3_layout_packTree(node) {
  var children = node.children;
  if (children && children.length) {
    children.forEach(d3_layout_packTree);
    node.r = d3_layout_packCircle(children);
  } else {
    node.r = Math.sqrt(node.value);
  }
}

function d3_layout_packTransform(node, x, y, k) {
  var children = node.children;
  node.x = (x += k * node.x);
  node.y = (y += k * node.y);
  node.r *= k;
  if (children) {
    var i = -1, n = children.length;
    while (++i < n) d3_layout_packTransform(children[i], x, y, k);
  }
}

function d3_layout_packPlace(a, b, c) {
  var db = a.r + c.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  if (db && (dx || dy)) {
    var da = b.r + c.r,
        dc = Math.sqrt(dx * dx + dy * dy),
        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),
        theta = Math.acos(cos),
        x = cos * (db /= dc),
        y = Math.sin(theta) * db;
    c.x = a.x + x * dx + y * dy;
    c.y = a.y + x * dy - y * dx;
  } else {
    c.x = a.x + db;
    c.y = a.y;
  }
}
// Implements a hierarchical layout using the cluster (or dendrogram)
// algorithm.
d3.layout.cluster = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function cluster(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0],
        previousNode,
        x = 0,
        kx,
        ky;

    // First walk, computing the initial x & y values.
    d3_layout_treeVisitAfter(root, function(node) {
      var children = node.children;
      if (children && children.length) {
        node.x = d3_layout_clusterX(children);
        node.y = d3_layout_clusterY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_clusterLeft(root),
        right = d3_layout_clusterRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
    });

    return nodes;
  }

  cluster.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return cluster;
  };

  cluster.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return cluster;
  };

  return d3_layout_hierarchyRebind(cluster, hierarchy);
};

function d3_layout_clusterY(children) {
  return 1 + d3.max(children, function(child) {
    return child.y;
  });
}

function d3_layout_clusterX(children) {
  return children.reduce(function(x, child) {
    return x + child.x;
  }, 0) / children.length;
}

function d3_layout_clusterLeft(node) {
  var children = node.children;
  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
}

function d3_layout_clusterRight(node) {
  var children = node.children, n;
  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
}
// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
d3.layout.tree = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function tree(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    function firstWalk(node, previousSibling) {
      var children = node.children,
          layout = node._tree;
      if (children && (n = children.length)) {
        var n,
            firstChild = children[0],
            previousChild,
            ancestor = firstChild,
            child,
            i = -1;
        while (++i < n) {
          child = children[i];
          firstWalk(child, previousChild);
          ancestor = apportion(child, previousChild, ancestor);
          previousChild = child;
        }
        d3_layout_treeShift(node);
        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          layout.mod = layout.prelim - midpoint;
        } else {
          layout.prelim = midpoint;
        }
      } else {
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
        }
      }
    }

    function secondWalk(node, x) {
      node.x = node._tree.prelim + x;
      var children = node.children;
      if (children && (n = children.length)) {
        var i = -1,
            n;
        x += node._tree.mod;
        while (++i < n) {
          secondWalk(children[i], x);
        }
      }
    }

    function apportion(node, previousSibling, ancestor) {
      if (previousSibling) {
        var vip = node,
            vop = node,
            vim = previousSibling,
            vom = node.parent.children[0],
            sip = vip._tree.mod,
            sop = vop._tree.mod,
            sim = vim._tree.mod,
            som = vom._tree.mod,
            shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop._tree.ancestor = node;
          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim._tree.mod;
          sip += vip._tree.mod;
          som += vom._tree.mod;
          sop += vop._tree.mod;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop._tree.thread = vim;
          vop._tree.mod += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom._tree.thread = vip;
          vom._tree.mod += sip - som;
          ancestor = node;
        }
      }
      return ancestor;
    }

    // Initialize temporary layout variables.
    d3_layout_treeVisitAfter(root, function(node, previousSibling) {
      node._tree = {
        ancestor: node,
        prelim: 0,
        mod: 0,
        change: 0,
        shift: 0,
        number: previousSibling ? previousSibling._tree.number + 1 : 0
      };
    });

    // Compute the layout using Buchheim et al.'s algorithm.
    firstWalk(root);
    secondWalk(root, -root._tree.prelim);

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),
        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),
        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2,
        y1 = deep.depth || 1;

    // Clear temporary layout variables; transform x and y.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = node.depth / y1 * size[1];
      delete node._tree;
    });

    return nodes;
  }

  tree.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return tree;
  };

  tree.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return tree;
  };

  return d3_layout_hierarchyRebind(tree, hierarchy);
};

function d3_layout_treeSeparation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}

// function d3_layout_treeSeparationRadial(a, b) {
//   return (a.parent == b.parent ? 1 : 2) / a.depth;
// }

function d3_layout_treeLeft(node) {
  var children = node.children;
  return children && children.length ? children[0] : node._tree.thread;
}

function d3_layout_treeRight(node) {
  var children = node.children,
      n;
  return children && (n = children.length) ? children[n - 1] : node._tree.thread;
}

function d3_layout_treeSearch(node, compare) {
  var children = node.children;
  if (children && (n = children.length)) {
    var child,
        n,
        i = -1;
    while (++i < n) {
      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
        node = child;
      }
    }
  }
  return node;
}

function d3_layout_treeRightmost(a, b) {
  return a.x - b.x;
}

function d3_layout_treeLeftmost(a, b) {
  return b.x - a.x;
}

function d3_layout_treeDeepest(a, b) {
  return a.depth - b.depth;
}

function d3_layout_treeVisitAfter(node, callback) {
  function visit(node, previousSibling) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child,
          previousChild = null,
          i = -1,
          n;
      while (++i < n) {
        child = children[i];
        visit(child, previousChild);
        previousChild = child;
      }
    }
    callback(node, previousSibling);
  }
  visit(node, null);
}

function d3_layout_treeShift(node) {
  var shift = 0,
      change = 0,
      children = node.children,
      i = children.length,
      child;
  while (--i >= 0) {
    child = children[i]._tree;
    child.prelim += shift;
    child.mod += shift;
    shift += child.shift + (change += child.change);
  }
}

function d3_layout_treeMove(ancestor, node, shift) {
  ancestor = ancestor._tree;
  node = node._tree;
  var change = shift / (node.number - ancestor.number);
  ancestor.change += change;
  node.change -= change;
  node.shift += shift;
  node.prelim += shift;
  node.mod += shift;
}

function d3_layout_treeAncestor(vim, node, ancestor) {
  return vim._tree.ancestor.parent == node.parent
      ? vim._tree.ancestor
      : ancestor;
}
// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
// Modified to support a target aspect ratio by Jeff Heer
d3.layout.treemap = function() {
  var hierarchy = d3.layout.hierarchy(),
      round = Math.round,
      size = [1, 1], // width, height
      padding = null,
      pad = d3_layout_treemapPadNull,
      sticky = false,
      stickies,
      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio

  // Compute the area for each child based on value & scale.
  function scale(children, k) {
    var i = -1,
        n = children.length,
        child,
        area;
    while (++i < n) {
      area = (child = children[i]).value * (k < 0 ? 0 : k);
      child.area = isNaN(area) || area <= 0 ? 0 : area;
    }
  }

  // Recursively arranges the specified node's children into squarified rows.
  function squarify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          row = [],
          remaining = children.slice(), // copy-on-write
          child,
          best = Infinity, // the best row score so far
          score, // the current row score
          u = Math.min(rect.dx, rect.dy), // initial orientation
          n;
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while ((n = remaining.length) > 0) {
        row.push(child = remaining[n - 1]);
        row.area += child.area;
        if ((score = worst(row, u)) <= best) { // continue with this orientation
          remaining.pop();
          best = score;
        } else { // abort, and try a different orientation
          row.area -= row.pop().area;
          position(row, u, rect, false);
          u = Math.min(rect.dx, rect.dy);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        position(row, u, rect, true);
        row.length = row.area = 0;
      }
      children.forEach(squarify);
    }
  }

  // Recursively resizes the specified node's children into existing rows.
  // Preserves the existing layout!
  function stickify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          remaining = children.slice(), // copy-on-write
          child,
          row = [];
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while (child = remaining.pop()) {
        row.push(child);
        row.area += child.area;
        if (child.z != null) {
          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
          row.length = row.area = 0;
        }
      }
      children.forEach(stickify);
    }
  }

  // Computes the score for the specified row, as the worst aspect ratio.
  function worst(row, u) {
    var s = row.area,
        r,
        rmax = 0,
        rmin = Infinity,
        i = -1,
        n = row.length;
    while (++i < n) {
      if (!(r = row[i].area)) continue;
      if (r < rmin) rmin = r;
      if (r > rmax) rmax = r;
    }
    s *= s;
    u *= u;
    return s
        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))
        : Infinity;
  }

  // Positions the specified row of nodes. Modifies `rect`.
  function position(row, u, rect, flush) {
    var i = -1,
        n = row.length,
        x = rect.x,
        y = rect.y,
        v = u ? round(row.area / u) : 0,
        o;
    if (u == rect.dx) { // horizontal subdivision
      if (flush || v > rect.dy) v = rect.dy; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dy = v;
        x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
      }
      o.z = true;
      o.dx += rect.x + rect.dx - x; // rounding error
      rect.y += v;
      rect.dy -= v;
    } else { // vertical subdivision
      if (flush || v > rect.dx) v = rect.dx; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dx = v;
        y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
      }
      o.z = false;
      o.dy += rect.y + rect.dy - y; // rounding error
      rect.x += v;
      rect.dx -= v;
    }
  }

  function treemap(d) {
    var nodes = stickies || hierarchy(d),
        root = nodes[0];
    root.x = 0;
    root.y = 0;
    root.dx = size[0];
    root.dy = size[1];
    if (stickies) hierarchy.revalue(root);
    scale([root], root.dx * root.dy / root.value);
    (stickies ? stickify : squarify)(root);
    if (sticky) stickies = nodes;
    return nodes;
  }

  treemap.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return treemap;
  };

  treemap.padding = function(x) {
    if (!arguments.length) return padding;

    function padFunction(node) {
      var p = x.call(treemap, node, node.depth);
      return p == null
          ? d3_layout_treemapPadNull(node)
          : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
    }

    function padConstant(node) {
      return d3_layout_treemapPad(node, x);
    }

    var type;
    pad = (padding = x) == null ? d3_layout_treemapPadNull
        : (type = typeof x) === "function" ? padFunction
        : type === "number" ? (x = [x, x, x, x], padConstant)
        : padConstant;
    return treemap;
  };

  treemap.round = function(x) {
    if (!arguments.length) return round != Number;
    round = x ? Math.round : Number;
    return treemap;
  };

  treemap.sticky = function(x) {
    if (!arguments.length) return sticky;
    sticky = x;
    stickies = null;
    return treemap;
  };

  treemap.ratio = function(x) {
    if (!arguments.length) return ratio;
    ratio = x;
    return treemap;
  };

  return d3_layout_hierarchyRebind(treemap, hierarchy);
};

function d3_layout_treemapPadNull(node) {
  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};
}

function d3_layout_treemapPad(node, padding) {
  var x = node.x + padding[3],
      y = node.y + padding[0],
      dx = node.dx - padding[1] - padding[3],
      dy = node.dy - padding[0] - padding[2];
  if (dx < 0) { x += dx / 2; dx = 0; }
  if (dy < 0) { y += dy / 2; dy = 0; }
  return {x: x, y: y, dx: dx, dy: dy};
}
d3.csv = function(url, callback) {
  d3.text(url, "text/csv", function(text) {
    callback(text && d3.csv.parse(text));
  });
};
d3.csv.parse = function(text) {
  var header;
  return d3.csv.parseRows(text, function(row, i) {
    if (i) {
      var o = {}, j = -1, m = header.length;
      while (++j < m) o[header[j]] = row[j];
      return o;
    } else {
      header = row;
      return null;
    }
  });
};

d3.csv.parseRows = function(text, f) {
  var EOL = {}, // sentinel value for end-of-line
      EOF = {}, // sentinel value for end-of-file
      rows = [], // output rows
      re = /\r\n|[,\r\n]/g, // field separator regex
      n = 0, // the current line number
      t, // the current token
      eol; // is the current token followed by EOL?

  re.lastIndex = 0; // work-around bug in FF 3.6

  /** @private Returns the next token. */
  function token() {
    if (re.lastIndex >= text.length) return EOF; // special case: end of file
    if (eol) { eol = false; return EOL; } // special case: end of line

    // special case: quotes
    var j = re.lastIndex;
    if (text.charCodeAt(j) === 34) {
      var i = j;
      while (i++ < text.length) {
        if (text.charCodeAt(i) === 34) {
          if (text.charCodeAt(i + 1) !== 34) break;
          i++;
        }
      }
      re.lastIndex = i + 2;
      var c = text.charCodeAt(i + 1);
      if (c === 13) {
        eol = true;
        if (text.charCodeAt(i + 2) === 10) re.lastIndex++;
      } else if (c === 10) {
        eol = true;
      }
      return text.substring(j + 1, i).replace(/""/g, "\"");
    }

    // common case
    var m = re.exec(text);
    if (m) {
      eol = m[0].charCodeAt(0) !== 44;
      return text.substring(j, m.index);
    }
    re.lastIndex = text.length;
    return text.substring(j);
  }

  while ((t = token()) !== EOF) {
    var a = [];
    while ((t !== EOL) && (t !== EOF)) {
      a.push(t);
      t = token();
    }
    if (f && !(a = f(a, n++))) continue;
    rows.push(a);
  }

  return rows;
};
d3.csv.format = function(rows) {
  return rows.map(d3_csv_formatRow).join("\n");
};

function d3_csv_formatRow(row) {
  return row.map(d3_csv_formatValue).join(",");
}

function d3_csv_formatValue(text) {
  return /[",\n]/.test(text)
      ? "\"" + text.replace(/\"/g, "\"\"") + "\""
      : text;
}
d3.geo = {};

var d3_geo_radians = Math.PI / 180;
// TODO clip input coordinates on opposite hemisphere
d3.geo.azimuthal = function() {
  var mode = "orthographic", // or stereographic, gnomonic, equidistant or equalarea
      origin,
      scale = 200,
      translate = [480, 250],
      x0,
      y0,
      cy0,
      sy0;

  function azimuthal(coordinates) {
    var x1 = coordinates[0] * d3_geo_radians - x0,
        y1 = coordinates[1] * d3_geo_radians,
        cx1 = Math.cos(x1),
        sx1 = Math.sin(x1),
        cy1 = Math.cos(y1),
        sy1 = Math.sin(y1),
        cc = mode !== "orthographic" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,
        c,
        k = mode === "stereographic" ? 1 / (1 + cc)
          : mode === "gnomonic" ? 1 / cc
          : mode === "equidistant" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0)
          : mode === "equalarea" ? Math.sqrt(2 / (1 + cc))
          : 1,
        x = k * cy1 * sx1,
        y = k * (sy0 * cy1 * cx1 - cy0 * sy1);
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  azimuthal.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p = Math.sqrt(x * x + y * y),
        c = mode === "stereographic" ? 2 * Math.atan(p)
          : mode === "gnomonic" ? Math.atan(p)
          : mode === "equidistant" ? p
          : mode === "equalarea" ? 2 * Math.asin(.5 * p)
          : Math.asin(p),
        sc = Math.sin(c),
        cc = Math.cos(c);
    return [
      (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians,
      Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians
    ];
  };

  azimuthal.mode = function(x) {
    if (!arguments.length) return mode;
    mode = x + "";
    return azimuthal;
  };

  azimuthal.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    x0 = origin[0] * d3_geo_radians;
    y0 = origin[1] * d3_geo_radians;
    cy0 = Math.cos(y0);
    sy0 = Math.sin(y0);
    return azimuthal;
  };

  azimuthal.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return azimuthal;
  };

  azimuthal.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return azimuthal;
  };

  return azimuthal.origin([0, 0]);
};
// Derived from Tom Carden's Albers implementation for Protovis.
// http://gist.github.com/476238
// http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html

d3.geo.albers = function() {
  var origin = [-98, 38],
      parallels = [29.5, 45.5],
      scale = 1000,
      translate = [480, 250],
      lng0, // d3_geo_radians * origin[0]
      n,
      C,
      p0;

  function albers(coordinates) {
    var t = n * (d3_geo_radians * coordinates[0] - lng0),
        p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;
    return [
      scale * p * Math.sin(t) + translate[0],
      scale * (p * Math.cos(t) - p0) + translate[1]
    ];
  }

  albers.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p0y = p0 + y,
        t = Math.atan2(x, p0y),
        p = Math.sqrt(x * x + p0y * p0y);
    return [
      (lng0 + t / n) / d3_geo_radians,
      Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians
    ];
  };

  function reload() {
    var phi1 = d3_geo_radians * parallels[0],
        phi2 = d3_geo_radians * parallels[1],
        lat0 = d3_geo_radians * origin[1],
        s = Math.sin(phi1),
        c = Math.cos(phi1);
    lng0 = d3_geo_radians * origin[0];
    n = .5 * (s + Math.sin(phi2));
    C = c * c + 2 * n * s;
    p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
    return albers;
  }

  albers.origin = function(x) {
    if (!arguments.length) return origin;
    origin = [+x[0], +x[1]];
    return reload();
  };

  albers.parallels = function(x) {
    if (!arguments.length) return parallels;
    parallels = [+x[0], +x[1]];
    return reload();
  };

  albers.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return albers;
  };

  albers.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return albers;
  };

  return reload();
};

// A composite projection for the United States, 960x500. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
// TODO allow the composite projection to be rescaled?
d3.geo.albersUsa = function() {
  var lower48 = d3.geo.albers();

  var alaska = d3.geo.albers()
      .origin([-160, 60])
      .parallels([55, 65]);

  var hawaii = d3.geo.albers()
      .origin([-160, 20])
      .parallels([8, 18]);

  var puertoRico = d3.geo.albers()
      .origin([-60, 10])
      .parallels([8, 18]);

  function albersUsa(coordinates) {
    var lon = coordinates[0],
        lat = coordinates[1];
    return (lat > 50 ? alaska
        : lon < -140 ? hawaii
        : lat < 21 ? puertoRico
        : lower48)(coordinates);
  }

  albersUsa.scale = function(x) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(x);
    alaska.scale(x * .6);
    hawaii.scale(x);
    puertoRico.scale(x * 1.5);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(x) {
    if (!arguments.length) return lower48.translate();
    var dz = lower48.scale() / 1000,
        dx = x[0],
        dy = x[1];
    lower48.translate(x);
    alaska.translate([dx - 400 * dz, dy + 170 * dz]);
    hawaii.translate([dx - 190 * dz, dy + 200 * dz]);
    puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);
    return albersUsa;
  };

  return albersUsa.scale(lower48.scale());
};
d3.geo.bonne = function() {
  var scale = 200,
      translate = [480, 250],
      x0, // origin longitude in radians
      y0, // origin latitude in radians
      y1, // parallel latitude in radians
      c1; // cot(y1)

  function bonne(coordinates) {
    var x = coordinates[0] * d3_geo_radians - x0,
        y = coordinates[1] * d3_geo_radians - y0;
    if (y1) {
      var p = c1 + y1 - y, E = x * Math.cos(y) / p;
      x = p * Math.sin(E);
      y = p * Math.cos(E) - c1;
    } else {
      x *= Math.cos(y);
      y *= -1;
    }
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  bonne.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    if (y1) {
      var c = c1 + y, p = Math.sqrt(x * x + c * c);
      y = c1 + y1 - p;
      x = x0 + p * Math.atan2(x, c) / Math.cos(y);
    } else {
      y *= -1;
      x /= Math.cos(y);
    }
    return [
      x / d3_geo_radians,
      y / d3_geo_radians
    ];
  };

  // 90° for Werner, 0° for Sinusoidal
  bonne.parallel = function(x) {
    if (!arguments.length) return y1 / d3_geo_radians;
    c1 = 1 / Math.tan(y1 = x * d3_geo_radians);
    return bonne;
  };

  bonne.origin = function(x) {
    if (!arguments.length) return [x0 / d3_geo_radians, y0 / d3_geo_radians];
    x0 = x[0] * d3_geo_radians;
    y0 = x[1] * d3_geo_radians;
    return bonne;
  };

  bonne.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return bonne;
  };

  bonne.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return bonne;
  };

  return bonne.origin([0, 0]).parallel(45);
};
d3.geo.equirectangular = function() {
  var scale = 500,
      translate = [480, 250];

  function equirectangular(coordinates) {
    var x = coordinates[0] / 360,
        y = -coordinates[1] / 360;
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  equirectangular.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      -360 * y
    ];
  };

  equirectangular.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return equirectangular;
  };

  equirectangular.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return equirectangular;
  };

  return equirectangular;
};
d3.geo.mercator = function() {
  var scale = 500,
      translate = [480, 250];

  function mercator(coordinates) {
    var x = coordinates[0] / 360,
        y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;
    return [
      scale * x + translate[0],
      scale * Math.max(-.5, Math.min(.5, y)) + translate[1]
    ];
  }

  mercator.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90
    ];
  };

  mercator.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return mercator;
  };

  mercator.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return mercator;
  };

  return mercator;
};
function d3_geo_type(types, defaultValue) {
  return function(object) {
    return object && types.hasOwnProperty(object.type) ? types[object.type](object) : defaultValue;
  };
}
/**
 * Returns a function that, given a GeoJSON object (e.g., a feature), returns
 * the corresponding SVG path. The function can be customized by overriding the
 * projection. Point features are mapped to circles with a default radius of
 * 4.5px; the radius can be specified either as a constant or a function that
 * is evaluated per object.
 */
d3.geo.path = function() {
  var pointRadius = 4.5,
      pointCircle = d3_path_circle(pointRadius),
      projection = d3.geo.albersUsa(),
      buffer = [];

  function path(d, i) {
    if (typeof pointRadius === "function") pointCircle = d3_path_circle(pointRadius.apply(this, arguments));
    pathType(d);
    var result = buffer.length ? buffer.join("") : null;
    buffer = [];
    return result;
  }

  function project(coordinates) {
    return projection(coordinates).join(",");
  }

  var pathType = d3_geo_type({

    FeatureCollection: function(o) {
      var features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) buffer.push(pathType(features[i].geometry));
    },

    Feature: function(o) {
      pathType(o.geometry);
    },

    Point: function(o) {
      buffer.push("M", project(o.coordinates), pointCircle);
    },

    MultiPoint: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      while (++i < n) buffer.push("M", project(coordinates[i]), pointCircle);
    },

    LineString: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      buffer.push("M");
      while (++i < n) buffer.push(project(coordinates[i]), "L");
      buffer.pop();
    },

    MultiLineString: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        buffer.push("M");
        while (++j < m) buffer.push(project(subcoordinates[j]), "L");
        buffer.pop();
      }
    },

    Polygon: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        if ((m = subcoordinates.length - 1) > 0) {
          buffer.push("M");
          while (++j < m) buffer.push(project(subcoordinates[j]), "L");
          buffer[buffer.length - 1] = "Z";
        }
      }
    },

    MultiPolygon: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates index
          m, // subcoordinates.length
          subsubcoordinates, // subcoordinates[j]
          k, // subsubcoordinates index
          p; // subsubcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        while (++j < m) {
          subsubcoordinates = subcoordinates[j];
          k = -1;
          if ((p = subsubcoordinates.length - 1) > 0) {
            buffer.push("M");
            while (++k < p) buffer.push(project(subsubcoordinates[k]), "L");
            buffer[buffer.length - 1] = "Z";
          }
        }
      }
    },

    GeometryCollection: function(o) {
      var geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) buffer.push(pathType(geometries[i]));
    }

  });

  var areaType = path.area = d3_geo_type({

    FeatureCollection: function(o) {
      var area = 0,
          features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) area += areaType(features[i]);
      return area;
    },

    Feature: function(o) {
      return areaType(o.geometry);
    },

    Polygon: function(o) {
      return polygonArea(o.coordinates);
    },

    MultiPolygon: function(o) {
      var sum = 0,
          coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) sum += polygonArea(coordinates[i]);
      return sum;
    },

    GeometryCollection: function(o) {
      var sum = 0,
          geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) sum += areaType(geometries[i]);
      return sum;
    }

  }, 0);

  function polygonArea(coordinates) {
    var sum = area(coordinates[0]), // exterior ring
        i = 0, // coordinates.index
        n = coordinates.length;
    while (++i < n) sum -= area(coordinates[i]); // holes
    return sum;
  }

  function polygonCentroid(coordinates) {
    var polygon = d3.geom.polygon(coordinates[0].map(projection)), // exterior ring
        area = polygon.area(),
        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1),
        x = centroid[0],
        y = centroid[1],
        z = area,
        i = 0, // coordinates index
        n = coordinates.length;
    while (++i < n) {
      polygon = d3.geom.polygon(coordinates[i].map(projection)); // holes
      area = polygon.area();
      centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);
      x -= centroid[0];
      y -= centroid[1];
      z -= area;
    }
    return [x, y, 6 * z]; // weighted centroid
  }

  var centroidType = path.centroid = d3_geo_type({

    // TODO FeatureCollection
    // TODO Point
    // TODO MultiPoint
    // TODO LineString
    // TODO MultiLineString
    // TODO GeometryCollection

    Feature: function(o) {
      return centroidType(o.geometry);
    },

    Polygon: function(o) {
      var centroid = polygonCentroid(o.coordinates);
      return [centroid[0] / centroid[2], centroid[1] / centroid[2]];
    },

    MultiPolygon: function(o) {
      var area = 0,
          coordinates = o.coordinates,
          centroid,
          x = 0,
          y = 0,
          z = 0,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) {
        centroid = polygonCentroid(coordinates[i]);
        x += centroid[0];
        y += centroid[1];
        z += centroid[2];
      }
      return [x / z, y / z];
    }

  });

  function area(coordinates) {
    return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());
  }

  path.projection = function(x) {
    projection = x;
    return path;
  };

  path.pointRadius = function(x) {
    if (typeof x === "function") pointRadius = x;
    else {
      pointRadius = +x;
      pointCircle = d3_path_circle(pointRadius);
    }
    return path;
  };

  return path;
};

function d3_path_circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + (-2 * radius)
      + "a" + radius + "," + radius + " 0 1,1 0," + (+2 * radius)
      + "z";
}
/**
 * Given a GeoJSON object, returns the corresponding bounding box. The bounding
 * box is represented by a two-dimensional array: [[left, bottom], [right,
 * top]], where left is the minimum longitude, bottom is the minimum latitude,
 * right is maximum longitude, and top is the maximum latitude.
 */
d3.geo.bounds = function(feature) {
  var left = Infinity,
      bottom = Infinity,
      right = -Infinity,
      top = -Infinity;
  d3_geo_bounds(feature, function(x, y) {
    if (x < left) left = x;
    if (x > right) right = x;
    if (y < bottom) bottom = y;
    if (y > top) top = y;
  });
  return [[left, bottom], [right, top]];
};

function d3_geo_bounds(o, f) {
  if (d3_geo_boundsTypes.hasOwnProperty(o.type)) d3_geo_boundsTypes[o.type](o, f);
}

var d3_geo_boundsTypes = {
  Feature: d3_geo_boundsFeature,
  FeatureCollection: d3_geo_boundsFeatureCollection,
  GeometryCollection: d3_geo_boundsGeometryCollection,
  LineString: d3_geo_boundsLineString,
  MultiLineString: d3_geo_boundsMultiLineString,
  MultiPoint: d3_geo_boundsLineString,
  MultiPolygon: d3_geo_boundsMultiPolygon,
  Point: d3_geo_boundsPoint,
  Polygon: d3_geo_boundsPolygon
};

function d3_geo_boundsFeature(o, f) {
  d3_geo_bounds(o.geometry, f);
}

function d3_geo_boundsFeatureCollection(o, f) {
  for (var a = o.features, i = 0, n = a.length; i < n; i++) {
    d3_geo_bounds(a[i].geometry, f);
  }
}

function d3_geo_boundsGeometryCollection(o, f) {
  for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {
    d3_geo_bounds(a[i], f);
  }
}

function d3_geo_boundsLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}

function d3_geo_boundsMultiLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsMultiPolygon(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsPoint(o, f) {
  f.apply(null, o.coordinates);
}

function d3_geo_boundsPolygon(o, f) {
  for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}
// TODO breakAtDateLine?

d3.geo.circle = function() {
  var origin = [0, 0],
      degrees = 90 - 1e-2,
      radians = degrees * d3_geo_radians,
      arc = d3.geo.greatArc().source(origin).target(d3_identity);

  function circle() {
    // TODO render a circle as a Polygon
  }

  function visible(point) {
    return arc.distance(point) < radians;
  }

  circle.clip = function(d) {
    if (typeof origin === "function") arc.source(origin.apply(this, arguments));
    return clipType(d) || null;
  };

  var clipType = d3_geo_type({

    FeatureCollection: function(o) {
      var features = o.features.map(clipType).filter(d3_identity);
      return features && (o = Object.create(o), o.features = features, o);
    },

    Feature: function(o) {
      var geometry = clipType(o.geometry);
      return geometry && (o = Object.create(o), o.geometry = geometry, o);
    },

    Point: function(o) {
      return visible(o.coordinates) && o;
    },

    MultiPoint: function(o) {
      var coordinates = o.coordinates.filter(visible);
      return coordinates.length && {
        type: o.type,
        coordinates: coordinates
      };
    },

    LineString: function(o) {
      var coordinates = clip(o.coordinates);
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiLineString: function(o) {
      var coordinates = o.coordinates.map(clip).filter(function(d) { return d.length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    Polygon: function(o) {
      var coordinates = o.coordinates.map(clip);
      return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiPolygon: function(o) {
      var coordinates = o.coordinates.map(function(d) { return d.map(clip); }).filter(function(d) { return d[0].length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    GeometryCollection: function(o) {
      var geometries = o.geometries.map(clipType).filter(d3_identity);
      return geometries.length && (o = Object.create(o), o.geometries = geometries, o);
    }

  });

  function clip(coordinates) {
    var i = -1,
        n = coordinates.length,
        clipped = [],
        p0,
        p1,
        p2,
        d0,
        d1;

    while (++i < n) {
      d1 = arc.distance(p2 = coordinates[i]);
      if (d1 < radians) {
        if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));
        clipped.push(p2);
        p0 = p1 = null;
      } else {
        p1 = p2;
        if (!p0 && clipped.length) {
          clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));
          p0 = p1;
        }
      }
      d0 = d1;
    }

    // Close the clipped polygon if necessary.
    p0 = coordinates[0];
    p1 = clipped[0];
    if (p1 && p2[0] === p0[0] && p2[1] === p0[1] && !(p2[0] === p1[0] && p2[1] === p1[1])) {
      clipped.push(p1);
    }

    return resample(clipped);
  }

  // Resample coordinates, creating great arcs between each.
  function resample(coordinates) {
    var i = 0,
        n = coordinates.length,
        j,
        m,
        resampled = n ? [coordinates[0]] : coordinates,
        resamples,
        origin = arc.source();

    while (++i < n) {
      resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;
      for (j = 0, m = resamples.length; ++j < m;) resampled.push(resamples[j]);
    }

    arc.source(origin);
    return resampled;
  }

  circle.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    if (typeof origin !== "function") arc.source(origin);
    return circle;
  };

  circle.angle = function(x) {
    if (!arguments.length) return degrees;
    radians = (degrees = +x) * d3_geo_radians;
    return circle;
  };

  return d3.rebind(circle, arc, "precision");
}
d3.geo.greatArc = function() {
  var source = d3_geo_greatArcSource, p0,
      target = d3_geo_greatArcTarget, p1,
      precision = 6 * d3_geo_radians,
      interpolate = d3_geo_greatArcInterpolator();

  function greatArc() {
    var d = greatArc.distance.apply(this, arguments), // initializes the interpolator, too
        t = 0,
        dt = precision / d,
        coordinates = [p0];
    while ((t += dt) < 1) coordinates.push(interpolate(t));
    coordinates.push(p1);
    return {type: "LineString", coordinates: coordinates};
  }

  // Length returned in radians; multiply by radius for distance.
  greatArc.distance = function() {
    if (typeof source === "function") interpolate.source(p0 = source.apply(this, arguments));
    if (typeof target === "function") interpolate.target(p1 = target.apply(this, arguments));
    return interpolate.distance();
  };

  greatArc.source = function(_) {
    if (!arguments.length) return source;
    source = _;
    if (typeof source !== "function") interpolate.source(p0 = source);
    return greatArc;
  };

  greatArc.target = function(_) {
    if (!arguments.length) return target;
    target = _;
    if (typeof target !== "function") interpolate.target(p1 = target);
    return greatArc;
  };

  // Precision is specified in degrees.
  greatArc.precision = function(_) {
    if (!arguments.length) return precision / d3_geo_radians;
    precision = _ * d3_geo_radians;
    return greatArc;
  };

  return greatArc;
};

function d3_geo_greatArcSource(d) {
  return d.source;
}

function d3_geo_greatArcTarget(d) {
  return d.target;
}

function d3_geo_greatArcInterpolator() {
  var x0, y0, cy0, sy0, kx0, ky0,
      x1, y1, cy1, sy1, kx1, ky1,
      d,
      k;

  function interpolate(t) {
    var B = Math.sin(t *= d) * k,
        A = Math.sin(d - t) * k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      Math.atan2(y, x) / d3_geo_radians,
      Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians
    ];
  }

  interpolate.distance = function() {
    if (d == null) k = 1 / Math.sin(d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))));
    return d;
  };

  interpolate.source = function(_) {
    var cx0 = Math.cos(x0 = _[0] * d3_geo_radians),
        sx0 = Math.sin(x0);
    cy0 = Math.cos(y0 = _[1] * d3_geo_radians);
    sy0 = Math.sin(y0);
    kx0 = cy0 * cx0;
    ky0 = cy0 * sx0;
    d = null;
    return interpolate;
  };

  interpolate.target = function(_) {
    var cx1 = Math.cos(x1 = _[0] * d3_geo_radians),
        sx1 = Math.sin(x1);
    cy1 = Math.cos(y1 = _[1] * d3_geo_radians);
    sy1 = Math.sin(y1);
    kx1 = cy1 * cx1;
    ky1 = cy1 * sx1;
    d = null;
    return interpolate;
  };

  return interpolate;
}

function d3_geo_greatArcInterpolate(a, b) {
  var i = d3_geo_greatArcInterpolator().source(a).target(b);
  i.distance();
  return i;
}
d3.geo.greatCircle = d3.geo.circle;
d3.geom = {};
/**
 * Computes a contour for a given input grid function using the <a
 * href="http://en.wikipedia.org/wiki/Marching_squares">marching
 * squares</a> algorithm. Returns the contour polygon as an array of points.
 *
 * @param grid a two-input function(x, y) that returns true for values
 * inside the contour and false for values outside the contour.
 * @param start an optional starting point [x, y] on the grid.
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.contour = function(grid, start) {
  var s = start || d3_geom_contourStart(grid), // starting point
      c = [],    // contour polygon
      x = s[0],  // current x position
      y = s[1],  // current y position
      dx = 0,    // next x direction
      dy = 0,    // next y direction
      pdx = NaN, // previous x direction
      pdy = NaN, // previous y direction
      i = 0;

  do {
    // determine marching squares index
    i = 0;
    if (grid(x-1, y-1)) i += 1;
    if (grid(x,   y-1)) i += 2;
    if (grid(x-1, y  )) i += 4;
    if (grid(x,   y  )) i += 8;

    // determine next direction
    if (i === 6) {
      dx = pdy === -1 ? -1 : 1;
      dy = 0;
    } else if (i === 9) {
      dx = 0;
      dy = pdx === 1 ? -1 : 1;
    } else {
      dx = d3_geom_contourDx[i];
      dy = d3_geom_contourDy[i];
    }

    // update contour polygon
    if (dx != pdx && dy != pdy) {
      c.push([x, y]);
      pdx = dx;
      pdy = dy;
    }

    x += dx;
    y += dy;
  } while (s[0] != x || s[1] != y);

  return c;
};

// lookup tables for marching directions
var d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],
    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];

function d3_geom_contourStart(grid) {
  var x = 0,
      y = 0;

  // search for a starting point; begin at origin
  // and proceed along outward-expanding diagonals
  while (true) {
    if (grid(x,y)) {
      return [x,y];
    }
    if (x === 0) {
      x = y + 1;
      y = 0;
    } else {
      x = x - 1;
      y = y + 1;
    }
  }
}
/**
 * Computes the 2D convex hull of a set of points using Graham's scanning
 * algorithm. The algorithm has been implemented as described in Cormen,
 * Leiserson, and Rivest's Introduction to Algorithms. The running time of
 * this algorithm is O(n log n), where n is the number of input points.
 *
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.hull = function(vertices) {
  if (vertices.length < 3) return [];

  var len = vertices.length,
      plen = len - 1,
      points = [],
      stack = [],
      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;

  // find the starting ref point: leftmost point with the minimum y coord
  for (i=1; i<len; ++i) {
    if (vertices[i][1] < vertices[h][1]) {
      h = i;
    } else if (vertices[i][1] == vertices[h][1]) {
      h = (vertices[i][0] < vertices[h][0] ? i : h);
    }
  }

  // calculate polar angles from ref point and sort
  for (i=0; i<len; ++i) {
    if (i === h) continue;
    y1 = vertices[i][1] - vertices[h][1];
    x1 = vertices[i][0] - vertices[h][0];
    points.push({angle: Math.atan2(y1, x1), index: i});
  }
  points.sort(function(a, b) { return a.angle - b.angle; });

  // toss out duplicate angles
  a = points[0].angle;
  v = points[0].index;
  u = 0;
  for (i=1; i<plen; ++i) {
    j = points[i].index;
    if (a == points[i].angle) {
      // keep angle for point most distant from the reference
      x1 = vertices[v][0] - vertices[h][0];
      y1 = vertices[v][1] - vertices[h][1];
      x2 = vertices[j][0] - vertices[h][0];
      y2 = vertices[j][1] - vertices[h][1];
      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {
        points[i].index = -1;
      } else {
        points[u].index = -1;
        a = points[i].angle;
        u = i;
        v = j;
      }
    } else {
      a = points[i].angle;
      u = i;
      v = j;
    }
  }

  // initialize the stack
  stack.push(h);
  for (i=0, j=0; i<2; ++j) {
    if (points[j].index !== -1) {
      stack.push(points[j].index);
      i++;
    }
  }
  sp = stack.length;

  // do graham's scan
  for (; j<plen; ++j) {
    if (points[j].index === -1) continue; // skip tossed out points
    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {
      --sp;
    }
    stack[sp++] = points[j].index;
  }

  // construct the hull
  var poly = [];
  for (i=0; i<sp; ++i) {
    poly.push(vertices[stack[i]]);
  }
  return poly;
}

// are three points in counter-clockwise order?
function d3_geom_hullCCW(i1, i2, i3, v) {
  var t, a, b, c, d, e, f;
  t = v[i1]; a = t[0]; b = t[1];
  t = v[i2]; c = t[0]; d = t[1];
  t = v[i3]; e = t[0]; f = t[1];
  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;
}
// Note: requires coordinates to be counterclockwise and convex!
d3.geom.polygon = function(coordinates) {

  coordinates.area = function() {
    var i = 0,
        n = coordinates.length,
        a = coordinates[n - 1][0] * coordinates[0][1],
        b = coordinates[n - 1][1] * coordinates[0][0];
    while (++i < n) {
      a += coordinates[i - 1][0] * coordinates[i][1];
      b += coordinates[i - 1][1] * coordinates[i][0];
    }
    return (b - a) * .5;
  };

  coordinates.centroid = function(k) {
    var i = -1,
        n = coordinates.length,
        x = 0,
        y = 0,
        a,
        b = coordinates[n - 1],
        c;
    if (!arguments.length) k = -1 / (6 * coordinates.area());
    while (++i < n) {
      a = b;
      b = coordinates[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [x * k, y * k];
  };

  // The Sutherland-Hodgman clipping algorithm.
  coordinates.clip = function(subject) {
    var input,
        i = -1,
        n = coordinates.length,
        j,
        m,
        a = coordinates[n - 1],
        b,
        c,
        d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = coordinates[i];
      c = input[(m = input.length) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      a = b;
    }
    return subject;
  };

  return coordinates;
};

function d3_geom_polygonInside(p, a, b) {
  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
}

// Intersect two infinite lines cd and ab.
function d3_geom_polygonIntersect(c, d, a, b) {
  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],
      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],
      x13 = x1 - x3,
      x21 = x2 - x1,
      x43 = x4 - x3,
      y13 = y1 - y3,
      y21 = y2 - y1,
      y43 = y4 - y3,
      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);
  return [x1 + ua * x21, y1 + ua * y21];
}
// Adapted from Nicolas Garcia Belmonte's JIT implementation:
// http://blog.thejit.org/2010/02/12/voronoi-tessellation/
// http://blog.thejit.org/assets/voronoijs/voronoi.js
// See lib/jit/LICENSE for details.

// Notes:
//
// This implementation does not clip the returned polygons, so if you want to
// clip them to a particular shape you will need to do that either in SVG or by
// post-processing with d3.geom.polygon's clip method.
//
// If any vertices are coincident or have NaN positions, the behavior of this
// method is undefined. Most likely invalid polygons will be returned. You
// should filter invalid points, and consolidate coincident points, before
// computing the tessellation.

/**
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygons [[[x1, y1], [x2, y2], …], …]
 */
d3.geom.voronoi = function(vertices) {
  var polygons = vertices.map(function() { return []; });

  d3_voronoi_tessellate(vertices, function(e) {
    var s1,
        s2,
        x1,
        x2,
        y1,
        y2;
    if (e.a === 1 && e.b >= 0) {
      s1 = e.ep.r;
      s2 = e.ep.l;
    } else {
      s1 = e.ep.l;
      s2 = e.ep.r;
    }
    if (e.a === 1) {
      y1 = s1 ? s1.y : -1e6;
      x1 = e.c - e.b * y1;
      y2 = s2 ? s2.y : 1e6;
      x2 = e.c - e.b * y2;
    } else {
      x1 = s1 ? s1.x : -1e6;
      y1 = e.c - e.a * x1;
      x2 = s2 ? s2.x : 1e6;
      y2 = e.c - e.a * x2;
    }
    var v1 = [x1, y1],
        v2 = [x2, y2];
    polygons[e.region.l.index].push(v1, v2);
    polygons[e.region.r.index].push(v1, v2);
  });

  // Reconnect the polygon segments into counterclockwise loops.
  return polygons.map(function(polygon, i) {
    var cx = vertices[i][0],
        cy = vertices[i][1];
    polygon.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    return polygon.sort(function(a, b) {
      return a.angle - b.angle;
    }).filter(function(d, i) {
      return !i || (d.angle - polygon[i - 1].angle > 1e-10);
    });
  });
};

var d3_voronoi_opposite = {"l": "r", "r": "l"};

function d3_voronoi_tessellate(vertices, callback) {

  var Sites = {
    list: vertices
      .map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      })
      .sort(function(a, b) {
        return a.y < b.y ? -1
          : a.y > b.y ? 1
          : a.x < b.x ? -1
          : a.x > b.x ? 1
          : 0;
      }),
    bottomSite: null
  };

  var EdgeList = {
    list: [],
    leftEnd: null,
    rightEnd: null,

    init: function() {
      EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.leftEnd.r = EdgeList.rightEnd;
      EdgeList.rightEnd.l = EdgeList.leftEnd;
      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
    },

    createHalfEdge: function(edge, side) {
      return {
        edge: edge,
        side: side,
        vertex: null,
        "l": null,
        "r": null
      };
    },

    insert: function(lb, he) {
      he.l = lb;
      he.r = lb.r;
      lb.r.l = he;
      lb.r = he;
    },

    leftBound: function(p) {
      var he = EdgeList.leftEnd;
      do {
        he = he.r;
      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
      he = he.l;
      return he;
    },

    del: function(he) {
      he.l.r = he.r;
      he.r.l = he.l;
      he.edge = null;
    },

    right: function(he) {
      return he.r;
    },

    left: function(he) {
      return he.l;
    },

    leftRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[he.side];
    },

    rightRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[d3_voronoi_opposite[he.side]];
    }
  };

  var Geom = {

    bisect: function(s1, s2) {
      var newEdge = {
        region: {"l": s1, "r": s2},
        ep: {"l": null, "r": null}
      };

      var dx = s2.x - s1.x,
          dy = s2.y - s1.y,
          adx = dx > 0 ? dx : -dx,
          ady = dy > 0 ? dy : -dy;

      newEdge.c = s1.x * dx + s1.y * dy
          + (dx * dx + dy * dy) * .5;

      if (adx > ady) {
        newEdge.a = 1;
        newEdge.b = dy / dx;
        newEdge.c /= dx;
      } else {
        newEdge.b = 1;
        newEdge.a = dx / dy;
        newEdge.c /= dy;
      }

      return newEdge;
    },

    intersect: function(el1, el2) {
      var e1 = el1.edge,
          e2 = el2.edge;
      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {
        return null;
      }
      var d = (e1.a * e2.b) - (e1.b * e2.a);
      if (Math.abs(d) < 1e-10) {
        return null;
      }
      var xint = (e1.c * e2.b - e2.c * e1.b) / d,
          yint = (e2.c * e1.a - e1.c * e2.a) / d,
          e1r = e1.region.r,
          e2r = e2.region.r,
          el,
          e;
      if ((e1r.y < e2r.y) ||
         (e1r.y == e2r.y && e1r.x < e2r.x)) {
        el = el1;
        e = e1;
      } else {
        el = el2;
        e = e2;
      }
      var rightOfSite = (xint >= e.region.r.x);
      if ((rightOfSite && (el.side === "l")) ||
        (!rightOfSite && (el.side === "r"))) {
        return null;
      }
      return {
        x: xint,
        y: yint
      };
    },

    rightOf: function(he, p) {
      var e = he.edge,
          topsite = e.region.r,
          rightOfSite = (p.x > topsite.x);

      if (rightOfSite && (he.side === "l")) {
        return 1;
      }
      if (!rightOfSite && (he.side === "r")) {
        return 0;
      }
      if (e.a === 1) {
        var dyp = p.y - topsite.y,
            dxp = p.x - topsite.x,
            fast = 0,
            above = 0;

        if ((!rightOfSite && (e.b < 0)) ||
          (rightOfSite && (e.b >= 0))) {
          above = fast = (dyp >= e.b * dxp);
        } else {
          above = ((p.x + p.y * e.b) > e.c);
          if (e.b < 0) {
            above = !above;
          }
          if (!above) {
            fast = 1;
          }
        }
        if (!fast) {
          var dxs = topsite.x - e.region.l.x;
          above = (e.b * (dxp * dxp - dyp * dyp)) <
            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));

          if (e.b < 0) {
            above = !above;
          }
        }
      } else /* e.b == 1 */ {
        var yl = e.c - e.a * p.x,
            t1 = p.y - yl,
            t2 = p.x - topsite.x,
            t3 = yl - topsite.y;

        above = (t1 * t1) > (t2 * t2 + t3 * t3);
      }
      return he.side === "l" ? above : !above;
    },

    endPoint: function(edge, side, site) {
      edge.ep[side] = site;
      if (!edge.ep[d3_voronoi_opposite[side]]) return;
      callback(edge);
    },

    distance: function(s, t) {
      var dx = s.x - t.x,
          dy = s.y - t.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  };

  var EventQueue = {
    list: [],

    insert: function(he, site, offset) {
      he.vertex = site;
      he.ystar = site.y + offset;
      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {
        var next = list[i];
        if (he.ystar > next.ystar ||
          (he.ystar == next.ystar &&
          site.x > next.vertex.x)) {
          continue;
        } else {
          break;
        }
      }
      list.splice(i, 0, he);
    },

    del: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}
      ls.splice(i, 1);
    },

    empty: function() { return EventQueue.list.length === 0; },

    nextEvent: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {
        if (ls[i] == he) return ls[i+1];
      }
      return null;
    },

    min: function() {
      var elem = EventQueue.list[0];
      return {
        x: elem.vertex.x,
        y: elem.ystar
      };
    },

    extractMin: function() {
      return EventQueue.list.shift();
    }
  };

  EdgeList.init();
  Sites.bottomSite = Sites.list.shift();

  var newSite = Sites.list.shift(), newIntStar;
  var lbnd, rbnd, llbnd, rrbnd, bisector;
  var bot, top, temp, p, v;
  var e, pm;

  while (true) {
    if (!EventQueue.empty()) {
      newIntStar = EventQueue.min();
    }
    if (newSite && (EventQueue.empty()
      || newSite.y < newIntStar.y
      || (newSite.y == newIntStar.y
      && newSite.x < newIntStar.x))) { //new site is smallest
      lbnd = EdgeList.leftBound(newSite);
      rbnd = EdgeList.right(lbnd);
      bot = EdgeList.rightRegion(lbnd);
      e = Geom.bisect(bot, newSite);
      bisector = EdgeList.createHalfEdge(e, "l");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(lbnd, bisector);
      if (p) {
        EventQueue.del(lbnd);
        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
      }
      lbnd = bisector;
      bisector = EdgeList.createHalfEdge(e, "r");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(bisector, rbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, newSite));
      }
      newSite = Sites.list.shift();
    } else if (!EventQueue.empty()) { //intersection is smallest
      lbnd = EventQueue.extractMin();
      llbnd = EdgeList.left(lbnd);
      rbnd = EdgeList.right(lbnd);
      rrbnd = EdgeList.right(rbnd);
      bot = EdgeList.leftRegion(lbnd);
      top = EdgeList.rightRegion(rbnd);
      v = lbnd.vertex;
      Geom.endPoint(lbnd.edge, lbnd.side, v);
      Geom.endPoint(rbnd.edge, rbnd.side, v);
      EdgeList.del(lbnd);
      EventQueue.del(rbnd);
      EdgeList.del(rbnd);
      pm = "l";
      if (bot.y > top.y) {
        temp = bot;
        bot = top;
        top = temp;
        pm = "r";
      }
      e = Geom.bisect(bot, top);
      bisector = EdgeList.createHalfEdge(e, pm);
      EdgeList.insert(llbnd, bisector);
      Geom.endPoint(e, d3_voronoi_opposite[pm], v);
      p = Geom.intersect(llbnd, bisector);
      if (p) {
        EventQueue.del(llbnd);
        EventQueue.insert(llbnd, p, Geom.distance(p, bot));
      }
      p = Geom.intersect(bisector, rrbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, bot));
      }
    } else {
      break;
    }
  }//end while

  for (lbnd = EdgeList.right(EdgeList.leftEnd);
      lbnd != EdgeList.rightEnd;
      lbnd = EdgeList.right(lbnd)) {
    callback(lbnd.edge);
  }
}
/**
* @param vertices [[x1, y1], [x2, y2], …]
* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], …]
 */
d3.geom.delaunay = function(vertices) {
  var edges = vertices.map(function() { return []; }),
      triangles = [];

  // Use the Voronoi tessellation to determine Delaunay edges.
  d3_voronoi_tessellate(vertices, function(e) {
    edges[e.region.l.index].push(vertices[e.region.r.index]);
  });

  // Reconnect the edges into counterclockwise triangles.
  edges.forEach(function(edge, i) {
    var v = vertices[i],
        cx = v[0],
        cy = v[1];
    edge.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    edge.sort(function(a, b) {
      return a.angle - b.angle;
    });
    for (var j = 0, m = edge.length - 1; j < m; j++) {
      triangles.push([v, edge[j], edge[j + 1]]);
    }
  });

  return triangles;
};
// Constructs a new quadtree for the specified array of points. A quadtree is a
// two-dimensional recursive spatial subdivision. This implementation uses
// square partitions, dividing each square into four equally-sized squares. Each
// point exists in a unique node; if multiple points are in the same position,
// some points may be stored on internal nodes rather than leaf nodes. Quadtrees
// can be used to accelerate various spatial operations, such as the Barnes-Hut
// approximation for computing n-body forces, or collision detection.
d3.geom.quadtree = function(points, x1, y1, x2, y2) {
  var p,
      i = -1,
      n = points.length;

  // Type conversion for deprecated API.
  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);

  // Allow bounds to be specified explicitly.
  if (arguments.length < 5) {
    if (arguments.length === 3) {
      y2 = x2 = y1;
      y1 = x1;
    } else {
      x1 = y1 = Infinity;
      x2 = y2 = -Infinity;

      // Compute bounds.
      while (++i < n) {
        p = points[i];
        if (p.x < x1) x1 = p.x;
        if (p.y < y1) y1 = p.y;
        if (p.x > x2) x2 = p.x;
        if (p.y > y2) y2 = p.y;
      }

      // Squarify the bounds.
      var dx = x2 - x1,
          dy = y2 - y1;
      if (dx > dy) y2 = y1 + dx;
      else x2 = x1 + dy;
    }
  }

  // Recursively inserts the specified point p at the node n or one of its
  // descendants. The bounds are defined by [x1, x2] and [y1, y2].
  function insert(n, p, x1, y1, x2, y2) {
    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points
    if (n.leaf) {
      var v = n.point;
      if (v) {
        // If the point at this leaf node is at the same position as the new
        // point we are adding, we leave the point associated with the
        // internal node while adding the new point to a child node. This
        // avoids infinite recursion.
        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {
          insertChild(n, p, x1, y1, x2, y2);
        } else {
          n.point = null;
          insertChild(n, v, x1, y1, x2, y2);
          insertChild(n, p, x1, y1, x2, y2);
        }
      } else {
        n.point = p;
      }
    } else {
      insertChild(n, p, x1, y1, x2, y2);
    }
  }

  // Recursively inserts the specified point p into a descendant of node n. The
  // bounds are defined by [x1, x2] and [y1, y2].
  function insertChild(n, p, x1, y1, x2, y2) {
    // Compute the split point, and the quadrant in which to insert p.
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        right = p.x >= sx,
        bottom = p.y >= sy,
        i = (bottom << 1) + right;

    // Recursively insert into the child node.
    n.leaf = false;
    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());

    // Update the bounds as we recurse.
    if (right) x1 = sx; else x2 = sx;
    if (bottom) y1 = sy; else y2 = sy;
    insert(n, p, x1, y1, x2, y2);
  }

  // Create the root node.
  var root = d3_geom_quadtreeNode();

  root.add = function(p) {
    insert(root, p, x1, y1, x2, y2);
  };

  root.visit = function(f) {
    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
  };

  // Insert all points.
  points.forEach(root.add);
  return root;
};

function d3_geom_quadtreeNode() {
  return {
    leaf: true,
    nodes: [],
    point: null
  };
}

function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
  if (!f(node, x1, y1, x2, y2)) {
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        children = node.nodes;
    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
  }
}

function d3_geom_quadtreePoint(p) {
  return {
    x: p[0],
    y: p[1]
  };
}
d3.time = {};

var d3_time = Date;

function d3_time_utc() {
  this._ = new Date(arguments.length > 1
      ? Date.UTC.apply(this, arguments)
      : arguments[0]);
}

d3_time_utc.prototype = {
  getDate: function() { return this._.getUTCDate(); },
  getDay: function() { return this._.getUTCDay(); },
  getFullYear: function() { return this._.getUTCFullYear(); },
  getHours: function() { return this._.getUTCHours(); },
  getMilliseconds: function() { return this._.getUTCMilliseconds(); },
  getMinutes: function() { return this._.getUTCMinutes(); },
  getMonth: function() { return this._.getUTCMonth(); },
  getSeconds: function() { return this._.getUTCSeconds(); },
  getTime: function() { return this._.getTime(); },
  getTimezoneOffset: function() { return 0; },
  valueOf: function() { return this._.valueOf(); },
  setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); },
  setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); },
  setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); },
  setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); },
  setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); },
  setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); },
  setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); },
  setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); },
  setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); }
};

var d3_time_prototype = Date.prototype;
d3.time.format = function(template) {
  var n = template.length;

  function format(date) {
    var string = [],
        i = -1,
        j = 0,
        c,
        f;
    while (++i < n) {
      if (template.charCodeAt(i) == 37) {
        string.push(
            template.substring(j, i),
            (f = d3_time_formats[c = template.charAt(++i)])
            ? f(date) : c);
        j = i + 1;
      }
    }
    string.push(template.substring(j, i));
    return string.join("");
  }

  format.parse = function(string) {
    var d = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0},
        i = d3_time_parse(d, template, string, 0);
    if (i != string.length) return null;

    // The am-pm flag is 0 for AM, and 1 for PM.
    if ("p" in d) d.H = d.H % 12 + d.p * 12;

    var date = new d3_time();
    date.setFullYear(d.y, d.m, d.d);
    date.setHours(d.H, d.M, d.S, d.L);
    return date;
  };

  format.toString = function() {
    return template;
  };

  return format;
};

function d3_time_parse(date, template, string, j) {
  var c,
      p,
      i = 0,
      n = template.length,
      m = string.length;
  while (i < n) {
    if (j >= m) return -1;
    c = template.charCodeAt(i++);
    if (c == 37) {
      p = d3_time_parsers[template.charAt(i++)];
      if (!p || ((j = p(date, string, j)) < 0)) return -1;
    } else if (c != string.charCodeAt(j++)) {
      return -1;
    }
  }
  return j;
}

var d3_time_zfill2 = d3.format("02d"),
    d3_time_zfill3 = d3.format("03d"),
    d3_time_zfill4 = d3.format("04d"),
    d3_time_sfill2 = d3.format("2d");

var d3_time_formats = {
  a: function(d) { return d3_time_weekdays[d.getDay()].substring(0, 3); },
  A: function(d) { return d3_time_weekdays[d.getDay()]; },
  b: function(d) { return d3_time_months[d.getMonth()].substring(0, 3); },
  B: function(d) { return d3_time_months[d.getMonth()]; },
  c: d3.time.format("%a %b %e %H:%M:%S %Y"),
  d: function(d) { return d3_time_zfill2(d.getDate()); },
  e: function(d) { return d3_time_sfill2(d.getDate()); },
  H: function(d) { return d3_time_zfill2(d.getHours()); },
  I: function(d) { return d3_time_zfill2(d.getHours() % 12 || 12); },
  j: function(d) { return d3_time_zfill3(1 + d3.time.dayOfYear(d)); },
  L: function(d) { return d3_time_zfill3(d.getMilliseconds()); },
  m: function(d) { return d3_time_zfill2(d.getMonth() + 1); },
  M: function(d) { return d3_time_zfill2(d.getMinutes()); },
  p: function(d) { return d.getHours() >= 12 ? "PM" : "AM"; },
  S: function(d) { return d3_time_zfill2(d.getSeconds()); },
  U: function(d) { return d3_time_zfill2(d3.time.sundayOfYear(d)); },
  w: function(d) { return d.getDay(); },
  W: function(d) { return d3_time_zfill2(d3.time.mondayOfYear(d)); },
  x: d3.time.format("%m/%d/%y"),
  X: d3.time.format("%H:%M:%S"),
  y: function(d) { return d3_time_zfill2(d.getFullYear() % 100); },
  Y: function(d) { return d3_time_zfill4(d.getFullYear() % 10000); },
  Z: d3_time_zone,
  "%": function(d) { return "%"; }
};

var d3_time_parsers = {
  a: d3_time_parseWeekdayAbbrev,
  A: d3_time_parseWeekday,
  b: d3_time_parseMonthAbbrev,
  B: d3_time_parseMonth,
  c: d3_time_parseLocaleFull,
  d: d3_time_parseDay,
  e: d3_time_parseDay,
  H: d3_time_parseHour24,
  I: d3_time_parseHour24,
  // j: function(d, s, i) { /*TODO day of year [001,366] */ return i; },
  L: d3_time_parseMilliseconds,
  m: d3_time_parseMonthNumber,
  M: d3_time_parseMinutes,
  p: d3_time_parseAmPm,
  S: d3_time_parseSeconds,
  // U: function(d, s, i) { /*TODO week number (sunday) [00,53] */ return i; },
  // w: function(d, s, i) { /*TODO weekday [0,6] */ return i; },
  // W: function(d, s, i) { /*TODO week number (monday) [00,53] */ return i; },
  x: d3_time_parseLocaleDate,
  X: d3_time_parseLocaleTime,
  y: d3_time_parseYear,
  Y: d3_time_parseFullYear
  // ,
  // Z: function(d, s, i) { /*TODO time zone */ return i; },
  // "%": function(d, s, i) { /*TODO literal % */ return i; }
};

// Note: weekday is validated, but does not set the date.
function d3_time_parseWeekdayAbbrev(date, string, i) {
  return d3_time_weekdayAbbrevRe.test(string.substring(i, i += 3)) ? i : -1;
}

// Note: weekday is validated, but does not set the date.
function d3_time_parseWeekday(date, string, i) {
  d3_time_weekdayRe.lastIndex = 0;
  var n = d3_time_weekdayRe.exec(string.substring(i, i + 10));
  return n ? i += n[0].length : -1;
}

var d3_time_weekdayAbbrevRe = /^(?:sun|mon|tue|wed|thu|fri|sat)/i,
    d3_time_weekdayRe = /^(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)/i,
    d3_time_weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

function d3_time_parseMonthAbbrev(date, string, i) {
  var n = d3_time_monthAbbrevLookup.get(string.substring(i, i += 3).toLowerCase());
  return n == null ? -1 : (date.m = n, i);
}

var d3_time_monthAbbrevLookup = d3.map({
  jan: 0,
  feb: 1,
  mar: 2,
  apr: 3,
  may: 4,
  jun: 5,
  jul: 6,
  aug: 7,
  sep: 8,
  oct: 9,
  nov: 10,
  dec: 11
});

function d3_time_parseMonth(date, string, i) {
  d3_time_monthRe.lastIndex = 0;
  var n = d3_time_monthRe.exec(string.substring(i, i + 12));
  return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
}

var d3_time_monthRe = /^(?:January|February|March|April|May|June|July|August|September|October|November|December)/ig;

var d3_time_monthLookup = d3.map({
  january: 0,
  february: 1,
  march: 2,
  april: 3,
  may: 4,
  june: 5,
  july: 6,
  august: 7,
  september: 8,
  october: 9,
  november: 10,
  december: 11
});

var d3_time_months = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];

function d3_time_parseLocaleFull(date, string, i) {
  return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
}

function d3_time_parseLocaleDate(date, string, i) {
  return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
}

function d3_time_parseLocaleTime(date, string, i) {
  return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
}

function d3_time_parseFullYear(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 4));
  return n ? (date.y = +n[0], i += n[0].length) : -1;
}

function d3_time_parseYear(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.y = d3_time_century() + +n[0], i += n[0].length) : -1;
}

function d3_time_century() {
  return ~~(new Date().getFullYear() / 1000) * 1000;
}

function d3_time_parseMonthNumber(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
}

function d3_time_parseDay(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.d = +n[0], i += n[0].length) : -1;
}

// Note: we don't validate that the hour is in the range [0,23] or [1,12].
function d3_time_parseHour24(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.H = +n[0], i += n[0].length) : -1;
}

function d3_time_parseMinutes(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.M = +n[0], i += n[0].length) : -1;
}

function d3_time_parseSeconds(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.S = +n[0], i += n[0].length) : -1;
}

function d3_time_parseMilliseconds(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 3));
  return n ? (date.L = +n[0], i += n[0].length) : -1;
}

// Note: we don't look at the next directive.
var d3_time_numberRe = /\s*\d+/;

function d3_time_parseAmPm(date, string, i) {
  var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
  return n == null ? -1 : (date.p = n, i);
}

var d3_time_amPmLookup = d3.map({
  am: 0,
  pm: 1
});

// TODO table of time zone offset names?
function d3_time_zone(d) {
  var z = d.getTimezoneOffset(),
      zs = z > 0 ? "-" : "+",
      zh = ~~(Math.abs(z) / 60),
      zm = Math.abs(z) % 60;
  return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);
}
d3.time.format.utc = function(template) {
  var local = d3.time.format(template);

  function format(date) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time();
      utc._ = date;
      return local(utc);
    } finally {
      d3_time = Date;
    }
  }

  format.parse = function(string) {
    try {
      d3_time = d3_time_utc;
      var date = local.parse(string);
      return date && date._;
    } finally {
      d3_time = Date;
    }
  };

  format.toString = local.toString;

  return format;
};
var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");

d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;

function d3_time_formatIsoNative(date) {
  return date.toISOString();
}

d3_time_formatIsoNative.parse = function(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
};

d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
function d3_time_interval(local, step, number) {

  function round(date) {
    var d0 = local(date), d1 = offset(d0, 1);
    return date - d0 < d1 - date ? d0 : d1;
  }

  function ceil(date) {
    step(date = local(new d3_time(date - 1)), 1);
    return date;
  }

  function offset(date, k) {
    step(date = new d3_time(+date), k);
    return date;
  }

  function range(t0, t1, dt) {
    var time = ceil(t0), times = [];
    if (dt > 1) {
      while (time < t1) {
        if (!(number(time) % dt)) times.push(new Date(+time));
        step(time, 1);
      }
    } else {
      while (time < t1) times.push(new Date(+time)), step(time, 1);
    }
    return times;
  }

  function range_utc(t0, t1, dt) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time_utc();
      utc._ = t0;
      return range(utc, t1, dt);
    } finally {
      d3_time = Date;
    }
  }

  local.floor = local;
  local.round = round;
  local.ceil = ceil;
  local.offset = offset;
  local.range = range;

  var utc = local.utc = d3_time_interval_utc(local);
  utc.floor = utc;
  utc.round = d3_time_interval_utc(round);
  utc.ceil = d3_time_interval_utc(ceil);
  utc.offset = d3_time_interval_utc(offset);
  utc.range = range_utc;

  return local;
}

function d3_time_interval_utc(method) {
  return function(date, k) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time_utc();
      utc._ = date;
      return method(utc, k)._;
    } finally {
      d3_time = Date;
    }
  };
}
d3.time.second = d3_time_interval(function(date) {
  return new d3_time(Math.floor(date / 1e3) * 1e3);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 1e3); // DST breaks setSeconds
}, function(date) {
  return date.getSeconds();
});

d3.time.seconds = d3.time.second.range;
d3.time.seconds.utc = d3.time.second.utc.range;
d3.time.minute = d3_time_interval(function(date) {
  return new d3_time(Math.floor(date / 6e4) * 6e4);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 6e4); // DST breaks setMinutes
}, function(date) {
  return date.getMinutes();
});

d3.time.minutes = d3.time.minute.range;
d3.time.minutes.utc = d3.time.minute.utc.range;
d3.time.hour = d3_time_interval(function(date) {
  var timezone = date.getTimezoneOffset() / 60;
  return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 36e5); // DST breaks setHours
}, function(date) {
  return date.getHours();
});

d3.time.hours = d3.time.hour.range;
d3.time.hours.utc = d3.time.hour.utc.range;
d3.time.day = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), date.getMonth(), date.getDate());
}, function(date, offset) {
  date.setDate(date.getDate() + offset);
}, function(date) {
  return date.getDate() - 1;
});

d3.time.days = d3.time.day.range;
d3.time.days.utc = d3.time.day.utc.range;

d3.time.dayOfYear = function(date) {
  var year = d3.time.year(date);
  return Math.floor((date - year) / 864e5 - (date.getTimezoneOffset() - year.getTimezoneOffset()) / 1440);
};
d3_time_weekdays.forEach(function(day, i) {
  day = day.toLowerCase();
  i = 7 - i;

  var interval = d3.time[day] = d3_time_interval(function(date) {
    (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
    return date;
  }, function(date, offset) {
    date.setDate(date.getDate() + Math.floor(offset) * 7);
  }, function(date) {
    var day = d3.time.year(date).getDay();
    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
  });

  d3.time[day + "s"] = interval.range;
  d3.time[day + "s"].utc = interval.utc.range;

  d3.time[day + "OfYear"] = function(date) {
    var day = d3.time.year(date).getDay();
    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
  };
});

d3.time.week = d3.time.sunday;
d3.time.weeks = d3.time.sunday.range;
d3.time.weeks.utc = d3.time.sunday.utc.range;
d3.time.weekOfYear = d3.time.sundayOfYear;
d3.time.month = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), date.getMonth(), 1);
}, function(date, offset) {
  date.setMonth(date.getMonth() + offset);
}, function(date) {
  return date.getMonth();
});

d3.time.months = d3.time.month.range;
d3.time.months.utc = d3.time.month.utc.range;
d3.time.year = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), 0, 1);
}, function(date, offset) {
  date.setFullYear(date.getFullYear() + offset);
}, function(date) {
  return date.getFullYear();
});

d3.time.years = d3.time.year.range;
d3.time.years.utc = d3.time.year.utc.range;
function d3_time_scale(linear, methods, format) {

  function scale(x) {
    return linear(x);
  }

  scale.invert = function(x) {
    return d3_time_scaleDate(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
    linear.domain(x);
    return scale;
  };

  scale.nice = function(m) {
    var extent = d3_time_scaleExtent(scale.domain());
    return scale.domain([m.floor(extent[0]), m.ceil(extent[1])]);
  };

  scale.ticks = function(m, k) {
    var extent = d3_time_scaleExtent(scale.domain());
    if (typeof m !== "function") {
      var span = extent[1] - extent[0],
          target = span / m,
          i = d3.bisect(d3_time_scaleSteps, target);
      if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
      if (!i) return linear.ticks(m).map(d3_time_scaleDate);
      if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
      m = methods[i];
      k = m[1];
      m = m[0].range;
    }
    return m(extent[0], new Date(+extent[1] + 1), k); // inclusive upper bound
  };

  scale.tickFormat = function() {
    return format;
  };

  scale.copy = function() {
    return d3_time_scale(linear.copy(), methods, format);
  };

  // TOOD expose d3_scale_linear_rebind?
  return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
}

// TODO expose d3_scaleExtent?
function d3_time_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function d3_time_scaleDate(t) {
  return new Date(t);
}

function d3_time_scaleFormat(formats) {
  return function(date) {
    var i = formats.length - 1, f = formats[i];
    while (!f[1](date)) f = formats[--i];
    return f[0](date);
  };
}

function d3_time_scaleSetYear(y) {
  var d = new Date(y, 0, 1);
  d.setFullYear(y); // Y2K fail
  return d;
}

function d3_time_scaleGetYear(d) {
  var y = d.getFullYear(),
      d0 = d3_time_scaleSetYear(y),
      d1 = d3_time_scaleSetYear(y + 1);
  return y + (d - d0) / (d1 - d0);
}

var d3_time_scaleSteps = [
  1e3,    // 1-second
  5e3,    // 5-second
  15e3,   // 15-second
  3e4,    // 30-second
  6e4,    // 1-minute
  3e5,    // 5-minute
  9e5,    // 15-minute
  18e5,   // 30-minute
  36e5,   // 1-hour
  108e5,  // 3-hour
  216e5,  // 6-hour
  432e5,  // 12-hour
  864e5,  // 1-day
  1728e5, // 2-day
  6048e5, // 1-week
  2592e6, // 1-month
  7776e6, // 3-month
  31536e6 // 1-year
];

var d3_time_scaleLocalMethods = [
  [d3.time.second, 1],
  [d3.time.second, 5],
  [d3.time.second, 15],
  [d3.time.second, 30],
  [d3.time.minute, 1],
  [d3.time.minute, 5],
  [d3.time.minute, 15],
  [d3.time.minute, 30],
  [d3.time.hour, 1],
  [d3.time.hour, 3],
  [d3.time.hour, 6],
  [d3.time.hour, 12],
  [d3.time.day, 1],
  [d3.time.day, 2],
  [d3.time.week, 1],
  [d3.time.month, 1],
  [d3.time.month, 3],
  [d3.time.year, 1]
];

var d3_time_scaleLocalFormats = [
  [d3.time.format("%Y"), function(d) { return true; }],
  [d3.time.format("%B"), function(d) { return d.getMonth(); }],
  [d3.time.format("%b %d"), function(d) { return d.getDate() != 1; }],
  [d3.time.format("%a %d"), function(d) { return d.getDay() && d.getDate() != 1; }],
  [d3.time.format("%I %p"), function(d) { return d.getHours(); }],
  [d3.time.format("%I:%M"), function(d) { return d.getMinutes(); }],
  [d3.time.format(":%S"), function(d) { return d.getSeconds(); }],
  [d3.time.format(".%L"), function(d) { return d.getMilliseconds(); }]
];

var d3_time_scaleLinear = d3.scale.linear(),
    d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);

d3_time_scaleLocalMethods.year = function(extent, m) {
  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
};

d3.time.scale = function() {
  return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
};
var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
  return [m[0].utc, m[1]];
});

var d3_time_scaleUTCFormats = [
  [d3.time.format.utc("%Y"), function(d) { return true; }],
  [d3.time.format.utc("%B"), function(d) { return d.getUTCMonth(); }],
  [d3.time.format.utc("%b %d"), function(d) { return d.getUTCDate() != 1; }],
  [d3.time.format.utc("%a %d"), function(d) { return d.getUTCDay() && d.getUTCDate() != 1; }],
  [d3.time.format.utc("%I %p"), function(d) { return d.getUTCHours(); }],
  [d3.time.format.utc("%I:%M"), function(d) { return d.getUTCMinutes(); }],
  [d3.time.format.utc(":%S"), function(d) { return d.getUTCSeconds(); }],
  [d3.time.format.utc(".%L"), function(d) { return d.getUTCMilliseconds(); }]
];

var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);

function d3_time_scaleUTCSetYear(y) {
  var d = new Date(Date.UTC(y, 0, 1));
  d.setUTCFullYear(y); // Y2K fail
  return d;
}

function d3_time_scaleUTCGetYear(d) {
  var y = d.getUTCFullYear(),
      d0 = d3_time_scaleUTCSetYear(y),
      d1 = d3_time_scaleUTCSetYear(y + 1);
  return y + (d - d0) / (d1 - d0);
}

d3_time_scaleUTCMethods.year = function(extent, m) {
  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
};

d3.time.scale.utc = function() {
  return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
};
})();

;
//TAG Utilities
TAG.Util = (function () {
    "use strict";

    var tagContainerId = 'tagRoot';

    //TAG.Util public methods and members
    return {
        makeNamespace: namespace,
        setToDefaults: setToDefaults,
        getGestureRecognizer: getGestureRecognizer,
        makeXmlRequest: makeXmlRequest,
        makeManipulatable: makeManipulatable,
        makeManipulatableWin: makeManipulatableWin,
        applyD3DataRec: applyD3DataRec,
        elementInDocument: elementInDocument,
        fitText: fitText,
        multiLineEllipsis: multiLineEllipsis,
        encodeText: encodeText,
        disableDrag: disableDrag,
        getFontSize: getFontSize,
        parseDateToYear : parseDateToYear,
        showLoading: showLoading,
        hideLoading: hideLoading,
        removeProgressCircle: removeProgressCircle,
        showProgressCircle: showProgressCircle,
        createQueue: createQueue,
        createDoubleEndedPQ: createDoubleEndedPQ,
        replaceSVGImg: replaceSVGImg,
        getMaxFontSizeEM: getMaxFontSizeEM,
        getMaxFontSize: getMaxFontSize,
        encodeXML: encodeXML,
        constrainAndPosition: constrainAndPosition,
        getFieldValueFromMetadata: getFieldValueFromMetadata,
        formatAddress: formatAddress,
        safeCall: safeCall,
        safeCallHandler: safeCallHandler,
        multiFnHandler: multiFnHandler,
        contains: contains,
        defaultVal: defaultVal,
        searchData: searchData,
        searchString: searchString,
        saveThumbnail: saveThumbnail,
        htmlEntityEncode: htmlEntityEncode,
        htmlEntityDecode: htmlEntityDecode,
        checkVideoConverted4Track: checkVideoConverted4Track,
        createConversionLoading: createConversionLoading,
        videoErrorHandler: videoErrorHandler,
        getHtmlAjax: getHtmlAjax,
        localVisibility: localVisibility,
        dimColor: dimColor,
        hexToRGBA: hexToRGBA,
        IdCreator: IdCreator,
        makeBorderRadius: makeBorderRadius,
        createTutorialPopup: createTutorialPopup,
        removeYoutubeVideo: removeYoutubeVideo
    };

    function removeYoutubeVideo(){
        var iframeEle = document.getElementsByTagName("iframe");
        if (iframeEle[0]) {
            iframeEle[0].src = "";
        }
    }

    function makeBorderRadius(ele, radius) {
        ele.css('border-radius', radius);
    }
    function IdCreator(){
        var Id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
        return Id;
    }

    function multiLineEllipsis(textHolder) {
        var text = textHolder.html();
        var t = $(textHolder.clone(true))
            .hide()
            .css('position', 'absolute')
            .css('overflow', 'visible')
            .width(textHolder.width())
            .height('auto');

        function height() {
            var bool = t.height() > textHolder.height();
            return bool;
        };
        
        if(textHolder.css("overflow") == "hidden")
        {
            textHolder.parent().append(t);
            var func = height;

            while (text.length > 0 && func())
            {
                text = text.substr(0, text.length - 1);
                t.html(text + "...");
            }

            textHolder.html(t.html());
            t.remove();
        }
    }
    /* 
    constrainAndPosition takes in a set of relative and absolute 
    constraints and positioning as well as an HTML element and 
    its intended container, and returns a dictionary of position 
    and sizing data which conforms to the specified requirements.
    For this to work, the container must already be initialized 
    to its correct size.

    Possible constraints for propertySpec object:
    width: w 
        // mandatory, target relative width as decimal percent
    height: h 
        // mandatory, target relative height as decimal percent

    max_height: max_h 
        // optional, max absolute height in px 
        // ignored if unspecified
    max_width: max_w 
        // optional, max absolute width in px
        // ignored if unspecified

    x_offset: x_off 
        // optional, relative offset from left border of container as decimal percent
        // ignored if unspecified
    y_offset: y_off 
        // optional, relative offset from top border of container as decimal percent
        // ignored if unspecified

    x_max_offset: x_max_off 
        // optional, max absolute offset from left border of container in px
        // ignored if unspecified
    y_max_offset: y_max_off 
        // optional, max absolute offset from top border of container in px
        // ignored if unspecified

    center_h: center_h 
        // optional, boolean indicating whether element should be horizontally centered
        // defaults to false if unspecified
        // overrides any x-offset/x-max-offset as well as align_right if set to true
    center_v: center_v 
        // optional, boolean indicating whether element should be vertically centered
        // defaults to false if unspecified
        // overrides any y-offset/y-max-offset as well as align_bottom if set to true

    align_right: align_right
        // optional, boolean indicating whether element should be aligned from the right
        // NOTE: in this mode, positive offset values work like negative values in that they 
        // will shift the element leftwards TOWARDS THE CENTER, not the right.
    align_bottom: align_bottom
        // optional, boolean indicating whether element should be aligned from the bottom
        // NOTE: in this mode, positive offset values work like negative values in that they 
        // will shift the element upwards TOWARDS THE CENTER, not the bottom.
    */
    function constrainAndPosition(container_width, container_height, propertySpec) {
        var adjustedProperties,
            center_h = propertySpec.center_h || false,
            center_v = propertySpec.center_v || false;

        var cw = container_width,
            ch = container_height;

        var adjHeight, adjWidth;
        if (propertySpec.max_height) {
            // constrain to max height if specified
            adjHeight = Math.min(propertySpec.height * ch, propertySpec.max_height);
        } else {
            adjHeight = propertySpec.height * ch;
        }

        if (propertySpec.max_width) {
            // constrain to max width if specified
            adjWidth = Math.min(propertySpec.width * cw, propertySpec.max_width);
        } else {
            adjWidth = propertySpec.width * cw;
        }

        var xPos, yPos;
        // horizontal (x) value determined based on alignment/centering and offsets
        if (center_h) {
            // if horizontal centering enabled, account for in processing of x-offset
            if (propertySpec.x_max_offset) {
                // if max offset specified
                xPos = 0.5 * (cw - adjWidth) + Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset);
            } else {
                // if unspecified, ignore
                xPos = 0.5 * (cw - adjWidth);
            }

        } else {
            // otherwise, take care of offset from horiz axis
            if (propertySpec.x_max_offset) {
                // if max offset specified
                if (propertySpec.align_right) {
                    // if right alignment also specified, factor in width of object 
                    // and subtract offset from container width
                    xPos = cw - Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset) - adjWidth;
                } else {
                    // otherwise just select offset based on minimum of relative and absolute constraints
                    xPos = Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset);
                }
            } else {
                // if unspecified, ignore
                xPos = propertySpec.x_offset * cw;
            }
        }

        // vertical (y) value determined based on alignment/centering and offsets
        if (center_v) {
            // if vertically centering enabled, account for in processing of y-offset
            if (propertySpec.y_max_offset) {
                // if max offset specified
                yPos = 0.5 * (ch - adjHeight) + Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset);
            } else {
                // if unspecified, ignore
                yPos = 0.5 * (ch - adjHeight);
            }  
            
        } else {
            //otherwise, take care of offset from vertical axis
            if (propertySpec.y_max_offset) {
                // if max offset specified
                if (propertySpec.align_bottom) {
                    // if bottom alignment also specified, factor in width of object 
                    // and subtract offset from container high
                    yPos = ch - Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset) - adjHeight;
                } else {
                    // otherwise just select offset based on minimum of relative and absolute constraints
                    yPos = Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset);
                }
            } else {
                // if unspecified, ignore
                yPos = propertySpec.y_offset * ch;
            }
        }
        
        adjustedProperties = {
            height: adjHeight,
            width: adjWidth,
            x: xPos,
            y: yPos,
        };
        
        return adjustedProperties;
    }

    // Sets the default value of an input to val
    // If the input loses focus when it's empty it will revert
    // to val.  Additionally, if hideOnClick is true then
    // if the value is val and the input gains focus it will be
    // set to the empty string
    function defaultVal(val, input, hideOnClick, ignore) {
        input.val(val);
        if (hideOnClick) {
            input.focus(function () {
                if (input.val() === val)
                    input.val('').change();
            });
        }
        input.blur(function () {
            if (input.val() === '') {
                input.val(val).change();
                searchData('', '.artButton', ignore);
            }
        });
    }

    // search the data of all objects matching selector
    function searchData(val, selector, ignore) {
        $.each($(selector), function (i, element) {
            var data = $(element).data();
            var show = false;
            $.each(data, function (k, v) {
                if ($.inArray(k, ignore) !== -1) return;
                //if (k === 'visible' || k === 'exhibits') return;
                if (searchString(v, val)) {
                    show = true;
                }
            });
            if (data.visible === false) {
                show = false;
            }
            if (show) {
                $(element).show();
            } else {
                $(element).hide();
            }
        });
    }

    // Checks if a string 'val' contains 'str
    // If 'val' is the default search text it will always return true
    // Case insensitive
    function searchString(str, val) {
        if (str) {
            return str.toLowerCase().indexOf(val.toLowerCase()) !== -1;
        }
        return true;
    }

    // save a video thumbnail using popcorn.capture
    function saveThumbnail(artwork) {

    }


    // Creates a queue that will run functions asynchronously.
    // Call createQueue() to get a queue, then with that object
    // call add() to add a job to the queue.  Jobs will be completed
    // when the browser has downtime.
    // Call clear() to remove anything currently in the queue.
    function createQueue() {
        return {
            _timer: null,
            _queue: [],
            // fn: the function to be called
            // 
            add: function (fn, context, time) {
                var setTimer = function (time, self) {
                    self._timer = setTimeout(function () {
                        time = self.add();
                        if (self._queue.length) {
                            setTimer(time, self);
                        }
                    }, time || 2);
                };

                if (fn) {
                    this._queue.push([fn, context, time]);
                    if (this._queue.length === 1) {
                        setTimer(time, this);
                    }
                    return;
                }

                var next = this._queue.shift();
                if (!next) {
                    return 0;
                }
                next[0].call(next[1] || window);
                return next[2];
            },
            clear: function () {
                clearTimeout(this._timer);
                this._queue = [];
            },
            isEmpty: function () {
                return (this._queue.length === 0);
            }
        };
    }

    function formatAddress(address) {
        address = address.replace('http://', '');
        address = address.split(':')[0];
        return address;
    }

    function safeCall(fn) {
        var passedArgs = [];
        for (var i = 1; i < arguments.length; i++) {
            passedArgs[i - 1] = arguments[i];
        }
        fn && typeof fn === "function" && fn.apply(null, passedArgs);
    }

    function safeCallHandler(fn) {
        var passedArgs = [];
        for (var i = 1; i < arguments.length; i++) {
            passedArgs[i - 1] = arguments[i];
        }
        return function () {
            fn && typeof fn === "function" && fn.apply(null, passedArgs);
        }
    }

    function multiFnHandler() {
        var fns = arguments;
        return function () {
            var args = [];
            for (var j = 0; j < arguments.length; j++) { // Need to copy arguments into a regular array for concat
                args[j] = arguments[j];
            }
            var passedArgs;
            if (fns && fns.length) {
                for (var i = 0; i < fns.length; i++) {
                    passedArgs = [fns[i]].concat(args);
                    safeCall.apply(null, passedArgs);
                }
            }
        }
    }

    function contains(object, val) {
        if (object && object.indexOf) {
            return object.indexOf(val) !== -1;
        }
        return false;
    }

    /* 
     * This method parses the Metadata fields and then checks whether the required metadata
     * field matches up with the one currently being looked at. Once it has found a match, it
     * returns the appropriate node corresponding to the field.
     *
     * From the old settings view, works there so should work here
     * Made it so that it creates blank text node if there is none
     */
    function getFieldValueFromMetadata(xml, field) {
        var metadata = getMetaData(xml);
        for (var i = 0; i < metadata.length; i++) {
            if (metadata[i].childNodes[0].textContent === field) {
                var out = metadata[i].childNodes[1].childNodes[0];
                if (out) return out;

                metadata[i].childNodes[1].appendChild(xml.createTextNode(''));
                return metadata[i].childNodes[1].childNodes[0];
            }
        }
        return null;
    }

    function getMetaData(doq) {
        return doq.getElementsByTagName("Metadata")[0].childNodes[0].childNodes[0].childNodes[1].childNodes[0].childNodes;
    }

    //takes text with special characters and returns the html encode string
    function encodeText(string) {
        var element = document.createElement("div");
        element.innerText = element.textContent = string;
        string = element.innerHTML;
        return string;
    }

    function encodeXML(string) {
        if (string)
            return string.replace(/\n/g, '<br>').
                replace(/&/g, '&amp;').
                replace(/<(.|\n)*?>/g, '').
                replace(/\'/g, '&apos;').
                replace(/\"/g, '&quot;');
        else return "";
    }

    function fitText(element, factor, options) {
        var loadedInterval = setInterval(function () {
            if (elementInDocument($(element))) {
                $(element).fitText(factor, options);
                clearInterval(loadedInterval);
            }
        });
    }

    /* Get an integer year from date metadata
     * @method parseDateToYear
     * @param {Object} date       object containing year, month, and day 
     * @return {Number} year      year (can have decimals to represent month, days)
     */
    function parseDateToYear(date){
        var yearString,
            neg = false,
            cent,
            year,
            month,
            monthDict,
            day,
            metadataDate,
            startDate,
            millisecondDifference,
            millisecondsPerDay = 1000 * 3600 * 24,
            dayInYear,
            totalDaysInYear,
            dayDecimal;

        if (date && date.year){
            yearString = date.year;
            //Catches 'ad', 'bc', 'bce' case, spacing, and order insensitive
            if (yearString.search(/bce?/i)>=0){
                neg = true;
                yearString = yearString.replace(/bce?/gi,'');
            }
            yearString = yearString.replace(/ad/gi,'')
                                   .replace(/ce(?!n)/gi,'')
                                   .replace(/\s/g, '')
                                   .replace(/,/g,'');
            //Catch 'century', 'c', and 'c.' and return mid year of that century (17th c --> 1650)
            if (yearString.search(/c.?/i)>=0 || yearString.search(/century/i)>=0){
                yearString.replace(/[a-z]\w/gi,'')
                          .replace(/c.?/gi, '')
                cent = parseInt(yearString) - 1 ;
                yearString = cent.toString() + '50';
            }

            year = parseInt(yearString);
            if (date.month){
                month = date.month;
                monthDict = {
                    "January": 1,
                    "February:": 2,
                    "March": 3,
                    "April": 4,
                    "May": 5,
                    "June": 6,
                    "July": 7,
                    "August": 8,
                    "September": 9,
                    "October": 10,
                    "November":11,
                    "December": 12
                }
                if (date.day){
                    day = date.day;
                } else {
                    day = 1;
                }
                metadataDate = new Date(year, monthDict[month],day);
                startDate = new Date(year,0,0);
                millisecondDifference = metadataDate - startDate;
                dayInYear = Math.round(millisecondDifference/millisecondsPerDay);
                //check for leap year
                (new Date(year,2,0).getDate() === 29) ? totalDaysInYear = 366 : totalDaysInYear = 365;
                dayDecimal = dayInYear/totalDaysInYear;
                year = year + dayDecimal;
            }
            if (neg){
                year = -year;  
            }
            return year;
        }
    }

    // Replace SVG img with inline SVG
    function replaceSVGImg(svgImg) {
        var $img = $(svgImg);
        var imgURL = $img.attr('src');
        var imgID = $img.attr('id');
        var imgClass = $img.attr('class');
        var imgStyle = $img.attr('style');

        $.get(imgURL, function (data) {
            var $svg = $(data).find('svg');

            // Add replaced image's ID to the new SVG
            if (typeof imgID !== 'undefined') {
                $svg = $svg.attr('id', imgID);
            }
            // Add replaced image's classes to the new SVG
            if (typeof imgClass !== 'undefined') {
                $svg = $svg.attr('class', imgClass);
            }
            // Add replaced image's classes to the new SVG
            if (typeof imgStyle !== 'undefined') {
                $svg = $svg.attr('style', imgStyle);
            }

            $svg = $svg.removeAttr('xmlns:a');

            $img.replaceWith($svg);
            return $img;
        });
    }

    // show spinning circle and change the background to tell users the new page is loading
    function showLoading(divToAppend, circleSize, top, left) {
        
        var progressCircCSS = {
            "position": 'absolute',
            'z-index': '50',
            'height': 'auto',
            'width': '10%',
            'left': '50%',
            'top': '50%'
        };
        if (top || left) {
            progressCircCSS.top = top;
            progressCircCSS.left = left;
        }
        var centerhor = '0px';
        var centerver = '0px';
        if (circleSize) {
            progressCircCSS.width = circleSize;
        }
        var colorString = $(divToAppend).css("background-color");
        if (colorString && colorString.indexOf("rgb")!== -1){
            var colorOnly = colorString.substring(colorString.indexOf("(") + 1, colorString.lastIndexOf(")")).split(/, \s*/);
            var bgColor = "rgba(" + colorOnly[0] + "," + colorOnly[1] + "," + colorOnly[2]  + "," + "0.5)";
            divToAppend.css({
                'background-color': bgColor
            });
        }

        var circle = showProgressCircle($(divToAppend), progressCircCSS, centerhor, centerver, false);
    }

    // hide specified div
    function hideLoading(divToHide) {
        var colorString = $(divToHide).css("background-color");
        if (colorString && colorString.indexOf("rgb") !== -1) {
            var colorOnly = colorString.substring(colorString.indexOf("(") + 1, colorString.lastIndexOf(")")).split(/, \s*/);
            var bgColor = "rgba(" + colorOnly[0] + "," + colorOnly[1] + "," + colorOnly[2] + "," + "1)";
            divToHide.css({ 'background-color': bgColor });
        }

        var circle = divToHide.find('.progressCircle');
        removeProgressCircle(circle);
    }

    //remove the progress circle when work is finished 
    function removeProgressCircle(circle) {
        circle.remove();
        circle = null;
    }

    // show circle; returns the progress circle so it can be removed later (note: center of element given to center circle within)
    function showProgressCircle(elAppendTo, cssObject, centerHor, centerVert, shouldCenter) {
        var progressCircle = $(document.createElement('img'));
        progressCircle.addClass("progressCircle");
        elAppendTo.append(progressCircle);
        progressCircle.attr('src', tagPath+"images/icons/progress-circle.gif");
        progressCircle.css(cssObject || { // css for entity loading circles
            'position': 'absolute',
            'left': '5%',
            'z-index': '50',
            'height': 'auto',
            'bottom': '10%',
            'width': '10%',
        });
        if (shouldCenter) {
            progressCircle.css({ top: centerVert - 0.5 * progressCircle.height(), left: centerHor - 0.5 * progressCircle.width() });
        }
        return progressCircle;
    }

    // Used in TourAuthoring layout
    function getFontSize(factor) {
        return factor * (window.innerWidth / 1920) + '%'; // Huh??? what is 1920? width of screen lol
    }

    //Takes d3 data and recursively applies it to all children. Only necessary if using D3
    function applyD3DataRec(element) {
        var nodes = element.childNodes;
        var i;
        for (i in nodes) {
            nodes[i].__data__ = element.__data__;
            applyD3DataRec(nodes[i]);
        }
    }

    //Creates a new namespace from a string (ex "TAG.Layout.Catalog")
    function namespace(namespaceString) {
        var parts = namespaceString.split('.'),
        parent = window,
        currentPart = '';
         var k=0;
	if(parts[0] === 'TAG') {
	TAG = TAG || {};
	parent = TAG;
	k = 1;
	} else if (parts[0] === 'Worktop') {
	Worktop = Worktop || {};
	parent = Worktop;
	k = 1;
	}
 
	for (var i = k, length = parts.length; i < length; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }

        return parent;
    }

    //Takes an object of options and an object of defaults, and combines them without overwriting.
    function setToDefaults(options, defaults) {
        return $.extend({}, defaults, options);
    }

    /*
    Gets the maximum font size in em that fits into the specified width and height.
    The output is a string with 'em' at the end.

        text: The text to measure
        minFontSize: Minimum font size (in em, a number not a string).  The output will be no smaller than this value
        maxWidth: The maximum width the text should be.
        maxHeight: The maximum height the text should be.
        step: Optional.  The step to increment by when testing font size.
    */
    function getMaxFontSizeEM(text, minFontSize, maxWidth, maxHeight, step) {
        if (!text) {
            return;
        }
        var testDiv = $(document.createElement('div'));
        var tagContainer = $('#tagRoot');
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            'position': 'absolute',
            'visibility': 'hidden',
			'font-size': minFontSize + 'em',
            'height': 'auto',
            'width': 'auto',
        });

        testDiv.text(text);
        tagContainer.append(testDiv);

        if (testDiv.width() >= maxWidth || testDiv.height() >= maxHeight) {
            return minFontSize + 'em';
			//currSize = minFontSize;
			//testDiv.css('font-size', currSize + 'em');
        }

        while (testDiv.width() < maxWidth && testDiv.height() < maxHeight) {
            currSize += step;
            testDiv.css('font-size', currSize + 'em');
        }
        testDiv.remove();
        currSize -= step;
        return currSize + 'em';
    }

    /**
     *  get max font size without em
     * @method getMaxFontSize
     * @param {String} text       TODO FINISH DOCUMENTATION
     */
    function getMaxFontSize(text, minFontSize, maxWidth, maxHeight, step) {
        var testDiv = $(document.createElement('div'));
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            'position': 'absolute',
            'visibility': 'hidden',
            'height': 'auto',
            'width': 'auto',
            'font-size': minFontSize + 'em',
        });
        testDiv.text(text);
        $('body').append(testDiv);

        if (testDiv.width() >= maxWidth || testDiv.height() >= maxHeight) {
            return minFontSize;
        }

        while (testDiv.width() < maxWidth && testDiv.height() < maxHeight) {
            currSize += step;
            testDiv.css('font-size', currSize + 'em');
        }
        testDiv.remove();
        return currSize;
    }
	
	/*
		Gets the maximum font size without em.
	*/
	function getMaxFontSize(text, minFontSize, maxWidth, maxHeight, step) {
        if (!text) {
            return;
        }
        var testDiv = $(document.createElement('div'));
        var tagContainer = $('#tagRoot');
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            'position': 'absolute',
            'visibility': 'hidden',
			'font-size': minFontSize + 'em',
            'height': 'auto',
            'width': 'auto',
        });

        testDiv.text(text);
        tagContainer.append(testDiv);

        if (testDiv.width() >= maxWidth || testDiv.height() >= maxHeight) {
            return minFontSize + 'em';
			//currSize = minFontSize;
			//testDiv.css('font-size', currSize + 'em');
        }

        while (testDiv.width() < maxWidth && testDiv.height() < maxHeight) {
            currSize += step;
            testDiv.css('font-size', currSize + 'em');
        }
        testDiv.remove();
        return currSize;
    }

    //Shouldn't be public anymore, this is primarily used by makeManipulatable
    function getGestureRecognizer() {
        var gr = new Windows.UI.Input.GestureRecognizer();
        gr.gestureSettings = Windows.UI.Input.GestureSettings.manipulationRotate |
            Windows.UI.Input.GestureSettings.manipulationTranslateX |
            Windows.UI.Input.GestureSettings.manipulationTranslateY |
            Windows.UI.Input.GestureSettings.manipulationScale |
            Windows.UI.Input.GestureSettings.manipulationRotateInertia |
            Windows.UI.Input.GestureSettings.manipulationScaleInertia |
            Windows.UI.Input.GestureSettings.manipulationTranslateInertia |
            Windows.UI.Input.GestureSettings.hold |
            Windows.UI.Input.GestureSettings.holdWithMouse |
            Windows.UI.Input.GestureSettings.rightTap |
            Windows.UI.Input.GestureSettings.tap;
        return gr;
    }

    //Makes an xml request, and will actually get a modified document, because internet explorer (the
    //environment that metro apps run in) by default never retrieves a new xml document, even if the server's
    //version is new. This fixes that.
    function makeXmlRequest(url) {

        if(!url) {
            return;
        }

        var request = new XMLHttpRequest();
        request.open("GET", url, false);
        request.send(null);
        if (false && !request.getResponseHeader("Date")) { // TODO figure out why this causes network errors
            var cached = request;
            request = new XMLHttpRequest();
            var ifModifiedSince = cached.getResponseHeader("Last-Modified") || new Date(0); // January 1, 1970
            request.open("GET", url, false);
            request.setRequestHeader("If-Modified-Since", ifModifiedSince);
            request.send("");
            if (request.status === 304) {
                request = cached;
            }
        }
        return request;
    }

    // determine if element is in a doc
    function elementInDocument(element) {
        element = $(element)[0];
        while (element) {
            if (element === document) {
                return true;
            }
            element = element.parentNode;
        }
        return false;
    }

    //give it a jquery element and it will disable drag on the element, and drag events should propagate to parent element
    //still don't know where to put this function yet
    function disableDrag(element) {
        element.attr("ondragstart", "return false");
    }

    // dz - double-ended priority queue implementation using parallel min and max heap
    function createDoubleEndedPQ(minComparator, maxComparator) {
        return {
            // DEPQ built on a min-max heap pair
            _minComp: minComparator,
            _maxComp: maxComparator,
            
            _maxheap: new binaryHeap(maxComparator),
            _minheap: new binaryHeap(minComparator),
            
            // add
            //Input: Element to be added
            add: function (element) {
                this._maxheap.push(element);
                this._minheap.push(element); 
                return element;
            },

            //Output: Minimum element in minheap
            getMin: function () {
                return this._minheap.peek();
            },

            getMax: function() {
                return this._maxheap.peek();
            },

            removeMin: function () {
                return this._minheap.pop();
            },

            removeMax: function () {
                return this._maxheap.pop();
            },

            remove: function (node) {
                this._maxheap.remove(node);
                this._minheap.remove(node);
            },

            size: function() {
                return this._maxheap.size();
            },

            clear: function () {
                this._maxheap = new binaryHeap(this._maxComp);
                this._minheap = new binaryHeap(this._minComp);
            },

            find: function (node) {
                return this._maxheap.find(node)
            },
        }
    }
    that.createDoubleEndedPQ = createDoubleEndedPQ;

    //VERY important function. Will take an element and add multitouch/scale/etc events to it. And inertia.
    //Takes in a set of functions (onManipulate, onTapped, onScroll, onHolding)
    //onManipulate(result), result has pivot.x,.y ; translation.x,.y; rotation, scale
    //onScroll(delta,pivot) is the scroll wheel
    //onTapped
    //onHolding
    function makeManipulatable(element, functions, stopOutside, noAccel) {
        var hammer = new Hammer(element, {
            hold_threshold: 3,
            drag_min_distance: 9,
            drag_max_touches: 10,
            hold_timeout: 600,
            tap_max_distance: 15,
            doubletap_distance: 17,
            doubletap_interval: 400,
            swipe: false
        });

        var lastTouched = null,
            that = this,
            manipulating = false,
            isDown = false,
            $element = $(element);

        var lastPos = {},
            lastEvt,
            timer,
            currentAccelId = 0,
            lastScale = 1;

        // general event handler
        function manipulationHandler(evt) {
            var translation;
            if (evt.gesture) {
                // Update Dir, and set pivot rotation, and scale values
                getDir(evt, true);
                var pivot = { x: evt.gesture.center.pageX - $element.offset().left, y: evt.gesture.center.pageY - $element.offset().top };
                var rotation = evt.gesture.rotation; // In degrees
                if (!lastPos.x && lastPos.x !== 0) {
                    translation = { x: evt.gesture.deltaX, y: evt.gesture.deltaY };
                } else {
                    translation = { x: evt.gesture.center.pageX - lastPos.x, y: evt.gesture.center.pageY - lastPos.y };
                }
                var scale = evt.gesture.scale - lastScale;
                // Previous values
                lastScale = evt.gesture.scale;
                lastPos.x = evt.gesture.center.pageX;
                lastPos.y = evt.gesture.center.pageY;
                lastEvt = evt;
                if (typeof functions.onManipulate === "function") {
                    functions.onManipulate({ 
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: 1 + scale,
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent
                    }, evt);
                };
                clearTimeout(timer);
                timer = setTimeout(function () {
                    var dir = getDir(evt);
                    if (evt.gesture.pointerType !== "mouse" && !noAccel)
                        accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
                }, 5);
                //if ((evt.type === "pinch" || evt.type === "pinchin" || evt.type === "pinchout") && typeof functions.onScroll === "function")
                //    functions.onScroll(1 + scale, pivot);
            } else {
                // Update Dir
                getDir(evt, true);
                var pivot = { x: evt.pageX - $element.offset().left, y: evt.pageY - $element.offset().top };
                // var rotation = evt.gesture.rotation; // In degrees // Don't need rotation...
                if (false && !lastPos.x && lastPos.x !== 0) { // TODO need this?
                    translation = { x: evt.gesture.deltaX, y: evt.gesture.deltaY };
                } else {
                    translation = { x: evt.pageX - lastPos.x, y: evt.pageY - lastPos.y };
                    console.log('translation.y = '+translation.y);
                }
                var scale = evt.gesture.scale - lastScale; /////////////////// HEREHEHEHEHEHRHERIEREIRHER ///
                lastScale = evt.gesture.scale;
                lastPos.x = evt.pageX;
                lastPos.y = evt.pageY;
                lastEvt = evt;

                if (typeof functions.onManipulate === "function") {
                    functions.onManipulate({ 
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: 1 + scale,
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent
                    }, evt);
                };

                clearTimeout(timer);
                timer = setTimeout(function () {
                    var dir = getDir(evt);
                    if (evt.gesture.pointerType !== "mouse" && !noAccel)
                        accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
                }, 5);
            }
        }


        function processPinch(evt) {
            var pivot = { x: evt.gesture.center.pageX - $element.offset().left, y: evt.gesture.center.pageY - $element.offset().top };
            var scale = evt.gesture.scale - lastScale;
            var rotation = evt.gesture.rotation; // In degrees
            var translation;
            if (!lastPos.x && lastPos.x !== 0) {
                translation = { x: 0, y: 0};
            } else {
                translation = { x: evt.gesture.center.pageX - lastPos.x, y: evt.gesture.center.pageY - lastPos.y };
            }
            lastPos.x = evt.gesture.center.pageX;
            lastPos.y = evt.gesture.center.pageY;
            getDir(evt, true);
            if (scale !== lastScale && typeof functions.onScroll === "function")
                functions.onScroll(1 + scale, pivot);

            if (typeof functions.onManipulate === "function")
                functions.onManipulate({                     
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent,
                        scale: 1 
                    }, evt);
            lastScale = evt.gesture.scale;
        }

        // mousedown
        var dragStart;
        function processDown(evt) {
            lastScale = 1;
            isDown = true;
            dragStart = evt.gesture.center;
            lastEvt = null;
            lastTouched = evt.srcElement;
            currentAccelId++;
            resetDir();
            clearTimeout(timer);
            //manipulationHandler(evt);
        }

        // mouse move
        function processMove(evt) {
            manipulationHandler(evt);
        }

        // requestAnimationFrame polyfill by Erik Möller
        // fixes from Paul Irish and Tino Zijdel
        (function () {
            var lastTime = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
            }

            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function (callback, element) {
                    var currTime = Date.now();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                      timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };

            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function (id) {
                    clearTimeout(id);
                };
        }());

        function accel(vx, vy, delay, id) {
            if (!lastEvt) return;
            if (currentAccelId !== id) return;
            if (Math.abs(vx) <= 4 && Math.abs(vy) <= 4) {
                return;
            }
            var offset = $element.offset();
            delay = delay || 5;
            var pivot = { x: lastEvt.gesture.center.pageX - offset.left, y: lastEvt.gesture.center.pageY - offset.top };
            var rotation = 0; // In degrees
            var translation = { x: vx, y: vy };
            var scale = 1;
            if (typeof functions.onManipulate === "function")
                functions.onManipulate({ 

                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: scale

                 }, lastEvt);

            timer = setTimeout(function () {
                accel(vx * 0.95, vy * 0.95, delay, id);
            }, delay);
            //timer = window.requestAnimationFrame(accel(vx * .95, vy * .95, delay, id), $element);
        }

        // mouse release
        function processUp(evt) {
            //evt.stopPropagation();
            isDown = false;
            lastPos = {};
            var dir = getDir(evt);
            if (evt.gesture.pointerType === "mouse" && !noAccel)
                accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
            if (typeof functions.onRelease === "function")
                functions.onRelease(evt);

            //var dir = getDir(evt);
            //resetDir();
            //setTimeout(function () {
                //accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
            //}, 1);
            //accel(30 * evt.gesture.velocityX * (evt.gesture.center.pageX > dragStart.pageX ? 1 : -1),//(Math.abs(evt.gesture.angle) < 90 ? 1 : -1),
            //    30 * evt.gesture.velocityY * (evt.gesture.center.pageY > dragStart.pageY ? 1 : -1));//evt.gesture.angle / Math.abs(evt.gesture.angle));
        }

        var firstEvtX, firstEvtY, changeX, changeY, prevEvt;
        function resetDir() {
            firstEvtX = null;
            firstEvtY = null;
            changeX = 0;
            changeY = 0;
            prevEvt = null;
        }

        function getDir(evt, noReturn) {
            if (!firstEvtX) {
                firstEvtX = evt;
                firstEvtX.currentDir = firstEvtX.gesture.deltaX / Math.abs(firstEvtX.gesture.deltaX) || 0;
                if (!prevEvt) {
                    prevEvt = evt;
                    return { vx: 0, vy: 0 };
                }
            } else {
                if (evt.gesture.deltaX > prevEvt.gesture.deltaX && firstEvtX.currentDir !== 1) {
                    firstEvtX = evt;
                    firstEvtX.currentDir = 1;
                } else if (evt.gesture.deltaX < prevEvt.gesture.deltaX && firstEvtX.currentDir !== -1) {
                    firstEvtX = evt;
                    firstEvtX.currentDir = -1;
                }
            }
            if (!firstEvtY) {
                firstEvtY = evt;
                firstEvtY.currentDir = firstEvtY.gesture.deltaY / Math.abs(firstEvtY.gesture.deltaY) || 0;
            } else {
                if (evt.gesture.deltaY > prevEvt.gesture.deltaY && firstEvtY.currentDir !== 1) {
                    firstEvtY = evt;
                    //console.log("firstEvtY SETB");
                    firstEvtY.currentDir = 1;
                } else if (evt.gesture.deltaY < prevEvt.gesture.deltaY && firstEvtY.currentDir !== -1) {
                    firstEvtY = evt;
                    //console.log("firstEvtY SETC");
                    firstEvtY.currentDir = -1;
                }
            }
            prevEvt = evt;
            if (!noReturn) {
                return {
                    vx: ((evt.gesture.deltaX - firstEvtX.gesture.deltaX) / (evt.gesture.timeStamp - firstEvtX.gesture.timeStamp)) || 0,
                    vy: ((evt.gesture.deltaY - firstEvtY.gesture.deltaY) / (evt.gesture.timeStamp - firstEvtY.gesture.timeStamp)) || 0,
                };
            }
        }
        function processScrollFirefox(evt) {
                // console.log("capturing wheel events");
                var pivot = { x: evt.clientX - $element.offset().left, y: evt.clientY - $element.offset().top };
                console.log(evt.detail);
                var delta = -evt.detail;
                
                //delta = delta * 1.1;
                /*
                if (delta < 0) { 
                    console.log("here; " + delta);
                    delta = 1.0 / 1.1;
                } else { 
                    console.log("there; " + delta);
                    delta = 1.1;
                }
                */
				if (delta < 0) delta = 1.0 / 1.1;
            	else delta = 1.1;
				console.log("delta processed " + delta);
                evt.cancelBubble = true;
                if (typeof functions.onScroll === "function") { 
                    functions.onScroll(delta, pivot);
                }
         }
        // scroll wheel
        function processScroll(evt) {
            var pivot = { x: evt.x - $element.offset().left, y: evt.y - $element.offset().top };
            var delta = evt.wheelDelta;
            if (evt.wheelDelta < 0) delta = 1.0 / 1.1;
            else delta = 1.1;
            evt.cancelBubble = true;
            if (typeof functions.onScroll === "function") functions.onScroll(delta, pivot);
        }

        hammer.on('touch', processDown);
        hammer.on('drag', function(evt){
            processMove(evt);
        });
        hammer.on('pinch', processPinch);
        hammer.on('release', processUp);
        element.onmousewheel = processScroll;
        element.addEventListener("DOMMouseScroll", processScrollFirefox);

        // double tap
        var doubleTappedHandler, event;
        if (typeof functions.onDoubleTapped === "function") {
            doubleTappedHandler = function (evt) {
                if (evt.gesture.srcEvent.button > 0 || evt.gesture.srcEvent.buttons == 2) {
                    return;
                }
                event = {};
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onDoubleTapped(event);
            };
            hammer.on('doubletap', doubleTappedHandler);
        }

        // short tap, i.e. left-click
        var tappedHandler = null;
        if (typeof functions.onTapped === "function") {
            tappedHandler = function (evt) {
                if (evt.gesture.srcEvent.button > 0) {
                    evt.stopPropagation();
                    event = {};
                    event.gesture = evt.gesture;
                    event.position = {};
                    event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                    event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                    if (functions.onTappedRight) {
                        functions.onTappedRight(event);
                    }
                    return;
                }
                event = {};
                event.position = {};
                event.button = evt.button;
                event.gesture = evt.gesture;
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onTapped(event);
            };
            hammer.on('tap', tappedHandler);
            //gr.addEventListener('tapped', tappedHandler);
        }

        var releasedHandler = null;
        if (typeof functions.onRelease === "function") {
            releasedHandler = function (evt) {
                event = {};
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onRelease(event);
            };
            hammer.on('release', releasedHandler);
        }

        //var debugLog = function(evt) {
        //    console.log(evt.type);
        //}

        //hammer.on('release hold tap touch drag doubletap', debugLog);

        // long-press, i.e. right-click
        var holdHandler = null;
        var rightClickHandler = null;
        var stopNextClick = false;
        if (typeof functions.onTappedRight === "function") {
            holdHandler = function (evt) {
                evt.stopPropagation();
                stopNextClick = true;
                event = {};
                event.gesture = evt.gesture;
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $element.offset().left;
                event.position.y = evt.gesture.center.pageY - $element.offset().top;
                functions.onTappedRight(event);
            };
            rightClickHandler = function (evt) {
                evt.stopPropagation();
                event = {};
                event.button = evt.button;
                event.gesture = evt.gesture;
                event.position = {};
                event.position.x = evt.pageX - $element.offset().left;
                event.position.y = evt.pageY - $element.offset().top;
                functions.onTappedRight(event);
            };
            element.addEventListener("MSPointerEvent", function (evt) {
                console.log(evt);
                if (stopNextClick) {
                    console.log("STOPPING CLICK");
                    evt.stopPropagation();
                    setTimeout(function () {
                        stopNextClick = false;
                    }, 1);
                    return;
                }
            }, true);
            element.addEventListener("mouseup", function (evt) {
                console.log("CLICK");
                if (stopNextClick) {
                    console.log("STOPPING CLICK");
                    evt.stopPropagation();
                    setTimeout(function () {
                        stopNextClick = false;
                    }, 1);
                    return;
                }
                if (evt.button === 2) {
                    rightClickHandler(evt);
                }

            }, true);

            hammer.on('hold', holdHandler);
        }

        return {
            cancelAccel: function () {
                currentAccelId++;
                clearTimeout(timer);
            }
        };
        
        //return gr;
    }

    //VERY important function. Will take an element and add multitouch/scale/etc events to it. And inertia.
    //Takes in a set of functions (onManipulate, onTapped, onScroll, onHolding)
    //onManipulate(result), result has pivot.x,.y ; translation.x,.y; rotation, scale
    //onScroll(delta,pivot) is the scroll wheel
    //onTapped
    //onHolding
    function makeManipulatableWin(element, functions, stopOutside) {

        var lastTouched = null;
        var that = this;
        var gr = TAG.Util.getGestureRecognizer();
        var manipulating = false;

        // general event handler
        function manipulationHandlerWin(evt) {
            if (evt.delta) {
                var pivot = { x: evt.position.x, y: evt.position.y };
                var rotation = evt.delta.rotation / 180 * Math.PI;
                var translation = { x: evt.delta.translation.x, y: evt.delta.translation.y };
                var scale = evt.delta.scale;
                //evt.target.autoProcessInertia = false;
                if (typeof functions.onManipulate === "function") {
                    if (evt.gesture) {
                        functions.onManipulate({
                            pivot: pivot,
                            translation: translation,
                            rotation: rotation,
                            target: evt.gesture.target,
                            touches: evt.gesture.touches,
                            pointerType: evt.gesture.pointerType,
                            center: evt.gesture.center,
                            deltaTime: evt.gesture.deltaTime,
                            deltaX: evt.gesture.deltaX,
                            deltaY: evt.gesture.deltaY,
                            velocityX: evt.gesture.velocityX,
                            velocityY: evt.gesture.velocityY,
                            angle: evt.gesture.angle,
                            direction: evt.gesture.direction,
                            distance: evt.gesture.distance,
                            eventType: evt.gesture.eventType,
                            srcEvent: evt.gesture.srcEvent,
                            startEvent: evt.gesture.startEvent,
                            scale: scale
                        });
                    } else {
                        functions.onManipulate({
                            pivot: pivot,
                            translation: translation,
                            rotation: rotation,
                            scale: scale,
                            grEvent: evt
                        });
                    }
                }
             }
        }

        function isManipulatingWin() { return manipulating; }

        // mousedown
        function processDownWin(evt) {
            lastTouched = evt.srcElement;
            var pp = evt.currentPoint;
            try {
                gr.processDownEvent(pp);
                element.msSetPointerCapture(evt.pointerId);

                evt.cancelBubble = true;
            }
            catch (err) {
                var message = err.message;
            }
        }

        // mouse move
        function processMoveWin(evt) {
            if (stopOutside) {
               if (evt.x < 0 || evt.y < 0 || evt.x > $(element).width() || evt.y > $(element).height()) {
                    return;
                }
            }
            var pps = evt.intermediatePoints;
            try {
                gr.processMoveEvents(pps);
            }
            catch (err) {
                var message = err.message;
            }
        }

        // mouse release
        function processUpWin(evt) {
            var pp = evt.currentPoint;
            try {
                gr.processUpEvent(pp);
            }
            catch (err) {
                var message = err.message;
            }
        }

        // scroll wheel
        function processScrollWin(evt) {
            var pivot = { x: evt.x, y: evt.y };
            var delta = evt.wheelDelta;
            if (evt.wheelDelta < 0) delta = 1.0 / 1.1;
            else delta = 1.1;
            evt.cancelBubble = true;
            if (typeof functions.onScroll === "function") functions.onScroll(delta, pivot);
        }

        element.addEventListener('MSPointerDown', processDownWin, false);
        element.addEventListener('MSPointerMove', processMoveWin, false);
        element.addEventListener('MSPointerUp', processUpWin, false);
        element.onmousewheel = processScrollWin;

        // start capturing manip
        function manipulationStartedHandlerWin(evt) {
            manipulating = true;
            manipulationHandlerWin(evt);
        }
        gr.addEventListener('manipulationstarted', manipulationStartedHandlerWin);

        // react to changes
        function manipulationDeltaHandlerWin(evt) {
            manipulationHandlerWin(evt);
        }
        gr.addEventListener('manipulationupdated', manipulationDeltaHandlerWin);

        // react to conclusion of manip
        function manipulationEndHandlerWin(evt) {
            manipulating = false;
            manipulationHandlerWin(evt);
        }
        gr.addEventListener('manipulationcompleted', manipulationEndHandlerWin);

        // short tap, i.e. left-click
        var tappedHandlerWin = null;
        if (typeof functions.onTapped === "function") {
            tappedHandlerWin = function(evt) {
                var event = {};
                event.position = {};
                if (evt.position.x < 50) {
                    event.position.x = $(lastTouched).offset().left - $(element).offset().left + evt.position.x;
                } else {
                    event.position.x = evt.position.x;
                }
                event.position.y = $(lastTouched).offset().top - $(element).offset().top + evt.position.y;
                functions.onTapped(event);
            };
            gr.addEventListener('tapped', tappedHandlerWin);
        }

        // long-press, i.e. right-click
        var rightTapHandlerWin = null;
        if (typeof functions.onTappedRight === "function") {
            rightTapHandlerWin = function (evt) {
                var event = {};
                event.position = {};
                event.position.x = evt.position.x;
                event.position.y = evt.position.y;
                functions.onTappedRight(event);
            };
            gr.addEventListener('righttapped', rightTapHandlerWin);
        }
        
        return gr;
    }

    function htmlEntityEncode(str) {
        /*try {
            return str ? $('<div />').text(encodeURIComponent(str).html()) : '';
        } catch (e){
            //use our deprecated function for now if error thrown
            return encodeXML(str);
        }*/
        
        encodeText(str || "");
        return str || "";
    }

    function htmlEntityDecode(str) {
        /*try {
            return str ? decodeURIComponent($('<div />').html(str).text()) : '';
        } catch (e) {
            return str ? unescape($('<div />').html(str).text()) : '';
        }*/
        return str || "";
    }

    /**
    function to check if the videos have been converted.
    Also, show the display in the track after conversion is done
    @param: an array of video tracks to convert.
    */
    function checkVideoConverted4Track(videos2Convert) {
        if (videos2Convert.length > 0) {
            for (var i = 0; i < videos2Convert.length; i++) {
                var track = videos2Convert[i];
                var media = track.getMedia();
                var videotag = $(document.createElement('video'));
                videotag.attr('preload', 'metadata');
                var filename = media.slice(8, media.length);//get rid of /Images/ before the filename
                TAG.Worktop.Database.getConvertedCheck(
                    (function (i, track, media, videotag) {
                        return function (output) {
                            if (output !== "False") {
                                console.log("converted/ or not being written now");
                                var mp4filepath = "/Images/" + output.substr(0, output.lastIndexOf('.')) + ".mp4";
                                var mp4file = TAG.Worktop.Database.fixPath(mp4filepath);
                                videotag.attr('src', mp4file);
                                videotag.on('loadedmetadata', function () {
                                    //remove from the video array and add display with the right duration
                                    track.changeTrackColor('white');
                                    track.videoConverted(true);
                                    track.addDisplay(0, this.duration);
                                    videos2Convert.remove(track);
                                });

                            } else {
                                console.log("not converted: ");
                            }
                        }
                    })(i, track, media, videotag), null, filename);
            }
        }
    }

    /*create video conversion loading message and circle for 
	  when imported videos are converting
	  O/P: the div containing the loading circle and message*/
    function createConversionLoading(msg, nocircle, isMp4) {
        var container = $(document.createElement('div'));
        container.attr('id', 'leftLoading');
        container.css({
            'position': 'absolute',
            'width': '80%',
            'left': '10%',
            'top': '40%',
            'color': 'white',
            'text-align': 'center',
        });
        
        var label = $(document.createElement('label'));
        label.text(msg);
        label.css({
            'height': '50%',
            'width': '50%',
            'font-size': '250%'
        });
        if (isMp4) {
            container.css({
                'top': '1%',
            });
            label.css('background-color','black');
        }
        if (!nocircle) {
            var circle = $(document.createElement('img'));
            circle.attr('src', tagPath + 'images/icons/progress-circle.gif');
            circle.css({
                'height': '50px',
                'width': 'auto',
                'left': '45%',
                display: 'block',
                position: 'relative',
                'top': '30%',
                'margin-bottom':'5%'
            });
            if (isMp4) {
                circle.css({
                    'height':'25px',
                    'top': '1%',
                    //'left':'',
                })
            }
            container.append(circle);
        }
        container.append(label);
        return container;
    }
    // sets up error handler for a video element
    // container is the div we'll append error messages to
    function videoErrorHandler(videoElt, container, conversionFlag) {
        return function (err) {
            var msg = "";
            switch (err.target.error.code) {
                case err.target.error.MEDIA_ERR_ABORTED:
                    msg = "Video playback aborted. Please see FAQs on the TAG website.";
                    break;
                case err.target.error.MEDIA_ERR_NETWORK:
                    msg = "Network error during video upload. Please see FAQs on the TAG website.";
                    break;
                case err.target.error.MEDIA_ERR_DECODE:
                    msg = "Error decoding video. Please see FAQs on the TAG website.";
                    break;
                case err.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    if (conversionFlag && conversionFlag === "False") {
                        //var loadingContainer = createConversionLoading();
                        msg = "This video is being converted to compatible formats for different browsers";
                        //container.append(createConversionLoading(msg));
                        //} else if (!conversionFlag) {
                        //msg = "The video format is not supported.";
                        //container.append(createConversionLoading(msg));
                    } else {
                        msg = "Either the video format is not supported or a network or server error occurred. Please see FAQs on the TAG website.";
                    }
                    break;
                default:
                    msg = "Error: please see FAQs on the TAG website.";
                    break;
            }
            $("#videoErrorMsg").remove();
            $("#leftLoading").remove();
            if (conversionFlag && conversionFlag === "False") {
                container.append(createConversionLoading(msg));
            } else if (!document.getElementById("leftLoading")) {
                //if (conversionFlag==="True") { //&& conversionFlag === "True"
                var msgdiv = $(document.createElement('div'));
                msgdiv.attr("id", "videoErrorMsg");
                msgdiv.css({
                    'position': 'absolute',
                    'width': '80%',
                    'left': '10%',
                    'top': '50%',
                    'color': 'white',
                    'text-align': 'center',
                    'font-size': TAG.Util.getMaxFontSizeEM(msg, 2, container.width() * 0.8, container.height() * 0.2, 0.1)
                });
                msgdiv.text(msg);
                container.append(msgdiv);
            }
            videoElt.hide();

            videoElt[0].onerror = function (err) { };// get rid of the error handler afterwards
        }
    }
    /**
     * Used by web app code to slide in pages given their html files
     * @param path     the path to the html file within the html directory
     */
    function getHtmlAjax(path) {
        var ret;
        $.ajax({
            async: false,
            cache: false,
            url: path.match(/\//) ? path : tagPath+"html/"+path,
            success: function (data) {
                ret = data;
            },
            error: function (err) {
                console.log("url = " + path);
                console.log("error: "+err.statusText);
                ret = null;
            },
            dataType: 'html'
        });
        return ret ? (IS_WINDOWS ? $(toStaticHTML(ret)) : $(ret)) :  '';
    }

     /**
     * @param collectionId      the id of the collection whose local visibility we want to check or set
     * @param setValue          falsy if just want to return visibility status
     *                          {visible: true}  if we want to set collection to be locally visible
     *                          {visible: false} if we want to hide the collection locally
     */
    function localVisibility(collectionId, setValue) {
        localStorage.invisibleCollectionsTAG = localStorage.invisibleCollectionsTAG || '[]';
        var tempList, index;
        try {
            tempList = JSON.parse(localStorage.invisibleCollectionsTAG);
        } catch (err) {
            localStorage.invisibleCollectionsTAG = '[]';
            tempList = [];
        }
        index = tempList.indexOf(collectionId);
        if (setValue && setValue.visible) {
            index >= 0 && tempList.splice(index, 1);
        } else if (setValue && setValue.hasOwnProperty('visible')) {
            index === -1 && tempList.push(collectionId);
        } else {
            return index >= 0 ? false : true;
        }
        localStorage.invisibleCollectionsTAG = JSON.stringify(tempList);
    }

    /**
     * Take in a color and return a dimmed version of that color (divide rgb by k)
     * @param {String} inColor      input color as a hex string
     * @param {Number} k            dimming factor
     * @return {String}             formatted as 'rbg(_,_,_)'
     */
    function dimColor(inColor, k) {
        var r,
            g,
            b;

        k = k || 3;

        inColor = inColor.replace(/\#/g, '');
        inColor = inColor.substring(0, 6);

        r = Math.round(parseInt(inColor.substring(0, 2), 16) / k);
        g = Math.round(parseInt(inColor.substring(2, 4), 16) / k);
        b = Math.round(parseInt(inColor.substring(4, 6), 16) / k);

        return 'rgb(' + r + ',' + g+ ',' + b + ')';
    }

    /**
     * Take in a color (in '#abcdef' format) and an opacity (0-1) and return an rgba(..) string
     * @param {String} color       input color as a hex string
     * @param {String} opac        input opacity
     * @return {String}            'rgba(color.r, color.g, color.b, opac)'
     */
    function hexToRGBA(color, opac) {
        var r, g, b;

        color = color.replace(/\#/g, '');
        color = color.substring(0, 6);

        r = parseInt(color.substring(0, 2), 16);
        g = parseInt(color.substring(2, 4), 16);
        b = parseInt(color.substring(4, 6), 16);

        return 'rgba(' + r + ',' + g + ',' + b + ',' + opac + ')';
    }

    /***
    * Create the tutorial popup for the collections page
    *@method createTutorialPopup
    */

    function createTutorialPopup() {
        var tagContainer = $('#tagRoot');
        var infoOverlay = $(TAG.Util.UI.blockInteractionOverlay());
        var infoBox = $(document.createElement('div')).addClass('infoBox');
        var infoMain = $(document.createElement('div')).addClass('infoMain');
        var infoTitle = $(document.createElement('div')).addClass('infoTitle');
        var closeButton = createCloseButton().addClass('closeButton');

        function createCloseButton() {
            var closeButton = $(document.createElement('img'));
            closeButton.attr('src', tagPath + 'images/icons/x.svg');
            closeButton.text('X');
            closeButton.css({
                'height': '3%',
                'width': '3%',
                'margin-left': '39%',
                'margin-bottom': '3.5%'
            });
            return closeButton;
        }

        infoBox.css({
            'background-color': 'black',
            'color': 'white',
            'height': '55%',
            'width': '50%',
            'margin-top': '15%',
            'margin-left': '25%',
        });

        infoTitle.css({
            'padding-top': '5%',
            'padding-left': '8%',
            'padding-right': '8%',
            'background-color': 'black',
            'display': 'block',
            'color': 'white',
            'border-top-left-radius': '3.5px',
            'border-top-right-radius': '3.5px',
            'font-size': '1.5em'
        }).text('Welcome to Touch Art Gallery');

            infoMain.css({
                'background-color': 'black',
                'display': 'block',
                'color': 'white',
                'font-size': '0.75em',
                'margin-left': '8%',
                'margin-top': '4%',
                'margin-right': '8%'
            });

            closeButton.css({
                'height': '4%',
                'width': '4%',
                'min-height': '20px',
                'min-width': '20px',
                'margin-left': '0%',
                'margin-bottom': '0%',
                'margin-top': '1%',
                'margin-right': '1%',
                'top': '0%',
                'display': 'block',
                'float': 'right'
            });

            infoBox.append(closeButton);
            infoBox.append(infoTitle);

            function createDivWithLabel(text, src) {
                var section = $(document.createElement('div'))
                    .addClass('infoSection')
                    .css({
                        'display': 'block',
                        'position': 'relative',
                        'width': '100%',
                        'min-height': '1.5%',
                        'max-height': '4%',
                        'padding-bottom': '1.5%',
                    })
                if (src) {
                    var imgholder = $(document.createElement('div'))
                        .addClass('infoSectionIconHolder')
                        .css({
                            'display': 'inline-block',
                            'position': 'absolute',
                            //'padding-top':'1%',
                            'height': '80%',
                            'width': '10%',
                            'left': '0%',
                            'top': '0%',
                            'text-align': 'center',
                            'vertical-align': 'middle'
                        });
                    imgholder.append(
                        $(document.createElement('img'))
                        .addClass('infoSectionIcon')
                        .attr('src', src)
                        .css({
                            'display': 'block',
                            'position': 'absolute',
                            'vertical-align': 'middle',
                            'width': '100%',
                            'max-width': '45px',
                            'height': 'auto',
                            'max-height': '45px'/*
                        bottom: '0px',
                        display: 'block',
                        height: '100%',
                        left: '0px',
                        'margin-bottom': 'auto',
                        'margin-left': 'auto',
                        'margin-right': 'auto',
                        'margin-top': 'auto',
                        'max-height': '80%',
                        'max-width': '80%',
                        position: 'absolute',
                        right: '0px',
                        top: '0px',
                        width: 'auto',*/
                        })
                    );
                    section.append(imgholder);
                }
                section.append(
                    $(document.createElement('div'))
                    .addClass('infoSectionText')
                    .text(text)
                    .css({
                        'display': 'inline-block',
                        'position': 'relative',
                        'width': src ? '85%' : '100%',
                        'left': src ? '12%' : '0%'
                    })
                );
                infoMain.append(section);
            }

            createDivWithLabel("Click or tap on a tile to preview the item it represents, and click/tap on its thumbnail again to begin exploring it in full.");
            createDivWithLabel("Tiles without icons are image artworks. Any media associated with the artwork will appear below the artwork in the previewer. You can explore the artwork with a specific media item by tapping on the item's thumbnail image.")
            createDivWithLabel("Tiles with the play icon represent video artworks. Click or tap on the tile to view them in the video player.", tagPath + 'images/video_icon.svg');
            createDivWithLabel("Tiles with this icon represent interactive tours. Click or tap on the tile to open them in the tour player. Tours are like video narratives, but can be paused at any time via the controls, or by tapping anywhere in the player. While paused, you can freely manipulate all items that are currently onscreen.", tagPath + 'images/tour_icon.svg');

        infoBox.append(infoMain);

        infoOverlay.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);
        infoOverlay.append(infoBox);

        closeButton.on('mousedown', function () {
            infoOverlay.fadeOut();
        });

        tagContainer.append(infoOverlay);
        infoOverlay.fadeIn();

    }



})();

/**
 * Utils for Animation, splitscreen, colors and the like
 */
TAG.Util.UI = (function () {
    "use strict";

    var PICKER_SEARCH_TEXT = 'Search by Name, Artist, or Year...';
    var IGNORE_IN_SEARCH = ['visible', 'exhibits', 'selected', 'guid', 'url', 'comp'];
    var recentlyAssociated = []; // recently associated media
    var recentlyAssociatedGUIDs = []; // to more easily check if a media has been associated recently
    var tagContainerId = 'tagRoot'; // TODO more general
    var globalKeyHandler = [];


    return {
        slidePageLeftSplit: slidePageLeftSplit,
        slidePageRightSplit: slidePageRightSplit,
        slidePageLeft: slidePageLeft,
        slidePageRight: slidePageRight,
        hexToR: hexToR,
        hexToG: hexToG,
        hexToB: hexToB,
        hexToRGB: hexToRGB,
        hexToRGBA: hexToRGBA,
        colorToHex: colorToHex,
        dimColor: dimColor,
        fitTextInDiv: fitTextInDiv,
        drawPushpins: drawPushpins,
        addPushpinToLoc: addPushpinToLoc,
        getLocationList: getLocationList,
        popUpMessage: popUpMessage,
        PopUpConfirmation: PopUpConfirmation,
        popupInputBox: popupInputBox,
        cgBackColor: cgBackColor,
        setUpBackButton: setUpBackButton,
        blockInteractionOverlay: blockInteractionOverlay,
        FeedbackBox: FeedbackBox,
        ChangeServerDialog: ChangeServerDialog,
        createAssociationPicker: createAssociationPicker,
        getRecentlyAssociated: getRecentlyAssociated,
        createCirc: createCirc,
        createLine: createVertLine,
        createKeyframe: createKeyframe,
        createDisplay: createDisplay,
        createTrack: createTrack,
        getStack: getStack,
        initKeyHandler: initKeyHandler,
        keyHandler: keyHandler,
        showPageLink: showPageLink
    };

    //initKeyHandler();

    function initKeyHandler() {
        window.focus();
        window.addEventListener('keydown', keyHandler);
    }

    /**The key handling event function
     * @method keyHandler
     * @param {Event} event     // the event triggered on key presses
     */
    function keyHandler(event) {
        event.stopPropagation();        
        if (globalKeyHandler && globalKeyHandler[0] && globalKeyHandler[0][event.which]) {
            globalKeyHandler[0][event.which](event);
        }
      }

    function getStack() {
        return globalKeyHandler;
    }

    function createTrack(specs) {
        // TODO if necessary
    }

    function createDisplay(specs) {
        var inRect, mainRect, outRect, inHandle, outHandle;
        var x = specs.x,
            fadeIn = specs.fadeIn,
            fadeOut = specs.fadeOut,
            mainLength = specs.mainLength,
            fadeColor = specs.fadeColor || '#ff7700',
            mainColor = specs.mainColor || '#81ad62',
            height = specs.height || '100%',
            container = specs.container;

        // fade in rectangle
        inRect = $(document.createElement('div'));
        inRect.addClass('inRect');
        inRect.css({
            'position': 'absolute',
            'left': x + "px",
            'top': '0px',
            'width': fadeIn + "px",
            'height': height,
            'border-left': '1px solid black',
            'border-right': '1px solid black',
            'background': 'linear-gradient(to right,white, ' + mainColor + ')' // DO FADE GRADIENT
        });

        // main rectangle
        mainRect = $(document.createElement('div'));
        mainRect.addClass('mainRect');
        mainRect.css({
            'position': 'absolute',
            'left': (x+fadeIn) + "px",
            'top': '0px',
            'width': mainLength + "px",
            'height': height,
            'background-color': mainColor
        });

        // fade out rectangle
        outRect = $(document.createElement('div'));
        outRect.addClass('outRect');
        outRect.css({
            'position': 'absolute',
            'left': (x+fadeIn+mainLength) + "px",
            'top': '0px',
            'width': fadeOut + "px",
            'height': height,
            'border-left': '1px solid black',
            'border-right': '1px solid black',
            'background': 'linear-gradient(to right, '+ mainColor + ',white)' // DO FADE GRADIENT
        });

        // fade in handle
        inHandle = createCirc(x, 48, 15, 5, '#000000', '#ffffff');
        inHandle.addClass('inHandle');

        // fade out handle
        outHandle = createCirc(x + mainLength + fadeIn + fadeOut, 48, 15, 5, '#000000', '#ffffff');
        outHandle.addClass('outHandle');

        container && container.append(mainRect).append(inRect).append(outRect).append(inHandle).append(outHandle);

        return { inRect: inRect, mainRect: mainRect, outRect: outRect, inHandle: inHandle, outHandle: outHandle };
    }

    function createKeyframe(specs) {
        var x=specs.x,
            y=specs.y || 48,
            container=specs.container;
        var line = createVertLine(x);
        line.addClass('keyframeLine');
        var circ = createCirc(x, y);
        circ.addClass('keyframeCirc');
        var innerCirc = createCirc(x, y, 17, 0, '#ff0000', '#ffffff');
        line.css('z-index', 2);
        circ.css('z-index', 3);
        innerCirc.css('z-index', 3);
        innerCirc.addClass('keyframeInnerCirc');
        container && container.append(line);
        container && container.append(circ);
        container && container.append(innerCirc);
        return { line: line, circ: circ, innerCirc: innerCirc };
    }

    function createCirc(cx, cy, radius, strokeW, strokeColor, fillColor) {
        var circ = $(document.createElement('div'));
        radius = radius || 21;
        strokeW = (strokeW === 0 || strokeW) ? strokeW : 5;
        strokeColor = strokeColor || "#296b2f";
        fillColor = fillColor || "#ffffff";
        circ.css({
            'border': strokeW + "px solid " + strokeColor,
            '-webkit-border-radius': (2 * radius) + "px",
            '-moz-border-radius':(2*radius)+"px",
            'border-radius': (2 * radius) + "px",
            'width': (2 * radius) + "px",
            'height': (2 * radius) + "px",
            'background-color': fillColor,
            'position': 'absolute',
            'left':(cx-radius-strokeW)+"px",
            'top': (cy - radius - strokeW) + "px",
        });
        return circ;
    }

    function createVertLine(x, width, color) {
        var line = $(document.createElement('div'));
        width = width || 3;
        color = color || "#296b2f";
        line.css({
            'width': width + "px",
            'height': "100%",
            'background-color': color,
            'position': 'absolute',
            'left': (x-width/2) + "px",
            'top': "0px"
        });
        return line;
    }

    function ChangeServerDialog() {
        var serverDialogOverlay = $(document.createElement('div'));
        var old_ip = localStorage.ip;
        var tagContainer = $('#tagRoot');
        serverDialogOverlay.attr('id', 'serverDialogOverlay');
        
        serverDialogOverlay.css({
            display: 'block',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'background-color': 'rgba(0,0,0,0.6)',
            'z-index': 1000000000 + 5
        });

        // dialog box for server changes
        var serverDialog = $(document.createElement('div'));
        serverDialog.attr('id', 'serverDialog');

        //

        var serverDialogSpecs = TAG.Util.constrainAndPosition($(tagContainer).width(), $(tagContainer).height(),
        {
            center_h: true,
            center_v: true,
            width: 0.5,
            height: 0.35,
            max_width: 560,
            max_height: 230
        });
        serverDialog.css({
            position: 'absolute',
            left: '30%',//serverDialogSpecs.x + 'px',
            top: '30%',//serverDialogSpecs.y + 'px',
            width: '40%',   //serverDialogSpecs.width + 'px',
            height: '40%',   //serverDialogSpecs.height + 'px',
            border: '3px double white',
            'text-align': 'center',
            'background-color': 'black'
        });

        serverDialogOverlay.append(serverDialog);
        var serverDialogTitle = $(document.createElement('div'));
        serverDialogTitle.attr('id', 'dialogTitle');
        serverDialogTitle.css({
            color: 'white',
            'width': '80%',
            'height': '15%',
            'left': '10%',
            'top': '10%',
            'font-size': '1.35em',
            'position': 'relative',
            'text-align': 'center'
        });
        serverDialogTitle.text("TAG Server Address:");
        serverDialog.append(serverDialogTitle);

        var serverDialogInput = $(document.createElement('input'));
        serverDialogInput.attr('id', 'serverDialogInput');
        serverDialogInput.css({
            display: 'block',
            margin: 'auto',
            'margin-bottom': '1%',
            'width': '60%',
	        'height':'10%',
            'position':'relative',
            'top':'15%',
	        'font-size':'100%'
        });
        serverDialogInput.val(localStorage.ip);
        serverDialogInput.focus(function () {
            serverDialogInput.select();
        });
        serverDialog.append(serverDialogInput);
        serverDialogInput.on('keydown', function(evt) {
            if (evt.which === 13 && serverDialog.length > 0) {
                evt.stopPropagation();
                evt.preventDefault();
                saveClick();
            }
        });

        /* TODO merging
        TAG.Telemetry.register(serverDialogInput, 'keydown', 'change_server', function(tobj, evt) {
            if(evt.which !== 13) {
                return true;
            }
            tobj.custom_3 = localStorage.ip;
            tobj.custom_4 = serverDialogInput.val();
            tobj.custom_5 = 'Kiosk';
        });
        */

        var serverDialogContact = $(document.createElement('div'));
        serverDialogContact.css({ 'margin-top': '10%' , 'color':'white','text-align': 'center'  });
        if (!IS_WINDOWS) {
            serverDialogContact.html(
                "Contact us for server setup at:<br /><a href='mailto:brown.touchartgallery@outlook.com'>brown.touchartgallery@outlook.com</a>.");
        } else {
            serverDialogContact.html(
                "Contact us for server setup at:<br />brown.touchartgallery@outlook.com.");
        }
        serverDialog.append(serverDialogContact);

        var serverButtonRow = $(document.createElement('div'));
        serverButtonRow.css({
            'margin-top': '5%',
        });
        serverDialog.append(serverButtonRow);
        var serverSaveButton = $(document.createElement('button'));
        serverSaveButton.css({
            'padding': '1%', 'border': '1px solid white', 'width': '14%','height':'3%' ,'position': 'relative','margin-top': '1%', 'float': "left", 'margin-left':'7%' ,'font-size':'90%','bottom':'1%'
        });
        serverSaveButton.text('Save');
        var serverErrorMessage = $(document.createElement('div'));
        serverErrorMessage.attr('id', 'serverErrorMessage');
        serverErrorMessage.css({
            'color': 'white',
            'left': '10%',
            'width': '80%',
	        'height':'10%',
            'text-align': 'center',
            'position': 'relative',
        });

        serverButtonRow.append(serverErrorMessage);
        serverErrorMessage.hide();


        var serverCancelButton = $(document.createElement('button'));
        serverCancelButton.css({
            'padding': '1%', 'border': '1px solid white', 'width': '14%','height':'3%', 'position': 'relative', 'margin-top': '1%', 'float': "right", 'margin-right': '7%','font-size':'90%','bottom':'1%'
        });
        serverCancelButton.text('Cancel');
        serverCancelButton.attr('type', 'button');
        serverButtonRow.append(serverCancelButton);
        serverButtonRow.append(serverSaveButton);
        serverCancelButton.click(function () {
            $('#serverDialogOverlay').remove();
        });

        function saveClick() {
            var address = serverDialogInput.val();
            switch(address) {
                case 'tagunicorn':
                    var unicorn = $(document.createElement('img'));
                    unicorn.attr('src', tagPath+'images/unicorn.jpg');
                    unicorn.css({
                        width: '100%',
                        height: '100%',
                        'z-index': 2147483647, // we really want this unicorn to show up
                        display: 'none',
                        position: 'absolute',
                    });
                    tagContainer.append(unicorn);
                    unicorn.fadeIn(500);
                    setTimeout(function () {
                        $('img').attr('src', tagPath+'images/unicorn.jpg');
                        $('.background').css('background-image', 'url('+tagPath+'"images/unicorn.jpg")');
                        unicorn.fadeOut(500, function () { unicorn.remove(); });
                    }, 5000);
                    return;
                case 'tagtest':
                    address = 'tagtestserver.cloudapp.net';
                    break;
                case 'tagdemo':
                    address = 'tagdemo.cloudapp.net';
                    break;
                case 'taglive':
                    address = 'browntagserver.com';
                    break;
                case 'taglocal':
                    address = '10.116.71.58';
                    break;
                case 'sam':
                case 'seattleartmuseum':
                    address = 'tag.seattleartmuseum.org'
                    break;
                default:
                    break;
            }
            serverCancelButton.hide();
            serverSaveButton.hide();
            serverErrorMessage.html('Connecting...');
            serverErrorMessage.show();
            TAG.Worktop.Database.changeServer(address, false, function () {
                TAG.Layout.StartPage(null, function (page) {
                    TAG.Util.UI.slidePageRight(page);
                });
            }, function () {
                serverCancelButton.show();
                serverSaveButton.show();
                serverErrorMessage.html('Could not connect to the specified address. Please try again.');
                serverErrorMessage.css({ 'margin-top': '-3%'});
                serverErrorMessage.show();
                serverDialogTitle.css({ 'margin-bottom': '-3%'});
                serverDialog.css({
                    width: '40%',   //serverDialogSpecs.width + 'px',
                    height: '45%',   //serverDialogSpecs.height + 'px',
                });
                serverDialogContact.css({ 'margin-top': '13%' , 'color':'white','text-align': 'center'  });        
            });
        }

        serverSaveButton.on('click', saveClick);

        /* TODO merging
        TAG.Telemetry.register(serverSaveButton, 'click', 'change_server', function(tobj, evt) {
            tobj.custom_3 = localStorage.ip;
            tobj.custom_4 = serverDialogInput.val();
            tobj.custom_5 = 'Kiosk';
        });
        */

        var serverCircle = $(document.createElement('img'));
        serverCircle.css({
            'width': '20px',
            'height': 'auto',
            'display': 'none',
            'margin-right': '3%',
            'margin-top': '2.5%',
            'float': 'right'
        });
        serverCircle.attr('src', tagPath+'images/icons/progress-circle.gif');

        var serverPasswordErrorMessage = $(document.createElement('div'));
        serverPasswordErrorMessage.attr('id', 'serverPasswordErrorMessage');
        serverPasswordErrorMessage.css({
            color: 'white',
            'font-size': '1.25em',
            'margin-bottom': '10px',
        });
        serverPasswordErrorMessage.html('Invalid authoring password entered. Please try again.');
        serverPasswordErrorMessage.hide();

        tagContainer.append(serverDialogOverlay);
        serverDialogInput.focus();
    }


    function FeedbackBox(sourceType, sourceID) {
        var dialogOverlay = $(document.createElement('div'));
        var tagContainer = $('#tagRoot');
        $(dialogOverlay).attr('id', 'dialogOverlay');

        $(dialogOverlay).css({
            display: 'none',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'background-color': 'rgba(0,0,0,0.6)',
            'z-index': 10000000,
        });

        var feedbackBox = $(document.createElement('div'));
        $(feedbackBox).addClass('feedbackBox');
        var feedbackBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),

        {
            center_h: true,
            center_v: true,
            width: 0.5,
            height: 0.35,
            max_width: 560,
            max_height: 210,
        });
		var leftPos = ($('#tagRoot').width() - feedbackBoxSpecs.width) * 0.5;
        $(feedbackBox).css({
            position: 'absolute',
            left: '20%', //leftPos + 'px',
            top: '25%', // feedbackBoxSpecs.y + 'px',
            width: '62%', // feedbackBoxSpecs.width + 'px',
            height: '45%', // feedbackBoxSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',

        });

        $(dialogOverlay).append(feedbackBox);
		$(dialogOverlay).click(cancelFeedback);
		$(feedbackBox).click(function(event){
			event.stopPropagation();
		});
		
        var feedbackLabel = $(document.createElement('label'));
        $(feedbackLabel).addClass('feedbackLabel');
        $(feedbackLabel).text('Send Feedback');
        $(feedbackLabel).css({
            'left': '9%',
            'top': '12.5%',
            'width': '80%',
            'height': '15%',
            'text-align': 'left',
            'color': 'white',
            'position': 'absolute',
            'font-size': '100%'
        });

        var commentBox = $(document.createElement('textarea'));
        $(commentBox).addClass('commentBox');
        $(commentBox).css({
            'border-color': 'gray',
            'color': 'gray',
            'position': 'relative',
            'min-width': 0,
            'left': '9%',
            'top': '12%',
            'width': '77%',
            'height': '30%'


        });

        $(commentBox).attr('placeholder', 'Questions or Comments');

        /*******buttons********/

        var buttonRow = $(document.createElement('div'));
        $(buttonRow).css({
            'position': 'relative',
            'width': '80%',
            'left': '10%',
            'bottom': '-74%',
            'display': 'inline-block'
        });
        var submitButton = $(document.createElement('button'));
        $(submitButton).css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
            'margin-left': '-2%',
            'display': 'inline-block',
        });
        $(submitButton).text('Send ');
        $(submitButton).on('click', submitFeedback);

        function submitFeedback() {
            var type = (typeof sourceType === 'function') ? sourceType() : sourceType;
            var id = (typeof sourceID === 'function') ? sourceID() : sourceID;
            TAG.Worktop.Database.createFeedback($(commentBox).val(), type, id);
            $(dialogOverlay).css({ 'display': 'none' });
            $(commentBox).val('');
            var popup = TAG.Util.UI.popUpMessage(null, "Your feedback has been submitted, thank you for your feedback.", null, null, null, true);
            tagContainer.append(popup);
            $(popup).css('z-index', 1000000);
            $(popup).show();
        }
        var cancelButton = $(document.createElement('button'));
        $(cancelButton).css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
            'float': "right",
            'margin-right': '-2%',
            'display': 'inline-block',
        });
        $(cancelButton).text('Cancel');
        
        $(cancelButton).click(cancelFeedback);
        function cancelFeedback() {
            $(commentBox).val('');
            $(dialogOverlay).css({ 'display': 'none' });

        }
        $(feedbackBox).append(buttonRow);
        $(buttonRow).append(submitButton);
        $(buttonRow).append(cancelButton);

        $(feedbackBox).append(commentBox);
        $(feedbackBox).append(feedbackLabel);
        return dialogOverlay;
    }

    // overlay that "absorbs" interactions with elements below it, used to isolate popup forms etc.
    function blockInteractionOverlay(opac) {

        opac = (opac || opac===0) ? Math.max(Math.min(parseFloat(opac), 1), 0) : 0.6;
        
        var overlay = document.createElement('div');
        $(overlay).attr('id', 'blockInteractionOverlay');

        $(overlay).css({

            display: 'none',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'background-color': 'rgba(0,0,0,'+opac+')',
            'z-index': '10000000'
        });
        
        return overlay;
    }

    // unused - this is not tested, use at your own risk - consider removing?
    //function PopUpWarningBox(message) {
    //    var overlay = BlockInteractionOverlay();
    //    var WarningBox = document.createElement('div');
    //    $(WarningBox).css({
    //        'height': '30%',
    //        'width': '45%',
    //        'position': 'fixed',
    //        'top': '50%',
    //        'left': '50%',
    //        'margin-top': '-15%',
    //        'margin-left': '-22.5%',
    //        'background-color': 'black',
    //        'z-index': '100',
    //        'border': '3px double white',
    //    });

    //    var messageLabel = document.createElement('div');
    //    $(messageLabel).css({ 'top': '5%', 'height': '20%', 'width': '90%', 'color': 'white', 'margin': '5%', 'font-size': '200%' });
    //    $(messageLabel).text(message);

    //    var optionButtonDiv = document.createElement('div');
    //    $(optionButtonDiv).css({ 'height': '10%', 'width': '25%', 'left': '70%', 'position': 'relative', 'top': '35%' });
    //    var okButton = document.createElement('button');
    //    $(okButton).css({ 'font-size': '140%', 'margin-left': '2%' });
    //    $(okButton).text("OK");
    //    okButton.onclick = function () {
    //        $(overlay).fadeOut(500, function () { $(overlay).remove(); });
    //    }
    //    $(optionButtonDiv).append(okButton);

    //    $(confirmBox).append(messageLabel);
    //    $(confirmBox).append(optionButtonDiv);

    //    $(overlay).append(confirmBox)
    //    return overlay;
    //}

    // generate a popup message with specified text and button
    function popUpMessage(clickAction, message, buttonText, noFade, useHTML, onDialogClick) {
        var overlay,first;
        if(document.getElementById("popupblockInteractionOverlay")){
            overlay = $(document.getElementById("popupblockInteractionOverlay"));
        }else{
            overlay = blockInteractionOverlay();
            first = true;
            $(overlay).attr('id', 'popupblockInteractionOverlay');
        }
        var confirmBox = document.createElement('div');
        var confirmBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width: 650,
               max_height: 300,
           });
		var leftPos = ($('#tagRoot').width() - confirmBoxSpecs.width) * 0.5;
        var currentKeyHandler = globalKeyHandler[0];

        $(confirmBox).css({
            //'height': '30%',
            //'width': '45%',
            //'position': 'absolute',
            //'top': '50%',
            //'left': '50%',
            //'margin-top': '-15%',
            //'margin-left': '-22.5%',
            //'background-color': 'black',
            //'z-index': '100',
            //'border': '3px double white',

            position: 'absolute',
            left: leftPos + 'px',
            top: confirmBoxSpecs.y + 'px',
            width: confirmBoxSpecs.width + 'px',
            height: confirmBoxSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',

        });
		if(onDialogClick){
			$(overlay).click(removeAll);
			$(confirmBox).click(function(event){
				event.stopPropagation();
			});
		}

        var messageLabel = document.createElement('div');
        $(messageLabel).css({
            //'top': '5%',
            //'height': '20%',
            //'width': '90%',
            //'color': 'white',
            //'margin': '5%',
            //'font-size': '200%'

            color: 'white',
            'width': '80%',
            'height': '30%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '1.20em',
            'position': 'relative',
            'text-align': 'center',
            'word-wrap': 'break-word',

        });
        var fontsize = TAG.Util.getMaxFontSizeEM(message, 1.5, $(messageLabel).width(), $(messageLabel).height());
        $(messageLabel).css('font-size', fontsize);
        TAG.Util.multiLineEllipsis($(messageLabel));
        if (useHTML) {
            $(messageLabel).html(message);
        } else {
            $(messageLabel).text(message);
        }
        var optionButtonDiv = document.createElement('div');
        $(optionButtonDiv).addClass('optionButtonDiv');
        $(optionButtonDiv).css({
            'height': '10%',
            'width': '100%',
            'position': 'absolute',
            'bottom': '6%',
            'right': '2%',
        });

        var confirmButton = document.createElement('button');
        $(confirmButton).css({
            //'font-size': '140%',
            //'margin-left': '2%',
            //'float': 'right',
            //'margin-right':'2%'

            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            //'margin-top': '1%',
            'float': "right",
            'margin-right': '3%',
            'margin-top': '-1%',
            color: 'white',
        }).css('border-radius', '3.5px');
        buttonText = (!buttonText || buttonText === "") ? "OK" : buttonText;
        $(confirmButton).text(buttonText);
        confirmButton.onclick = function () {
            if (clickAction) {
                clickAction();
            }
            if (first) {
                removeAll();
            } else {
                $(confirmBox).remove();
            }
        };

        function onEnter() {
            if(clickAction) {
                clickAction();
            }
            removeAll();
            
        }

        globalKeyHandler[0] = { 13: onEnter, };

        function removeAll() {
            if (noFade) {
                $(overlay).hide();
                $(overlay).remove();
            } else {
                $(overlay).fadeOut(500, function () { $(overlay).remove(); });
            }
            globalKeyHandler[0] = currentKeyHandler;
        }

        $(optionButtonDiv).append(confirmButton);

        $(confirmBox).append(messageLabel);
        $(confirmBox).append(optionButtonDiv);

        $(overlay).append(confirmBox);
        return overlay;
    }

    
    // popup message to ask for user confirmation of an action e.g. deleting a tour
    function PopUpConfirmation(confirmAction, message, confirmButtonText, noFade, cancelAction, container, onkeydown,forTourBack,fortelemetry) {
        var overlay;
        var origin;
        if (document.getElementById("popupblockInteractionOverlay")) {
            overlay = $(document.getElementById("popupblockInteractionOverlay"));
        } else {
            origin = true;
            overlay = blockInteractionOverlay();
            $(overlay).attr('id', 'popupblockInteractionOverlay');
        }
        container = container || window;
        var confirmBox = document.createElement('div');
        var popUpHandler = {
            13: doOnEnter,
        }
        var currKeyHandler = globalKeyHandler[0];
        globalKeyHandler[0] = popUpHandler;
        
        //temp solution for telemetry box in all resolutions and browsers. 
        var maxw = 600,
            maxh=300;
        if (fortelemetry) {
            maxw = $('body').width() * 0.45;
            maxh = $('body').height() * 0.33;
        }
        var confirmBoxSpecs = TAG.Util.constrainAndPosition($(container).width(), $(container).height(),
            {
                center_h: true,
                center_v: true,
                width: 0.5,
                height: 0.35,
                max_width:maxw,// $('body').width()*0.33,
                max_height: maxh//$('body').height()*0.2,
            });

        $(confirmBox).css({
            position: 'absolute',
            left: confirmBoxSpecs.x + 'px',
            top: confirmBoxSpecs.y + 'px',
            width: confirmBoxSpecs.width + 'px',
            height: confirmBoxSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black'
        });

        var messageLabel = document.createElement('div');
        
        $(messageLabel).css({
            color: 'white',
            'width': '80%',
            'height': '50%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '0.8em',
            'overflow': 'hidden',
            'position': 'relative',
            'text-align': 'center',
            'text-overflow': 'ellipsis',
            'word-wrap': 'break-word'
        });
        var fontsize =TAG.Util.getMaxFontSizeEM(message, 1, $(messageLabel).width(), $(messageLabel).height());
        if (fortelemetry&&IS_WINDOWS) {
            fontsize = TAG.Util.getMaxFontSizeEM(message, 0.8, $(messageLabel).width(), $(messageLabel).height());
        }
        $(messageLabel).css('font-size', fontsize);
        $(messageLabel).text(message).attr("id","popupmessage");
        $(confirmBox).append(messageLabel);
        TAG.Util.multiLineEllipsis($(messageLabel));
        var optionButtonDiv = document.createElement('div');
        $(optionButtonDiv).addClass('optionButtonDiv');
        $(optionButtonDiv).css({
            'height': '20%',
            'width': '100%',
            'position': 'absolute',
            'color': 'white',
            'bottom': '5%',
            'right': '5%',
            'text-align':'center'
        });
        $(confirmBox).append(optionButtonDiv);

        $(overlay).append(confirmBox);
        var confirmButton = document.createElement('button');
        $(confirmButton).css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "left",
            'margin-left': '12%',
            'color': 'white',
            'border-radius': '3.5px',
            'margin-top': '1%'

        }).attr('id', 'popupConfirmButton');
        confirmButtonText = (!confirmButtonText || confirmButtonText === "") ? "Confirm" : confirmButtonText;
        $(confirmButton).text(confirmButtonText);
       
        confirmButton.onclick = function () {
            if (origin) {
                removeAll();
            } else {
                $(confirmBox).remove()
            }
            confirmAction();
        };

        confirmButton.onkeydown = function (event) {
            switch (event.which) {
                case 13: // enter key
                    removeAll();
                    confirmAction();
            }
        }
        $(optionButtonDiv).append(confirmButton);

        var cancelButton = document.createElement('button');
        var $cancelButton = $(cancelButton);
        $cancelButton.css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "right",
            'margin-right': '3%',
            'color': 'white',
            'margin-top': '1%',
            'border-radius': '3.5px'
        }).attr('id', 'popupCancelButton');
        $cancelButton.text('Cancel');
        $(optionButtonDiv).append(cancelButton);

        if (forTourBack) {
            $cancelButton.text('Don\'t Save');
            $(optionButtonDiv).css({
                "right": "0%",
            });
            $(confirmButton).css({
                'left': '12%',
                'margin': 'auto',
                'margin-top': '1%',
            });
            var realcancelbtn = $(document.createElement('button'));
            realcancelbtn.css({
                'padding': '1%',
                'border': '1px solid white',
                'width': 'auto',
                'position': 'relative',
                'float': "right",
                //'margin-right': '12%',
                'right':'12%',
                'color': 'white',
                'margin-top': '1%',
                'border-radius': '3.5px'
            }).text("Cancel");
            var btnwidth = $(cancelButton).width();
            var dontleft = ($(optionButtonDiv).width() - btnwidth) / 2;
            $cancelButton.css({
                "float": 'none',
                'margin': 'auto',
                'margin-top':'1%',                
            });
            $(optionButtonDiv).append(realcancelbtn);
            realcancelbtn.click(function () {
                if (origin) {
                    removeAll();
                } else {
                    $(confirmBox).remove();
                }
            });
        }
        cancelButton.onclick = function () {
            if(origin){
                removeAll();
            }else{
                $(confirmBox).remove();
            }
            cancelAction && cancelAction();
        }

        
        if(fortelemetry){
            $cancelButton.text("No, I don't mind")
                .css({
                    "border-radius":'3.5px',
                    "background-color": "white",
                    "color":'black',
                    "font-weight":"bold"
                });
            $(confirmButton).css({
                "border-radius":'3.5px',
                "font-weight":"bold"
            });
        }
        function doOnEnter() {
            removeAll();
            confirmAction();
        }
        

        function removeAll() {
            if (noFade) {
                $(overlay).hide();
                $(overlay).remove();
            } else {
                $(overlay).fadeOut(500, function () { $(overlay).remove(); });
            }
            globalKeyHandler[0] = currKeyHandler;
        }


       
        return overlay;
    }

    /**
     * Create an input box popup
     * @method popupInputBox
     * @param {Object} options             some input options (callback function for confirm button, etc)
     *            {Function} cancelAction    action to take on clicking "cancel"
     *            {Function} confirmAction   action to take on clicking "confirm"
     *            {jQuery obj} container     container used for styling the popup box
     *            {String} message           message to show at top of popup
     *            {String} placeholder       placeholder text inside input field
     *            {String} confirmText       custom text for the "confirm" button
     * @return {jQuery obj}                overly of popup box
     */
    function popupInputBox(options) {
        var overlay = $(blockInteractionOverlay()),
            cancelAction = function () {
                options.cancelAction && options.cancelAction();
                removeAll();
            },
            confirmAction = function () {
                options.confirmAction && options.confirmAction(inputField.val()); // TODO iframe sanitize input here?
                removeAll();
            },
            popupHandler = {
                13: confirmAction
            },
            container = options.container || window,
            currKeyHandler = globalKeyHandler[0],
            popupBox = $(document.createElement('div')),
            popupBoxSpecs = TAG.Util.constrainAndPosition($(container).width(), $(container).height(), {
                center_h: true,
                center_v: true,
                width: 0.5,
                height: 0.35,
                max_width: 560,
                max_height: 200,
            }),
            messageLabel = $(document.createElement('div')),
            optionButtonDiv = $(document.createElement('div')),
            inputField = $(document.createElement('input')),
            message = options.message || '',
            confirmButton = $(document.createElement('button')),
            cancelButton = $(document.createElement('button')),
            confirmButtonText = options.confirmText || '';

        globalKeyHandler[0] = popupHandler; // TODO KEYHANDLER should we be prepending rather than overwriting first element? same with popupconfirmation above

        popupBox.css({
            position: 'absolute',
            left: popupBoxSpecs.x + 'px',
            top: popupBoxSpecs.y + 'px',
            width: popupBoxSpecs.width + 'px',
            height: popupBoxSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black'
        });

        messageLabel.css({
            color: 'white',
            'width': '80%',
            'height': '30%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '0.6em',
            'position': 'relative',
            'text-align': 'center',
            'word-wrap': 'break-word'
        });

        messageLabel.text(message);

        inputField.css({
            width: '60%',
            left: '20%',
            position: 'relative'
        });
        inputField.attr({
            type: 'text',
            placeholder: options.placeholder || 'Paste URL here...'
        });

        optionButtonDiv.addClass('optionButtonDiv');
        optionButtonDiv.css({
            'height': '20%',
            'width': '100%',
            'position': 'absolute',
            'bottom': '10%',
            'right': '5%'
        });

        confirmButton.css({
            'color': 'white',
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "left",
            'margin-left': '12%',
            'margin-top': '-1%'

        });
        confirmButtonText = !confirmButtonText ? "Confirm" : confirmButtonText;
        confirmButton.text(confirmButtonText);

        confirmButton.on('click', confirmAction);

        confirmButton.on('keydown', function (event) { // TODO KEYHANDLER do we need a separate keydown handler for this? should be handled in global key handling
            switch (event.which) {
                case 13: // enter key
                    confirmAction();
            }
        });

        cancelButton.css({
            'color': 'white',
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "right",
            'margin-right': '3%',
            'margin-top': '-1%'
        });
        cancelButton.text('Cancel');
        cancelButton.on('click', cancelAction);

        function removeAll() {
            overlay.fadeOut(500, function () {
                overlay.remove();
            });
            globalKeyHandler[0] = currKeyHandler;
        }

        optionButtonDiv.append(cancelButton);
        optionButtonDiv.append(confirmButton);

        popupBox.append(messageLabel);
        popupBox.append(inputField);
        popupBox.append(optionButtonDiv);

        overlay.append(popupBox);
        return overlay;
    }

    /**
     * Following functions transition between pages while in splitscreen mode
     */
    /**
     * Use _Split fn's for transitions that need to preserve splitscreen
     * Note: pages passed in to this function should have a top-level root node
     * (true of exhibition, catalog and artmode)
     */
    // used for setting button colors
    function cgBackColor(buttonType, buttonToChange, isMouseLeave) {
        switch (buttonType) {
            case "backButton":
                if (!isMouseLeave) {
                    $(buttonToChange).css({ 'background-color': 'gray', 'border-radius': '999px' });
                }
                else {
                    $(buttonToChange).css({ 'background-color': 'transparent', 'border-radius': '999px' });
                }
                break;
            case "labelButton":
                $(buttonToChange).css({ 'background-color': 'white', 'color': 'black' });
                break;
            case "forwardButton":
                $(buttonToChange).css({ 'background-color': 'gray' });
                break;
        }
    }

    /**
     * Set up handlers for back button
     * @method setUpBackButton
     * @param {jQuery Obj} elt         jQuery object for back button element
     * @param {Function} clickHandler  click handler for button
     */
    function setUpBackButton(elt, clickHandler) {
        elt.on('mouseleave', function () {
            cgBackColor("backButton", elt, true);
        });
        elt.on('mousedown', function () {
            cgBackColor("backButton", elt, false);
        });
        elt.on('click', clickHandler);
    }

    // slide towards left (splitscreen)
    function slidePageLeftSplit(oldpage, newpage, callback) {
        var outgoingDone = false,
            incomingDone = false,
            metaContainer = oldpage.parent(),
            outgoing = makeFullPage(),
            incoming = makeFullPage();
        
        var elements = metaContainer.children();
        elements.remove();

        elements.appendTo($(outgoing));
        $(outgoing).css({ left: "0%", float: "left" });

        $(incoming).append(newpage);
        $(incoming).css({ left: "120%", display: "inline" });

        metaContainer.append(outgoing);
        metaContainer.append(incoming);

        $(outgoing).animate({ left: "-120%" }, 1000, 'easeOutQuad', function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: "0%" }, 1000, 'easeOutQuad', function () {
            $(incoming).detach();
            metaContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone && incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // slide towards right (splitscreen)
    function slidePageRightSplit(oldpage, newpage, callback) {
        var outgoingDone = false,
            incomingDone = false,
            metaContainer = oldpage.parent(),
            outgoing = makeFullPage(),
            incoming = makeFullPage(),
            elements = metaContainer.children();

        elements.detach();

        elements.appendTo($(outgoing));
        $(outgoing).css({ left: "0%", float: "left" });

        $(incoming).append(newpage);
        $(incoming).css({ left: "-120%", display: "inline" });

        metaContainer.append(outgoing);
        metaContainer.append(incoming);

        $(outgoing).animate({ left: "120%" }, 1000, 'easeOutQuad', function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: "0%" }, 1000, 'easeOutQuad', function () {
            $(incoming).detach();
            metaContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone && incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    /**
     * Use for any page transition that does not need to preserve splitscreen
     */
    // towards left
    function slidePageLeft(newpage, callback) {
        
        var outgoingDone = false;
        var incomingDone = false;
        var tagContainer = $('#tagRoot');

        var elements = tagContainer.children();
        elements.remove();

        var outgoing = makeFullPage();
        elements.appendTo($(outgoing));
        $(outgoing).css({ left: "0%", float: "left" });

        var incoming = makeFullPage();
        $(incoming).append(newpage);
        $(incoming).css({ left: "120%", display: "inline" });

        tagContainer.append(outgoing);
        tagContainer.append(incoming);

        $(outgoing).animate({ left: "-120%" }, 1000, 'easeOutQuad', function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: "0%" }, 1000, 'easeOutQuad', function () {
            $(incoming).detach();
            tagContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone && incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // towards right
    function slidePageRight(newpage, callback) {
        var outgoingDone = false;
        var incomingDone = false;
        var tagContainer = $('#tagRoot');

        var elements = tagContainer.children();
        elements.remove();

        var outgoing = makeFullPage();
        elements.appendTo($(outgoing));
        $(outgoing).css({ left: "0%", float: "left" });

        var incoming = makeFullPage();
        $(incoming).append(newpage);
        $(incoming).css({ left: "-120%", display: "inline" });

        tagContainer.append(outgoing);
        tagContainer.append(incoming);

        $(outgoing).animate({ left: "120%" }, 1000, 'easeOutQuad', function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: "0%" }, 1000, 'easeOutQuad', function () {
            $(incoming).detach();
            tagContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone && incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // cleanup: currently unused, leave or delete up to reviewer
    /*function makeTriangle(width, height, color) {
        var toReturn = document.createElement('div');
        $(toReturn).css({
            width: "0px", height: "0px", "border-top": (height / 2) + "px solid transparent",
            "border-bottom": (height / 2) + "px solid transparent", "border-left": width + "px solid " + color
        });
        return toReturn;
    }*/

    // make a full-page div
    function makeFullPage() {
        var newPage = document.createElement("div");
        $(newPage).css({ height: "100%", width: "100%", position: "absolute" });
        return newPage;
    }

    function hexToRGB(h) { return 'rgba(' + hexToR(h) + ',' + hexToG(h) + ',' + hexToB(h) + ','; } // return rgba value of hex color leaving space for alpha
    function hexToR(h) { return parseInt((cutHex(h)).substring(0, 2), 16); }
    function hexToG(h) { return parseInt((cutHex(h)).substring(2, 4), 16); }
    function hexToB(h) { return parseInt((cutHex(h)).substring(4, 6), 16); }
    function cutHex(h) { return (h.charAt(0) === "#") ? h.substring(1, 7) : h; }

    /**
     * Take in a color (in '#abcdef' format) and an opacity (0-1) and return an rgba(..) string
     * @method hexToRGBA
     * @param {String} color       input color as a hex string
     * @param {String} opac        input opacity
     * @return {String}            'rgba(color.r, color.g, color.b, opac)'
     */
    function hexToRGBA(color, opac) {
        var r, g, b;

        color = color.replace(/\#/g, '');
        color = color.substring(0, 6);

        r = parseInt(color.substring(0, 2), 16);
        g = parseInt(color.substring(2, 4), 16);
        b = parseInt(color.substring(4, 6), 16);

        return 'rgba(' + r + ',' + g + ',' + b + ',' + opac + ')';
    }

    //Takes a RGB or RGBA color value as input and outputs the Hex color representation, without the '#' symbol in front
    function colorToHex(rgb) {
        var digits = rgb.match(/(rgb|rgba)\((\d+),\s*(\d+),\s*(\d+)\,*\s*((\d+\.\d+)|\d+)*\)$/);
        function hex(x) {
            var str = ("0" + parseInt(x, 10).toString(16)).toUpperCase();  
            return str.slice(-2);
        }
        if (digits !== null && digits !== undefined) { // string.match() returns null if regexp fails
            return hex(digits[2]) + hex(digits[3]) + hex(digits[4]);
        }
        else if (rgb === "transparent") {
            return "000000"; // Prevent this from breaking due to bad server state (jastern 3/7/2013)
        }
        else {
            return "000000";
        }
    }

    /**
     * Take in a color and return a dimmed version of that color (divide rgb by k)
     * @param {String} inColor      input color as a hex string
     * @param {Number} k            dimming factor
     * @return {String}             formatted as 'rbg(_,_,_)'
     */
    function dimColor(inColor, k) {
        var r,
            g,
            b;

        k = k || 3;

        inColor = inColor.replace(/\#/g, '');
        inColor = inColor.substring(0, 6);

        r = Math.round(parseInt(inColor.substring(0, 2), 16) / k);
        g = Math.round(parseInt(inColor.substring(2, 4), 16) / k);
        b = Math.round(parseInt(inColor.substring(4, 6), 16) / k); 

        return 'rgb(' + r + ',' + g+ ',' + b + ')';
    }

    //function called to fit the text (that is wrapped in a span) within a div element.
    //created for fitting text in museumInfo
    function fitTextInDiv(element, max, min) {
        var fontSize = parseInt(element.css('font-size'), 10);
        if (parseInt(element.parent()[0].scrollHeight, 10) > element.parent().height()) {
            while (parseInt(element.parent()[0].scrollHeight, 10) > element.parent().height() && fontSize > min) {
                fontSize--;
                element.css('font-size', fontSize + 'px');
            }
        } else if (parseInt(element.height(), 10) < (element.parent().height())) {
            while (parseInt(element.height(), 10) < (element.parent().height()) && fontSize < max) {
                fontSize++;
                element.css('font-size', fontSize + 'px');
                if (parseInt(element.parent()[0].scrollHeight, 10) > element.parent().height()) {
                    fontSize--;
                    element.css('font-size', fontSize);
                    break;
                }
            }
        }
    }


    //Creates Microsoft.Maps.Pushpin objects from the locObjects within the locationList object, and displays the pushpins on the map
    function drawPushpins(locationList, map) {
        map.entities.clear();
        for (var i = 0; i < locationList.length; i++) {
            var locationItem = locationList[i];
            var location;
            if (locationItem.resource.latitude) { // if latitude exists then it's a custom pushpin
                location = locationItem.resource;
            } else {
                var lat = locationItem.resource.point.coordinates[0];
                var long = locationItem.resource.point.coordinates[1];
                location = new Microsoft.Maps.Location(lat, long);
            }
            var pushpinOptions = {
                text: String(i + 1),
                icon: tagPath+'images/icons/locationPin.png',
                width: 20,
                height: 30
            };
            var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);

            //Add some info about the location in the pin
            //if (locationItem.date) {
            //    pushpin.date = locationItem.date;
            //} else {
            //    pushpin.date = 'Date Unspecified';
            //}

            pushpin.location = locationItem.address;
            pushpin.description = '';
            if (locationItem.info) {
                pushpin.description = locationItem.info;
            }
            map.entities.push(pushpin);
        }

    }

    function addCustomPushpin(locs, currentLocationIndex) {
        var pushpinOptions = {
            text: String(currentLocationIndex),
            icon: tagPath+'images/icons/locationPin.png',
            width: 20,
            height: 30
        };
        var pushpin = new Microsoft.Maps.Pushpin(locs.resource, pushpinOptions);
        pushpin.location = locs.address;
        pushpin.description = '';
        if (locs.info) {
            pushpin.description = locs.info;
        }
        locs.pushpin = pushpin;
    }

    //function takes a locObject and creates the pushpins that correspond to them 
    function addPushpinToLoc(locs, currentLocationIndex) {
        //set pushpin for location
        if (locs.resource.latitude) {
            addCustomPushpin(locs, currentLocationIndex);
            return;
        }
        var lat = locs.resource.point.coordinates[0];
        var long = locs.resource.point.coordinates[1];
        var location = new Microsoft.Maps.Location(lat, long);
        var pushpinOptions = {
            text: String(currentLocationIndex),
            icon: tagPath+'images/icons/locationPin.png',
            width: 20,
            height: 30
        };
        var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);

        //Add some info about the location in the pin
        //if (locs.date && !isNaN(locs.date.year)) {
        //    pushpin.date = locs.date;
        //} else {
        //    pushpin.date = 'Date Unspecified';
        //}

        pushpin.location = locs.address;
        pushpin.description = '';
        if (locs.info) {
            pushpin.description = locs.info;
        }
        //assign pushpin to location
        locs.pushpin = pushpin;
    }

    //gets JSON encoded location list from artwork XML and displays the information
    function getLocationList(metadata) { //TODO DW - update/review this
        var locationList;
        //parsing the location field in the artwork metadata to obtain the pushpin information
        var data = metadata.RichLocationHistory || metadata.Location;
        try {
            locationList = JSON.parse(data);
        } catch (e) {
            console.log('artwork location metadata cannot be parsed.');
            locationList = [];
            return locationList;
        }

        if (locationList.locations) {
            // load dates and modernize old date objects
            for (var i = 0; i < locationList.locations.length; i++) {
                var locationItem = locationList.locations[i];
                if (locationItem.date) {
                    // convert old dates to new dates
                    if (locationItem.date.getFullYear) {
                        var y = date.getUTCFullYear();
                        var m = date.getUTCMonth();
                        var d = date.getUTCDay();
                        locationItem.date = {
                            year: y,
                            month: m,
                            day: d,
                        }
                    }
                    //no longer needed
                    //locationItem.pushpin.date = locationItem.date;
                }
            }
            return locationList.locations;
        } else {
            // load dates and modernize old date objects
            for (var i = 0; i < locationList.length; i++) {
                var locationItem = locationList[i];
                if (locationItem.date) {
                    // convert old dates to new dates
                    if (locationItem.date.getFullYear) {
                        var y = date.getUTCFullYear();
                        var m = date.getUTCMonth();
                        var d = date.getUTCDay();
                        locationItem.date = {
                            year: y,
                            month: m,
                            day: d,
                        }
                    }
                    locationItem.pushpin.date = locationItem.date;
                }
            }
            return locationList;
        }
    }

    var selectCSS = {
        'color': '#aaaaaa',
        'display': 'inline-block',
        'margin-left': '20px'
    };

    /**
     * Creates a picker (e.g. click add/remove media in the artwork editor) to manage
     *   associations between different TAG components (exhib, artworks, assoc media)
     * @param root           object: jquery object for the root of the DOM (we'll append an overlay to this)
     * @param title          string: the title to appear at the top of the picker
     * @param target         object: a comp property (object whose associations we're managing) and a type property
     *                               ('exhib', 'artwork', 'media') telling us what kind of component it is
     * @param type           string: "exhib" (exhib-artwork), "artwork" (artwork-media) : type of the association
     * @param tabs           array: list of tab objects. Each has a name property (string, title of tab), a getObjs
     *                              property (a function to be called to get each entity listed in the tab), and a
     *                              args property (which will be extra arguments sent to getObjs)
     * @param filter         object: a getObjs property to get components that are already associated with target
     *                               (e.g. getAssocMediaTo if type='artwork') and an args property (extra args to getObjs)
     * @param callback       function: function to be called when import is clicked or a component is double clicked
     */
    function createAssociationPicker(root, title, target, type, tabs, filter, callback) {
        var pickerOverlay,
            picker,
            pickerHeader,
            tabBanner,
            tab,
            i,
            searchTab,
            pickerSearchBar,
            selectAllLabel,
            deselectAllLabel,
            mainContainer,
            addedComps = [], // components we will be associating to target
            addedCompsObjs = [], // keep track of the component objects (to be added to the recently associated list)
            removedComps = [], // components whose associations with target we will be removing
            origComps = [], // components that are already associated with target
            tabCache = [], // cached results from the server
            loadQueue = TAG.Util.createQueue(),

            currentKeyHandler = globalKeyHandler[0];
            globalKeyHandler[0] = { 13: onEnter };

        for (i = 0; i < tabs.length; i++) {
            tabCache.push({ cached: false, comps: [] });
        }

        var filterArgs = (filter.args || []).concat([function (comps) { // this has async stuff, make sure it gets called by the time it needs to be
            for (i = 0; i < comps.length; i++) {
                origComps.push(comps[i].Identifier);
            }
        }, error, cacheError]);
        filter.getObjs.apply(null, filterArgs);

        // overlay
        pickerOverlay = $(blockInteractionOverlay());
        pickerOverlay.addClass('pickerOverlay');
        pickerOverlay.css('z-index', 10000000);
        pickerOverlay.appendTo($(root));
        pickerOverlay.fadeIn();

        // picker div
        picker = $(document.createElement('div'));
        picker.addClass("picker");
        picker.css({
            position: 'absolute',
            width: '60%',
            height: '55%',
            padding: '1%',
            'padding-left': '2%',
            'background-color': 'black',
            'border': '3px double white',
            top: '22%',
            left: '20%',
        });
        pickerOverlay.append(picker);

        // heading
        pickerHeader = $(document.createElement('div'));
        pickerHeader.addClass('pickerHeading');
        pickerHeader.text(title);
        pickerHeader.css({
            'width': '97%',
            'color': 'white',
            'font-size': '120%',
            'height': '7%',
            'margin-bottom': '10px'
        });

        picker.append(pickerHeader);
        var fontsize = TAG.Util.getMaxFontSizeEM(title,0.7,pickerHeader.width(),pickerHeader.height());
        pickerHeader.css('font-size', fontsize);
        // tab container
        if( tabs.length >= 2) {
            tabBanner = $(document.createElement('div'));
            tabBanner.css({
                'width': '100%',
                'height': '8%',
                'left': '5%'
            });
            tabBanner.attr("id", "tabBanner");
            picker.append(tabBanner);

            // tabs
            for (i = 0; i < tabs.length; i++) {
                tab = $(document.createElement('div'));
                tab.addClass('tab');
                tab.attr('id', 'tab' + i);
                tab.css({
                    'display': 'inline-block',
                    'min-width': '18%',
                    'width': 'auto',
                    'padding-left': '2%',
                    'padding-right': '2%',
                    'padding-top': '1%',
                    'height': '85%',
                    'color': 'white',
                    'border-top': '1px solid ' + ((i === 0) ? 'white' : 'black'),
                    'border-right': '1px solid ' + ((i === 0) ? 'white' : 'black'),
                    'border-left': '1px solid ' + ((i === 0) ? 'white' : 'black'), // repeated computation
                    'border-bottom': '1px solid ' + ((i === 0) ? 'black' : 'white'),
                    'text-align': 'center',
                    'font-size':'0.8em'
                });
                tab.text(tabs[i].name);
                tab.on('click', tabHelper(i));
                tabBanner.append(tab);
            }
            tab = $(document.createElement('div'));
            tab.attr("id", "extraSpaceAwwwwwYeahhhh");
            tab.css({
                'display': 'inline-block',
                'color': 'black',
                'width': (90 - 20 * tabs.length) + '%',
                'height': '100%',
                'border-bottom': '1px solid white',
                'border-left': '1px solid black'
            });
            tab.text('_'); // suuuuuuuuper hacky; vertical positioning wasn't right... TODO
            //tabBanner.append(tab);
        }

        searchTab = $(document.createElement('div'));
        searchTab.attr("id","searchTab");
        searchTab.css({
            'height': '8%',
            'width': '100%',
            'margin-top': '2%',
            'top': '13%'
        })

        picker.append(searchTab);

        // search bar
        pickerSearchBar = $(document.createElement('input'));
        pickerSearchBar.addClass("searchBar");
        pickerSearchBar.attr('type', 'text');
        pickerSearchBar.css({
            'margin-left': '1%',
            'width': '20%',
            'height': '55%',
        });
        // TAG.Util.defaultVal("Search by Name...", pickerSearchBar, true, IGNORE_IN_SEARCH); // TODO more specific search (e.g. include year for artworks)
        //pickerSearchBar.attr("placeholder", "Search");
        pickerSearchBar.keyup(function (event) {
            event.stopPropagation();
            if (event.which === 13) {
                TAG.Util.searchData(pickerSearchBar.val(), '.compHolder', IGNORE_IN_SEARCH);
            }
        });

        pickerSearchBar.css({
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size': 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position': '8px center'
        });

        pickerSearchBar.on('focus', function () { pickerSearchBar.css({ 'background-image': 'none' }); });
        pickerSearchBar.on('focusout', function () {
            if (!pickerSearchBar.val()) {
                pickerSearchBar.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });
            }
        });

        searchTab.append(pickerSearchBar);

        pickerSearchBar.on('keyup', function () {
            if (!pickerSearchBar.val()) {
                TAG.Util.searchData('', '.compHolder', IGNORE_IN_SEARCH);
            }
        });

        // select all label
        selectAllLabel = $(document.createElement('div'));
        selectAllLabel.attr("id", "selectAllLabel");
        selectAllLabel.css({
            'color': '#aaaaaa',
            'display': 'inline-block',
            'margin-left': '5%',
            'font-size':'0.8em',
        });
        selectAllLabel.text('Select All');
        
        selectAllLabel.on('click', function () {
            var holder, guid, index;
            confirmButton.prop('disabled', false);
            confirmButton.css('opacity', '1');
            $.each($('.compHolder'), function (ind, holderElt) {
                holder = $(holderElt);
                if (!holder.data("selected") && holder.css("display") !== "none") {
                    holder.css('background', '#999');
                    holder.data("selected", true);
                    guid = holder.data("guid");
                    index = origComps.indexOf(guid);
                    if (index >= 0) {
                        removedComps.remove(guid);
                    } else {
                        addedComps.push(guid);
                        addedCompsObjs.push(holder.data('comp'));
                    }
                }
            });
        }); // TODO
        searchTab.append(selectAllLabel);

        // deselect all label
        deselectAllLabel = $(document.createElement('div'));
        deselectAllLabel.attr("id", "deselectAllLabel");
        deselectAllLabel.css({
            'color': '#aaaaaa',
            'display': 'inline-block',
            'margin-left': '5%',
            'font-size': '0.8em',
        });
        deselectAllLabel.text('Deselect All');
        deselectAllLabel.on('click', function () {
            var holder, guid, index, addedIndex;
            confirmButton.prop('disabled', false);
            confirmButton.css('opacity', '1');
            $.each($('.compHolder'), function (ind, holderElt) {
                holder = $(holderElt);
                if (holder.data("selected") && holder.css("display") !== "none") {
                    holder.css('background', '#222');
                    holder.data("selected", false);
                    guid = holder.data("guid");
                    index = origComps.indexOf(guid);
                    if (index >= 0) {
                        removedComps.push(guid)
                    } else {
                        addedIndex = addedComps.indexOf(guid);
                        addedComps.splice(addedIndex, 1);
                        addedCompsObjs.splice(addedIndex, 1);
                    }
                }
            });
        }); // TODO
        searchTab.append(deselectAllLabel);

        // main thumbnail container
        mainContainer = $(document.createElement('div'));
        mainContainer.attr("id", "mainThumbnailContainer");
        mainContainer.css({
            'overflow-y': 'scroll',
            'margin-top': '10px',
            'width': '100%',
            //'height': '75%' // should actually figure out how tall this should be based on other elements TODO
        });
        picker.append(mainContainer);
        mainContainer.css({height: (picker.height() - mainContainer.offset().top + picker.offset().top - 30) + "px"});

        // cancel and save buttons
        var optionButtonDiv = $(document.createElement('div'));
        optionButtonDiv.addClass('optionButtonDiv');
        optionButtonDiv.css({
            'height': '5%',
            'width': '100%'
        });

        var progressCSS = {
            'left': '5%',
            'top': '15px',
            'width': '40px',
            'height': 'auto',
            'position': 'relative',
            'z-index': 50
        };

        var progressCirc;

        var confirmButton = $(document.createElement('button'));
        confirmButton.css({
            'margin': '1%',
            'border': '1px solid white',
            'color': 'white',
            'padding-left': '1%',
            'padding-right': '1%',
            'background-color': 'black',
            'width': 'auto',
            'position': 'relative',
            'float': "right",
            'border-radius': '3.5px'
        });

        confirmButton.text("Save");
        confirmButton.on('click', function () {
            confirmButton.attr('disabled', true).css({ 'color': 'rgba(255, 255, 255, 0.5)' });
            cancelButton.attr('disabled', true).css({ 'color': 'rgba(255, 255, 255, 0.5)' });
            $('.compHolder').off();
            progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
            finalizeAssociations();
            globalKeyHandler[0] = currentKeyHandler;
        });

        /**Saves changes for pressing enter key
         * @method onEnter
         */
        function onEnter(event) {
            event.stopPropagation();
            event.preventDefault();
            if (pickerSearchBar.is(':focus')) {
                TAG.Util.searchData(pickerSearchBar.val(), '.compHolder', IGNORE_IN_SEARCH);
            } else if (confirmButton.is(':disabled')) {
                cancelButton.click();
            }
            else {
                progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
                finalizeAssociations();
                globalKeyHandler[0] = currentKeyHandler;
            }            
        }

        var cancelButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelButton.css({
            'margin': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'color': 'white',
            'padding-left': '1%',
            'padding-right': '1%',
            'background-color': 'black',
            'position': 'relative',
            'float': "right",
            'margin-right': '3%'
        });

        cancelButton.text('Cancel');
        cancelButton.on('click', function () {
            $('.compHolder').off();
            cancelButton.attr('disabled', true).css({ 'color': 'rgba(255, 255, 255, 0.5)' });
            confirmButton.attr('disabled', true).css({ 'color': 'rgba(255, 255, 255, 0.5)' });
            pickerOverlay.fadeOut(function () { 
                pickerOverlay.empty(); 
                pickerOverlay.remove(); 
            }); //Josh L -- fix so the div actually fades out
            globalKeyHandler[0] = currentKeyHandler;
        });

        optionButtonDiv.append(cancelButton);
        optionButtonDiv.append(confirmButton);

        picker.append(optionButtonDiv);

        tabHelper(0)(); // load first tab
        confirmButton.prop('disabled', true);
        confirmButton.css('opacity', '0.4');

        $('#mainThumbnailContainer').on('click', function (event) {
            confirmButton.prop('disabled', false);
            confirmButton.css('opacity', '1');
        });

        // helper functions

        // click handler for tabs
        function tabHelper(j) {            
            return function () {                
                loadQueue.clear();
                progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
                pickerSearchBar.attr("value", "");
                pickerSearchBar.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });
                mainContainer.empty();
                $(".tab").css({
                    'border-top': '1px solid black',
                    'border-right': '1px solid black',
                    'border-left': '1px solid black',
                    'border-bottom': '1px solid white'
                });
                $("#tab" + j).css({
                    'border-top': '1px solid white',
                    'border-right': '1px solid white',
                    'border-left': '1px solid white',
                    'border-bottom': '1px solid black'
                });
                if (!tabCache[j].cached) {
                    var tabArgs = (tabs[j].args || []).concat([function (comps) {
                        tabCache[j].cached = true;
                        tabCache[j].comps = comps;
                        success(comps);
                    }, error, cacheError]);
                    tabs[j].getObjs.apply(null, tabArgs);
                } else {
                    success(tabCache[j].comps); // used cached results if possible
                }

            }
        }

        function success(comps) {
            var newComps = [];
            for (var i = 0; i < comps.length; i++) {
                if (!(type === 'artwork' && comps[i].Metadata.Type === 'VideoArtwork')) {
                    newComps.push(comps[i]);
                }
            }
            drawComps(newComps, compSingleDoubleClick);
            TAG.Util.removeProgressCircle(progressCirc);
        }

        function error() {
            console.log("ERROR IN TABHELPER");
        }

        function cacheError() {
            error();
        }

        /** 
         * Creates the media panel
         * @param compArray   the list of media to appear in the panel
         * @param applyClick  function to add handlers to each holder element
         */
        function drawComps(compArray, applyClick) {
            if (compArray) {
                addedComps.length = 0;
                addedCompsObjs.length = 0;
                removedComps.length = 0;
                compArray.sort(function (a, b) {
                    return (a.Name.toLowerCase() < b.Name.toLowerCase()) ? -1 : 1;
                });
                for (var i = 0; i < compArray.length; i++) {
                    loadQueue.add(drawComp(compArray[i], applyClick),i);
                }
            }
        }

        function drawComp(comp, applyClick,i) {
            return function () {
                var compHolder = $(document.createElement('div'));
                compHolder.addClass("compHolder");
                compHolder.attr('id', comp.Identifier); // unique identifier for this media
                compHolder.data({
                    'type': comp.Metadata.ContentType,
                    'guid': comp.Identifier,
                    'name': comp.Name,
                    'duration': comp.Metadata.Duration,
                    'comp': comp,
                    'year': comp.Metadata.Year,
                    'artist': comp.Metadata.Artist
                });
                var isSelected = (origComps.indexOf(comp.Identifier) >= 0);//selectedArtworksUrls[compArray[i].Metadata.Source] ? true : false;
                if (isSelected) {
                    console.log("is selected");
                }
                compHolder.data('selected', isSelected);
                compHolder.css({
                    float: 'left',
                    background: isSelected ? '#999' : '#222',
                    width: '15%',
                    height: '35%',
                    padding: '1%',
                    //'padding-bottom': '0%',
                    margin: '1%',
                    'text-align': 'center',
                    border: '1px solid white',
                    color: 'white'
                });
                mainContainer.append(compHolder);

                // create the thumbnail to show in the media holder
                var imgHolderDiv = $(document.createElement('div'));
                imgHolderDiv.addClass('compHolderDiv');
                imgHolderDiv.css({
                    "position": 'relative',
                    "height": "75%",
                    "margin": "2%",
                    "width":"96%"
                });
                compHolder.append(imgHolderDiv);

                var compHolderImage = $(document.createElement('img')); // change to img for image
                compHolderImage.addClass('compHolderImage');

                var typeIndicatorImage = $(document.createElement('img')); // to hold a tour or video icon
                typeIndicatorImage.addClass('typeIndicatorImage');

                var FIXPATH = TAG.Worktop.Database.fixPath;
                var shouldAppendTII = false;

                if (comp.Metadata.ContentType === 'Audio') {
                    compHolderImage.attr('src', tagPath+'images/audio_icon.svg');
                } else if (comp.Metadata.ContentType === 'Video' || comp.Type === 'Video' || comp.Metadata.Type === 'VideoArtwork') {
                    compHolderImage.attr('src', (comp.Metadata.Thumbnail && !comp.Metadata.Thumbnail.match(/.mp4/)) ? FIXPATH(comp.Metadata.Thumbnail) : tagPath+'images/video_icon.svg');
                    //shouldAppendTII = true;
                    //typeIndicatorImage.attr('src', tagPath+'images/icons/catalog_video_icon.svg');
                } else if (comp.Metadata.ContentType === 'Image' || comp.Type === 'Image') {
                    var imageSrc;
                    if (comp.Metadata.Thumbnail) {
                        imageSrc=FIXPATH(comp.Metadata.Thumbnail)
                    } else if (comp.Metadata.Source) {
                        imageSrc = FIXPATH(comp.Metadata.Source)
                    } else {
                        imageSrc = tagPath + 'images/image_icon.svg';
                    }
                    compHolderImage.attr('src', imageSrc);
                } else if (comp.Metadata.ContentType === 'iframe') {
                    compHolderImage.attr('src', tagPath + 'images/video_icon.svg'); // TODO iframe fix this with new icon
                } else if (comp.Type === 'Empty' || comp.Metadata.ContentType === "Tour") { // tours....don't know why the type is 'Empty'
                    compHolderImage.attr('src', comp.Metadata.Thumbnail ? FIXPATH(comp.Metadata.Thumbnail) : tagPath + 'images/icons/catalog_tour_icon.svg');
                    shouldAppendTII = true;
                    typeIndicatorImage.attr('src', tagPath + 'images/icons/catalog_tour_icon.svg');
                } else {//text associated media without any media...
                    compHolderImage.attr('src', tagPath + 'images/text_icon.svg');
                }

                // if (compHolderImage.height() / compHolderImage.width() > 1) {
                //     compHolderImage.css({
                //         'width': 'auto',
                //         'height': '100%',
                //     });
                // } else {
                //     compHolderImage.css({
                //         'height': 'auto',
                //         'width': '100%',
                //     });
                // }
                compHolderImage.css({
                    'max-height': '100%',
                    'position': 'absolute',
                    'left': '0',
                    'right': '0',
                    'top': '0',
                    'bottom': '0',
                    'margin': 'auto',
                    'display': 'block',
                    'max-width': '100%',
                    width: 'auto',
                });
                if (i < 30) {
                    $(".compHolderImage").css({
                        'max-height': '100%',
                        //'position': 'absolute',
                        //'left': '0',
                        //'right': '0',
                        //'top': '0',
                        //'bottom': '0',
                        //'margin': 'auto',
                        //'display': 'block',
                        'max-width': '100%',
                        width: 'auto',
                        //height: 'auto'
                    });
                }
                // compHolderImage.removeAttr('width');
                // compHolderImage.removeAttr('height');
                imgHolderDiv.append(compHolderImage);

                if (shouldAppendTII) {
                    typeIndicatorImage.css({
                        'position': 'absolute',
                        'width': '20%',
                        'height': 'auto',
                        'left': '75%',
                        'bottom': '5%',
                        'z-index': 2
                    });
                    typeIndicatorImage.removeAttr('width');
                    typeIndicatorImage.removeAttr('height');
                    imgHolderDiv.append(typeIndicatorImage);
                }

                // create the text to show in the media holder
                var compHolderText = $(document.createElement('div'));
                compHolderText.addClass('compHolderText');
                //trims off long names
                var name = comp.Name;
                //if (comp.Name.length > 24) { // we should do this in a more flexible way.... TODO JL
                //    name = comp.Name.slice(0, 24) + "...";
                //} else {
                //    name = comp.Name;
                //}

                compHolderText.text(name);
                compHolderText.css({
                    'padding-left': '3%',
                    'font-size': '70%',
                    //'margin' :'0% 2% 0% 2%',
                    'overflow': 'hidden',
                    //'overflow-y': 'visible',
                    'text-overflow': 'ellipsis',
                    'white-space': 'nowrap',
                    'height': '22%',
                    'color':'white'
                });
                compHolder.append(compHolderText);
                applyClick(compHolder); // binds handlers
            }
        }

        //single clicking on associated media selects it, to be imported
        function compSingleClick(e, compHolder) {
            var guid = compHolder.data('guid'),
                index = origComps.indexOf(guid),
                addedIndex;
                
            if (compHolder.data("selected")) {
                compHolder.data("selected", false);
                compHolder.css('background', '#222');
                if(index >= 0) {
                    removedComps.push(guid)
                } else {
                    addedIndex = addedComps.indexOf(guid);
                    addedComps.splice(addedIndex, 1);
                    addedCompsObjs.splice(addedIndex, 1);
                }
            }
            else {
                compHolder.data("selected", true);
                compHolder.css('background', '#999');
                if (index >= 0) {
                    removedComps.remove(guid);
                } else {
                    addedComps.push(guid);
                    addedCompsObjs.push(compHolder.data('comp'));
                }
            }
            //console.log("added length = " + addedComps.length);
            //console.log("remove length = " + removedComps.length);
            //console.log("orig length = " + origComps.length + "\n");
        }

        // double clicking on associated media will import all selected media
        function compDoubleClick(evt, compHolder) {
            var guid = compHolder.data('guid'),
                index = origComps.indexOf(guid);
            compHolder.css('background', '#999');
            if (compHolder.data('selected') !== true) {
                if (index >= 0) {
                    removedComps.remove(guid)
                } else {
                    addedComps.push(guid);
                    addedCompsObjs.push(compHolder.data('comp'));
                }
                compHolder.data("selected", true);
            }
            finalizeAssociations();
        }

        //this handles discriminating between the double and single clicks for importing media
        //cleans up bugs where both click events were firing and media would import twice
        function compSingleDoubleClick(compHolder) {
            compHolder.click(function (evt) {
                var that = this;
                setTimeout(function () {
                    var dblclick = parseInt($(that).data('double'), 10);
                    if (dblclick > 0) {
                        $(that).data('double', dblclick - 1);
                    } else {
                        compSingleClick.call(that, evt, compHolder);
                    }
                }, 300);
            });
            //.dblclick(function (evt) {
            //    $(this).data('double', 2);
            //    compDoubleClick.call(this, evt, compHolder);
            //});
        }

        // adds media as an associated media of each artwork in artworks
        function finalizeAssociations() {
            var options = {};

            // only update recentlyAssociated if the target is an artwork and we're managing an artwork-media assoc
            if (type === 'artwork' && target.type === 'artwork') {
                for (var i = 0; i < addedComps.length; i++) {
                    if (recentlyAssociatedGUIDs.indexOf(addedComps[i]) < 0) {
                        recentlyAssociatedGUIDs.push(addedComps[i]);
                        recentlyAssociated.push(addedCompsObjs[i]);
                    }
                }
            }

            if (addedComps.length) {
                options.AddIDs = addedComps.join(",");
            }
            if (removedComps.length) {
                options.RemoveIDs = removedComps.join(",");
            }
            if (addedComps.length || removedComps.length) {
                if (type === 'artwork' && target.type === 'artwork') {
                    TAG.Worktop.Database.changeArtwork(target.comp.Identifier, options, function () { // SUCCESS HANDLER
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        // AUTH ERROR HANDLER
                        console.log(err.message);
                    }, function (err) {
                        // CONFLICT HANDLER
                        console.log(err.message);
                    }, function (err) {
                        // GENERAL ERROR HANDLER
                        console.log(err.message);
                    });
                } else if (type === 'artwork' && target.type === 'media') {
                    TAG.Worktop.Database.changeHotspot(target.comp.Identifier, options, function () { // TODO (Add/RemoveIDs for changeHotspot)
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    });
                } else if (type === 'exhib' && target.type === 'exhib') {
                    TAG.Worktop.Database.changeExhibition(target.comp.Identifier, options, function() {
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    });
                }
            } else {
                callback();
                pickerOverlay.fadeOut();
                pickerOverlay.empty();
                pickerOverlay.remove();
            }
            if (type === "exhib" && target.type === "exhib") {
                var progressCircCSS = {
                    'position': 'absolute',
                    'left': '40%',
                    'top': '40%',
                    'z-index': '50',
                    'height': 'auto',
                    'width': '20%'
                };
                var viewer = $("#setViewViewer");
                var vert = viewer.height() / 2;
                var horz = viewer.width() / 2;
                var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, horz, vert, true);
            }
            pickerOverlay.fadeOut();
            pickerOverlay.empty();
            pickerOverlay.remove();
        }
    }

    function getRecentlyAssociated(callback) {
        callback(recentlyAssociated);
    }


    //var containerCSS = { // css for an entire container
    //    'width': '20%',
    //    'float': 'left',
    //    'text-align': 'center'
    //};

    //var thumbnailCSS = { // css for the thumbnail in a container
    //    'position': 'absolute',
    //    'width': '90%', // height will be set dynamically to be square
    //    'left': '5%',
    //    'top': '5%'
    //};

    //var metadataCSS = { // css for title/artist/year metadata div
    //    'position': 'absolute',
    //    'width': '90%',
    //    'left': '5%',
    //    'top': '2%',
    //    'text-overflow': 'ellipsis',
    //    'overflow': 'hidden',
    //    'white-space': 'nowrap'
    //};

    //var progressCircCSS = { // css for entity loading circles
    //    'position': 'absolute',
    //    'left': '5%',
    //    'z-index': '50',
    //    'height': 'auto',
    //    'top': '18%',
    //    'width': '10%',
    //};

    //function setHeight($elt) {
    //    var w = $elt.width();
    //    $elt.css("height", w + "px");
    //}

    ///**
    // * Creates a container for an entity, to be called by createAssociationPicker
    // * @param comp           object: component object from the server
    // * @param type           string: 'exhib', 'artwork', 'media'
    // * @param onclick        handler: click handler for the container
    // * @param selected       boolean: is the container already selected
    // * @return               object: returns the container as a jquery object
    // */
    //function createHolderButton(comp, type, onclick, selected) {
    //    var container = $(document.createElement('div'));
    //    container.addClass('pickerButton');
    //    container.css(containerCSS);
    //    var thumbnail = $(document.createElement('img'));
    //    var metadataDiv = $(document.createElement('div'));

    //    switch (type) {
    //        case 'exhib':
    //            break;
    //        case 'artwork':
    //            container.data({
    //                name: comp.Name,
    //                artist: comp.Metadata.Artist,
    //                year: comp.Metadata.Year,
    //                selected: selected
    //            });
    //            thumbnail.attr('src', TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail));
    //            metadataDiv.html(comp.Name + '<br />' + comp.Metadata.Artist + " (" + comp.Metadata.Year + ")");
    //            break;
    //        case 'media':
    //            container.data({
    //                name: comp.title,
    //                selected: selected
    //            });
    //            thumbnail.attr('src', TAG.Worktop.Database.fixPath(comp.source));
    //            metadataDiv.html(comp.title);
    //            break;
    //        default:
    //            break;
    //    }

    //    container.on('mousedown', function () {
    //        container.css({
    //            'background': 'white',
    //        });
    //    });
    //    container.on('mouseup', function () {
    //        container.css({
    //            'background': 'transparent',
    //        });
    //    });
    //    container.on('mouseleave', function () {
    //        container.css({
    //            'background': 'transparent',
    //        });
    //    });
    //    container.on('click', function (evt) {
    //        evt.stopPropagation();
    //        container.data("selected", !container.data("selected"));
    //    });

    //    thumbnail.css(thumbnailCSS);
    //    setHeight(thumbnail);
    //    container.append(thumbnail);

    //    var circle = TAG.Util.showProgressCircle(container, progressCircCSS, '0px', '0px', false);
    //    image.load(function () {
    //        TAG.Util.removeProgressCircle(circle);
    //    });

    //    metadataDiv.css(metadataCSS);
    //    container.append(metadataDiv);

    //    return container;
    //}

    /**
     * Creates a dialog that displays a link to the current page (for use in web app only).
     * @method showPageLink
     * @param {String} baseurl         
     * @param {Object} params          URL params to include
     */
    function showPageLink(baseurl, params) {
        var overlay      = $(document.createElement('div')),
            container    = $(document.createElement('div')),
            linkLabel    = $(document.createElement('label')),
            linkInput    = $(document.createElement('input')),
            buttonRow    = $(document.createElement('div')),
            cancelButton = $(document.createElement('button')),
            tagContainer = $('#tagRoot'),
            text         = baseurl.split(/#/)[0] + '#',
            paramNum     = 0,
            key;

        params = params || {};

        overlay.attr('id', 'linkDialogOverlay');
        overlay.css({
            display: 'none',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'background-color': 'rgba(0,0,0,0.6)',
            'z-index': 10000000,
        });

        container.addClass('linkDialogContainer');
        container.css({
            position: 'absolute',
            left: '20%',
            top: '25%',
            width: '62%',
            border: '3px double white',
            'background-color': 'black',
        });

        overlay.append(container);
        overlay.on('click', closeLinkOverlay);
        container.on('click', function(evt){
            evt.stopPropagation();
        });

        linkInput.addClass('linkDialogInput');
        linkInput.css({
            'border-color': 'gray',
            'color': 'gray',
            'font-size': '1.3em',
            'position': 'relative',
            'margin-top': '20px',
            'min-width': 0,
            'left': '10%',
            'width': '80%'
        });

        //Read-only link
        linkInput.attr('readonly', true);

        for(key in params) {
            if(params.hasOwnProperty(key) && (params[key] || params[key] === false)) {
                text += ((paramNum++) > 0 ? '&' : '') + key + '=' + params[key];
            }
        }
        if(!params.tagserver) {
            text += ((paramNum++) > 0 ? '&' : '') + 'tagserver=' + localStorage.ip;
        }

        linkInput.attr({
            'value':       text,
            'placeholder': 'No page link available'
        });

        buttonRow.css({
            'margin': '20px 0px 20px 0px',
            'position': 'relative',
            'width': '80%',
            'left': '10%',
            'text-align': 'center',
            'display': 'inline-block'
        });

        cancelButton.css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
            'margin-right': '-2%',
            'display': 'inline-block',
        });
        cancelButton.text('Close');
        cancelButton.on('click', closeLinkOverlay);

        function closeLinkOverlay() {
            overlay.fadeOut(500, function() {
                overlay.remove();
            });
        }

        container.append(linkInput);
        
        container.append(buttonRow);
        buttonRow.append(cancelButton);

        return overlay;
    }

})();

/**
 * Some common functionality between the rich location editing and
 * viewing interfaces
 * @method TAG.Util.RLH
 * @param {Object} input           a couple input options
 *         {Doq}         artwork        artwork doq
 *         {jQuery obj}  root           root of current page
 *         {Boolean}     authoring      whether we're in authoring mode
 */
TAG.Util.RLH = function (input) {
    var artwork = input.artwork, // artwork doq
        root = input.root,       // root of current page
        bingMapHelper,       // helper object for Bing map
        customMapHelper,     // helper object for custom maps
        richLocationData,    // object containing rich location data (e.g., 
        currentIndex,        // current map being shown
        mapGuids = [],       // list of map guids, including bing map, the first one is bing Map and null
        mapDoqs = {},        // dictionary of map doqs, not including bing map, keyed by map guid
        defaultMapShown,     // whether bing map is shown
        locations,           // list of locations
        mapHolders = {},     // dictionary of map holder divs, keyed by mapguid
        annotImgs = {},      // object of annotated images corresponding to custom map deepzoom images (keyed by map guid)
        map,                 // bing map
        pushpins = [],       // used to iterate through pushpins
        disabledOverlay,     // overlay on default (bing) map holder if it's disabled
        importDisabledOverlay,
        formIsEnabled,       // form is currently being displayed
        isEditForm,          // edit location form is open (as opposed to add location form)
        importingMap,        // used to show the correct map after importing 

        locationPanelDiv,    // outer container for whole location history UI
        locationPanel,       // holds content of location history UI

        topRegion,           // contains map name and dots
        metadataContainer,   // map name container div
        nameInput,           // input element for map name
        additionalInfoInput, // input element for additional map info (e.g., date)
        //mapDescriptionInput, // input element for a short map description
        saveMapButton,       // button for saving metadata changes to a map

        mapRegion,           // contains map, arrows
        leftArrowContainer,  // contains left arrow
        leftArrowButton,     // shows previous map if any
        mapContainer,        // map container div (contains all map holders)
        rightArrowContainer, // contains right arrow
        rightArrowButton,    // shows next map if any

        buttonsRegion,       // contains buttons
        buttonsRegionDisabled,
        addLocationButton,   // button for adding new location
        sortLocationsByTitleButton, // sorts the locations by title
        sortLocationsByDateButton, // sorts the locations by date
        dotsContainer,       // dots container div
        deleteButton,        // delete/hide/show map button
        importMapButton,     // import map button

        locationsRegion;     // contains location list

    if (!artwork || !root) {
        console.log("need to provide input.artwork and input.root");
        return;
    }

    return {
        init: init
    };

    /**
     * Initializes rich location history editing (called only once). Grabs
     * artwork.Metadata.RichLocationHistory (or converts old artwork.Metadata.Location
     * object to new format), builds UI, and shows the first map.
     * @method init
     */
    function init() {
        // get data and initialize maps and locations
        richLocationData = artwork.Metadata.RichLocationHistory ? JSON.parse(unescape(artwork.Metadata.RichLocationHistory)) : locationToRichLocation(artwork.Metadata.Location);
        locations = richLocationData.locations || [];
        defaultMapShown = richLocationData.defaultMapShown;
        currentIndex = 0;
        if (!IS_WINDOWS) {
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = 'http://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&onscriptload=DrawMap';
            document.getElementsByTagName('head')[0].appendChild(script);
        }
        bingMapHelper = BingMapHelper();
        customMapHelper = CustomMapHelper();
        importingMap = false;
        isEditForm = false;

        // initialize UI (most of this should be done in JADE/STYL in web app)
        locationPanelDiv = $(document.createElement('div'))
                        .attr('id', 'locationHistoryOuterContainer')
                        .css({
                            position: 'absolute',
                            top: '12%',
                            left: input.authoring?'20%':'22%',
                            width: '65%',
                            height: '85%',
                            display: 'none',
                            'z-index': '51'
                        })
                        .appendTo(root);

        locationPanel = $(document.createElement('div'))
                        .attr('id', 'locationHistoryContainer')
                        .css({
                            display:'inline-block',
                            position: 'relative',
                            width: '100%',
                            height: '100%',
                            top: '0%',
                            left: '0%',
                            'z-indez': 99,
                            "border-top-right-radius": "3.5px",
                            "border-bottom-right-radius": "3.5px",
                            'background-color': 'rgba(0,0,0,0.75)'
                        })
                        .appendTo(locationPanelDiv);

        topRegion = $(document.createElement('div'))
                    .attr('id', 'locationHistoryTopRegion')
                    .css({
                        position: 'relative',
                        width: '100%',
                        height: '7%',
                        'font-size': '.5em'
                    })
                    .appendTo(locationPanel);

        metadataContainer = $(document.createElement('div'))
                        .attr('id', 'locationHistoryMetadataContainer')
                        .css({
                            position: 'absolute',
                            'width': '80%',
                            'height': '80%',
                            'top': '10%',
                            'left': '10%',
                            'display':'block'
                        })
                        .appendTo(topRegion);

        if (input.authoring) {
            nameInput = $(document.createElement('input'))
                    .attr({
                        id: 'locationHistoryNameInput',
                        placeholder: 'Map name'
                    })
                    .css({
                        position: 'relative',
                        width: '35%',
                        height: '60%',
                        'max-height':'60px',
                        top: '20%',
                        'font-size':'110%'
                    })
                    .appendTo(metadataContainer);
            /*nameInput.on('keyup', function () {
                var txt = (nameInput && nameInput[0] && nameInput[0].value) ? nameInput[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if (nameInput && nameInput[0] && nameInput[0].value && nameInput[0].value != txt) {
                    nameInput[0].value = txt;
                }
            });*/
            additionalInfoInput = $(document.createElement('input'))
                        .attr({
                            id: 'locationHistoryAdditionalInfoInput',
                            placeholder: 'Date',
                            maxlength:'15'
                        })
                        .css({
                            position: 'relative',
                            'margin-left': '10px',
                            width: '20%',
                            height: '60%',
                            'max-height': '60px',
                            top: '20%',
                            'font-size': '110%'
                        })
                        .appendTo(metadataContainer);
            /*additionalInfoInput.on('keyup', function () {
                var txt = (additionalInfoInput && additionalInfoInput[0] && additionalInfoInput[0].value) ? additionalInfoInput[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if (additionalInfoInput && additionalInfoInput[0] && additionalInfoInput[0].value && additionalInfoInput[0].value != txt) {
                    additionalInfoInput[0].value = txt;
                }
            });*/
            saveMapButton = $(document.createElement('button'))
                            .attr({
                                id: 'locationHistorySaveMapButton',
                                type: 'button'
                            })
                            .css({
                                position: 'relative',
                                'margin-left': '10px',
                                top: '20%',
                                height: '60%',
                                'max-height': '60px',
                            })
                            .text('Save')
                            .appendTo(metadataContainer);
            saveMapButton.on('click', saveCurrentMapMetadata);
        } else {
            nameInput = $(document.createElement('div'))
                    .attr({
                        id: 'locationHistoryNameHolder'
                    })
                    .css({
                        'font-size': '2.5em',
                        position: 'absolute',
                        top: '15%',
                        height: '90%',
                        width:'100%',
                        'text-overflow': 'ellipsis',
                        'overflow': 'hidden',
                        'white-space': 'nowrap',
                        'display':'block'
                    })
                    .appendTo(metadataContainer);

            additionalInfoInput = $(document.createElement('div'))
                        .attr({
                            id: 'locationHistoryAdditionalInfoHolder'
                        })
                        .css({
                            'font-size': '2.5em',
                            position: 'absolute',
                            top: '15%',
                            right: '0%',
                            height: '90%'
                        })
                        .appendTo(metadataContainer);
        }

        mapRegion = $(document.createElement('div'))
                    .attr('id', 'locationHistoryMapRegion')
                    .css({
                        position: 'relative',
                        width: '100%',
                        height: '49%'
                    })
                    .appendTo(locationPanel);

        leftArrowContainer = $(document.createElement('div'))
                    .attr('id', 'locationHistoryLeftArrowContainer')
                    .css({
                        position: 'absolute',
                        width: '10%',
                        height: '100%'
                    })
                    .appendTo(mapRegion);

        leftArrowButton = $(document.createElement('img'))
                    .attr('id', 'locationHistoryLeftArrowButton')
                    .attr('src', tagPath+'images/icons/Left.png')
                    .css({
                        position: 'absolute',
                        width: '13px',
                        height: 'auto',
                        right: '10%',
                        top: '50%',
                        cursor: 'pointer'
                    })
                    .appendTo(leftArrowContainer)

        mapContainer = $(document.createElement('div'))
                    .attr('id', 'locationHistoryMapContainer')
                    .css({
                        top:'2%',
                        position: 'absolute',
                        width: '80%',
                        height: '100%',
                        left: '10%',
                        'border': '1px solid white',
                        'background-color': 'rgba(0,0,0,0.8)'
                    })
                    .appendTo(mapRegion);

        rightArrowContainer = $(document.createElement('div'))
                    .attr('id', 'locationHistoryRightArrowContainer')
                    .css({
                        position: 'absolute',
                        width: '10%',
                        height: '100%',
                        left: '90%'
                    })
                    .appendTo(mapRegion);

        rightArrowButton = $(document.createElement('img'))
                    .attr('id', 'locationHistoryRightArrowButton')
                    .attr('src', tagPath+'images/icons/Right.png')
                    .css({
                        position: 'absolute',
                        width: '13px',
                        height: 'auto',
                        left: '10%',
                        top: '50%',
                        cursor: 'pointer'
                    })
                    .appendTo(rightArrowContainer)

        disabledOverlay = $(document.createElement('div'))
                    .attr('id', 'defaultMapDisabledOverlay')
                    .css({
                        'background-color': 'rgba(0,0,0,0.85)',
                        'color': 'white',
                        'font-size': '20px',
                        'height': '100%',
                        'position': 'absolute',
                        'text-align': 'center',
                        'top': '0%',
                        'width': '100%'
                    })
                    .text('Bing map is disabled.');

        importDisabledOverlay = $(document.createElement('div'))
                    .attr('id', 'importDisabledOverlay')
                    .css({
                        'background-color': 'rgba(0,0,0,0.5)',
                        'color': 'white',
                        'font-size': '30px',
                        'height': '100%',
                        'position': 'absolute',
                        'vertical-align':'middle',
                        'text-align': 'center',
                        'top': '0%',
                        'z-index': '1000',
                        'display': 'block',
                        width: '100%',
                        height: '100%',
                        left: '0%',
                    })
                    .append($(document.createElement('div'))
                        .css({
                            'top': '30%',
                            'position':'relative'
                        })
                        .text('Loading...')
                    );

        if (input.authoring) {

            dotsContainer = $(document.createElement('div'))
                    .attr('id', 'locationHistoryDotsContainer')
                    .css({
                        'margin-left': 'auto',
                        'margin-right': 'auto',
                        'margin-top': '5px',
                        'margin-bottom': '5px',
                        //'width': '30%',
                        'height': '30px',
                        'top': '100%',
                        'text-align': 'center',
                        display: 'block',
                    })
                    .appendTo(locationPanel);

        }

        buttonsRegion = $(document.createElement('div'))
                    .attr('id', 'locationHistoryButtonsRegion')
                    .css({
                        position: 'relative',
                        left: '10%',
                        width: '80%',
                        top: '0%',
                        height: '6%',
                        'margin-bottom': '0%'
                    })
                    .appendTo(locationPanel);

        buttonsRegionDisabled = $(document.createElement('div'))
                    .attr('id', 'locationHistoryButtonsRegionDisabled')
                    .css({
                        position: 'absolute',
                        left: '0',
                        width: '100%',
                        top: '0%',
                        height: '100%',
                        'z-index': '100000',
                        'display': 'none',
                        'background-color': 'rgba(0,0,0,0.01)',
                    })
                    .appendTo(buttonsRegion);

        if (input.authoring) {
            addLocationButton = $(document.createElement('button'))
                        .attr({
                            'id': 'locationHistoryAddLocationButton',
                            'type': 'button'
                        })
                        .css({
                            position: 'relative',
                            float: 'left'
                        })
                        .appendTo(buttonsRegion)
                        .text('Add Location').css('border-radius', '3.5px');
            sortLocationsByTitleButton = $(document.createElement('button'))
                        .attr({
                            'id': 'locationHistorySortLocationsByTitleButton',
                            'type': 'button'
                        })
                        .css({
                            position: 'relative',
                            'margin-left': '10px',
                            float: 'left'
                        })
                        .appendTo(buttonsRegion)
                        .text('Sort By Title').css('border-radius', '3.5px');
            sortLocationsByDateButton = $(document.createElement('button'))
                        .attr({
                            'id': 'locationHistorySortLocationsByDateButton',
                            'type': 'button'
                        })
                        .css({
                            position: 'relative',
                            'margin-left': '10px',
                            float: 'left'
                        })
                        .appendTo(buttonsRegion)
                        .text('Sort By Date').css('border-radius', '3.5px');

            importMapButton = $(document.createElement('button'))
                    .attr({
                        'id': 'locationHistoryImportMapButton',
                        'type': 'button'
                    })
                    .css({
                        position: 'relative',
                        float: 'right'
                    })
                    .appendTo(buttonsRegion)
                    .text('Import Map').css('border-radius', '3.5px');

            deleteButton = $(document.createElement('button'))
                        .attr({
                            'id': 'locationHistoryDeleteButton',
                            'type': 'button'
                        })
                        .css({
                            position: 'relative',
                            'margin-right': '10px',
                            float: 'right'
                        })
                        .text('Delete Map')
                        .appendTo(buttonsRegion).css('border-radius', '3.5px');



            importMapButton.on('click', importMap);
            deleteButton.on('click', function (evt) {
                var mapName = function () {
                    if (mapGuids[currentIndex]) {
                        if (mapDoqs[mapGuids[currentIndex]].Name.length > 14) {
                            return "'" + mapDoqs[mapGuids[currentIndex]].Name.substring(0, 14) + '...' + "'";
                        } else {
                            return "'" + mapDoqs[mapGuids[currentIndex]].Name + "'";
                        }
                    } else {
                        return 'Custom Map';
                    }
                }();
                if (!(currentIndex === 0)) { //if it's not the bing map being displayed, confirm the deletion
                    var overlay = TAG.Util.UI.PopUpConfirmation(function () {
                        deleteMap();
                    }, "Are you sure you want to delete " + mapName + " and all locations associated with it?", "Yes");
                    root.append(overlay);
                    $(overlay).show();
                    evt.stopPropagation();
                } else {
                    deleteMap(); //hides bing map
                };
            });
            addLocationButton.on('click', addLocation);
            sortLocationsByTitleButton.on('click', sortLocationsByTitle);
            sortLocationsByDateButton.on('click', sortLocationsByDate);
        } else {
            dotsContainer = $(document.createElement('div'))
                            .attr('id', 'locationHistoryDotsContainer')
                            .css({
                                position: 'absolute',
                                'width': '40%',
                                'height': '50%',
                                'top': '50%',
                                'left': '30%',
                                'text-align': 'center'
                            })
                            .appendTo(buttonsRegion);
        }

        locationsRegion = $(document.createElement('div'))
                    .attr('id', 'locationHistoryLocationsRegion')
                    .css({
                        top:'1%',
                        position: 'relative',
                        width: '80%',
                        left: '10%',
                        height: '28%',
                        color: 'white',
                        'font-size': '11',
                        'font-weight': '300',
                        'overflow-y': 'auto',
                        'overflow-x': 'hidden'
                    })
                    .appendTo(locationPanel)
                    .text("No locations to display...");

        if (!(input.authoring)) {
            locationsRegion.css({
                top: '2%',
                height: '32%'
            });
        }

        // set up click handlers, etc
        leftArrowButton.on('click', function () {
            if (currentIndex - 1 >= 0) {
                showMap(mapGuids[--currentIndex]);
            } else {
                currentIndex = mapGuids.length - 1;
                showMap(mapGuids[currentIndex]);
            }
        });

        rightArrowButton.on('click', function () {
            if (currentIndex + 1 < mapGuids.length) {
                showMap(mapGuids[++currentIndex]);
            } else {
                currentIndex = 0;
                showMap(mapGuids[0]);
            }
        });

        // load in the first map in the list
        getMaps();

        return locationPanelDiv;
    }

    /**
    *Hides the Map Name field, Additional Input (date) field, and save button in the metadata container
    *Called when the Bing Map is being displayed, displays the name 'Bing Map'
    *@method hideMetadataEditingFields
    */
    function hideMetadataEditingFields() {
        nameInput.css({ visibility: 'hidden' });
        additionalInfoInput.css({ visibility: 'hidden' });
        saveMapButton && saveMapButton.css({ visibility: 'hidden' });
        $(document.createElement('div'))
            .attr({
                id: 'bingMapNameHolder'
            })
            .css({
                'font-size': '2.5em',
                'vertical-align':'middle',
                position: 'absolute',
                top: '15%',
                height: '90%',
                'z-index': '50',
                color: 'white'
            })
            .text('Bing Map')
            .appendTo(metadataContainer);
        if (!input.authoring) {
            $('#bingMapNameHolder').css({
                //top: '0%',
                //'margin-top': '-1%'
            });
        } else {
            $('#bingMapNameHolder').css({
                //'font-size': '210%',
            });
        }
    }

    /**
    *Shows the Map Name field, Additional Input (date) field, and save button in the metadata container
    *Reverses the above function, called when any map besides the bing map is displayed
    *@method showMetadataEditingFields
    */
    function showMetadataEditingFields() {
        $('#bingMapNameHolder').remove();
        nameInput.css({ visibility: 'visible' });
        additionalInfoInput.css({ visibility: 'visible' });
        saveMapButton && saveMapButton.css({ visibility: 'visible' });
    }

    /**
     * Get all the maps for the artwork
     * @method getMaps
     * @param {Function} callback      function to call when maps have been obtained and loaded
     */
    function getMaps(callback) {
        callback = callback || function () {
            if (!importingMap) { //don't display the first map if an import has just occured
                try {
                    showMap(mapGuids[currentIndex]);
                } catch (e) {
                    showMap(mapGuids[0]);
                }
            } else { //display the last one instead
                importingMap = false;
                showMap(mapGuids[mapGuids.length - 1]);
                removeLoadingOverlay();
            }
        };
        mapGuids = (defaultMapShown || input.authoring) ? [null] : [null];
        TAG.Worktop.Database.getMaps(artwork.Identifier, function (mps) {
            var mapslength = mps.length;
            if (mapslength > 0) {
                for (var i = 0; i < mapslength; i++) {
                    mapDoqs[mps[i].Identifier] = mps[i];
                    mapGuids.push(mps[i].Identifier);
                }
            }
            loadMaps(callback);
            createDots();
        }, function () {
            loadMaps(callback);
            createDots();
        }, function () {
            loadMaps(callback);
            createDots();
        });
    }

    /**
     * Loads all maps by creating holders for them within the mapContainer div.
     * @method loadMaps
     * @param {Function} callback      function to call when loading is complete
     */
    function loadMaps(callback) {
        var i,
            holder,
            m,
            img,
            progress = { // allows init functions to keep track of how many maps have loaded (call callback after all have loaded)
                total: mapGuids.length,
                done: 0
            },
            helper,
            loadCallback;

        mapHolders = {};
        mapContainer.empty(); // TODO this is inefficient, just here for rapid prototyping

        loadCallback = function () {
            callback && callback();
            createLocationList();
        };

        for (i = 0; i < mapGuids.length; i++) {
            holder = $(document.createElement('div'))
                        .addClass('locationHistoryMapHolder')
                        .css({
                            //'background-color': 'rgba(0,0,0,0.8)',
                            //'border': '1px solid white',
                            position: 'absolute',
                            width: '100%',
                            height: '100%',
                            left: '0%',
                            top: '0%',
                            'text-align': 'center',
                            display: 'none'
                        })
                        .appendTo(mapContainer);
            mapHolders[mapGuids[i]] = holder;
            helper = mapGuids[i] ? customMapHelper : bingMapHelper;
            helper.init({
                container: holder,
                mapdoq: mapDoqs[mapGuids[i]],
                progress: progress,
                loadCallback: loadCallback
            });
        }
    }

    /**
     * Saves any metadata changes to the current map
     * @method saveCurrentMapMetadata
     */
    function saveCurrentMapMetadata() {
        var progressCSS = {
            'left': '70%',
            'top': '10px',
            'width': 'auto',
            'height': '50%',
            'position': 'relative',
            'z-index': 50,
            'display': 'inline-block'
        };
        var progCirc = TAG.Util.showProgressCircle(topRegion, progressCSS);

        var index = currentIndex;
        if (mapGuids[index]) {
            TAG.Worktop.Database.changeMap(mapDoqs[mapGuids[index]], {
                Name: nameInput.val() || 'Custom Map',
                AdditionalInfo: additionalInfoInput.val(),
                //Description: mapDescriptionInput.val()
            }, function () {
                var mapName = function () {
                    if (nameInput.val()) {
                        if (nameInput.val().length > 14) {
                            return "'" + nameInput.val().substring(0, 14) + '...' + "'";
                        } else {
                            return "'" + nameInput.val() + "'";
                        }
                    } else {
                        return "'Custom Map'";
                    }
                }();
                deleteButton && deleteButton.text('Delete ' + mapName);
                TAG.Util.removeProgressCircle(progCirc);
                TAG.Worktop.Database.getDoq(mapDoqs[mapGuids[index]].Identifier, function (newMap) {
                    mapDoqs[mapGuids[index]] = newMap;
                });
            }, TAG.Util.UI.errorContactingServerPopup, function () {
                TAG.Util.removeProgressCircle(progCirc);
                TAG.Worktop.Database.getDoq(mapDoqs[mapGuids[index]].Identifier, function (newMap) {
                    mapDoqs[mapGuids[index]] = newMap;
                });
            });
        }
    }

    /**
     * Helper function to iterate through location list and call a
     * helper function for each.
     * @method iterateThroughLocations
     * @param {Function} toCall       helper method to call for each map; by
     *                                default, called with two params (loc and mapdoq)
     */
    function iterateThroughLocations(toCall) {
        var i,
            helper;

        for (i = 0; i < locations.length; i++) {
            if (!locations[i].map && !defaultMapShown && !input.authoring) {
                continue;
            }
            helper = locations[i].map ? customMapHelper : bingMapHelper;
            if (!locations[i].map || mapDoqs[locations[i].map]) { // make sure the custom map exists
                helper[toCall](locations[i], mapDoqs[locations[i].map]);
            }
        }
    }

    /**
     * Create list of locations in the bottom panel
     * @method createLocationList
     */
    function createLocationList() {
        locationsRegion.empty();
        iterateThroughLocations("createLocationItem");
    }

    /**
     * Shows the specified map holder, sets currentIndex, and deals with dot colors
     * @method showMap
     * @param {String} guid        key into mapHolders
     */
    function showMap(guid) {
        var i;

        showMetadataEditingFields(); //by default; hideMetadataEditingFields() is called later for bing map
        currentIndex = mapGuids.indexOf(guid);

        // style map dots
        $('.locationHistoryMapDot').css('opacity', '0.4'); //resets all dots to the unselected state
        $('#dot-' + guid).css('opacity', '1'); //selects the correct dot

        // show the correct map holder
        $('.locationHistoryMapHolder').css('display', 'none');
        mapHolders[guid].css('display', 'block');

        // add correct content to name and additional info fields
        if (input.authoring && mapDoqs[guid]) {
            nameInput.attr('value', mapDoqs[guid].Name || '');
            additionalInfoInput.attr('value', mapDoqs[guid].Metadata.AdditionalInfo || '');
        } else {
            nameInput.text(mapDoqs[guid] ? (mapDoqs[guid].Name || 'Custom Map') : 'Bing Map');
            additionalInfoInput.text(mapDoqs[guid] ? (mapDoqs[guid].Metadata.AdditionalInfo || '') : '');
        }

        // deal with additional Bing map styling
        if (!guid) {
            hideMetadataEditingFields(); //hide fields for the bing map
            if (!defaultMapShown) {
                mapHolders[null].append(disabledOverlay);
                deleteButton && deleteButton.text('Show Bing Map');
            } else {
                deleteButton && deleteButton.text('Hide Bing Map');
            }
        } else {
            var mapName = function () {
                if (mapDoqs[guid].Name) {
                    if (mapDoqs[guid].Name.length > 14) {
                        return "'" + mapDoqs[guid].Name.substring(0, 14) + '...' + "'";
                    } else {
                        return "'" + mapDoqs[guid].Name + "'";
                    }
                } else {
                    return 'Custom Map';
                }
            }();
            deleteButton && deleteButton.text('Delete ' + mapName);
        }
    }

    /**
     * Shows a message in the bottom region indicating that saving/loading is
     * underway.
     * @method showLoadingMessage
     * @param {String} message            an optional custom message
     */
    function showLoadingMessage(message) {
        var messageDiv = $(document.createElement('div'));

        messageDiv.css({
            color: 'white',
            'font-size': '20px',
            position: 'relative',
            'text-align': 'center',
            width: '100%'
        });
        messageDiv.text(message || 'Loading...');
        var progressCSS = {
            'left': '5%',
            'top': '15px',
            'width': '40px',
            'height': 'auto',
            'position': 'relative',
            'z-index': 50
        };
        var progCirc = TAG.Util.showProgressCircle(messageDiv, progressCSS);

        locationsRegion.empty();
        locationsRegion.append(messageDiv);
    }

    /**
     * Creates map dots (below the map)
     * @method createDots
     */
    function createDots() {
        var i,
            dot;
        dotsContainer.empty();
        for (i = 0; i < mapGuids.length; i++) {
            dot = $(document.createElement('div'))
                    .addClass('locationHistoryMapDot')
                    .attr('id', 'dot-' + mapGuids[i])
                    .css({
                        display: 'inline-block',
                        cursor: 'pointer',
                        'background-color': 'white',
                        'border': '3px solid white',
                        'border-radius': '20px',
                        'border-color': 'white',
                        width: '6px',
                        height: '6px',
                        'margin-left': '5px',
                        opacity:'1'
                    })
                    .appendTo(dotsContainer);
            dot.on('click', dotClickHelper(i));
        }
    }

    /**
     * Click handler helper for map dots (just calls showMap)
     * @method dotClickHelper
     * @param {Number} i             the index of the dot clicked
     * @return {Function}            a click handler for a map dot
     */
    function dotClickHelper(i) {
        return function () {
            currentIndex = i;
            showMap(mapGuids[i]);
        }
    }

    /**
     * Click function for addLocation Button. create a pin on the map and create
     * a location editing form.  Only one form can be displayed at a time.
     * @method addLocation
     */
    function addLocation() {
        if (!formIsEnabled) {
            formIsEnabled = true;
            var mapguid = mapGuids[currentIndex],
                helper = mapguid ? customMapHelper : bingMapHelper,
                editingFormElements = helper.createLocationEditor();

            locationsRegion.append(editingFormElements.container);
            locationsRegion.scrollTop(0);
            locationsRegion.scrollTop(editingFormElements.container.position().top+20);
        }
    }

    /**
     * Function to remove the add location form when the cancel button is clicked.
     * @method removeLocationForm
     */
    function removeLocationForm() {
        formIsEnabled = false;
        $('.locationEditingContainer').remove();
    }

    /**
     * Function to sort the locations in the list by title when the sort button is clicked.
     * @method sortLocations
     */
    function sortLocationsByTitle() {
        var l;
        var ind;
        if (!formIsEnabled) {

            //sort
            locations.sort(function (a, b) {
                return (a.title.toLowerCase() < b.title.toLowerCase()) ? -1 : 1;
            });

            //hides all location pins (prevents duplicate pins bug)
            for (l = 0; l < map.entities.getLength() ; l++) { //iterates through bing map pushpins
                map.entities.get(l).setOptions({ visible: false });
            }
            for (ind = 0; ind < pushpins.length; ind++) {
                pushpins[ind].css({display:'none'});
                //pushpins[ind].remove();
            }

            //re-creates list (for now)
            createLocationList();

            //save
            TAG.Worktop.Database.changeArtwork(artwork.Identifier, { RichLocationHistory: generateRichLocationData() }, success, error, error, error);
            function success() {}
            function error() { console.log('An error occured while saving.'); }
        }
    }

    /**
     * Function to sort the locations in the list by title when the sort button is clicked.
     * @method sortLocations
     */
    function sortLocationsByDate() {
        var l;
        var ind;
        if (!formIsEnabled) {

            //sort
            locations.sort(function (a, b) {
                return (a.date < b.date) ? -1 : 1;
            });

            //hides all location pins (prevents duplicate pins bug)
            for (l = 0; l < map.entities.getLength() ; l++) { //iterates through bing map pushpins
                map.entities.get(l).setOptions({ visible: false });
            }
            for (ind = 0; ind < pushpins.length; ind++) {
                pushpins[ind].css({ display: 'none' });
                //pushpins[ind].remove();
            }

            //re-creates list (for now)
            createLocationList();

            //save
            TAG.Worktop.Database.changeArtwork(artwork.Identifier, { RichLocationHistory: generateRichLocationData() }, success, error, error, error);
            function success() { }
            function error() { console.log('An error occured while saving.'); }

        }
    }

    /**
     * For backwards compatibility, translates an artwork.Location property to an
     * artwork.RichLocationHistory property
     * @method locationToRichLocation
     * @param {String} locationData           old location data to transform
     * @return {Object}                       properly formatted rich location data
     */
    function locationToRichLocation(locationData) {
        var parsedData = (typeof (locationData) === "string") ? JSON.parse(unescape(locationData)) : locationData,
            locs = [],
            loc,
            i;

        for (i = 0; i < parsedData.length; i++) {
            loc = parsedData[i];
            locs.push({
                map: null,
                latitude: (loc.resource && loc.resource.point && loc.resource.point.coordinates && loc.resource.point.coordinates[0]) ? loc.resource.point.coordinates[0] : 0,
                longitude: (loc.resource && loc.resource.point && loc.resource.point.coordinates && loc.resource.point.coordinates[1]) ? loc.resource.point.coordinates[1] : 0,
                title: loc.address || '',
                date: (loc.date === "string") ? loc.date : '', // TODO maybe do some parsing here
                description: loc.info || ''
            });
        }

        return {
            defaultMapShown: true,
            locations: locs
        };
    }

    /**
     * Some helper functions for the Bing map. The idea is to have BingMapHelper
     * and CustomMapHelper implement the same interface, so manipulating location data can
     * be generic
     * @method BingMapHelper
     */
    function BingMapHelper() {
        var pushpin,
            credentials = "AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj"; // bing maps credentials

        /**
         * Makes the map, creates pushpin, etc
         * @method init
         * @method {Object} input        some input options
         *             container:        container of the bing map
         *             progress:         an object allowing us to keep track of how many of all maps have loaded 
         *             loadCallback:     callback function to call if this is the last map to load
         */
        function init(input) {

            // load bing map
            
            if (IS_WINDOWS) {
                Microsoft.Maps.loadModule('Microsoft.Maps.Map', {
                    callback: initMap
                });
            } else {
                Microsoft.Maps.loadModule('Microsoft.Maps.Themes.BingTheme', {
                    callback: initMap
                });
            }

            /**
             * Callback function to initiailize bing map
             * @method initMap
             */
            function initMap() {
                var mapOptions = {
                    credentials: credentials,
                    mapTypeID: Microsoft.Maps.MapTypeId.road,
                    showScalebar: true,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    showDashboard: false,
                    showMapTypeSelector: false,
                    zoom: 2,
                    center: new Microsoft.Maps.Location(20, 0)
                };

                map = new Microsoft.Maps.Map(input.container[0], mapOptions);

                map.setView({
                    mapTypeId: Microsoft.Maps.MapTypeId.road
                });

                if (++input.progress.done >= input.progress.total) {
                    input.loadCallback && input.loadCallback();
                }
            }
        }

        /**
         * Draws a pushpin using the input location. Note that this is a location object
         * from artwork.Metdata.RichLocationHistory.locations.
         * @method drawPushpin
         * @param {Object} options       some input options
         *          {Object} location      location data for pushpin
         *          {Doq} mapdoq           the doq representing our map (not used here)
         *          {Boolean} editing      whether this pushpin should be manipulatable
         * @return {Microsoft.Maps.Pushpin}     the pushpin object
         */
        function drawPushpin(options) {
            var location = options.location,
                editing = options.editing,
                loc = new Microsoft.Maps.Location(location.latitude, location.longitude),
                pushpin;

            pushpin = new Microsoft.Maps.Pushpin(loc, {
                draggable: !!editing,
                icon: tagPath+'images/icons/locationPin.svg', //green icon is the default
                width: 20,
                height: 30
            });

            //ability to select a pushpin
            Microsoft.Maps.Events.addHandler(pushpin, 'click', selectPushpin);
            function selectPushpin() {
                if (!formIsEnabled) { //don't do anything if another form is already open
                    if (location.descContainer.css('display') === 'block') { //if previously selected - deselect
                        deselect(location, pushpin, false);
                    } else {
                        select(location, pushpin, false);
                        //scroll to the correct location in the list
                        locationsRegion.scrollTop(0);
                        locationsRegion.scrollTop(pushpin.container.position().top);
                    }
                }
            }

            map.entities.push(pushpin);

            return pushpin;
        }

        /**
         * Removes the given pushpin from the map
         * @method removePushpin
         * @param {Object} options           some input options
         *          {Microsoft.Maps.Pushpin}   pushpin    the pushpin to remove
         */
        function removePushpin(options) {
            map.entities.remove(options.pushpin);
        }

        /**
         * Creates location editing interface (used for adding new and editing existing
         * locations)
         * @method createLocationEditor
         * @param {Object} options       some input options
         *          {Object} location       location data to be edited (null for new location)
         *          {Number} index          index of location in location list
         *          {Function} cancelClick  cancel button click handler
         * @return {jQuery obj}          editing container div, which can be appended to list
         */
        function createLocationEditor(options) {
            options = options || {};

            var editingFormElements = commonCreateLocationEditor({
                location: options.location,
                custom: false,
                mapguid: null,
                index: options.index,
                cancelClick: options.cancelClick
            });

            // set up search button click handler
            editingFormElements.searchButton.on('click', function () {
                editingFormElements.resultsDiv.css({ 'margin-bottom': '2%' }); //set this margin only when the results div will be displayed
                editingFormElements.resultsDiv.empty();
                editingFormElements.resultsDiv.text('Searching...'); // TODO better loading UI

                searchBingLocation(editingFormElements.titleInput.val(), function (result) { // success handler
                    var i;

                    // error checking
                    if (!result || !result.resourceSets || !result.resourceSets[0] || !result.resourceSets[0].resources || !result.resourceSets[0].resources.length) {
                        editingFormElements.resultsDiv.text('No results found.'); // TODO could look better
                        return;
                    }

                    editingFormElements.resultsDiv.empty();

                    for (i = 0; i < result.resourceSets[0].resources.length; i++) {
                        editingFormElements.resultsDiv.append(createSearchResultDiv(result.resourceSets[0].resources[i]));
                    }

                    //Select the first result
                    $('.bingSearchResultContainer:eq(0)').click();

                }, function () { // error handler
                    editingFormElements.resultsDiv.text('Error contacting Bing Maps. Please try again.');
                });
            });

            /**
             * Creates a bing map search result div. Called by the callback to searchBingLocation.
             * @method createSearchResultDiv
             * @param {Object} result                this is an object derived from the results of a bing map search
             */
            function createSearchResultDiv(result) {
                var container = $(document.createElement('div')).addClass('bingSearchResultContainer');

                container.css({
                    position: 'relative',
                    width: '100%',
                    'padding-left': '10px',
                    'font-size':'20px'
                });

                container.text(result.address.formattedAddress);

                container.on('click', function () {

                    $('.bingSearchResultContainer').css('background-color', 'rgba(0,0,0,0)');
                    container.css('background-color', 'rgba(255,255,255,0.2)');

                    // error checking
                    if (!result.point || !result.point.coordinates || !result.point.coordinates.length) {
                        return;
                    }

                    editingFormElements.titleInput.attr('value', result.address.formattedAddress);

                    // reset pushpin location
                    editingFormElements.pushpin.setLocation({
                        latitude: result.point.coordinates[0],
                        longitude: result.point.coordinates[1]
                    });

                    // error checking
                    if (!result.bbox || !result.bbox.length) {
                        return;
                    }

                    // pan/zoom to specified point
                    map.setView({
                        bounds: Microsoft.Maps.LocationRect.fromLocations(
                                new Microsoft.Maps.Location(result.bbox[0], result.bbox[1]),
                                new Microsoft.Maps.Location(result.bbox[2], result.bbox[3])
                            )
                    });
                });

                return container;
            }

            /**
             * Searches the input string on a bing map.
             * @method searchBingLocation
             * @param {String} locString          input string to search
             * @param {Function} success          function to call when results have been found
             * @param {Function} error            error callback
             */
            function searchBingLocation(locString, success, error) {
                var requestURL = "http://dev.virtualearth.net/REST/v1/Locations?query=" + encodeURI(locString) + "&output=json&key=" + credentials;

                $.ajax({
                    url: requestURL,
                    success: success,
                    error: error
                });
            }

            return editingFormElements
        }

        /**
         * Creates a location item in the bottom panel (locationsRegion)
         * @method  
         * @param {Object} location      location data for item
         */
        function createLocationItem(location) {
            commonCreateLocationItem({
                location: location,
                custom: false
            });
        }

        return {
            init: init,
            drawPushpin: drawPushpin,
            removePushpin: removePushpin,
            createLocationEditor: createLocationEditor,
            createLocationItem: createLocationItem
        };
    };

    /**
     * Some helper functions for custom maps. The idea is to have BingMapHelper
     * and CustomMapHelper implement the same interface, so manipulating location data can
     * be generic
     * @method CustomMapHelper
     */
    function CustomMapHelper() {

        /**
         * Initialize a custom map
         * @method init
         * @param {Object} input        some input options
         *             container:        container of the bing map
         *             progress:         an object allowing us to keep track of how many of all maps have loaded
         *             loadCallback:     callback function to call if this is the last map to load
         *             mapdoq:           the doq of the custom map
         */
        function init(input) {
            annotImgs = {};
            var annotImg = new TAG.AnnotatedImage({
                root        :   input.container,
                doq         :   input.mapdoq,
                callback    :   function(){
                    annotImg.openArtwork(input.mapdoq);
                    annotImgs[input.mapdoq.Identifier] = annotImg;
                    annotImg.initZoom();
                    
                    if (++input.progress.done >= input.progress.total) {
                            input.loadCallback && input.loadCallback();
                    }
                },
                noMedia: true,
                disableZoom : false
            });
        }

        /**
         * Draw a pushpin on the given map
         * @method drawPushpin
         * @param {Object} options       some input options
         *          {Object} location      location data for pushpin
         *          {Doq} mapdoq           the doq representing our map
         *          {Boolean} editing      whether this pushpin should be manipulatable
         * @return {jQuery obj}          the pushpin element
         */
        function drawPushpin(options) {
            var location = options.location,
                mapdoq = options.mapdoq,
                editing = options.editing,
                annotImg = annotImgs[mapdoq.Identifier],
                pushpin = $(document.createElement('img')),
                lastPivot;
            if (!annotImg) {
                return;
            }

            pushpin.attr({
                src: tagPath+'images/icons/locationPin.svg'
            });

            pushpin.css({
                width: '20px',
                height: '30px',
                'z-index': '1'
            });

            pushpin.addClass('locationPushpin');

            pushpins.push(pushpin);

            if (editing) {
                pushpin.attr({
                    src: tagPath+'images/icons/locationPin2.svg'
                });
            }

            pushpin.on('click', function () {
                if (!editing) {
                    if (!formIsEnabled) { //don't do anything if another form is already open
                        if (location.descContainer.css('display') === 'block') { //if previously selected - deselect
                            deselect(location, pushpin, true);
                        } else { //if not previously selected - select
                            select(location, pushpin, true);
                            //scroll to the correct location in the list
                            locationsRegion.scrollTop(0);
                            locationsRegion.scrollTop(pushpin.container.position().top);
                        }
                    }
                }
            });

            //all pins start off in an overlay
            annotImg.addOverlay(pushpin[0], new Seadragon.Point(location.x, location.y), Seadragon.OverlayPlacement.BOTTOM);

            var isOverlay = true,
                x,
                y,
                t,
                l,
                w = parseFloat(pushpin.css('width')),
                h = parseFloat(pushpin.css('height'));

            TAG.Util.makeManipulatable(pushpin[0], {
                onManipulate: function (res) {
                    if (editing) {
                        if (isOverlay) {
                            annotImg.pauseManip(); //prevents the image from moving when the pin is being manipulated
                            isOverlay = false;
                            t = pushpin.css('top');
                            l = pushpin.css('left');
                            annotImg.removeOverlay(pushpin[0]); //seems like this changes the CSS of the pushpin?
                            pushpin.appendTo(mapHolders[mapdoq.Identifier]);
                            pushpin.css({
                                top: t,
                                left: l,
                                position: 'absolute'
                            });
                        }

                        //if pushpin is within bounds of viewport
                        if (annotImg.isInViewportBounds(pushpin)) {
                            t = parseFloat(pushpin.css('top')),
                            l = parseFloat(pushpin.css('left'));

                            pushpin.css("top", (t + res.translation.y) + "px");
                            pushpin.css("left", (l + res.translation.x) + "px");

                            //update the overlay coordinates here - b/c need the translation
                            x = l + res.translation.x + (0.5 * w);
                            y = t + res.translation.y + (h);

                            lastPivot = res.pivot;

                        }
                        //otherwise the location of the pushpin is not updated with manipulation
                    }
                },
                onRelease: function (evt) {
                    if (editing && !isOverlay) {
                        //add the overlay back once mouse is released
                        isOverlay = true;

                        //if pushpin is not within bounds of image, it snaps back to the edge on release
                        if (!annotImg.isInImageBounds(pushpin)) {
                            var coord = annotImg.returnElementToBounds(pushpin);
                            pushpin.css("top", (coord.y - h) + "px");
                            pushpin.css("left", (coord.x - 0.5 * w) + "px");
                            annotImg.addOverlay(pushpin[0], annotImg.pointFromPixel(new Seadragon.Point(coord.x, coord.y)), Seadragon.OverlayPlacement.BOTTOM);
                        } else {
                            annotImg.addOverlay(pushpin[0], annotImg.pointFromPixel(new Seadragon.Point(x, y)), Seadragon.OverlayPlacement.BOTTOM);
                        }
                        annotImg.restartManip(); //allow manipulation of the DZ image after the pin is put down
                    }
                },
                onScroll: function (delta, pivot) { //allow scrolling of the map while dragging a pin (or when the mouse is on top of a pin)
                    annotImg.scroll(delta, { //use the location of the pushpin for the pivot
                        x: w + parseFloat(pushpin.css('left')),
                        y: h + parseFloat(pushpin.css('top'))
                    });
                }
            }, false, true);

            return pushpin;
        }

        /**
         * Removes the given pushpin from the map
         * @method removePushpin
         * @param {Object} options        some input options
         *          {jQuery obj} pushpin    the pushpin to remove
         *          {Object} mapguid        corresponding map's guid
         */
        function removePushpin(options) {
            annotImgs[options.mapguid].removeOverlay(options.pushpin[0]);
            options.pushpin.remove();
        }

        /**
         * Creates location editing interface (used for adding new and editing existing
         * locations)
         * @method createLocationEditor
         * @param {Object} options       some input options
         *          {Object} location       location data to be edited (null for new location)
         *          {Number} index          index of location in location list
         *          {Function} cancelClick  cancel button click handler
         * @return {jQuery obj}          editing container div, which can be appended to list
         */
        function createLocationEditor(options) {
            options = options || {};

            return commonCreateLocationEditor({
                location: options.location,
                custom: true,
                mapguid: mapGuids[currentIndex],
                index: options.index,
                cancelClick: options.cancelClick
            });
        }

        /**
         * Creates a location item in the bottom panel (locationsRegion)
         * @method createLocationItem
         * @param {Object} location      location data for item
         * @param {Doq} mapdoq           the doq representing our map
         */
        function createLocationItem(location, mapdoq) {
            var container = commonCreateLocationItem({
                location: location,
                custom: true,
                mapguid: mapdoq.Identifier
            });
        }

        return {
            init: init,
            drawPushpin: drawPushpin,
            removePushpin: removePushpin,
            createLocationEditor: createLocationEditor,
            createLocationItem: createLocationItem
        };
    }

    /**
     * Common functionality for creating location items
     * @method commonCreateLocationItem
     * @param {Object} options        some input options:
     *          {Object} location        the location in question
     *          {Boolean} custom         whether this is from a custom map
     *          {String} mapguid         the guid of the map in question
     *          
     * @return {jQuery obj}           the outer container of the list item
     */
    function commonCreateLocationItem(options) {
        var container = $(document.createElement('div')).addClass('locationItemContainer'),
            deleteButton = $(document.createElement('img')).addClass('locationItemDeleteButton'),
            editButton = $(document.createElement('img')).addClass('locationItemEditButton'),
            titleContainer = $(document.createElement('div')).addClass('locationItemTitle'),
            dateContainer = $(document.createElement('div')).addClass('locationItemDate'),
            descContainer = $(document.createElement('div')).addClass('locationItemDesc'),
            location = options.location,
            custom = options.custom,
            helper = custom ? customMapHelper : bingMapHelper,
            mapguid = options.mapguid || null,
            pushpin;

        location && (location.descContainer = descContainer);
        location && (location.container = container);

        if (!location) {
            console.log("please provide all options");
            return;
        }

        pushpin = helper.drawPushpin({
            location: options.location,
            mapdoq: mapDoqs[mapguid],
            editing: false
        });

        pushpin['container'] = container;

        //pushpins.push(pushpin);

        container.css({
            margin: '0px 0px 10px 0px',
            position: 'relative',
            width: '100%',
        });
        container.on('click', function () {
            if (!formIsEnabled) { //don't do anything if another form is already open
                if (location.descContainer.css('display') === 'block') { //if previously selected
                    if (custom) {
                        deselect(location, pushpin, true);
                    } else {
                        deselect(location, pushpin, false);
                    }
                }
                else { //if not previously selected
                    if (custom) {
                        annotImgs[mapguid].panToPoint(pushpin[0]);
                        select(location, pushpin, true);
                    } else {
                        select(location, pushpin, false);
                        if (!map.getBounds().contains(pushpin.getLocation())) {
                            map.setView(new Microsoft.Maps.LocationRect.fromLocations(pushpin.getLocation()));
                        }
                    }
                    showMap(mapguid); //don't show the map if you are deselecting a label from another map
                }
            }
        });

        if (input.authoring) {

            deleteButton.css({
                display: 'inline-block',
                cursor: 'pointer',
                height: '30px',
                margin: '2px',
                position: 'relative',
                'vertical-align': 'middle',
                width: '30px'
            });

            deleteButton.attr('src', tagPath+'images/icons/delete.svg');

            deleteButton.on('click', function (evt) {
                var overlay = TAG.Util.UI.PopUpConfirmation(function () {
                    index = locations.indexOf(location);
                    if (index >= 0) {
                        locations.splice(index, 1);
                        saveRichLocationHistory();
                    } else {
                        console.log("error");
                    }
                }, "Are you sure you want to delete this location?", "Yes");
                root.append(overlay);
                $(overlay).show();

                evt.stopPropagation();
            });

            editButton.css({
                display: 'inline-block',
                cursor: 'pointer',
                height: '30px',
                margin: '2px',
                position: 'relative',
                'vertical-align': 'middle',
                width: '30px'
            });

            editButton.attr('src', tagPath+'images/icons/edit.png');

            editButton.on('click', function (evt) {
                if (!formIsEnabled) {
                    formIsEnabled = true;
                    isEditForm = true;

                    //deselect other locations (if necessary)
                    $('.locationItemDesc').css({ 'display': 'none' });
                    $('.locationItemContainer').css('background-color', 'rgba(0,0,0,0)');
                    //reset all pushpins to the green icon
                    $('.locationPushpin').attr('src', tagPath+'images/icons/locationPin.svg');
                    for (l = 0; l < map.entities.getLength() ; l++) { //iterates through bing map pushpins
                        map.entities.get(l).setOptions({ icon: tagPath+'images/icons/locationPin.svg' });
                    }

                    if (custom) {
                        pushpin && pushpin.attr('src', tagPath+'images/icons/locationPin2.svg');
                    }
                    //if it's a bing map pushpin, it's set to red below

                    var editingFormElements;
                    showMap(mapguid);

                    //make sure that the pin is visible on the map
                    if (custom) {
                        annotImgs[mapguid].panToPoint(pushpin[0]);
                    } else {
                        if (!map.getBounds().contains(pushpin.getLocation())) {
                            map.setView(new Microsoft.Maps.LocationRect.fromLocations(pushpin.getLocation()));
                        }
                    }

                    editingFormElements = helper.createLocationEditor({
                        location: location,
                        index: locations.indexOf(location),
                        cancelClick: function () {
                            commonCreateLocationItem(options).insertAfter($('.locationEditingContainer'));
                            //editingFormElements.container.after(container);
                            //editingFormElements.container.remove();
                            //pushpin = helper.drawPushpin({
                            //    location: location,
                            //    mapdoq: mapDoqs[location.map],
                            //    editing: false
                            //});
                        }
                    });
                    container.after(editingFormElements.container);
                    container.detach();
                    helper.removePushpin({
                        pushpin: pushpin,
                        mapguid: location.map
                    });
                    (!custom) && map.entities.get(map.entities.getLength() - 1).setOptions({ icon: tagPath+'images/icons/locationPin2.svg' }); //set the last pushpin to red

                    //scroll to the correct position
                    locationsRegion.scrollTop(0);
                    locationsRegion.scrollTop(editingFormElements.container.position().top + 20);
                }
            });
        }

        titleContainer.css({
            display: 'inline-block',
            margin: '0px 10px 0px 10px',
            position: 'relative',
            'vertical-align': 'middle',
            'max-font-size': '24px',
            'min-font-size' : "12px",
            "font-size": root.height()/40
        });
        titleContainer.text((location.title ? location.title + (location.date ? ',' : '') : (location.date ? '' : '(Untitled Location)')));
        (!location.title && titleContainer.css({margin:'0px 0px 0px 10px'}));

        dateContainer.css({
            display: 'inline-block',
            margin: '0px 0px 0px 0px',
            position: 'relative',
            'vertical-align': 'middle',
            'max-font-size': '24px',
            'min-font-size' : "12px",
            "font-size": root.height()/40
        });
        dateContainer.text(location.date || '');

        descContainer.css({
            display: 'none',
            margin: '0px 0px 0px 80px',
            position: 'relative',
            'vertical-align': 'middle',
            'max-font-size': '24px',
            'min-font-size' : "12px",
            "font-size": root.height()/50,
            'padding-right': '20px',
            'font-style': 'italic'
        });

        if (!input.authoring) {
            descContainer.css({ margin: '0px 0px 0px 10px' });
        }

        descContainer.text(location.description || '');
        if (descContainer.text() === '') { //don't put padding if it's empty, so that clicking on it won't change the height
            descContainer.css('padding-bottom', '0px');
        } else {
            descContainer.css('padding-bottom', '10px');
        }

        if (input.authoring) {
            container.append(deleteButton);
            container.append(editButton);
        }

        container.append(titleContainer);
        container.append(dateContainer);
        container.append(descContainer);

        locationsRegion.append(container);

        return container;
    }

    /**
     * Common functionality for creating location editor UIs. This is here because a lot
     * of code would be copied between the BingMapHelper and CustomMapHelper otherwise. Some
     * functionality is specific to one or the other, though, so that's taken care of in their
     * respective createLocationEditor methods using the returned components here.
     * @method commonCreateLocationEditor
     * @param {Object} options       some input options
     *          {Object} location       the location in question
     *          {Boolean} custom        whether this is a custom map
     *          {String} mapguid        the guid of the map in question
     *          {Number} index          index of loaaction in location list
     *          {Function} cancelClick  cancel button click event
     * @return {Object}              the relevant components of the editing form
     */
    function commonCreateLocationEditor(options) {
        options = options || {}; // cut down on null checks later

        //'de-select' any previous locations from the list (only want one red pin at a time)
        $('.locationItemContainer').css('background-color', 'rgba(0,0,0,0)');
        $('.locationItemDesc').css({ 'display': 'none' });
        $('.locationPushpin').attr('src', tagPath+'images/icons/locationPin.svg');
        for (var l = 0; l < map.entities.getLength() ; l++) { //iterates through all of the bing map pushpins
            map.entities.get(l).setOptions({ icon: tagPath+'images/icons/locationPin.svg' });
        }

        var container = $(document.createElement('div')).addClass('locationEditingContainer'),

            titleContainer = $(document.createElement('div')).addClass('locationOptionsContainer'),
            titleInput = $(document.createElement('input')).addClass('locationTitleInput'),

            titleLabel = $(document.createElement('div')).addClass('locationLabel').text('Location Title'),

            dateContainer = $(document.createElement('div')).addClass('locationOptionsContainer'),
            dateInput = $(document.createElement('input')).addClass('locationDateInput'),
            dateLabel = $(document.createElement('div')).addClass('locationLabel').text('Date'),

            descContainer = $(document.createElement('div')).addClass('locationOptionsContainer'),
            descInput = $(document.createElement('textarea')).addClass('locationDescInput'),
            descLabel = $(document.createElement('div')).addClass('locationLabel').text('Description'),

            bottomButtonsContainer = $(document.createElement('div')).addClass('locationOptionsContainer'),
            saveButton = $(document.createElement('button')).addClass('locationSaveButton'),
            deleteButton = $(document.createElement('button')).addClass('locationDeleteButton'),
            cancelButton = $(document.createElement('button')).addClass('locationCancelButton'),

            searchButton,
            resultsDiv,
            location = options.location,
            index = options.index,
            custom = options.custom,
            mapguid = options.mapguid,
            helper = custom ? customMapHelper : bingMapHelper,
            pushpin,
            cancelClick = function () {
                formIsEnabled = false;
                options.cancelClick && options.cancelClick();
                removeLocationForm();
                helper.removePushpin({
                    pushpin: pushpin,
                    mapguid: mapguid
                });
            };
        /*titleInput.on('keyup', function () {
            var txt = (titleInput && titleInput[0] && titleInput[0].value) ? titleInput[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (titleInput && titleInput[0] && titleInput[0].value && titleInput[0].value != txt) {
                titleInput[0].value = txt;
            }
        });

        dateInput.on('keyup', function () {
            var txt = (dateInput && dateInput[0] && dateInput[0].value) ? dateInput[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (dateInput && dateInput[0] && dateInput[0].value && dateInput[0].value != txt) {
                dateInput[0].value = txt;
            }
        });

        descInput.on('keyup', function () {
            var txt = (descInput && descInput[0] && descInput[0].value) ? descInput[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (descInput && descInput[0] && descInput[0].value && descInput[0].value != txt) {
                descInput[0].value = txt;
            }
        });*/

        if (!custom) {
            if (!location || index < 0 || index >= locations.length) {
                var bounds = map.getBounds();
                var centerCoord = map.getCenter();
                location = {
                    latitude: centerCoord.latitude + (.01 * (bounds.getSouth() - bounds.getNorth())), //1% offset from center is to prevent the new pin from directly 
                    longitude: centerCoord.longitude + (.01 * (bounds.getEast() - bounds.getWest())) //overlapping one that may have been previously selected
                };
                index = locations.length;
            }
        } else {
            if (!location || index < 0 || index >= locations.length) {
                var startLocation = annotImgs[mapguid].createStartingPoint(); //uses the same 1% offset
                location = {
                    x: startLocation.x,
                    y: startLocation.y
                }
                index = locations.length;
            }
        }

        pushpin = helper.drawPushpin({
            location: location,
            mapdoq: mapDoqs[mapguid],
            editing: true
        });

        if (custom) {
            pushpin.attr('src', tagPath+'images/icons/locationPin2.svg');
        } else {
            pushpin.setOptions({ icon: tagPath+'images/icons/locationPin2.svg' });
        }

        container.css({
            'width': '100%',
            'position': 'relative',
            'overflow': 'auto',
            'padding': '0px 4% 0px 0px',
            'margin-bottom': '4%',
            'margin-top': '2%'
        });

        titleLabel.css({
            'width': '20%',
            'display': 'inline-block',
            'vertical-align': 'top',
            'text-align': 'right'
        });

        dateLabel.css({
            'width': '20%',
            'display': 'inline-block',
            'vertical-align': 'top',
            'text-align': 'right'
        });

        descLabel.css({
            'width': '20%',
            'display': 'inline-block',
            'vertical-align': 'top',
            'text-align': 'right'
        });

        titleContainer.css({
            'margin-bottom': '2%'
        });

        dateContainer.css({
            'margin-bottom': '2%'
        });

        descContainer.css({
            'margin-bottom': '2%'
        });


        titleInput.css({
            position: 'relative',
            width: '52%',
            left: '2%',
            display: 'inline-block'
        });
        titleInput.attr({
            placeholder: ' Title',
            value: location.title ? location.title : ''
        });

        if (!custom) {

            titleInput.css({ width: '42%' });

            searchButton = $(document.createElement('button')).addClass('locationEditorSearchButton').css('border-radius', '3.5px');
            searchButton.attr({
                type: 'button'
            });
            searchButton.text('Search');
            searchButton.css({ 'display': 'inline-block', 'margin-left':'3.5%'});

            resultsDiv = $(document.createElement('div')).addClass('locationEditorSearchResults');
            resultsDiv.css({
                left: '22%',
                'max-height': '200px',
                'overflow-x': 'hidden',
                'overflow-y': 'auto',
                position: 'relative',
                width: '52.5%'
            });
        }

        titleInput.on('keydown', function (event) {
            event.stopPropagation();
            if (event.which === 13 && searchButton) {
                event.preventDefault();
                searchButton.click();
            }
        });

        dateInput.css({
            position: 'relative',
            width: '52%',
            left: '2%',
            display: 'inline-block'
        });
        dateInput.attr({
            placeholder: ' Date',
            value: location.date ? location.date : ''
        });

        descInput.css({
            position: 'relative',
            width: '49.75%',
            left: '2%',
            display: 'inline-block'
        });
        descInput.attr({
            placeholder: ' Description',
            rows: '3',
            value: location.description ? location.description : ''
        });

        bottomButtonsContainer.css({
            'display': 'inline-block',
            position: 'relative',
            left: '22%',
            width: '70%'
        });

        saveButton.css({
            position: 'relative',
            'margin-right': '2%'
        }).css('border-radius', '3.5px');
        saveButton.text('Save Location');
        saveButton.on('click', function () {

            // TODO only replace the relevant list item rather than recreating whole list
            var pushpinLocation,
                newLoc,
                currInd = currentIndex;

            if (custom) {
                pushpinLocation = annotImgs[mapGuids[currInd]].getOverlayCoordinates(pushpin[0]);
                newLoc = {
                    map: mapGuids[currInd],
                    title: titleInput.val(),
                    date: dateInput.val(),
                    description: descInput.val(),
                    x: pushpinLocation.x,
                    y: pushpinLocation.y
                };
            } else {
                pushpinLocation = pushpin.getLocation();
                newLoc = {
                    map: null,
                    title: titleInput.val(),
                    date: dateInput.val(),
                    description: descInput.val(),
                    latitude: pushpinLocation.latitude,
                    longitude: pushpinLocation.longitude
                };
            }
            if (index >= 0 && index < locations.length) {
                locations[index] = newLoc;
            } else {
                locations.push(newLoc);
            }

            saveRichLocationHistory({
                callback: function () {
                    showMap(mapGuids[currInd]);
                }
            });
            formIsEnabled = false;
        });

        if (location) {
            deleteButton.css({
                position: 'relative',
                'margin-right': '2%'
            });
            deleteButton.text('Delete').css('border-radius', '3.5px');
            deleteButton.on('click', function (evt) {
                formIsEnabled = false;
                var overlay = TAG.Util.UI.PopUpConfirmation(function () {
                    index = locations.indexOf(location);
                    if (index >= 0 && index < locations.length) {
                        locations.splice(index, 1);
                    }
                    saveRichLocationHistory();
                }, "Are you sure you want to delete this location?", "Yes");
                root.append(overlay);
                $(overlay).show();
                evt.stopPropagation();
            });
        }

        cancelButton.css({
            position: 'relative',
            'margin-right': '2%'
        });
        cancelButton.text('Cancel').css('border-radius', '3.5px');
        cancelButton.on('click', cancelClick);

        titleContainer.append(titleLabel);
        titleContainer.append(titleInput);
        container.append(titleContainer);
        if (!custom) {
            titleContainer.append(searchButton);
            container.append(resultsDiv);
        }

        dateContainer.append(dateLabel);
        dateContainer.append(dateInput);
        container.append(dateContainer);

        descContainer.append(descLabel);
        descContainer.append(descInput);
        container.append(descContainer);

        bottomButtonsContainer.append(saveButton);
        if (isEditForm) { //new added locations should not have a delete button
            (location && bottomButtonsContainer.append(deleteButton));
            isEditForm = false;
        }
        bottomButtonsContainer.append(cancelButton);
        container.append(bottomButtonsContainer);

        if (custom) {
            return {
                container: container
            };
        }
        return {
            container: container,
            titleInput: titleInput,
            searchButton: searchButton,
            resultsDiv: resultsDiv,
            pushpin: pushpin
        };
    }

    /**
     * Saves latest rich location history data to the artwork doq. Uses the maps and
     * locations variables, so make sure those are up to date before calling. Reloads
     * all maps afterwards.
     * @method saveRichLocationHistory
     * @param {Object} input       some input options, including:
     *              toadd          a string of comma-separated GUIDs of maps to add
     *              toremove       a string of comma-separated GUIDs of maps to remove
     *              noReload       a boolean telling us whether to reload maps or not
     *              callback       a callback function to be called after saving and reloading artwork is done
     */
    function saveRichLocationHistory(input) {

        if ($('.locationTitleInput').is(':focus')) {
            return;
        }

        disableButtons();

        var options = {
            RichLocationHistory: generateRichLocationData()
        };

        input = input || {}; // cut down on null checks later

        if (input.toadd) {
            options.AddMaps = input.toadd;
        }

        if (input.toremove) {
            options.RemoveMaps = input.toremove;

        }

        !input.noReload && showLoadingMessage();
        TAG.Worktop.Database.changeArtwork(artwork.Identifier, options, success, error, error, error);

        function success() {
            TAG.Worktop.Database.getDoq(artwork.Identifier, function (newArtwork) {
                if (newArtwork.Metadata) {
                    artwork = newArtwork;
                }
                richLocationData = artwork.Metadata.RichLocationHistory ? JSON.parse(unescape(artwork.Metadata.RichLocationHistory)) : locationToRichLocation(artwork.Metadata.Location);
                locations = richLocationData.locations || [];
                !input.noReload && getMaps(input.callback);
                enableButtons();
                if (defaultMapShown) {
                    disabledOverlay.remove();
                } else {
                    disabledOverlay.text("Bing Map is disabled.");
                }
            }, error, error);
            //input.sort && input.callback();
        }

        function error() {
            console.log('An error occured while saving.');
            enableButtons();
            disabledOverlay.remove();
        }
    }

    /**
     * Generates a RichLocationHistory property (string) from the maps and locations
     * variables for saving. A helper function for saveRichLocationHistory.
     * @method generateRichLocationData
     * @return {String}              a string to be used as a RichLocationHistory property
     */
    function generateRichLocationData() {
        return JSON.stringify({
            defaultMapShown: defaultMapShown,
            locations: locations
        });
    }

    /**
     * Toggles the default map overlay to indicate that it is
     * enabled or disabled. Uses the value of defaultMapShown
     * to do so.
     * @method toggleDefaultMap
     */
    function toggleDefaultMap() {   
        defaultMapShown = !defaultMapShown;
        disabledOverlay.appendTo(mapHolders[null]);
        disabledOverlay.text("Loading...");
        deleteButton.text(defaultMapShown ? 'Hide Bing Map' : 'Show Bing Map');
    }

    /**
     * Delete the selected map, reload maps, set the current map to bing map (for now)
     * @method deleteMap
     */
    function deleteMap() {
        var mapguid = mapGuids[currentIndex],
            i,
            locs;
        if (mapguid) {
            removeLocations(mapguid);
            saveRichLocationHistory({
                toremove: mapguid
            });
        } else {
            toggleDefaultMap();
            saveRichLocationHistory({
                noReload: true
            });
        }
    }

    /**
     * Remove locations associated with a given map from artwork metadata
     * @method removeLocations
     * @param {String} guid       map guid
     */
    function removeLocations(guid) {
        var i;

        for (i = locations.length - 1; i >= 0; i--) {
            if (locations[i].map === guid) {
                locations.splice(i, 1);
            }
        }

        richLocationData = {
            defaultMapShown: defaultMapShown,
            locations: locations
        };
    }

    /**
     * Upload a custom map from user's computer
     * @method uploadCustomMap
     */
    function importMap() {
        formIsEnabled = false;
        importingMap = true;
        var fileArray,
            i;

        TAG.Authoring.FileUploader(
            root,
            TAG.Authoring.FileUploadTypes.Map, // TODO RLH TESTING: change this to TAG.Authoring.FileUploadTypes.Map to test map uploading
            function (files) {
                fileArray = files;
            },
            function (urls) {
                var newDoq
                if (!urls.length && urls.length !== 0) { // check to see whether a single file was returned
                    urls = [urls];
                }
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[0]);
                } catch (error) {
                    console.log("error in uploading: " + error.message);
                    return;
                }
                mapGuids.push(newDoq.Identifier);

                mapDoqs[newDoq.Identifier] = newDoq;
                //update changeartwork and linq the map and artwork

                importLoadingOverlay();

                saveRichLocationHistory({
                    toadd: newDoq.Identifier,
                });

                //reload (which will show the map that has just been imported)
                loadMaps();

                //TAG.Worktop.Database.changeArtwork(artwork.Identifier, {AddMaps:JSON.stringify(maps)});
                // TODO this is just in here for testing purposes
                //TAG.Worktop.Database.changeMap(newDoq.Identifier, { Name: "Custom Map", Description: "Test description", AdditionalInfo: "Middle Pharaoh Period" }, function () {
                //    console.log('success in changeMap');
                //}, function () { }, function () { }, function () { }); // TODO RLH TESTING: make sure map doq is updated properly (the next time it's loaded, it should have these metadata)
            },
            ['.jpg', '.png', '.gif'],//, '.tif', '.tiff' these two crashes visual studio every time we click on the dot to show map. haven't found why though
            false,
            function () {
                root.append(TAG.Util.UI.popUpMessage(null, "There was an error uploading the file.  Please try again later."));
            },
            false // batch upload disabled for now
        );

    }

    /**
    * Append a loading message over the map region to indicate loading while a map is being uploaded
    * @method importLoadingOverlay()
    */
    function importLoadingOverlay() {
        locationPanel.append(importDisabledOverlay);
    }

    /**
    * Remove the loading message over the map region to indicate loading while a map is being uploaded
    * @method removeLoadingOverlay()
    */
    function removeLoadingOverlay() {
        importDisabledOverlay.remove();
    }

    
    /**
     * De-select a location pin and the corresponding location list item
     * @method deselect
     */
    function deselect(location, pushpin, custom) {
        location.descContainer.css({ 'display': 'none' });
        $('.locationItemContainer').css('background-color', 'rgba(0,0,0,0)');
        if (!custom) {
            pushpin.setOptions({ icon: tagPath+'images/icons/locationPin.svg' });
        } else {
            $('.locationPushpin').attr('src', tagPath+'images/icons/locationPin.svg');
        }
    }

    /**
     * Select a location pin and the corresponding location list item
     * @method select
     */
    function select(location, pushpin, custom) {
        var l;

        //if not previously selected - expand the correct description
        $('.locationItemDesc').css({ 'display': 'none' });
        location.descContainer.css({ 'display': 'block' });
        $('.locationItemContainer').css('background-color', 'rgba(0,0,0,0)');
        pushpin.container.css('background-color', 'rgba(255,255,255,0.2)');

        //reset all pushpins here to the green icon
        $('.locationPushpin').attr('src', tagPath+'images/icons/locationPin.svg');
        if (input.authoring || defaultMapShown) { //can't access map if in art mode and bing map is not shown
            for (l = 0; l < map.entities.getLength() ; l++) { //iterates through all of the bing map pushpins
                map.entities.get(l).setOptions({ icon: tagPath+'images/icons/locationPin.svg' });
            }
        }

        if (!custom) {
            //make the right pushpin red
            pushpin.setOptions({ icon: tagPath+'images/icons/locationPin2.svg' });
        } else {
            //make the right pushpin red
            pushpin && pushpin.attr('src', tagPath+'images/icons/locationPin2.svg');
        }
    };

    /**
    * Disables the buttons below the map.  Used when saving is in progress.
    * @method disableButtons()
    */

    function disableButtons() {
        buttonsRegionDisabled.css({ display: 'block' });

        $('#locationHistoryAddLocationButton').disabled = true;
        $('#locationHistoryAddLocationButton').css({'color': 'rgba(255, 255, 255, 0.5)'});

        $('#locationHistorySortLocationsByTitleButton').disabled = true;
        $('#locationHistorySortLocationsByTitleButton').css({'color': 'rgba(255, 255, 255, 0.5)'});

        $('#locationHistorySortLocationsByDateButton').disabled = true;
        $('#locationHistorySortLocationsByDateButton').css({'color': 'rgba(255, 255, 255, 0.5)'});

        $('#locationHistoryImportMapButton').disabled = true;
        $('#locationHistoryImportMapButton').css({ 'color': 'rgba(255, 255, 255, 0.5)' });

        $('#locationHistoryDeleteButton').disabled = true;
        $('#locationHistoryDeleteButton').css({ 'color': 'rgba(255, 255, 255, 0.5)' });
    }

    /**
    * Re-enables the buttons below the map.  Called when saving is complete.
    * @method enableButtons()
    */

    function enableButtons() {
        
        buttonsRegionDisabled.css({ display: 'none' });

        $('#locationHistoryAddLocationButton').disabled = false;
        $('#locationHistoryAddLocationButton').css({'color': 'rgba(255, 255, 255, 1.0)'});

        $('#locationHistorySortLocationsByTitleButton').disabled = false;
        $('#locationHistorySortLocationsByTitleButton').css({'color': 'rgba(255, 255, 255, 1.0)'});

        $('#locationHistorySortLocationsByDateButton').disabled = false;
        $('#locationHistorySortLocationsByDateButton').css({'color': 'rgba(255, 255, 255, 1.0)'});

        $('#locationHistoryImportMapButton').disabled = false;
        $('#locationHistoryImportMapButton').css({ 'color': 'rgba(255, 255, 255, 1.0)' });

        $('#locationHistoryDeleteButton').disabled = false;
        $('#locationHistoryDeleteButton').css({ 'color': 'rgba(255, 255, 255, 1.0)' });
    }


    /**
     * Built-in object extensions
     */

    // From JS: the good parts
    // Shortcut for adding a function to an object
    Function.prototype.method = function (name, func) {
        if (!this.prototype[name]) {
            this.prototype[name] = func;
            return this;
        }
    };

    // Curry a function
    Function.method('curry', function () {
        var slice = Array.prototype.slice,
            args = slice.apply(arguments),
            that = this;
        return function () {
            return that.apply(null, args.concat(slice.apply(arguments)));
        };
    });

    /**
     * If specified object is in the array, remove it
     * @param obj   object to be removed
     */
    Array.method('remove', function (obj) {
        var i = this.indexOf(obj);
        if (i !== -1) {
            this.splice(i, 1);
            return true;
        } else {
            return false;
        }
    });

    /**
     * Insert object into array based on comparator fn given
     * Assumes array is already sorted!
     * @param obj       Object to be inserted
     * @param comp      Function used to compare objects; obj will be inserted when comp evaluates to true; takes two args, first is current array elt, second is obj
     * @returns         Index of obj in array after insertion
     */
    Array.method('insert', function (obj, comp) {
        var i;
        for (i = 0; i < this.length; i++) {
            if (comp(this[i], obj)) {
                this.splice(i, 0, obj);
                return i;
            }
        }
        this.push(obj);
        return this.length - 1;
    });

    /**
     * Constrain a number to given range
     * @param num   value to constrain
     * @param min   minimum limit
     * @param max   maximum limit
     */
    if (!Math.constrain) {
        Math.constrain = function (num, min, max) {
            return Math.min(max, Math.max(min, num));
        };
    }
}


/**
 * Utils for the artwork viewer and the artwork editor
 * @class TAG.Util.Artwork
 */
TAG.Util.Artwork = (function () {
    "use strict";

    return {
        createThumbnailButton: createThumbnailButton
    };

    /**
     * Creates a thumbnail button to be used in a side bar list
     * @method createThumbnailButton
     * @param {Object} options      options for creating the thumbnail button:
     *            title         title of the button, shown above the thumbnail
     *            year          year of the media, shown below the thumbnail
     *            handler       a click handler for the button
     *            buttonClass   an extra class to add to the button
     *            buttonID      an id to give to the button
     *            src           thumbnail image source
     *            width         custom width of button
     *            height        custom height of button
     * @return {jQuery obj}      the button
     */
    function createThumbnailButton(options) {
        options = options || {};

        var title       = options.title,
            year        = options.year,
            handler     = options.handler,
            buttonClass = options.buttonClass,
            buttonID    = options.buttonID,
            src         = options.src,
            width       = options.width,
            height      = options.height || 0.18 * $('#tagRoot').height() + 'px',
            holder               = $(document.createElement('div')).addClass('thumbnailButton'),
            thumbHolderDiv       = $(document.createElement('div')).addClass('thumbnailHolderDiv'),
            holderContainer      = $(document.createElement('div')).addClass('thumbnailButtonContainer'),
            holderInnerContainer = $(document.createElement('div')).addClass('thumbnailButtonInnerContainer'),
            thumbnailImage       = $(document.createElement('img')).addClass('thumbnailButtonImage'),
            titleDiv = $(document.createElement('div')).addClass('thumbnailButtonTitle'),
            yearDiv = $(document.createElement('div')).addClass('thumbnailButtonYear');



        /********************************************\

        ----------------------------------------------      <--- holder
        | ------------------------------------------ |     
        | |              NAME OF DOQ               | <--- titleDiv
        | |                                        | |
        | ------------------------------------------ |
        | ------------------------------------------ |
        | |                                        | |
        | |                                        | |
        | |                                        | <------ thumbHolderDiv
        | |                                        | |
        | |              THUMBNAIL                 | |
        | |                IMAGE                   | |
        | |                 HERE                  <--------- thumbnailImage
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | ------------------------------------------ |
        | ------------------------------------------ |
        | |                 YEAR                   | <--- yearDiv
        | |                                        | |
        | ------------------------------------------ |
        ----------------------------------------------

        \********************************************/
        
        buttonClass && holder.addClass(buttonClass);
        holder.css('height', height);
        buttonID && holder.attr('id', buttonID);

        holder.on("click", handler);

        titleDiv.text(title);
        holder.append(titleDiv);
        holder.append(thumbHolderDiv);
        thumbHolderDiv.append(holderContainer);
        holderContainer.append(holderInnerContainer);

        thumbnailImage.attr('src', src);

        thumbnailImage.removeAttr('width');
        thumbnailImage.removeAttr('height');

        if (buttonClass && buttonClass === 'assetHolder') { //Artwork Editor TODO J/S
            holder.css({
                //border: '1px solid rgba(255,255,255,0.4)',
            });
            titleDiv.css({
                margin: '1% 2% 0% 2%',
                top: '80%',
                height: '20%',
                'white-space': 'nowrap',
                overflow: 'hidden',
                'text-overflow': 'ellipsis',
                'text-align': 'center',
                'font-size': '75%',
                padding: '0% 3% 0% 3%'
            });
            thumbHolderDiv.css({
                height: '70%',
                position: 'relative',
                width: '92%',
                margin: '-2% 4% 4% 4%',
                display: 'block',
            });
            holderContainer.css({
                display: 'block',
                position: 'relative',
                width: '100%',
                height: '100%',
                'margin-top': '5%',
            });
            holderInnerContainer.css({
                display: 'block',
                'height': '100%',
                'width': '100%',
                'vertical-align': 'middle',
                'text-align': 'center',
                'position': 'relative',
                'top':'0%',
                'left':'0%',
            });
            if (src.indexOf('svg') > -1) {
                thumbnailImage.css({
                    bottom: '0px',
                    display: 'block',
                    height: '100%',
                    left: '0px',
                    'margin-bottom': 'auto',
                    'margin-left': 'auto',
                    'margin-right': 'auto',
                    'margin-top': 'auto',
                    'max-height': '100%',
                    'max-width': '100%',
                    position: 'absolute',
                    right: '0px',
                    top: '0px',
                    width: 'auto',
                });
            } else {
                thumbnailImage.css({
                    bottom: '0px',
                    display: 'block',
                    height: 'auto',
                    left: '0px',
                    'margin-bottom': 'auto',
                    'margin-left': 'auto',
                    'margin-right': 'auto',
                    'margin-top': 'auto',
                    'max-height': '100%',
                    'max-width': '100%',
                    position: 'absolute',
                    right: '0px',
                    top: '0px',
                    width: 'auto',
                });
            }
        } else {
            thumbnailImage.css({
                bottom: '0px',
                height: 'auto',
                left: '0px',
                'margin-bottom': 'auto',
                'margin-left': 'auto',
                'margin-right': 'auto',
                'margin-top': 'auto',
                'max-height': '100%',
                'max-width': '100%',
                position: 'absolute',
                right: '0px',
                top: '0px',
                width: 'auto',
            });
        }

        holderInnerContainer.append(thumbnailImage);

        yearDiv.text(year);
        holder.append(yearDiv);

        return holder;
    }
})();

/**
 * Built-in object extensions
 */

// From JS: the good parts
// Shortcut for adding a function to an object
Function.prototype.method = function (name, func) {
    if (!this.prototype[name]) {
        this.prototype[name] = func;
        return this;
    }
};

// Curry a function
Function.method('curry', function () {
    var slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = this;
    return function () {
        return that.apply(null, args.concat(slice.apply(arguments)));
    };
});

/**
 * If specified object is in the array, remove it
 * @param obj   object to be removed
 */
Array.method('remove', function (obj) {
    var i = this.indexOf(obj);
    if (i !== -1) {
        this.splice(i, 1);
        return true;
    } else {
        return false;
    }
});

/**
 * Insert object into array based on comparator fn given
 * Assumes array is already sorted!
 * @param obj       Object to be inserted
 * @param comp      Function used to compare objects; obj will be inserted when comp evaluates to true; takes two args, first is current array elt, second is obj
 * @returns         Index of obj in array after insertion
 */
Array.method('insert', function (obj, comp) {
    var i;
    for (i = 0; i < this.length; i++) {
        if (comp(this[i], obj)) {
            this.splice(i, 0, obj);
            return i;
        }
    }
    this.push(obj);
    return this.length - 1;
});

/**
 * Constrain a number to given range
 * @param num   value to constrain
 * @param min   minimum limit
 * @param max   maximum limit
 */
if (!Math.constrain) {
    Math.constrain = function (num, min, max) {
        return Math.min(max, Math.max(min, num));
    };
}

/**
 * Defining a to-two-decimal-places function in Math
 * @method Math.twoDecPlaces
 * @param {Number} x             the number to convert to two decimal places
 * @return {Number}              x chopped at two decimal places
 */
Math.twoDecPlaces = function (x) {
    return Math.floor(x * 100) / 100;
};

;
/**
  @license html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */
(function(window, document, undefined){

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */
"use strict";

var _html2canvas = {},
previousElement,
computedCSS,
html2canvas;


function h2clog(a) {
    if (_html2canvas.logging && window.console && window.console.log) {
        window.console.log(a);
    }
}

_html2canvas.Util = {};

_html2canvas.Util.backgroundImage = function (src) {

    if (/data:image\/.*;base64,/i.test( src ) || /^(-webkit|-moz|linear-gradient|-o-)/.test( src )) {
        return src;
    }

    if (src.toLowerCase().substr( 0, 5 ) === 'url("') {
        src = src.substr( 5 );
        src = src.substr( 0, src.length - 2 );
    } else {
        src = src.substr( 4 );
        src = src.substr( 0, src.length - 1 );
    }

    return src;
};

_html2canvas.Util.Bounds = function getBounds (el) {
    var clientRect,
    bounds = {};

    if (el.getBoundingClientRect){
        clientRect = el.getBoundingClientRect();


        // TODO add scroll position to bounds, so no scrolling of window necessary
        bounds.top = clientRect.top;
        bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);
        bounds.left = clientRect.left;

        // older IE doesn't have width/height, but top/bottom instead
        bounds.width = clientRect.width || (clientRect.right - clientRect.left);
        bounds.height = clientRect.height || (clientRect.bottom - clientRect.top);

        return bounds;

    }
};

_html2canvas.Util.getCSS = function (el, attribute) {
    // return $(el).css(attribute);

    var val;

    function toPX( attribute, val ) {
        var rsLeft = el.runtimeStyle && el.runtimeStyle[ attribute ],
        left,
        style = el.style;

        // Check if we are not dealing with pixels, (Opera has issues with this)
        // Ported from jQuery css.js
        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels

        if ( !/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test( val ) && /^-?\d/.test( val ) ) {

            // Remember the original values
            left = style.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                el.runtimeStyle.left = el.currentStyle.left;
            }
            style.left = attribute === "fontSize" ? "1em" : (val || 0);
            val = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                el.runtimeStyle.left = rsLeft;
            }

        }

        if (!/^(thin|medium|thick)$/i.test( val )) {
            return Math.round(parseFloat( val )) + "px";
        }

        return val;

    }


    if ( window.getComputedStyle ) {
        if ( previousElement !== el ) {
            computedCSS = document.defaultView.getComputedStyle(el, null);
        }
        val = computedCSS[ attribute ];

        if ( attribute === "backgroundPosition" ) {

            val = (val.split(",")[0] || "0 0").split(" ");

            val[ 0 ] = ( val[0].indexOf( "%" ) === -1 ) ? toPX(  attribute + "X", val[ 0 ] ) : val[ 0 ];
            val[ 1 ] = ( val[1] === undefined ) ? val[0] : val[1]; // IE 9 doesn't return double digit always
            val[ 1 ] = ( val[1].indexOf( "%" ) === -1 ) ? toPX(  attribute + "Y", val[ 1 ] ) : val[ 1 ];
        }

    } else if ( el.currentStyle ) {
        // IE 9>
        if (attribute === "backgroundPosition") {
            // Older IE uses -x and -y
            val = [ toPX(  attribute + "X", el.currentStyle[ attribute + "X" ]  ), toPX(  attribute + "Y", el.currentStyle[ attribute + "Y" ]  ) ];
        } else {

            val = toPX(  attribute, el.currentStyle[ attribute ]  );

            if (/^(border)/i.test( attribute ) && /^(medium|thin|thick)$/i.test( val )) {
                switch (val) {
                    case "thin":
                        val = "1px";
                        break;
                    case "medium":
                        val = "0px"; // this is wrong, it should be 3px but IE uses medium for no border as well.. TODO find a work around
                        break;
                    case "thick":
                        val = "5px";
                        break;
                }
            }
        }



    }




    return val;



//return $(el).css(attribute);


};


_html2canvas.Util.BackgroundPosition = function ( el, bounds, image ) {
    // TODO add support for multi image backgrounds

    var bgposition =  _html2canvas.Util.getCSS( el, "backgroundPosition" ) ,
    topPos,
    left,
    percentage,
    val;

    if (bgposition.length === 1){
        val = bgposition;

        bgposition = [];

        bgposition[0] = val;
        bgposition[1] = val;
    }



    if (bgposition[0].toString().indexOf("%") !== -1){
        percentage = (parseFloat(bgposition[0])/100);
        left =  ((bounds.width * percentage)-(image.width*percentage));

    }else{
        left = parseInt(bgposition[0],10);
    }

    if (bgposition[1].toString().indexOf("%") !== -1){

        percentage = (parseFloat(bgposition[1])/100);
        topPos =  ((bounds.height * percentage)-(image.height*percentage));
    }else{
        topPos = parseInt(bgposition[1],10);
    }




    return {
        top: topPos,
        left: left
    };

};

_html2canvas.Util.Extend = function (options, defaults) {
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            defaults[key] = options[key];
        }
    }
    return defaults;
};


/*
 * Derived from jQuery.contents()
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
_html2canvas.Util.Children = function( elem ) {


    var children;
    try {

        children = (elem.nodeName && elem.nodeName.toUpperCase() === "IFRAME") ?
        elem.contentDocument || elem.contentWindow.document : (function( array ){
            var ret = [];

            if ( array !== null ) {

                (function( first, second ) {
                    var i = first.length,
                    j = 0;

                    if ( typeof second.length === "number" ) {
                        for ( var l = second.length; j < l; j++ ) {
                            first[ i++ ] = second[ j ];
                        }

                    } else {
                        while ( second[j] !== undefined ) {
                            first[ i++ ] = second[ j++ ];
                        }
                    }

                    first.length = i;

                    return first;
                })( ret, array );

            }

            return ret;
        })( elem.childNodes );

    } catch (ex) {
        h2clog("html2canvas.Util.Children failed with exception: " + ex.message);
        children = [];
    }
    return children;
};

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Contributor(s):
      Niklas von Hertzen <http://www.twitter.com/niklasvh>
      André Fiedler      <http://www.twitter.com/sonnenkiste>

  Released under MIT License
 */

(function(){

_html2canvas.Generate = {};

var reGradients = [
    /^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)-]+)\)$/,
    /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
    /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z-]+)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z-]*)([\w\d\.\s,%\(\)]+)\)$/,
    /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z-]+)([\w\d\.\s,%\(\)]+)\)$/
];

/*
 * TODO: Add IE10 vendor prefix (-ms) support
 * TODO: Add W3C gradient (linear-gradient) support
 * TODO: Add old Webkit -webkit-gradient(radial, ...) support
 * TODO: Maybe some RegExp optimizations are possible ;o)
 */
_html2canvas.Generate.parseGradient = function(css, bounds) {
    var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3;

    for(i = 0; i < len; i+=1){
        m1 = css.match(reGradients[i]);
        if(m1) break;
    }

    if(m1) {
        switch(m1[1]) {
            case '-webkit-linear-gradient':
            case '-o-linear-gradient':

                gradient = {
                    type: 'linear',
                    x0: null,
                    y0: null,
                    x1: null,
                    y1: null,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[2].match(/\w+/g);
                if(m2){
                    m2Len = m2.length;
                    for(i = 0; i < m2Len; i+=1){
                        switch(m2[i]) {
                            case 'top':
                                gradient.y0 = 0;
                                gradient.y1 = bounds.height;
                                break;

                            case 'right':
                                gradient.x0 = bounds.width;
                                gradient.x1 = 0;
                                break;

                            case 'bottom':
                                gradient.y0 = bounds.height;
                                gradient.y1 = 0;
                                break;

                            case 'left':
                                gradient.x0 = 0;
                                gradient.x1 = bounds.width;
                                break;
                        }
                    }
                }
                if(gradient.x0 === null && gradient.x1 === null){ // center
                    gradient.x0 = gradient.x1 = bounds.width / 2;
                }
                if(gradient.y0 === null && gradient.y1 === null){ // center
                    gradient.y0 = gradient.y1 = bounds.height / 2;
                }

                // get colors and stops
                m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i < m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3] === '%'){
                                stop /= 100;
                            } else { // px - stupid opera
                                stop /= bounds.width;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;

            case '-webkit-gradient':

                gradient = {
                    type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 0,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
                if(m2){
                    gradient.x0 = (m2[1] * bounds.width) / 100;
                    gradient.y0 = (m2[2] * bounds.height) / 100;
                    gradient.x1 = (m2[3] * bounds.width) / 100;
                    gradient.y1 = (m2[4] * bounds.height) / 100;
                }

                // get colors and stops
                m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
                if(m2){
                    m2Len = m2.length;
                    for(i = 0; i < m2Len; i+=1){
                        m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
                        stop = parseFloat(m3[2]);
                        if(m3[1] === 'from') stop = 0.0;
                        if(m3[1] === 'to') stop = 1.0;
                        gradient.colorStops.push({
                            color: m3[3],
                            stop: stop
                        });
                    }
                }
                break;

            case '-moz-linear-gradient':

                gradient = {
                    type: 'linear',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 0,
                    colorStops: []
                };

                // get coordinates
                m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

                // m2[1] == 0%   -> left
                // m2[1] == 50%  -> center
                // m2[1] == 100% -> right

                // m2[2] == 0%   -> top
                // m2[2] == 50%  -> center
                // m2[2] == 100% -> bottom

                if(m2){
                    gradient.x0 = (m2[1] * bounds.width) / 100;
                    gradient.y0 = (m2[2] * bounds.height) / 100;
                    gradient.x1 = bounds.width - gradient.x0;
                    gradient.y1 = bounds.height - gradient.y0;
                }

                // get colors and stops
                m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i < m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3]){ // percentage
                                stop /= 100;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;

            case '-webkit-radial-gradient':
            case '-moz-radial-gradient':
            case '-o-radial-gradient':

                gradient = {
                    type: 'circle',
                    x0: 0,
                    y0: 0,
                    x1: bounds.width,
                    y1: bounds.height,
                    cx: 0,
                    cy: 0,
                    rx: 0,
                    ry: 0,
                    colorStops: []
                };

                // center
                m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
                if(m2){
                    gradient.cx = (m2[1] * bounds.width) / 100;
                    gradient.cy = (m2[2] * bounds.height) / 100;
                }

                // size
                m2 = m1[3].match(/\w+/);
                m3 = m1[4].match(/[a-z-]*/);
                if(m2 && m3){
                    switch(m3[0]){
                        case 'farthest-corner':
                        case 'cover': // is equivalent to farthest-corner
                        case '': // mozilla removes "cover" from definition :(
                            var tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            var tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
                            break;
                        case 'closest-corner':
                            var tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            var tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                            var bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                            gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
                            break;
                        case 'farthest-side':
                            if(m2[0] === 'circle'){
                                gradient.rx = gradient.ry = Math.max(
                                    gradient.cx,
                                    gradient.cy,
                                    gradient.x1 - gradient.cx,
                                    gradient.y1 - gradient.cy
                                );
                            } else { // ellipse

                                gradient.type = m2[0];

                                gradient.rx = Math.max(
                                    gradient.cx,
                                    gradient.x1 - gradient.cx
                                );
                                gradient.ry = Math.max(
                                    gradient.cy,
                                    gradient.y1 - gradient.cy
                                );
                            }
                            break;
                        case 'closest-side':
                        case 'contain': // is equivalent to closest-side
                            if(m2[0] === 'circle'){
                                gradient.rx = gradient.ry = Math.min(
                                    gradient.cx,
                                    gradient.cy,
                                    gradient.x1 - gradient.cx,
                                    gradient.y1 - gradient.cy
                                );
                            } else { // ellipse

                                gradient.type = m2[0];

                                gradient.rx = Math.min(
                                    gradient.cx,
                                    gradient.x1 - gradient.cx
                                );
                                gradient.ry = Math.min(
                                    gradient.cy,
                                    gradient.y1 - gradient.cy
                                );
                            }
                            break;

                        // TODO: add support for "30px 40px" sizes (webkit only)
                    }
                }

                // color stops
                m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                if(m2){
                    m2Len = m2.length;
                    step = 1 / Math.max(m2Len - 1, 1);
                    for(i = 0; i < m2Len; i+=1){
                        m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                        if(m3[2]){
                            stop = parseFloat(m3[2]);
                            if(m3[3] === '%'){
                                stop /= 100;
                            } else { // px - stupid opera
                                stop /= bounds.width;
                            }
                        } else {
                            stop = i * step;
                        }
                        gradient.colorStops.push({
                            color: m3[1],
                            stop: stop
                        });
                    }
                }
                break;
        }
    }

    return gradient;
};

_html2canvas.Generate.Gradient = function(src, bounds) {
    var canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d'),
    gradient, grad, i, len, img;

    canvas.width = bounds.width;
    canvas.height = bounds.height;

    // TODO: add support for multi defined background gradients (like radial gradient example in background.html)
    gradient = _html2canvas.Generate.parseGradient(src, bounds);

    img = new Image();

    if(gradient){
        if(gradient.type === 'linear'){
            grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);

            for (i = 0, len = gradient.colorStops.length; i < len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog(['failed to add color stop: ', e, '; tried to add: ', gradient.colorStops[i], '; stop: ', i, '; in: ', src]);
                }
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, bounds.width, bounds.height);

            img.src = canvas.toDataURL();
        } else if(gradient.type === 'circle'){

            grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);

            for (i = 0, len = gradient.colorStops.length; i < len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog(['failed to add color stop: ', e, '; tried to add: ', gradient.colorStops[i], '; stop: ', i, '; in: ', src]);
                }
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, bounds.width, bounds.height);

            img.src = canvas.toDataURL();
        } else if(gradient.type === 'ellipse'){

            // draw circle
            var canvasRadial = document.createElement('canvas'),
                ctxRadial = canvasRadial.getContext('2d'),
                ri = Math.max(gradient.rx, gradient.ry),
                di = ri * 2, imgRadial;

            canvasRadial.width = canvasRadial.height = di;

            grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);

            for (i = 0, len = gradient.colorStops.length; i < len; i+=1) {
                try {
                    grad.addColorStop(gradient.colorStops[i].stop, gradient.colorStops[i].color);
                }
                catch(e) {
                    h2clog(['failed to add color stop: ', e, '; tried to add: ', gradient.colorStops[i], '; stop: ', i, '; in: ', src]);
                }
            }

            ctxRadial.fillStyle = grad;
            ctxRadial.fillRect(0, 0, di, di);

            ctx.fillStyle = gradient.colorStops[i - 1].color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            imgRadial = new Image();
            imgRadial.onload = function() { // wait until the image is filled

                // transform circle to ellipse
                ctx.drawImage(imgRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);

                img.src = canvas.toDataURL();

            }
            imgRadial.src = canvasRadial.toDataURL();
        }
    }

    return img;
};

_html2canvas.Generate.ListAlpha = function(number) {
    var tmp = "",
    modulus;

    do {
        modulus = number % 26;
        tmp = String.fromCharCode((modulus) + 64) + tmp;
        number = number / 26;
    }while((number*26) > 26);

    return tmp;
};

_html2canvas.Generate.ListRoman = function(number) {
    var romanArray = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"],
    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    roman = "",
    v,
    len = romanArray.length;

    if (number <= 0 || number >= 4000) {
        return number;
    }

    for (v=0; v < len; v+=1) {
        while (number >= decimal[v]) {
            number -= decimal[v];
            roman += romanArray[v];
        }
    }

    return roman;

};

})();
/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/

/*
 *  New function for traversing elements
 */

_html2canvas.Parse = function ( images, options ) {
    window.scroll(0,0);

    var support = {
        rangeBounds: false,
        svgRendering: options.svgRendering && (function( ){
            var img = new Image(),
            canvas = document.createElement("canvas"),
            ctx = (canvas.getContext === undefined) ? false : canvas.getContext("2d");
            if (ctx === false) {
                // browser doesn't support canvas, good luck supporting SVG on canvas
                return false;
            }
            canvas.width = canvas.height = 10;
            img.src = [
            "data:image/svg+xml,",
            "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>",
            "<foreignObject width='10' height='10'>",
            "<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>",
            "sup",
            "</div>",
            "</foreignObject>",
            "</svg>"
            ].join("");
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch(e) {
                return false;
            }
            h2clog('html2canvas: Parse: SVG powered rendering available');
            return true;

        })()
    },
    element = (( options.elements === undefined ) ? document.body : options.elements[0]), // select body by default
    needReorder = false,
    numDraws = 0,
    fontData = {},
    doc = element.ownerDocument,
    ignoreElementsRegExp = new RegExp("(" + options.ignoreElements + ")"),
    body = doc.body,
    r,
    testElement,
    rangeBounds,
    rangeHeight,
    stack,
    ctx,
    docDim,
    i,
    children,
    childrenLen;


    function docSize(){

        return {
            width: Math.max(
                Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
                ),
            height: Math.max(
                Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
                )
        };

    }

    images = images || {};

    // Test whether we can use ranges to measure bounding boxes
    // Opera doesn't provide valid bounds.height/bottom even though it supports the method.


    if (doc.createRange) {
        r = doc.createRange();
        //this.support.rangeBounds = new Boolean(r.getBoundingClientRect);
        if (r.getBoundingClientRect){
            testElement = doc.createElement('boundtest');
            testElement.style.height = "123px";
            testElement.style.display = "block";
            body.appendChild(testElement);

            r.selectNode(testElement);
            rangeBounds = r.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support.rangeBounds = true;
            }
            body.removeChild(testElement);


        }

    }


    /*
    var rootStack = new this.storageContext($(document).width(),$(document).height());
    rootStack.opacity = this.getCSS(this.element,"opacity");
    var stack = this.newElement(this.element,rootStack);


    this.parseElement(this.element,stack);
     */




    var getCSS = _html2canvas.Util.getCSS;
    function getCSSInt(element, attribute) {
        var val = parseInt(getCSS(element, attribute), 10);
        return (isNaN(val)) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html
    }

    // Drawing a rectangle
    function renderRect (ctx, x, y, w, h, bgcolor) {
        if (bgcolor !=="transparent"){
            ctx.setVariable("fillStyle", bgcolor);
            ctx.fillRect (x, y, w, h);
            numDraws+=1;
        }
    }


    function textTransform (text, transform) {
        switch(transform){
            case "lowercase":
                return text.toLowerCase();

            case "capitalize":
                return text.replace( /(^|\s|:|-|\(|\))([a-z])/g , function (m, p1, p2) {
                    if (m.length > 0) {
                        return p1 + p2.toUpperCase();
                    }
                } );

            case "uppercase":
                return text.toUpperCase();

            default:
                return text;

        }

    }

    function trimText (text) {
        return text.replace(/^\s*/g, "").replace(/\s*$/g, "");
    }

    function fontMetrics (font, fontSize) {

        if (fontData[font + "-" + fontSize] !== undefined) {
            return fontData[font + "-" + fontSize];
        }


        var container = doc.createElement('div'),
        img = doc.createElement('img'),
        span = doc.createElement('span'),
        baseline,
        middle,
        metricsObj;


        container.style.visibility = "hidden";
        container.style.fontFamily = font;
        container.style.fontSize = fontSize;
        container.style.margin = 0;
        container.style.padding = 0;

        body.appendChild(container);



        // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
        img.src = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=";
        img.width = 1;
        img.height = 1;

        img.style.margin = 0;
        img.style.padding = 0;
        img.style.verticalAlign = "baseline";

        span.style.fontFamily = font;
        span.style.fontSize = fontSize;
        span.style.margin = 0;
        span.style.padding = 0;




        span.appendChild(doc.createTextNode('Hidden Text'));
        container.appendChild(span);
        container.appendChild(img);
        baseline = (img.offsetTop - span.offsetTop) + 1;

        container.removeChild(span);
        container.appendChild(doc.createTextNode('Hidden Text'));

        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";

        middle = (img.offsetTop-container.offsetTop) + 1;
        metricsObj = {
            baseline: baseline,
            lineWidth: 1,
            middle: middle
        };


        fontData[font + "-" + fontSize] = metricsObj;

        body.removeChild(container);

        return metricsObj;

    }


    function drawText(currentText, x, y, ctx){
        if (trimText(currentText).length>0) {
            ctx.fillText(currentText,x,y);
            numDraws+=1;
        }
    }


    function renderText(el, textNode, stack) {
        var ctx = stack.ctx,
        family = getCSS(el, "fontFamily"),
        size = getCSS(el, "fontSize"),
        color = getCSS(el, "color"),
        text_decoration = getCSS(el, "textDecoration"),
        text_align = getCSS(el, "textAlign"),
        letter_spacing = getCSS(el, "letterSpacing"),
        bounds,
        text,
        metrics,
        renderList,
        listLen,
        bold = getCSS(el, "fontWeight"),
        font_style = getCSS(el, "fontStyle"),
        font_variant = getCSS(el, "fontVariant"),
        align = false,
        newTextNode,
        textValue,
        textOffset = 0,
        oldTextNode,
        c,
        range,
        parent,
        wrapElement,
        backupText;

        // apply text-transform:ation to the text



        textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, "textTransform"));
        text = trimText(textNode.nodeValue);

        if (text.length>0){

            if (text_decoration !== "none"){
                metrics = fontMetrics(family, size);
            }

            text_align = text_align.replace(["-webkit-auto"],["auto"]);

            if (options.letterRendering === false && /^(left|right|justify|auto)$/.test(text_align) && /^(normal|none)$/.test(letter_spacing)){
                // this.setContextVariable(ctx,"textAlign",text_align);
                renderList = textNode.nodeValue.split(/(\b| )/);

            }else{
                //  this.setContextVariable(ctx,"textAlign","left");
                renderList = textNode.nodeValue.split("");
            }

            switch(parseInt(bold, 10)){
                case 401:
                    bold = "bold";
                    break;
                case 400:
                    bold = "normal";
                    break;
            }

            ctx.setVariable("fillStyle", color);

            /*
              need to be defined in the order as defined in http://www.w3.org/TR/CSS21/fonts.html#font-shorthand
              to properly work in Firefox
            */
            ctx.setVariable("font", font_style+ " " + font_variant  + " " + bold + " " + size + " " + family);

            if (align){
                ctx.setVariable("textAlign", "right");
            }else{
                ctx.setVariable("textAlign", "left");
            }


            /*
        if (stack.clip){
        ctx.rect (stack.clip.left, stack.clip.top, stack.clip.width, stack.clip.height);
        ctx.clip();
        }
             */


            oldTextNode = textNode;


            for ( c=0, listLen = renderList.length; c < listLen; c+=1 ) {
                textValue = null;



                if (support.rangeBounds){
                    // getBoundingClientRect is supported for ranges
                    if (text_decoration !== "none" || trimText(renderList[c]).length !== 0) {
                        textValue = renderList[c];
                        if (doc.createRange){
                            range = doc.createRange();

                            range.setStart(textNode, textOffset);
                            range.setEnd(textNode, textOffset + textValue.length);
                        }else{
                            // TODO add IE support
                            range = body.createTextRange();
                        }

                        if (range.getBoundingClientRect()) {
                            bounds = range.getBoundingClientRect();
                        }else{
                            bounds = {};
                        }

                    }
                }else{
                    // it isn't supported, so let's wrap it inside an element instead and get the bounds there

                    // IE 9 bug
                    if (typeof oldTextNode.nodeValue !== "string" ){
                        continue;
                    }

                    newTextNode = oldTextNode.splitText(renderList[c].length);

                    parent = oldTextNode.parentNode;
                    wrapElement = doc.createElement('wrapper');
                    backupText = oldTextNode.cloneNode(true);

                    wrapElement.appendChild(oldTextNode.cloneNode(true));
                    parent.replaceChild(wrapElement, oldTextNode);

                    bounds = _html2canvas.Util.Bounds(wrapElement);

                    textValue = oldTextNode.nodeValue;

                    oldTextNode = newTextNode;
                    parent.replaceChild(backupText, wrapElement);


                }

                if (textValue !== null){
                    drawText(textValue, bounds.left, bounds.bottom, ctx);
                }

                switch(text_decoration) {
                    case "underline":
                        // Draws a line at the baseline of the font
                        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                        renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
                        break;
                    case "overline":
                        renderRect(ctx, bounds.left, bounds.top, bounds.width, 1, color);
                        break;
                    case "line-through":
                        // TODO try and find exact position for line-through
                        renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
                        break;

                }





                textOffset += renderList[c].length;

            }



        }

    }

    function listPosition (element, val) {
        var boundElement = doc.createElement( "boundelement" ),
        type,
        bounds;

        boundElement.style.display = "inline";
        //boundElement.style.width = "1px";
        //boundElement.style.height = "1px";

        type = element.style.listStyleType;
        element.style.listStyleType = "none";

        boundElement.appendChild( doc.createTextNode( val ) );


        element.insertBefore(boundElement, element.firstChild);


        bounds = _html2canvas.Util.Bounds( boundElement );
        element.removeChild( boundElement );
        element.style.listStyleType = type;
        return bounds;

    }
    

    
    function elementIndex( el ) {
        var i = -1,
        count = 1,
        childs = el.parentNode.childNodes;

        if ( el.parentNode ) {
            while( childs[ ++i ] !== el ) {
               if ( childs[ i ].nodeType === 1 ) {
                   count++;
               }
            }
            return count;
        } else {
            return -1;
        }
       
    }

    function renderListItem(element, stack, elBounds) {


        var position = getCSS(element, "listStylePosition"),
        x,
        y,
        type = getCSS(element, "listStyleType"),
        currentIndex,
        text,
        listBounds,
        bold = getCSS(element, "fontWeight");

        if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {

            currentIndex = elementIndex( element );

            switch(type){
                case "decimal":
                    text = currentIndex;
                    break;
                case "decimal-leading-zero":
                    if (currentIndex.toString().length === 1){
                        text = currentIndex = "0" + currentIndex.toString();
                    }else{
                        text = currentIndex.toString();
                    }
                    break;
                case "upper-roman":
                    text = _html2canvas.Generate.ListRoman( currentIndex );
                    break;
                case "lower-roman":
                    text = _html2canvas.Generate.ListRoman( currentIndex ).toLowerCase();
                    break;
                case "lower-alpha":
                    text = _html2canvas.Generate.ListAlpha( currentIndex ).toLowerCase();
                    break;
                case "upper-alpha":
                    text = _html2canvas.Generate.ListAlpha( currentIndex );
                    break;
            }


            text += ". ";
            listBounds = listPosition(element, text);



            switch(bold){
                case 401:
                    bold = "bold";
                    break;
                case 400:
                    bold = "normal";
                    break;
            }




            ctx.setVariable( "fillStyle", getCSS(element, "color") );
            ctx.setVariable( "font", getCSS(element, "fontVariant") + " " + bold + " " + getCSS(element, "fontStyle") + " " + getCSS(element, "fontSize") + " " + getCSS(element, "fontFamily") );


            if ( position === "inside" ) {
                ctx.setVariable("textAlign", "left");
                //   this.setFont(stack.ctx, element, false);
                x = elBounds.left;

            }else{
                return;
            /*
                 TODO really need to figure out some more accurate way to try and find the position.
                 as defined in http://www.w3.org/TR/CSS21/generate.html#propdef-list-style-position, it does not even have a specified "correct" position, so each browser
                 may display it whatever way it feels like.
                 "The position of the list-item marker adjacent to floats is undefined in CSS 2.1. CSS 2.1 does not specify the precise location of the marker box or its position in the painting order"

                ctx.setVariable("textAlign", "right");
                //  this.setFont(stack.ctx, element, true);
                x = elBounds.left - 10;
                 */
            }

            y = listBounds.bottom;

            drawText(text, x, y, ctx);


        }


    }

    function loadImage (src){
        var img = images[src];
        if (img && img.succeeded === true) {
            return img.img;
        } else {
            return false;
        }
    }






    function clipBounds(src, dst){

        var x = Math.max(src.left, dst.left),
        y = Math.max(src.top, dst.top),
        x2 = Math.min((src.left + src.width), (dst.left + dst.width)),
        y2 = Math.min((src.top + src.height), (dst.top + dst.height));

        return {
            left:x,
            top:y,
            width:x2-x,
            height:y2-y
        };

    }

    function setZ(zIndex, parentZ){
        // TODO fix static elements overlapping relative/absolute elements under same stack, if they are defined after them
        var newContext;
        if (!parentZ){
            newContext = h2czContext(0);
            return newContext;
        }

        if (zIndex !== "auto"){
            needReorder = true;
            newContext = h2czContext(zIndex);
            parentZ.children.push(newContext);
            return newContext;

        }

        return parentZ;

    }

    function renderBorders(el, ctx, bounds, clip){

        /*
         *  TODO add support for different border-style's than solid
         */

        var x = bounds.left,
        y = bounds.top,
        w = bounds.width,
        h = bounds.height,
        borderSide,
        borderData,
        bx,
        by,
        bw,
        bh,
        borderBounds,
        borders = (function(el){
            var borders = [],
            sides = ["Top","Right","Bottom","Left"],
            s;

            for (s = 0; s < 4; s+=1){
                borders.push({
                    width: getCSSInt(el, 'border' + sides[s] + 'Width'),
                    color: getCSS(el, 'border' + sides[s] + 'Color')
                });
            }

            return borders;

        }(el));


        for (borderSide = 0; borderSide < 4; borderSide+=1){
            borderData = borders[borderSide];

            if (borderData.width>0){
                bx = x;
                by = y;
                bw = w;
                bh = h - (borders[2].width);

                switch(borderSide){
                    case 0:
                        // top border
                        bh = borders[0].width;
                        break;
                    case 1:
                        // right border
                        bx = x + w - (borders[1].width);
                        bw = borders[1].width;
                        break;
                    case 2:
                        // bottom border
                        by = (by + h) - (borders[2].width);
                        bh = borders[2].width;
                        break;
                    case 3:
                        // left border
                        bw = borders[3].width;
                        break;
                }

                borderBounds = {
                    left:bx,
                    top:by,
                    width: bw,
                    height:bh
                };

                if (clip){
                    borderBounds = clipBounds(borderBounds, clip);
                }


                if (borderBounds.width>0 && borderBounds.height>0){
                    renderRect(ctx, bx, by, borderBounds.width, borderBounds.height, borderData.color);
                }


            }
        }

        return borders;

    }


    function renderFormValue (el, bounds, stack){

        var valueWrap = doc.createElement('valuewrap'),
        cssArr = ['lineHeight','textAlign','fontFamily','color','fontSize','paddingLeft','paddingTop','width','height','border','borderLeftWidth','borderTopWidth'],
        i,
        textValue,
        textNode,
        arrLen,
        style;

        for (i = 0, arrLen = cssArr.length; i < arrLen; i+=1){
            style = cssArr[i];

            try {
                valueWrap.style[style] = getCSS(el, style);
            } catch( e ) {
                // Older IE has issues with "border"
                h2clog("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
            }
        }


        valueWrap.style.borderColor = "black";
        valueWrap.style.borderStyle = "solid";
        valueWrap.style.display = "block";
        valueWrap.style.position = "absolute";
        if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === "SELECT"){
            valueWrap.style.lineHeight = getCSS(el, "height");
        }


        valueWrap.style.top = bounds.top + "px";
        valueWrap.style.left = bounds.left + "px";

        if (el.nodeName === "SELECT"){
            // TODO increase accuracy of text position
            textValue = el.options[el.selectedIndex].text;
        } else{
            textValue = el.value;
        }
        textNode = doc.createTextNode(textValue);

        valueWrap.appendChild(textNode);
        body.appendChild(valueWrap);


        renderText(el, textNode, stack);
        body.removeChild(valueWrap);



    }





    function renderImage (ctx, image, sx, sy, sw, sh, dx, dy, dw, dh) {
        ctx.drawImage(
            image,
            sx, //sx
            sy, //sy
            sw, //sw
            sh, //sh
            dx, //dx
            dy, // dy
            dw, //dw
            dh //dh
            );
        numDraws+=1;

    }


    function renderBackgroundRepeat (ctx, image, x, y, width, height, elx, ely){
        var sourceX = 0,
        sourceY=0;
        if (elx-x>0){
            sourceX = elx-x;
        }

        if (ely-y>0){
            sourceY = ely-y;
        }

        renderImage(
            ctx,
            image,
            sourceX, // source X
            sourceY, // source Y
            width-sourceX, // source Width
            height-sourceY, // source Height
            x+sourceX, // destination X
            y+sourceY, // destination Y
            width-sourceX, // destination width
            height-sourceY // destination height
            );
    }


    function renderBackgroundRepeatY (ctx, image, bgp, x, y, w, h){

        var height,
        width = Math.min(image.width,w),bgy;

        bgp.top = bgp.top-Math.ceil(bgp.top/image.height)*image.height;


        for(bgy=(y+bgp.top);bgy<h+y;){


            if ( Math.floor(bgy+image.height)>h+y){
                height = (h+y)-bgy;
            }else{
                height = image.height;
            }
            renderBackgroundRepeat(ctx,image,x+bgp.left,bgy,width,height,x,y);

            bgy = Math.floor(bgy+image.height);

        }
    }

    function renderBackgroundRepeatX(ctx, image, bgp, x, y, w, h){

        var height = Math.min(image.height,h),
        width,bgx;


        bgp.left = bgp.left-Math.ceil(bgp.left/image.width)*image.width;


        for (bgx=(x+bgp.left);bgx<w+x;) {

            if (Math.floor(bgx+image.width)>w+x){
                width = (w+x)-bgx;
            }else{
                width = image.width;
            }

            renderBackgroundRepeat(ctx,image,bgx,(y+bgp.top),width,height,x,y);

            bgx = Math.floor(bgx+image.width);


        }
    }

    function renderBackground(el,bounds,ctx){

        // TODO add support for multi background-images
        var background_image = getCSS(el, "backgroundImage"),
        background_repeat = getCSS(el, "backgroundRepeat").split(",")[0],
        image,
        bgp,
        bgy,
        bgw,
        bgsx,
        bgsy,
        bgdx,
        bgdy,
        bgh,
        h,
        height,
        add;

        //   if (typeof background_image !== "undefined" && /^(1|none)$/.test(background_image) === false && /^(-webkit|-moz|linear-gradient|-o-)/.test(background_image)===false){

        if ( !/data:image\/.*;base64,/i.test(background_image) && !/^(-webkit|-moz|linear-gradient|-o-)/.test(background_image) ) {
            background_image = background_image.split(",")[0];
        }

        if ( typeof background_image !== "undefined" && /^(1|none)$/.test( background_image ) === false ) {
            background_image = _html2canvas.Util.backgroundImage( background_image );
            image = loadImage( background_image );


            bgp = _html2canvas.Util.BackgroundPosition(el, bounds, image);

            // TODO add support for background-origin
            if ( image ){
                switch ( background_repeat ) {

                    case "repeat-x":
                        renderBackgroundRepeatX( ctx, image, bgp, bounds.left, bounds.top, bounds.width, bounds.height );
                        break;

                    case "repeat-y":
                        renderBackgroundRepeatY( ctx, image, bgp, bounds.left, bounds.top, bounds.width, bounds.height );
                        break;

                    case "no-repeat":
                        /*
                    this.drawBackgroundRepeat(
                        ctx,
                        image,
                        bgp.left+bounds.left, // sx
                        bgp.top+bounds.top, // sy
                        Math.min(bounds.width,image.width),
                        Math.min(bounds.height,image.height),
                        bounds.left,
                        bounds.top
                        );*/


                       
                        bgw = bounds.width - bgp.left;
                        bgh = bounds.height - bgp.top;
                        bgsx = bgp.left;
                        bgsy = bgp.top;
                        bgdx = bgp.left+bounds.left;
                        bgdy = bgp.top+bounds.top;

                        //
                        //     bgw = Math.min(bgw,image.width);
                        //  bgh = Math.min(bgh,image.height);

                        if (bgsx<0){
                            bgsx = Math.abs(bgsx);
                            bgdx += bgsx;
                            bgw = Math.min(bounds.width,image.width-bgsx);
                        }else{
                            bgw = Math.min(bgw,image.width);
                            bgsx = 0;
                        }

                        if (bgsy<0){
                            bgsy = Math.abs(bgsy);
                            bgdy += bgsy;
                            // bgh = bgh-bgsy;
                            bgh = Math.min(bounds.height,image.height-bgsy);
                        }else{
                            bgh = Math.min(bgh,image.height);
                            bgsy = 0;
                        }


                        if (bgh>0 && bgw > 0){
                            renderImage(
                                ctx,
                                image,
                                bgsx, // source X : 0
                                bgsy, // source Y : 1695
                                bgw, // source Width : 18
                                bgh, // source Height : 1677
                                bgdx, // destination X :906
                                bgdy, // destination Y : 1020
                                bgw, // destination width : 18
                                bgh // destination height : 1677
                                );

                        }
                        break;
                    default:



                        bgp.top = bgp.top-Math.ceil(bgp.top/image.height)*image.height;


                        for(bgy=(bounds.top+bgp.top);bgy<bounds.height+bounds.top;){



                            h = Math.min(image.height,(bounds.height+bounds.top)-bgy);


                            if ( Math.floor(bgy+image.height)>h+bgy){
                                height = (h+bgy)-bgy;
                            }else{
                                height = image.height;
                            }
                            // console.log(height);

                            if (bgy<bounds.top){
                                add = bounds.top-bgy;
                                bgy = bounds.top;

                            }else{
                                add = 0;
                            }

                            renderBackgroundRepeatX(ctx,image,bgp,bounds.left,bgy,bounds.width,height);
                            if (add>0){
                                bgp.top += add;
                            }
                            bgy = Math.floor(bgy+image.height)-add;
                        }
                        break;


                }
            }else{
                h2clog("html2canvas: Error loading background:" + background_image);
            //console.log(images);
            }

        }
    }



    function renderElement(el, parentStack){

        var bounds = _html2canvas.Util.Bounds(el),
        x = bounds.left,
        y = bounds.top,
        w = bounds.width,
        h = bounds.height,
        image,
        bgcolor = getCSS(el, "backgroundColor"),
        cssPosition = getCSS(el, "position"),
        zindex,
        opacity = getCSS(el, "opacity"),
        stack,
        stackLength,
        borders,
        ctx,
        bgbounds,
        imgSrc,
        paddingLeft,
        paddingTop,
        paddingRight,
        paddingBottom;

        if (!parentStack){
            docDim = docSize();
            parentStack = {
                opacity: 1
            };
        }else{
            docDim = {};
        }


        //var zindex = this.formatZ(this.getCSS(el,"zIndex"),cssPosition,parentStack.zIndex,el.parentNode);

        zindex = setZ( getCSS( el, "zIndex"), parentStack.zIndex );



        stack = {
            ctx: h2cRenderContext( docDim.width || w , docDim.height || h ),
            zIndex: zindex,
            opacity: opacity * parentStack.opacity,
            cssPosition: cssPosition
        };



        // TODO correct overflow for absolute content residing under a static position

        if (parentStack.clip){
            stack.clip = _html2canvas.Util.Extend( {}, parentStack.clip );
        //stack.clip = parentStack.clip;
        //   stack.clip.height = stack.clip.height - parentStack.borders[2].width;
        }


        if ( options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(el, "overflow")) === true && /(BODY)/i.test(el.nodeName) === false ){
            if (stack.clip){
                stack.clip = clipBounds(stack.clip, bounds);
            }else{
                stack.clip = bounds;
            }
        }


        stackLength =  zindex.children.push(stack);

        ctx = zindex.children[stackLength-1].ctx;

        ctx.setVariable("globalAlpha", stack.opacity);

        // draw element borders
        borders = renderBorders(el, ctx, bounds, false);
        stack.borders = borders;


        // let's modify clip area for child elements, so borders dont get overwritten

        /*
    if (stack.clip){
        stack.clip.width = stack.clip.width-(borders[1].width);
        stack.clip.height = stack.clip.height-(borders[2].width);
    }
     */
        if (ignoreElementsRegExp.test(el.nodeName) && options.iframeDefault !== "transparent"){
            if (options.iframeDefault === "default"){
                bgcolor = "#efefef";
            }else{
                bgcolor = options.iframeDefault;
            }
        }

        // draw base element bgcolor

        bgbounds = {
            left: x + borders[3].width,
            top: y + borders[0].width,
            width: w - (borders[1].width + borders[3].width),
            height: h - (borders[0].width + borders[2].width)
        };

        //if (this.withinBounds(stack.clip,bgbounds)){

        if (stack.clip){
            bgbounds = clipBounds(bgbounds, stack.clip);

        //}

        }


        if (bgbounds.height > 0 && bgbounds.width > 0){
            renderRect(
                ctx,
                bgbounds.left,
                bgbounds.top,
                bgbounds.width,
                bgbounds.height,
                bgcolor
                );

            renderBackground(el, bgbounds, ctx);
        }

        switch(el.nodeName){
            case "IMG":
                imgSrc = el.getAttribute('src');
                image = loadImage(imgSrc);
                if (image){

                    paddingLeft = getCSSInt(el, 'paddingLeft');
                    paddingTop = getCSSInt(el, 'paddingTop');
                    paddingRight = getCSSInt(el, 'paddingRight');
                    paddingBottom = getCSSInt(el, 'paddingBottom');


                    renderImage(
                        ctx,
                        image,
                        0, //sx
                        0, //sy
                        image.width, //sw
                        image.height, //sh
                        x + paddingLeft + borders[3].width, //dx
                        y + paddingTop + borders[0].width, // dy
                        bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                        bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
                        );

                }else{
                    h2clog("html2canvas: Error loading <img>:" + imgSrc);
                }
                break;
            case "INPUT":
                // TODO add all relevant type's, i.e. HTML5 new stuff
                // todo add support for placeholder attribute for browsers which support it
                if (/^(text|url|email|submit|button|reset)$/.test(el.type) && el.value.length > 0){

                    renderFormValue(el, bounds, stack);


                /*
                 this just doesn't work well enough

                this.newText(el,{
                    nodeValue:el.value,
                    splitText: function(){
                        return this;
                    },
                    formValue:true
                },stack);
                 */
                }
                break;
            case "TEXTAREA":
                if (el.value.length > 0){
                    renderFormValue(el, bounds, stack);
                }
                break;
            case "SELECT":
                if (el.options.length > 0){
                    renderFormValue(el, bounds, stack);
                }
                break;
            case "LI":
                renderListItem(el, stack, bgbounds);
                break;
            case "CANVAS":
                paddingLeft = getCSSInt(el, 'paddingLeft');
                paddingTop = getCSSInt(el, 'paddingTop');
                paddingRight = getCSSInt(el, 'paddingRight');
                paddingBottom = getCSSInt(el, 'paddingBottom');
                renderImage(
                    ctx,
                    el,
                    0, //sx
                    0, //sy
                    el.width, //sw
                    el.height, //sh
                    x + paddingLeft + borders[3].width, //dx
                    y + paddingTop + borders[0].width, // dy
                    bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                    bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
                    );
                break;
        }

        return zindex.children[stackLength - 1];
    }



    function parseElement (el, stack) {

        // skip hidden elements and their children
        if (getCSS(el, 'display') !== "none" && getCSS(el, 'visibility') !== "hidden") {

            stack = renderElement(el, stack) || stack;

            ctx = stack.ctx;

            if ( !ignoreElementsRegExp.test( el.nodeName ) ) {
                var elementChildren = _html2canvas.Util.Children( el ),
                i,
                node,
                childrenLen;
                for (i = 0, childrenLen = elementChildren.length; i < childrenLen; i+=1) {
                    node = elementChildren[i];

                    if ( node.nodeType === 1 ) {
                        parseElement(node, stack);
                    }else if ( node.nodeType === 3 ) {
                        renderText(el, node, stack);
                    }

                }

            }
        } 
    }

    stack = renderElement(element, null);

    /*
    SVG powered HTML rendering, non-tainted canvas available from FF 11+ onwards
    */

    if ( support.svgRendering ) {
        (function( body ){
            var img = new Image(),
            size =  docSize(),
            html = "";

            function parseDOM( el ) {
                var children = _html2canvas.Util.Children( el ),
                len = children.length,
                attr,
                a,
                alen,
                elm,
                i;
                for ( i = 0; i < len; i+=1 ) {
                    elm = children[ i ];
                    if ( elm.nodeType === 3 ) {
                        // Text node

                        html += elm.nodeValue.replace(/\</g,"&lt;").replace(/\>/g,"&gt;");
                    } else if ( elm.nodeType === 1 ) {
                        // Element
                        if ( !/^(script|meta|title)$/.test(elm.nodeName.toLowerCase()) ) {

                            html += "<" + elm.nodeName.toLowerCase();

                            // add attributes
                            if ( elm.hasAttributes() ) {
                                attr = elm.attributes;
                                alen = attr.length;
                                for ( a = 0; a < alen; a+=1 ) {
                                    html += " " + attr[ a ].name + '="' + attr[ a ].value + '"';
                                }
                            }


                            html += '>';

                            parseDOM( elm );


                            html += "</" + elm.nodeName.toLowerCase() + ">";
                        }
                    }

                }

            }

            parseDOM( body );
            img.src = [
            "data:image/svg+xml,",
            "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='" + size.width + "' height='" + size.height + "'>",
            "<foreignObject width='" + size.width + "' height='" + size.height + "'>",
            "<html xmlns='http://www.w3.org/1999/xhtml' style='margin:0;'>",
            html.replace(/\#/g,"%23"),
            "</html>",
            "</foreignObject>",
            "</svg>"
            ].join("");




            img.onload = function() {
                stack.svgRender = img;
            };

        })( document.documentElement );

    }


    // parse every child element
    for (i = 0, children = element.children, childrenLen = children.length; i < childrenLen; i+=1){
        parseElement(children[i], stack);
    }


    stack.backgroundColor = getCSS( document.documentElement, "backgroundColor" );

    return stack;

};

function h2czContext(zindex) {
    return {
        zindex: zindex,
        children: []
    };
}

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
 */

_html2canvas.Preload = function( options ) {

    var images = {
        numLoaded: 0,   // also failed are counted here
        numFailed: 0,
        numTotal: 0,
        cleanupDone: false
    },
    pageOrigin,
    methods,
    i,
    count = 0,
    element = options.elements[0] || document.body,
    doc = element.ownerDocument,
    domImages = doc.images, // TODO probably should limit it to images present in the element only
    imgLen = domImages.length,
    link = doc.createElement("a"),
    supportCORS = (function( img ){
        return (img.crossOrigin !== undefined);
    })(new Image()),
    timeoutTimer;

    link.href = window.location.href;
    pageOrigin  = link.protocol + link.host;






    function isSameOrigin(url){
        link.href = url;
        link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
        var origin = link.protocol + link.host;
        return (origin === pageOrigin);
    }

    function start(){
        h2clog("html2canvas: start: images: " + images.numLoaded + " / " + images.numTotal + " (failed: " + images.numFailed + ")");
        if (!images.firstRun && images.numLoaded >= images.numTotal){
            h2clog("Finished loading images: # " + images.numTotal + " (failed: " + images.numFailed + ")");

            if (typeof options.complete === "function"){
                options.complete(images);
            }

        }
    }

    // TODO modify proxy to serve images with CORS enabled, where available
    function proxyGetImage(url, img, imageObj){
        var callback_name,
        scriptUrl = options.proxy,
        script;

        link.href = url;
        url = link.href; // work around for pages with base href="" set - WARNING: this may change the url

        callback_name = 'html2canvas_' + (count++);
        imageObj.callbackname = callback_name;

        if (scriptUrl.indexOf("?") > -1) {
            scriptUrl += "&";
        } else {
            scriptUrl += "?";
        }
        scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;
        script = doc.createElement("script");

        window[callback_name] = function(a){
            if (a.substring(0,6) === "error:"){
                imageObj.succeeded = false;
                images.numLoaded++;
                images.numFailed++;
                start();
            } else {
                setImageLoadHandlers(img, imageObj);
                img.src = a;
            }
            window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
            try {
                delete window[callback_name];  // for all browser that support this
            } catch(ex) {}
            script.parentNode.removeChild(script);
            script = null;
            delete imageObj.script;
            delete imageObj.callbackname;
        };

        script.setAttribute("type", "text/javascript");
        script.setAttribute("src", scriptUrl);
        imageObj.script = script;
        window.document.body.appendChild(script);

    }

    function getImages (el) {



        // if (!this.ignoreRe.test(el.nodeName)){
        //
        
        var contents = _html2canvas.Util.Children(el),
        i,
        background_image,
        src,
        img,
        elNodeType = false;

        // Firefox fails with permission denied on pages with iframes
        try {
            var contentsLen = contents.length;
            for (i = 0;  i < contentsLen; i+=1 ){
                // var ignRe = new RegExp("("+this.ignoreElements+")");
                // if (!ignRe.test(element.nodeName)){
                getImages(contents[i]);
                // }
            }
        }
        catch( e ) {}


        // }
        try {
            elNodeType = el.nodeType;
        } catch (ex) {
            elNodeType = false;
            h2clog("html2canvas: failed to access some element's nodeType - Exception: " + ex.message);
        }

        if (elNodeType === 1 || elNodeType === undefined){

            // opera throws exception on external-content.html
            try {
                background_image = _html2canvas.Util.getCSS(el, 'backgroundImage');
            }catch(e) {
                h2clog("html2canvas: failed to get background-image - Exception: " + e.message);
            }
            if ( background_image && background_image !== "1" && background_image !== "none" ) {

                // TODO add multi image background support

                if (/^(-webkit|-o|-moz|-ms|linear)-/.test( background_image )) {

                    img = _html2canvas.Generate.Gradient( background_image, _html2canvas.Util.Bounds( el ) );

                    if ( img !== undefined ){
                        images[background_image] = {
                            img: img,
                            succeeded: true
                        };
                        images.numTotal++;
                        images.numLoaded++;
                        start();

                    }

                } else {
                    src = _html2canvas.Util.backgroundImage(background_image.match(/data:image\/.*;base64,/i) ? background_image : background_image.split(",")[0]);
                    methods.loadImage(src);
                }

                /*
            if (background_image && background_image !== "1" && background_image !== "none" && background_image.substring(0,7) !== "-webkit" && background_image.substring(0,3)!== "-o-" && background_image.substring(0,4) !== "-moz"){
                // TODO add multi image background support
                src = _html2canvas.Util.backgroundImage(background_image.split(",")[0]);
                methods.loadImage(src);            */
            }
        }
    }

    function setImageLoadHandlers(img, imageObj) {
        img.onload = function() {
            if ( imageObj.timer !== undefined ) {
                // CORS succeeded
                window.clearTimeout( imageObj.timer );
            }

            images.numLoaded++;
            imageObj.succeeded = true;
            img.onerror = img.onload = null;
            start();
        };
        img.onerror = function() {

            if (img.crossOrigin === "anonymous") {
                // CORS failed
                window.clearTimeout( imageObj.timer );

                // let's try with proxy instead
                if ( options.proxy ) {
                    var src = img.src;
                    img = new Image();
                    imageObj.img = img;
                    img.src = src;

                    proxyGetImage( img.src, img, imageObj );
                    return;
                }
            }


            images.numLoaded++;
            images.numFailed++;
            imageObj.succeeded = false;
            img.onerror = img.onload = null;
            start();

        };

        // TODO Opera has no load/error event for SVG images

        // Opera ninja onload's cached images
        /*
        window.setTimeout(function(){
            if ( img.width !== 0 && imageObj.succeeded === undefined ) {
                img.onload();
            }
        }, 100); // needs a reflow for base64 encoded images? interestingly timeout of 0 doesn't work but 1 does.
         */
    }


    methods = {
        loadImage: function( src ) {
            var img, imageObj;
            if ( src && images[src] === undefined ) {
                img = new Image();
                if ( src.match(/data:image\/.*;base64,/i) ) {
                    img.src = src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, '');
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                } else if ( isSameOrigin( src ) || options.allowTaint ===  true ) {
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                    img.src = src;
                } else if ( supportCORS && !options.allowTaint && options.useCORS ) {
                    // attempt to load with CORS

                    img.crossOrigin = "anonymous";
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    setImageLoadHandlers(img, imageObj);
                    img.src = src;

                    // work around for https://bugs.webkit.org/show_bug.cgi?id=80028
                    img.customComplete = function () {
                        if (!this.img.complete) {
                            this.timer = window.setTimeout(this.img.customComplete, 100);
                        } else {
                            this.img.onerror();
                        }
                    }.bind(imageObj);
                    img.customComplete();

                } else if ( options.proxy ) {
                    imageObj = images[src] = {
                        img: img
                    };
                    images.numTotal++;
                    proxyGetImage( src, img, imageObj );
                }
            }

        },
        cleanupDOM: function(cause) {
            var img, src;
            if (!images.cleanupDone) {
                if (cause && typeof cause === "string") {
                    h2clog("html2canvas: Cleanup because: " + cause);
                } else {
                    h2clog("html2canvas: Cleanup after timeout: " + options.timeout + " ms.");
                }

                for (src in images) {
                    if (images.hasOwnProperty(src)) {
                        img = images[src];
                        if (typeof img === "object" && img.callbackname && img.succeeded === undefined) {
                            // cancel proxy image request
                            window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                            try {
                                delete window[img.callbackname];  // for all browser that support this
                            } catch(ex) {}
                            if (img.script && img.script.parentNode) {
                                img.script.setAttribute("src", "about:blank");  // try to cancel running request
                                img.script.parentNode.removeChild(img.script);
                            }
                            images.numLoaded++;
                            images.numFailed++;
                            h2clog("html2canvas: Cleaned up failed img: '" + src + "' Steps: " + images.numLoaded + " / " + images.numTotal);
                        }
                    }
                }

                // cancel any pending requests
                if(window.stop !== undefined) {
                    window.stop();
                } else if(document.execCommand !== undefined) {
                    document.execCommand("Stop", false);
                }
                if (document.close !== undefined) {
                    document.close();
                }
                images.cleanupDone = true;
                if (!(cause && typeof cause === "string")) {
                    start();
                }
            }
        },
        renderingDone: function() {
            if (timeoutTimer) {
                window.clearTimeout(timeoutTimer);
            }
        }

    };

    if (options.timeout > 0) {
        timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
    }
    h2clog('html2canvas: Preload starts: finding background-images');
    images.firstRun = true;

    getImages( element );

    h2clog('html2canvas: Preload: Finding images');
    // load <img> images
    for (i = 0; i < imgLen; i+=1){
        methods.loadImage( domImages[i].getAttribute( "src" ) );
    }

    images.firstRun = false;
    h2clog('html2canvas: Preload: Done.');
    if ( images.numTotal === images.numLoaded ) {
        start();
    }

    return methods;

};




/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/
function h2cRenderContext(width, height) {
    var storage = [];
    return {
        storage: storage,
        width: width,
        height: height,
        fillRect: function () {
            storage.push({
                type: "function",
                name: "fillRect",
                'arguments': arguments
            });
        },
        drawImage: function () {
            storage.push({
                type: "function",
                name: "drawImage",
                'arguments': arguments
            });
        },
        fillText: function () {
            storage.push({
                type: "function",
                name: "fillText",
                'arguments': arguments
            });
        },
        setVariable: function (variable, value) {
            storage.push({
                type: "variable",
                name: variable,
                'arguments': value
            });
        }
    };
}

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/
_html2canvas.Renderer = function(parseQueue, options){


    var queue = [];

    function sortZ(zStack){
        var subStacks = [],
        stackValues = [],
        zStackChildren = zStack.children,
        s,
        i,
        stackLen,
        zValue,
        zLen,
        stackChild,
        b,
        subStackLen;


        for (s = 0, zLen = zStackChildren.length; s < zLen; s+=1){

            stackChild = zStackChildren[s];

            if (stackChild.children && stackChild.children.length > 0){
                subStacks.push(stackChild);
                stackValues.push(stackChild.zindex);
            }else{
                queue.push(stackChild);
            }

        }

        stackValues.sort(function(a, b) {
            return a - b;
        });

        for (i = 0, stackLen = stackValues.length; i < stackLen; i+=1){
            zValue = stackValues[i];
            for (b = 0, subStackLen = subStacks.length; b <= subStackLen; b+=1){

                if (subStacks[b].zindex === zValue){
                    stackChild = subStacks.splice(b, 1);
                    sortZ(stackChild[0]);
                    break;

                }
            }
        }

    }


    sortZ(parseQueue.zIndex);
    if ( typeof options._renderer._create !== "function" ) {
        throw new Error("Invalid renderer defined");
    }
    return options._renderer._create( parseQueue, options, document, queue, _html2canvas );

};

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/


html2canvas = function( elements, opts ) {

    var queue,
    canvas,
    options = {
        // general
        logging: false,
        elements: elements,

        // preload options
        proxy: "http://html2canvas.appspot.com/",
        timeout: 0,    // no timeout
        useCORS: false, // try to load images as CORS (where available), before falling back to proxy
        allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true

        // parse options
        svgRendering: false, // use svg powered rendering where available (FF11+)
        iframeDefault: "default",
        ignoreElements: "IFRAME|OBJECT|PARAM",
        useOverflow: true,
        letterRendering: false,

        // render options

        flashcanvas: undefined, // path to flashcanvas
        width: null,
        height: null,
        taintTest: true, // do a taint test with all images before applying to canvas
		renderer: "Canvas"
    }, renderer;

    options = _html2canvas.Util.Extend(opts, options);

	if (typeof options.renderer === "string" && _html2canvas.Renderer[options.renderer] !== undefined) {
		options._renderer = _html2canvas.Renderer[options.renderer]( options );
	} else if (typeof options.renderer === "function") {
		options._renderer = options.renderer( options );
	} else {
		throw("Unknown renderer");
	}

    _html2canvas.logging = options.logging;
    options.complete = function( images ) {

        if (typeof options.onpreloaded === "function") {
            if ( options.onpreloaded( images ) === false ) {
                return;
            }
        }
        queue = _html2canvas.Parse( images, options );

        if (typeof options.onparsed === "function") {
            if ( options.onparsed( queue ) === false ) {
                return;
            }
        }

        canvas = _html2canvas.Renderer( queue, options );

        if (typeof options.onrendered === "function") {
            options.onrendered( canvas );
        }


    };

    // for pages without images, we still want this to be async, i.e. return methods before executing
    window.setTimeout( function(){
        _html2canvas.Preload( options );
    }, 0 );

    return {
        render: function( queue, opts ) {
            return _html2canvas.Renderer( queue, _html2canvas.Util.Extend(opts, options) );
        },
        parse: function( images, opts ) {
            return _html2canvas.Parse( images, _html2canvas.Util.Extend(opts, options) );
        },
        preload: function( opts ) {
            return _html2canvas.Preload( _html2canvas.Util.Extend(opts, options) );
        },
        log: h2clog
    };
};

html2canvas.log = h2clog; // for renderers
html2canvas.Renderer = {
    Canvas: undefined // We are assuming this will be used
};

/*
  html2canvas v0.34 <http://html2canvas.hertzen.com>
  Copyright (c) 2011 Niklas von Hertzen. All rights reserved.
  http://www.twitter.com/niklasvh

  Released under MIT License
*/


_html2canvas.Renderer.Canvas = function( options ) {

    options = options || {};

    var doc = document,
    canvas = options.canvas || doc.createElement('canvas'),
    usingFlashcanvas = false,
    _createCalled = false,
    canvasReadyToDraw = false,
    methods,
    flashMaxSize = 2880; // flash bitmap limited to 2880x2880px // http://stackoverflow.com/questions/2033792/argumenterror-error-2015-invalid-bitmapdata


    if (canvas.getContext){
        h2clog("html2canvas: Renderer: using canvas renderer");
        canvasReadyToDraw = true;
    } else if ( options.flashcanvas !== undefined ){
        usingFlashcanvas = true;
        h2clog("html2canvas: Renderer: canvas not available, using flashcanvas");
        var script = doc.createElement("script");
        script.src = options.flashcanvas;

        script.onload = (function(script, func){
            var intervalFunc;

            if (script.onload === undefined) {
                // IE lack of support for script onload

                if( script.onreadystatechange !== undefined ) {

                    intervalFunc = function() {
                        if (script.readyState !== "loaded" && script.readyState !== "complete") {
                            window.setTimeout( intervalFunc, 250 );

                        } else {
                            // it is loaded
                            func();

                        }

                    };

                    window.setTimeout( intervalFunc, 250 );

                } else {
                    h2clog("html2canvas: Renderer: Can't track when flashcanvas is loaded");
                }

            } else {
                return func;
            }

        })(script, function(){

            if (typeof window.FlashCanvas !== "undefined") {
                h2clog("html2canvas: Renderer: Flashcanvas initialized");
                window.FlashCanvas.initElement( canvas );

                canvasReadyToDraw = true;
                if ( _createCalled !== false ) {
                    methods._create.apply( null, _createCalled );
                }
            }
        });

        doc.body.appendChild( script );

    }

    methods = {
        _create: function( zStack, options, doc, queue, _html2canvas ) {

            if ( !canvasReadyToDraw ) {
                _createCalled = arguments;
                return canvas;
            }

            var ctx = canvas.getContext("2d"),
            storageContext,
            i,
            queueLen,
            a,
            newCanvas,
            bounds,
            testCanvas = document.createElement("canvas"),
            hasCTX = ( testCanvas.getContext !== undefined ),
            storageLen,
            renderItem,
            testctx = ( hasCTX ) ? testCanvas.getContext("2d") : {},
            safeImages = [],
            fstyle;

            canvas.width = canvas.style.width = (!usingFlashcanvas) ? options.width || zStack.ctx.width : Math.min(flashMaxSize, (options.width || zStack.ctx.width) );
            canvas.height = canvas.style.height = (!usingFlashcanvas) ? options.height || zStack.ctx.height : Math.min(flashMaxSize, (options.height || zStack.ctx.height) );

            fstyle = ctx.fillStyle;
            ctx.fillStyle = zStack.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = fstyle;

            if ( options.svgRendering && zStack.svgRender !== undefined ) {
                // TODO: enable async rendering to support this
                ctx.drawImage( zStack.svgRender, 0, 0 );
            } else {
                for ( i = 0, queueLen = queue.length; i < queueLen; i+=1 ) {

                    storageContext = queue.splice(0, 1)[0];
                    storageContext.canvasPosition = storageContext.canvasPosition || {};

                    //this.canvasRenderContext(storageContext,parentctx);

                    // set common settings for canvas
                    ctx.textBaseline = "bottom";

                    if (storageContext.clip){
                        ctx.save();
                        ctx.beginPath();
                        // console.log(storageContext);
                        ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
                        ctx.clip();

                    }

                    if (storageContext.ctx.storage){

                        for (a = 0, storageLen = storageContext.ctx.storage.length; a < storageLen; a+=1){

                            renderItem = storageContext.ctx.storage[a];


                            switch(renderItem.type){
                                case "variable":
                                    ctx[renderItem.name] = renderItem['arguments'];
                                    break;
                                case "function":
                                    if (renderItem.name === "fillRect") {

                                        if (!usingFlashcanvas || renderItem['arguments'][0] + renderItem['arguments'][2] < flashMaxSize  && renderItem['arguments'][1] + renderItem['arguments'][3] < flashMaxSize) {
                                            ctx.fillRect.apply( ctx, renderItem['arguments'] );
                                        }
                                    }else if(renderItem.name === "fillText") {
                                        if (!usingFlashcanvas || renderItem['arguments'][1] < flashMaxSize  && renderItem['arguments'][2] < flashMaxSize) {
                                            ctx.fillText.apply( ctx, renderItem['arguments'] );
                                        }
                                    }else if(renderItem.name === "drawImage") {

                                        if (renderItem['arguments'][8] > 0 && renderItem['arguments'][7]){
                                            if ( hasCTX && options.taintTest ) {
                                                if ( safeImages.indexOf( renderItem['arguments'][ 0 ].src ) === -1 ) {
                                                    testctx.drawImage( renderItem['arguments'][ 0 ], 0, 0 );
                                                    try {
                                                        testctx.getImageData( 0, 0, 1, 1 );
                                                    } catch(e) {
                                                        testCanvas = doc.createElement("canvas");
                                                        testctx = testCanvas.getContext("2d");
                                                        continue;
                                                    }

                                                    safeImages.push( renderItem['arguments'][ 0 ].src );

                                                }
                                            }
                                            ctx.drawImage.apply( ctx, renderItem['arguments'] );
                                        }
                                    }


                                    break;
                                default:

                            }

                        }

                    }
                    if (storageContext.clip){
                        ctx.restore();
                    }

                }
            }

            h2clog("html2canvas: Renderer: Canvas renderer done - returning canvas obj");

            queueLen = options.elements.length;

            if (queueLen === 1) {
                if (typeof options.elements[ 0 ] === "object" && options.elements[ 0 ].nodeName !== "BODY" && usingFlashcanvas === false) {
                    // crop image to the bounds of selected (single) element
                    bounds = _html2canvas.Util.Bounds( options.elements[ 0 ] );
                    newCanvas = doc.createElement('canvas');
                    newCanvas.width = bounds.width;
                    newCanvas.height = bounds.height;
                    ctx = newCanvas.getContext("2d");

                    ctx.drawImage( canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height );
                    canvas = null;
                    return newCanvas;
                }
            } /*else {
        // TODO clip and resize multiple elements

            for ( i = 0; i < queueLen; i+=1 ) {
                if (options.elements[ i ] instanceof Element) {

                }

            }
        }
        */



            return canvas;
        }
    };

    return methods;

};

window.html2canvas = html2canvas;
}(window, document));


;
/*! Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
 * Dual licensed under the MIT (MIT_LICENSE.txt)
 * and GPL Version 2 (GPL_LICENSE.txt) licenses.
 *
 * Version: 1.1.1
 * Requires jQuery 1.3+
 * Docs: http://docs.jquery.com/Plugins/livequery
 */

(function($) {

$.extend($.fn, {
	livequery: function(type, fn, fn2) {
		var self = this, q;

		// Handle different call patterns
		if ($.isFunction(type))
			fn2 = fn, fn = type, type = undefined;

		// See if Live Query already exists
		$.each( $.livequery.queries, function(i, query) {
			if ( self.selector == query.selector && self.context == query.context &&
				type == query.type && (!fn || fn.$lqguid == query.fn.$lqguid) && (!fn2 || fn2.$lqguid == query.fn2.$lqguid) )
					// Found the query, exit the each loop
					return (q = query) && false;
		});

		// Create new Live Query if it wasn't found
		q = q || new $.livequery(this.selector, this.context, type, fn, fn2);

		// Make sure it is running
		q.stopped = false;

		// Run it immediately for the first time
		q.run();

		// Contnue the chain
		return this;
	},

	expire: function(type, fn, fn2) {
		var self = this;

		// Handle different call patterns
		if ($.isFunction(type))
			fn2 = fn, fn = type, type = undefined;

		// Find the Live Query based on arguments and stop it
		$.each( $.livequery.queries, function(i, query) {
			if ( self.selector == query.selector && self.context == query.context &&
				(!type || type == query.type) && (!fn || fn.$lqguid == query.fn.$lqguid) && (!fn2 || fn2.$lqguid == query.fn2.$lqguid) && !this.stopped )
					$.livequery.stop(query.id);
		});

		// Continue the chain
		return this;
	}
});

$.livequery = function(selector, context, type, fn, fn2) {
	this.selector = selector;
	this.context  = context;
	this.type     = type;
	this.fn       = fn;
	this.fn2      = fn2;
	this.elements = [];
	this.stopped  = false;

	// The id is the index of the Live Query in $.livequery.queries
	this.id = $.livequery.queries.push(this)-1;

	// Mark the functions for matching later on
	fn.$lqguid = fn.$lqguid || $.livequery.guid++;
	if (fn2) fn2.$lqguid = fn2.$lqguid || $.livequery.guid++;

	// Return the Live Query
	return this;
};

$.livequery.prototype = {
	stop: function() {
		var query = this;

		if ( this.type )
			// Unbind all bound events
			this.elements.unbind(this.type, this.fn);
		else if (this.fn2)
			// Call the second function for all matched elements
			this.elements.each(function(i, el) {
				query.fn2.apply(el);
			});

		// Clear out matched elements
		this.elements = [];

		// Stop the Live Query from running until restarted
		this.stopped = true;
	},

	run: function() {
		// Short-circuit if stopped
		if ( this.stopped ) return;
		var query = this;

		var oEls = this.elements,
			els  = $(this.selector, this.context),
			nEls = els.not(oEls);

		// Set elements to the latest set of matched elements
		this.elements = els;

		if (this.type) {
			// Bind events to newly matched elements
			nEls.bind(this.type, this.fn);

			// Unbind events to elements no longer matched
			if (oEls.length > 0)
				$.each(oEls, function(i, el) {
					if ( $.inArray(el, els) < 0 )
						$.event.remove(el, query.type, query.fn);
				});
		}
		else {
			// Call the first function for newly matched elements
			nEls.each(function() {
				query.fn.apply(this);
			});

			// Call the second function for elements no longer matched
			if ( this.fn2 && oEls.length > 0 )
				$.each(oEls, function(i, el) {
					if ( $.inArray(el, els) < 0 )
						query.fn2.apply(el);
				});
		}
	}
};

$.extend($.livequery, {
	guid: 0,
	queries: [],
	queue: [],
	running: false,
	timeout: null,

	checkQueue: function() {
		if ( $.livequery.running && $.livequery.queue.length ) {
			var length = $.livequery.queue.length;
			// Run each Live Query currently in the queue
			while ( length-- )
				$.livequery.queries[ $.livequery.queue.shift() ].run();
		}
	},

	pause: function() {
		// Don't run anymore Live Queries until restarted
		$.livequery.running = false;
	},

	play: function() {
		// Restart Live Queries
		$.livequery.running = true;
		// Request a run of the Live Queries
		$.livequery.run();
	},

	registerPlugin: function() {
		$.each( arguments, function(i,n) {
			// Short-circuit if the method doesn't exist
			if (!$.fn[n]) return;

			// Save a reference to the original method
			var old = $.fn[n];

			// Create a new method
			$.fn[n] = function() {
				// Call the original method
				var r = old.apply(this, arguments);

				// Request a run of the Live Queries
				$.livequery.run();

				// Return the original methods result
				return r;
			}
		});
	},

	run: function(id) {
		if (id != undefined) {
			// Put the particular Live Query in the queue if it doesn't already exist
			if ( $.inArray(id, $.livequery.queue) < 0 )
				$.livequery.queue.push( id );
		}
		else
			// Put each Live Query in the queue if it doesn't already exist
			$.each( $.livequery.queries, function(id) {
				if ( $.inArray(id, $.livequery.queue) < 0 )
					$.livequery.queue.push( id );
			});

		// Clear timeout if it already exists
		if ($.livequery.timeout) clearTimeout($.livequery.timeout);
		// Create a timeout to check the queue and actually run the Live Queries
		$.livequery.timeout = setTimeout($.livequery.checkQueue, 20);
	},

	stop: function(id) {
		if (id != undefined)
			// Stop are particular Live Query
			$.livequery.queries[ id ].stop();
		else
			// Stop all Live Queries
			$.each( $.livequery.queries, function(id) {
				$.livequery.queries[ id ].stop();
			});
	}
});

// Register core DOM manipulation methods
$.livequery.registerPlugin('append', 'prepend', 'after', 'before', 'wrap', 'attr', 'removeAttr', 'addClass', 'removeClass', 'toggleClass', 'empty', 'remove', 'html');

// Run Live Queries when the Document is ready
$(function() { $.livequery.play(); });

})(jQuery);
;
/*!
 * Autolinker.js
 * Version 0.6.0
 * 
 * Copyright(c) 2014 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 * 
 * https://github.com/gregjacobs/Autolinker.js
 */
/**
 * @class Autolinker
 * @extends Object
 * @singleton
 * 
 * Singleton class which exposes the {@link #link} method, used to process a given string of text,
 * and wrap the URLs, email addresses, and Twitter handles in the appropriate anchor (&lt;a&gt;) tags.
 */
var Autolinker = {
	
	// NOTE: The matcherRegex will be included after the class, from the compiled regex source
	
	
	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 * 
	 * A regular expression used to pull out HTML tags from a string.
	 * 
	 * Capturing groups:
	 * 
	 * 1. If it is an end tag, this group will have the '/'.
	 * 2. The tag name.
	 */
	htmlRegex : /<(\/)?(\w+)(?:(?:\s+\w+(?:\s*=\s*(?:".*?"|'.*?'|[^'">\s]+))?)+\s*|\s*)\/?>/g,


	/**
	 * @private
	 * @property {RegExp} prefixRegex
	 * 
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	prefixRegex: /^(https?:\/\/)?(www\.)?/,
	
	
	/**
	 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
	 * Does not link URLs found within HTML tags.
	 * 
	 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
	 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 * 
	 * @method link
	 * @param {String} html The HTML text to link URLs within.
	 * @param {Object} [options] Any options for the autolinking, specified in an object. It may have the following properties:
	 * @param {Boolean} [options.newWindow=true] True if the links should open in a new window, false otherwise.
	 * @param {Boolean} [options.stripPrefix=true] True if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of links, false otherwise.
	 * @param {Number} [options.truncate] A number for how many characters long URLs/emails/twitter handles should be truncated to
	 *   inside the text of a link. If the URL/email/twitter is over the number of characters, it will be truncated to this length by 
	 *   adding a two period ellipsis ('..') into the middle of the string.
	 *   Ex: a url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look like this: 'http://www...th/to/a/file'
	 * @param {Boolean} [options.twitter=true] True if Twitter handles ("@example") should be automatically linked.
	 * @param {Boolean} [options.email=true] True if email addresses should be automatically linked.
	 * @param {Boolean} [options.urls=true] True if miscellaneous URLs should be automatically linked.
	 * @return {String} The HTML text, with URLs automatically linked
	 */
	link : function( html, options ) {
		options = options || {};
		
		var htmlRegex = Autolinker.htmlRegex,         // full path for friendly
		    matcherRegex = Autolinker.matcherRegex,   // out-of-scope calls
		    newWindow = ( 'newWindow' in options ) ? options.newWindow : true,  // defaults to true
		    stripPrefix = ( 'stripPrefix' in options ) ? options.stripPrefix : true,  // defaults to true
		    truncate = options.truncate,
		    enableTwitter = ( 'twitter' in options ) ? options.twitter : true,  // defaults to true
		    enableEmailAddresses = ( 'email' in options ) ? options.email : true,  // defaults to true
		    enableUrls = ( 'urls' in options ) ? options.urls : true,  // defaults to true
		    currentResult, 
		    lastIndex = 0,
		    inBetweenTagsText,
		    resultHtml = "",
		    anchorTagStackCount = 0;
		
		// Function to process the text that lies between HTML tags. This function does the actual wrapping of
		// URLs with anchor tags.
		function autolinkText( text ) {
			text = text.replace( matcherRegex, function( matchStr, $1, $2, $3, $4, $5 ) {
				var twitterMatch = $1,
				    twitterHandlePrefixWhitespaceChar = $2,  // The whitespace char before the @ sign in a Twitter handle match. This is needed because of no lookbehinds in JS regexes
				    twitterHandle = $3,  // The actual twitterUser (i.e the word after the @ sign in a Twitter handle match)
				    emailAddress = $4,   // For both determining if it is an email address, and stores the actual email address
				    urlMatch = $5,       // The matched URL string
					
				    prefixStr = "",      // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
				    suffixStr = "",      // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.
					
				    anchorAttributes = [];
				
				// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
				// in the match. This handles cases like the string "wikipedia.com/something_(disambiguation)" (which should be auto-
				// linked, and when it is enclosed in parenthesis itself, such as: "(wikipedia.com/something_(disambiguation))" (in
				// which the outer parens should *not* be auto-linked.
				var lastChar = matchStr.charAt( matchStr.length - 1 );
				if( lastChar === ')' ) {
					var openParensMatch = matchStr.match( /\(/g ),
						closeParensMatch = matchStr.match( /\)/g ),
						numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
						numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;
					
					if( numOpenParens < numCloseParens ) {
						matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
						suffixStr = ")";  // this will be added after the <a> tag
					}
				}
				
				
				var anchorHref = matchStr,  // initialize both of these
					anchorText = matchStr;  // values as the full match

				if( ( twitterMatch && !enableTwitter ) || ( emailAddress && !enableEmailAddresses ) || ( urlMatch && !enableUrls ) ) {
					// A disabled link type
					return prefixStr + anchorText + suffixStr;
				}
				
				// Process the urls that are found. We need to change URLs like "www.yahoo.com" to "http://www.yahoo.com" (or the browser
				// will try to direct the user to "http://jux.com/www.yahoo.com"), and we need to prefix 'mailto:' to email addresses.
				if( twitterMatch ) {
					prefixStr = twitterHandlePrefixWhitespaceChar;
					anchorHref = 'https://twitter.com/' + twitterHandle;
					anchorText = '@' + twitterHandle;
				
				} else if( emailAddress ) {
					anchorHref = 'mailto:' + emailAddress;
					anchorText = emailAddress;
				
				} else if( !/^[A-Za-z]{3,9}:/i.test( anchorHref ) ) {  // string doesn't begin with a protocol, add http://
					anchorHref = 'http://' + anchorHref;
				}

				if( stripPrefix ) {
					anchorText = anchorText.replace( Autolinker.prefixRegex, '' );
				}

				// remove trailing slash
				if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
					anchorText = anchorText.slice( 0, -1 );
				}
				
				// Set the attributes for the anchor tag
				anchorAttributes.push( 'href="' + anchorHref + '"' );
				if( newWindow ) {
					anchorAttributes.push( 'target="_blank"' );
				}
				
				// Truncate the anchor text if it is longer than the provided 'truncate' option
				if( truncate && anchorText.length > truncate ) {
					anchorText = anchorText.substring( 0, truncate - 2 ) + '..';
				}
				
				return prefixStr + '<a ' + anchorAttributes.join( " " ) + '>' + anchorText + '</a>' + suffixStr;  // wrap the match in an anchor tag
			} );
			
			return text;
		}
		
		
		// Loop over the HTML string, ignoring HTML tags, and processing the text that lies between them,
		// wrapping the URLs in anchor tags 
		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    tagName = currentResult[ 2 ],
			    isClosingTag = !!currentResult[ 1 ];
			
			inBetweenTagsText = html.substring( lastIndex, currentResult.index );
			lastIndex = currentResult.index + tagText.length;
			
			// Process around anchor tags, and any inner text / html they may have
			if( tagName === 'a' ) {
				if( !isClosingTag ) {  // it's the start <a> tag
					anchorTagStackCount++;
					resultHtml += autolinkText( inBetweenTagsText );
					
				} else {     // it's the end </a> tag
					anchorTagStackCount--;	
					if( anchorTagStackCount === 0 ) {
						resultHtml += inBetweenTagsText;  // We hit the matching </a> tag, simply add all of the text from the start <a> tag to the end </a> tag without linking it
					}
				}
				
			} else if( anchorTagStackCount === 0 ) {   // not within an anchor tag, link the "in between" text
				resultHtml += autolinkText( inBetweenTagsText );
			}
			
			resultHtml += tagText;  // now add the text of the tag itself verbatim
		}
		
		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			resultHtml += autolinkText( html.substring( lastIndex ) );
		}
		
		return resultHtml;
	}

};

/**
 * @member Autolinker
 * @private
 * @property {RegExp} matcherRegex
 * 
 * The regular expression that matches URLs, email addresses, and Twitter handles.
 * 
 * Capturing groups:
 * 
 * 1. Group that is used to determine if there is a Twitter handle match (i.e. @someTwitterUser). Simply check for its existence
 *    to determine if there is a Twitter handle match. The next couple of capturing groups give information about the Twitter 
 *    handle match.
 * 2. The whitespace character before the @sign in a Twitter handle. This is needed because there are no lookbehinds in JS regular
 *    expressions, and can be used to reconstruct the original string in a replace().
 * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
 * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full address.
 *    Ex: 'me@my.com'
 * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
 *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
 */
/*global Autolinker*/
Autolinker.matcherRegex = /((^|\s)@(\w{1,15}))|((?:[\-;:&=\+\$,\w\.]+@)[A-Za-z0-9\.\-]*[A-Za-z0-9\-]\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b)|((?:(?:(?:[A-Za-z]{3,9}:(?:\/\/)?)[A-Za-z0-9\.\-]*[A-Za-z0-9\-])|(?:(?:www\.)[A-Za-z0-9\.\-]*[A-Za-z0-9\-])|(?:[A-Za-z0-9\.\-]*[A-Za-z0-9\-]\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b))(?:[-A-Za-z0-9+&@#\/%?=~_()|!:,.;]*[-A-Za-z0-9+&@#\/%=~_()|])?)/g;


;
/* global TAG: true, WinJS: false */
TAG.Util.makeNamespace('TAG.TourAuthoring.Constants');

/**
 * List of constants used across multiple files and locations
 */
TAG.TourAuthoring.Constants = (function () {
    "use strict";
    return {
        aboveRinZIndex: 100000000, // ridiculous number to beat out RIN's ridiculous z-indexes so we can put things on top of it
        keyframeSize: 21, // radius in px, should be small but large enough to recieve touch
        innerKeyframeSize: 17, // radius of circle that appears when keyframe is selected
        keyframeStrokeW: 5,
        keyframeLineW: 3,
        fadeBtnSize: 15,
        rinBorder: 2,
        minZoom: 1,
        maxZoom: 100,
        handleColor: '#DAD9CC',
        keyframeColor: '#296B2F',
        audioKeyframeColor: '#283F53',
        selectedKeyframeColor: '#6B293F',
        displayColor: '#81AD62',
        inkDisplayColor: "#AAAAAA",
        selectedDisplayColor: '#143417',
        selectedInkDisplayColor: '#2E2E2E',
        inkDragHandleRadius: 20,
        doubleTap: 400,
        trackHeight: 96,
        minimizedTrackHeight: 36,
        esOffset: 0.05, // displays on same track need at least this much space btw them to show up properly
        timeRulerSize: 54,
        defaultVolume: 0.8,
        epsilon: 0.01,
        menuDecimals: 2, // number of decimals to round to in menu inputs
        maxTourLength: 15 * 60,
        minMediaLength: 5,
        inkTrackOffset: 0, // this functionality is probably obsolete
        defaultFade: 0.5,
        displayEpsilon: 0.5
    };
})();
;
TAG.Util.makeNamespace("TAG.Util.Constants");

TAG.Util.Constants = (function (options) {
    "use strict";

    var constants = {

    };

    var pages = {
        START_PAGE:       0,
        COLLECTIONS_PAGE: 1,
        ARTWORK_VIEWER:   2,
        VIDEO_PLAYER:     3,
        TOUR_PLAYER:      4,
        AUTHORING_HUB:    5,
        ARTWORK_EDITOR:   6,
        TOUR_AUTHORING:   7
    };


    return{
        pages: pages,
        get: getConstant,
        set: setConstant
    };

    function getConstant(name, defaultVal) {
        return constants[name] || defaultVal;
    }
    function setConstant(name, value) {
        constants[name] = value;
    }
})();
;
TAG.Util.makeNamespace("TAG.Util.Splitscreen");

/**
 * Utility functions for splitscreen mode.
 * @class TAG.Util.Splitscreen
 * @constructor
 * @return {Object}               some public methods
 */

TAG.Util.Splitscreen = (function () {
    "use strict";
    var on = false,
        viewerL = null,
        viewerR = null;

    return {
        init: init,
        exit: exitSplitscreen,
        isOn: isOn,
        setOn: setOn,
        setViewers: setViewers,
    };

    /**
     * Returns whether we're in splitscreen mode
     * @method isOn
     * @return {Boolean}       whether we're in splitscreen mode
     */
    function isOn() {
        return on;
    }

    /**
     * Sets whether we're in splitscreen mode
     * @method setOn
     * @param {Boolean} state       whether we should be in splitscreen mode
     */
    function setOn(state) {
        on = state;
    }

    /**
     * Sets the seadragon viewer for a certain artwork viewer root
     * @method setViewers
     * @param {jQuery obj} root              root of the artwork viewer
     * @param {AnnotatedImage} zoomimage     the AnnotatedImage object from which we'll get the viewer
     */
    function setViewers(root, zoomimage) {
        if (root.data('split') === "L") {
            viewerL = zoomimage.viewer;
        }
        if (root.data('split') === 'R') {
            viewerR = zoomimage.viewer;
        }
    }


    /**
     * Starts splitscreen
     * @method init
     * @param {jQuery obj} rootL     DOM root element (as JQuery obj) to go in left screen
     * @param {jQuery obj} rootR     DOM root element (as JQuery obj) to go in right screen
     */
    function init(rootL, rootR) {
        on = true;

        // initialize meta-containers
        var Lscreen = $(document.createElement('div')),
            Rscreen = $(document.createElement('div')),
            splitbar = $(document.createElement('div')),
            spliticon = $(document.createElement('img'));

        // left screen
        Lscreen.attr('id', 'metascreen-L');
        Lscreen.append(rootL);
        Lscreen.css({
            'position': 'absolute',
            'left': '0%',
            'top': '0%',
            'width': '49.5%',
            'height': '100%',
            'z-index': '999',
            'overflow': 'hidden',
        });

        if(rootL.attr('id') === 'newCatalogRoot') {
            rootL.find('.bottomButton').css("float", "left");
        };

        // right screen
        Rscreen.attr('id', 'metascreen-R');
        Rscreen.append(rootR);
        Rscreen.css({
            'position': 'absolute',
            'left': '50.5%',
            'top': '0%',
            'width': '49.5%',
            'height': '100%',
            'z-index': '998', // Rscreen should be lower than Lscreen so left-transitions can work
            'overflow': 'hidden',
        });

        // center divider
        splitbar.attr('id', 'splitbar');
        splitbar.css({
            'position': 'absolute',
            'left': '49.5%',
            'top': '0%',
            'width': '1%',
            'height': '100%',
            'z-index': '1000',
            'background-color': '#191915',
        });

        // buttons
        var exitL = makeExitButton('R'),
            exitR = makeExitButton('L');
        exitL.css({ left: '-350%', width: "300%" });
        exitR.css({ right: '-350%', width: "300%" });
        splitbar.append(exitL).append(exitR);

        $('#tagRoot').append(Lscreen).append(splitbar).append(Rscreen);

        /**
         * Helper function for making exit buttons
         * Inner function of init()
         * @method makeExitButton
         * @param {String} side     the side the button is going to go on ('L' or 'R')
         * @return {jQuery obj}     the exit button
         */
        function makeExitButton(side) {
            var exit = $(document.createElement('img'));
            exit.attr('src', tagPath + 'images/icons/x.svg');
            exit.css({
                'cursor': 'pointer',
                'position': 'absolute',
                'top': '94%',
                'width': '115%',
                'height': 'auto',
            });
            exit.on('click', function () {
                exitSplitscreen(side);
            });
            return exit;
        }
    }

    /**
     * Exits splitscreen, making the specified side fullscreen and removing the other
     * @method exitSplitscreen
     * @param newside   The side to be made fullscreen, either 'R' or 'L'
     */
    function exitSplitscreen(newside) {
        var oldside,
            pickedScreen = $('#metascreen-' + newside).detach(),
            root = $(pickedScreen.children('.rootPage')[0]); // only child should be root

        on = false;
        
        root.data('split', 'L');
        
        // remove all unnecessary metacontainers and contents
        if (newside === 'L') {
            $('#metascreen-R').remove();

            if (viewerL) {
                $(viewerL.container).css({ 'width': '100%', 'height': '100%' });
                viewerL.scheduleUpdate();
                /**
                var newLContainerSize = {
                    x: $(viewerL.container).width(),
                    y: $(viewerL.container).height()
                };
                viewerL.viewport.resize(newLContainerSize, false);
                viewerL.viewport.applyConstraints();
                viewerL.viewport.update();
                **/
            }
            viewerR = null;

        } else {
            $('#metascreen-L').remove();

            if (viewerR) {
                $(viewerR.container).css({ 'width': '100%', 'height': '100%' });
                viewerR.scheduleUpdate();
               // viewerR.viewport.applyConstraints();
               // viewerR.viewport.update();
            }
            //viewerR.viewport.panTo(new Seadragon.Point(outerContainerPivot.x,outerContainerPivot.y));
            viewerL = null;

        }
        $('#splitbar').remove();

        $('#tagRoot').append(root);

        fixLayoutsOnExit();

        if (viewerL) {
           // viewerL.scheduleUpdate();
            //viewerL.viewport.applyConstraints();
        }
        if (viewerR) {
            //viewerR.scheduleUpdate();
            //viewerR.viewport.applyConstraints();
        }
        viewerL = null;
        viewerR = null;

        /**
         * All the layout specific edits that need to be made upon exit
         * Theoretically, all of this should get wrapped into layout classes
         * but not sure the class pattern used allows for it
         * TODO document
         */
        function fixLayoutsOnExit() {
            // debugger;
            // Layout specific edits
            if (root.attr('id') === 'artmodeRoot') { // Fix sidebar, toggler, and splitscreen button
                var sideBar = root.find('#sideBar'),
                    toggler = root.find('#toggler'),
                    togglerImage = root.find('#togglerImage'),
                    splitscreenContainer = root.find('#splitscreenContainer'),
                    seadragonManipContainer = root.find('#seadragonManipContainer'),
                    splitscreenIcon = root.find('.splitscreen-icon'),
                    locationHistoryDiv = root.find('#locationHistory');
                    //locationHistoryPanel = root.find('.locationHistoryPanel'),
                    //locationHistoryToggle = root.find('.locationHistoryToggle'),
                    //locationHistoryToggleIcon = root.find('.locationHistoryToggleIcon'),
                    //locationHistoryText = root.find('.locationHistoryContainer').find('img'),
                    //locationHistoryIcon = root.find('.locationHistoryContainer').find('div'),
                    //lhmapsuffix = (newside === 'R') ? 'R' : '',
                    //lhmap = root.find('.lpMapDiv'),
                    //sidebarsize = window.innerWidth * 0.2,
                //locsize = window.innerWidth * 0.8;
                locationHistoryDiv.css({ "color": "#" + TAG.Worktop.Database.getMuseumPrimaryFontColor() });
                sideBar.css({
                    'left': '0%',
                    'right' : 'auto'
                });
                toggler.css({
                    'position': 'absolute',
                    'left': 'auto',
                    'right': '-12%',
                    borderTopRightRadius: "10px",
                    borderBottomRightRadius: "10px",
                    borderTopLeftRadius: "0px",
                    borderBottomLeftRadius: "0px",
                });
                togglerImage.attr("src", tagPath + 'images/icons/Close.svg')
                            .css({
                                'left': '0%',
                                'right': 'auto'
                              });
                seadragonManipContainer.css({
                    'right': '0%',
                    'left': 'auto'
                });
                splitscreenContainer.css('display', 'block');
                //locationHistoryToggle.css({
                //    left: '87.5%',
                //    'border-bottom-right-radius': '10px',
                //    'border-top-right-radius': '10px'
                //});
                //$(locationHistoryToggleIcon).attr('src', 'images/icons/Left.png');
                //locationHistoryText.css("opacity", "1.0"); // reset location history opacity to 1.0
                //locationHistoryIcon.css("opacity", "1.0");
                //lhmap.attr('id', 'lpMapDiv');
            } else if(root.attr('id') === 'newCatalogRoot') {
                root.find('.bottomButton').css({
                    "float": "right",
                    "display" : "block"
                });
                root.find('.nextPrevCollection').css({
                    'width': (.95 * root.find("#collectionArea").width() - root.find('.mainCollection').width()) / 2 - root.find(".arrow").width(),
                });
                root.find('#infoButton').show();
                if (root.find('#infoDiv').width() !== 0) {
                    root.find('#infoDiv').css('width', '25%');
                    root.find("#tileDiv").css({ 'margin-left': '0%', 'left': root.find('#infoDiv').width() });
                }
                root.find("#toggleRow").css('width',"20%");
            } else if (root.hasClass('videoPlayer')) {
                root.find('#playPauseButton').attr('src', 'images/icons/PlayWhite.svg');
            } else if (root.hasClass('exhibition')) { // Restore defaults to exhibition
                root.find('.leftbar-header').css({
                    height: '5%',
                });
                root.find('.exhibition-label').css({
                    width: '50%',
                });
                root.find('.videos-label').css({
                    width: '50%',
                });
                root.find('.selectExhibition').css({
                    'font-size': '1.5em',
                    'letter-spacing': 'inherit',
                });
                root.find('.exhibition-title').css({
                    'font-size': '5.7em',
                    'letter-spacing': 'inherit',
                });
                root.find('.exhibition-subtitle-1').css({
                    'font-size': '3em',
                    'letter-spacing': 'inherit',
                });
                root.find('.exhibition-subtitle-2').css({
                    'font-size': '2em',
                    'letter-spacing': 'inherit',
                });
                root.find('#catalogBackButton').css({
                    'display': 'block'
                });
                root.find('.feedback-icon').css({
                    'display': 'inline'
                });
                root.find('#exhibition-label').css({
                    'display': 'block'
                });
                root.find('#tutorialButton').show();
                root.find('#infoButton').show();
                //if (root.find('#infoDiv').width() !== 0) {
                //    root.find('#infoDiv').css('width', '25%');
                //    root.find("#tileDiv").css({ 'margin-left': '0%' ,'left': infoDiv.width()});
                //}

                //$('.exhibition-selection').css('font-size', '200%');//LADS.Util.getMaxFontSizeEM(root.find('.exhibition-selection .exhibition-title').text(), 1.5, $(window).width() * 0.75 * 0.8, .2 * root.find(".exhibition-selection").height()));

                // dz - dynamic font sizing
                var size = 0.096 * 0.45 * $(window).height();
                var exhibTitleSize = LADS.Util.getMaxFontSizeEM('W', 0.25, 9999, size * 0.85, 0.1);

                // exhibition selector text sizees
                $('.exhibition-selection .exhibition-title').css({
                    'font-size': exhibTitleSize,
                });

                //LADS.Util.getMaxFontSizeEM(root.find('.exhibition-selection .exhibition-title').text(), 1.5, $(window).width() * 0.75 * 0.8, .2 * root.find(".exhibition-selection").height()));

                // "collections" text - give this an ID instead of a class
                root.find('#exhibition-label').css('font-size', LADS.Util.getMaxFontSizeEM('Collections', 1, $(window).width() * 0.1, 1000));

                // big exhibition name text = give this an ID instead of a class
                root.find('.exhibition-name-div').css('font-size', LADS.Util.getMaxFontSizeEM(root.find('.exhibition-name-div').text(), 1.5, $(window).width() * 0.75 * 0.8, .2 * root.find(".exhibition-info").height()));

                var imgW = .40 * $(".contentdiv").width();
                var imgH = imgW / 1.4;
                root.find('.img-container').css({
                    height: imgH + "px",
                    width: imgW + "px"
                });
                root.find('.explore-text').css("font-size", LADS.Util.getMaxFontSizeEM("Explore", .5, .5 * root.find('.explore-tab').width(), .7 * root.find('.explore-tab').height()));
            }
        }
    }
})();
;
/**
 * TAG idle timer class. Wraps idle timer-related
 * functions in a contained scope.
 * @class TAG.Util.IdleTimer
 * @constructor
 * @return {Object}      a couple public methods
 */

var TAG = TAG || {};
TAG.Util.IdleTimer = (function() {
    var overlay,
        stageTwoDuration,
        overlayInterval;

     /**
      * This two-stage timer takes in two duration-callback pairs. The stage one 
      * callback is put on a timeout configured to the pre-specified duration
      * which will tick down until the callback executes or until it is restarted. 
      * Upon the stage one callback's execution, the stage two callback's timeout
      * is then started. However, if the second callback's timeout is reset, it will 
      * restart the entire timer back to stage one. Upon the second callback's 
      * execution, the timer will sit idle until the reset method is invoked.
      * @method TwoStageTimer
      * @param {Object} stageOne         the stage one timer pair (see timerPair helper function below)
      * @param {Object} stageTwo         the stage two timer pair
      */
    function TwoStageTimer(stageOne, stageTwo) {
        stageOne = stageOne || {};
        stageTwo = stageTwo || {};

        var s1d = stageOne.duration || idleDuration || 120000,   // duration of stage one timer
            s1c = stageOne.callback || defaultStageOne,          // stage one callback
            s2d = stageTwo.duration || 10000,                    // duration of stage two timer
            s2c = stageTwo.callback || defaultStageTwo,          // stage two callback
            s1TimeoutID = null,          // stage one timeout
            s2TimeoutID = null,          // stage two timeout
            started     = false;         // whether the TwoStageTimer has started

        stageTwoDuration = s2d;

        /**
         * Start the timer (the first stage)
         * @method start
         */
        function start() {
            if(idleDuration !== 0) { // default is no idle timer
                s1TimeoutID = setTimeout(fireS1, s1d);
                started = true;

            }
        }

        /**
         * Kill the timer by stopping both timeouts and setting started to false
         * @method kill
         */
        function kill() {
            s1TimeoutID && clearTimeout(s1TimeoutID);
            s2TimeoutID && clearTimeout(s2TimeoutID);
            overlayInterval && clearInterval(overlayInterval);
            started = false;
        }

        /**
         * Returns whether or not the timer is stopped
         * @method isStopped
         * @return {Boolean}       this._started
         */
        function isStopped() {
            return started;
        }

        /**
         * A general restart method -- clears timeouts and intervals and
         * restarts stage one timeout
         * @method restart
         */
        function restart() {
            s1TimeoutID && clearTimeout(s1TimeoutID);
            s2TimeoutID && clearTimeout(s2TimeoutID);
            overlayInterval && clearInterval(overlayInterval);

            start();
        }

        /**
         * Reinitialize the timer with new timerPairs
         * method reinitialize
         * @param {timerPair} newS1         new stage one timerPair
         * @param {timerPair} newS2         new stage two timerPair
         */
        function reinitialize(newS1, newS2) {
            clearTimeout(s1TimeoutID);
            clearTimeout(s2TimeoutID);
            s1d = newS1.duration;
            s1c = newS1.callback;
            s2d = newS2.duration;
            s2c = newS2.callback;
            s1TimeoutID = null;
            s2TimeoutID = null;

            stageTwoDuration = s2d;

            started = false;

            overlayInterval && clearInterval(overlayInterval);
        }

        /**
         * Private method to fire stage one timer
         * @method fireS1
         */
        function fireS1() {
            s1c();
            s2TimeoutID = setTimeout(fireS2, s2d);
        }

        /**
         * Private method to fire stage two timer
         * @method fireS2
         */
        function fireS2() {
            s2c();
            started = false;
        }

        return {
            start:        start,
            kill:         kill,
            isStopped:    isStopped,
            restart:      restart,
            reinitialize: reinitialize,
            s1d:          s1d
        };
    }

    /**
     * Create a timerPair object
     * @method timerPair
     * @param {Number} duration       length of timer
     * @param {Function} callback     function to be called when timer expires
     */
    function timerPair(duration, callback) {
        return {
            duration: duration,
            callback: callback
        }
    }

    /**
     * Create default stage one timerPair
     * @method defaultStageOne
     * @return {Object}               default stage one pair
     */
    function defaultStageOne() {
        return createIdleOverlay();
    }

    /**
     * Create default stage two timerPair
     * @method defaultStageTwo
     * @return {Object}               default stage two pair
     */
    function defaultStageTwo() {
        return returnHome();
    }

    /**
     * Create default idle timer warning overlay -- default
     * stage one callback
     * @method createIdleOverlay
     */
    function createIdleOverlay() {
        var textRegion    = $(document.createElement('div')).addClass('idleTimerTextRegion'),
            clock         = $(document.createElement('div')).addClass('idleTimerClock'),
            time          = 0,
            origDate      = new Date(),
            origTime      = origDate.getTime(),
            width;

        overlay = $(TAG.Util.UI.blockInteractionOverlay(0.8));
        
        // do this in styl file
        overlay.css({
            'text-align': 'center'
        });

        textRegion.css({
            'font-size': '2em',
            'left':  '10%',
            'position': 'absolute',
            'text-align': 'center',
            'top':   '30%',
            'width': '80%'
        });

        clock.css({
            'background-color': 'white',
            'border': '2px solid #ffffff',
            'border-radius': '50%',
            'display': 'block',
            'left': '45%',
            'position': 'absolute',
            'top': '50%',
            'width': '10%'
        });

        textRegion.html('Starting a new session when the timer below expires.<br />Tap anywhere to continue exploring.');

        overlay.append(textRegion);
        overlay.append(clock);

        $('#tagRoot').append(overlay);
        overlay.fadeIn();

        width = clock.width();
        clock.css('height', width + 'px');

        // when overlay is clicked, restart timer and remove overlay
        overlay.on('click', function() {
            overlay.off('click');
            idleTimer && idleTimer.restart(); // uses the global idleTimer (declared in Gruntfile.js)
            removeIdleOverlay();
        });

        // create ticking clock
        overlayInterval = setInterval(function() {
            var percentDone,
                gradString,
                date = new Date();

            time        = date.getTime() - origTime;
            percentDone = Math.min(time / stageTwoDuration, 1);
            gradString  = percentDone <= 0.5 ?
                            'linear-gradient('+(90+360*percentDone)+'deg, transparent 50%, black 50%), linear-gradient(90deg, black 50%, transparent 50%)' :
                            'linear-gradient('+(90+360*(percentDone - 0.5))+'deg, transparent 50%, white 50%), linear-gradient(90deg, black 50%, transparent 50%)'

            clock.css('background-image', gradString);

            if(percentDone >= 1) {
                clearInterval(overlayInterval);
            }
        }, 10);
    }

    /**
     * Remove the default warning overlay
     * @method removeIdleOverlay
     */
    function removeIdleOverlay() {
        overlay && overlay.fadeOut(overlay.remove);
    }

    /**
     * Returns to home page -- default stage two callback
     * @method returnHome
     */
    function returnHome() {
        TAG.Util.Splitscreen.setOn(false);
        TELEMETRY_SESSION_ID = TAG.Util.IdCreator();

        if(currentPage.name !== TAG.Util.Constants.pages.COLLECTIONS_PAGE || !currentPage.obj || !currentPage.obj.loadFirstCollection) {
            catalog = new TAG.Layout.CollectionsPage();
            TAG.Util.UI.slidePageRight(catalog.getRoot());
        } else {
            removeIdleOverlay();
            currentPage.obj.loadFirstCollection();
        }
    }

    /**
     * Restart the idle timer; this is a utility function and could be defined elsewhere
     * @method restartIdleTimer
     */
    function restartTimer() {
        idleTimer && idleTimer.restart();
        //console.log('idle timer started');
    }

    return {
        TwoStageTimer: TwoStageTimer,
        timerPair: timerPair,
        restartTimer: restartTimer,
        removeIdleOverlay: removeIdleOverlay
    };
})();

;
var TAG = TAG || LADS || {},
    LADS = LADS || TAG || {};

TAG.Util.makeNamespace("Worktop.Database");

/*
    Worktop.Database contains the cache object for all requests and contains mostly private non-static
    methods used by TAG.Worktop.Database.  Functions in here are generally functions that require the cache,
    although some requests here don't currently modify or use the cache, but they could be modified in the future
    to be smarted about caching (such as updating the cache and incrementing the count when a doq is posted).
*/
Worktop.Database = function (mainID) {
    var HTTP_PORT = LADS.Worktop.Database.HTTP_PORT;
    var HTTPS_PORT = LADS.Worktop.Database.HTTPS_PORT;
    var FILE_PORT = LADS.Worktop.Database.FILE_PORT;

    if (localStorage.ip === "137.117.37.220") localStorage.ip = "browntagserver.com"; // Switch to new domain for HTTPS
    var _baseURL = localStorage.ip ? localStorage.ip : "browntagserver.com";  // url of the server
    localStorage.ip = _baseURL; // keep localStorage.ip current

    var useServer = true;

    var CACHE_PREFIX = 'tag_cache.'

    var _cache;
    // Uncomment to reset cache on startup
    //delete localStorage[CACHE_PREFIX + _baseURL];
    if (localStorage[CACHE_PREFIX + _baseURL]) {
        _cache = JSON.parse(localStorage[CACHE_PREFIX + _baseURL]);
    } else {
        var _cache = {
            main: null,
            tours: null,
            exhibs: null,
            artworks: null,
            feedback: null,
            media: null,
            doqs: {},
            doqMedia: {},
            doqMaps: {},
            linqs: {}
        };
    }

    if (mainID && _cache.main && _cache.main.Identifier) {
        if (mainID !== _cache.main.Identifier) _cache = {};
    }


    var _static = LADS.Worktop.Database;
    var _util = LADS.Util;

    // writeCache function debounces calls to write the cache to disk
    var writeCache = $.debounce(250, function () {
        //COMMENTED OUT FOR AUG15 RELEASE MUST FIGURE OUT WHY CACHE IS FILLING UP SO FAST?!?
       // localStorage[CACHE_PREFIX + _baseURL] = JSON.stringify(_cache);
    });

    return {
        getURL: getURL,
        getFileURL: getFileURL,
        getSecureURL: getSecureURL,
        setURL: setURL,
        setBaseURL: setBaseURL,

        getExhibitions: getExhibitions,
        getArtworks: getArtworks,
        getTours: getTours,
        getAssocMedia: getAssocMedia,
        getDoq: getDoq,
        getFeedback: getFeedback,
        getMain: getMain,
        getAssocMediaTo: getAssocMediaTo,
        getArtworksAssocTo: getArtworksAssocTo,
        getLinq: getLinq,
        getArtworksIn: getArtworksIn,
        getAssocMediaIn: getAssocMediaIn,
        getMaps: getMaps,

        putTour: putTour,
        putExhibition: putExhibition,
        putFeedback: putFeedback,
        putArtwork: putArtwork,
        putMap: putMap,
        putHotspot: putHotspot,

        postTour: postTour,
        postExhibition: postExhibition,
        postArtwork: postArtwork,
        postHotspot: postHotspot,
        postIframeAssocMedia: postIframeAssocMedia,
        postMap: postMap,
        postMain: postMain,
        addSortOptions: addSortOptions,

        deleteDoq: deleteDoq,
        deleteLinq: deleteLinq,
    };

    ///////////////
    // NEW STUFF //
    ///////////////

    function getExhibitions(handlers) {
        getRequest(
            "Exhibitions",
            safeCache('exhibs', 'doqs'),
            safeCache('exhibs', 'count'),
            handlers);
    }

    function getArtworks(handlers) {
        getRequest(
            "Artworks",
            safeCache('artworks', 'doqs'),
            safeCache('artworks', 'count'),
            handlers);
    }

    function getTours(handlers) {
        getRequest(
            "Tours",
            safeCache('tours', 'doqs'),
            safeCache('tours', 'count'),
            handlers);
    }

    // TODO: PLEASE NO - bmost //TODO: PLEASE YES - jjfu :P
    function addSortOptions(guid, handlers, throwOnWarn) {
        getRequest(
            "AddSortOptions",
            safeCache('doqs', guid),
            safeCache(false, false, 'doqs', guid, 'Metadata', 'Count'),
            handlers,
            { "Guid": guid });
    }

    function getAssocMedia(handlers) {
        getRequest(
            "AllAssociatedMedia",
            safeCache('media', 'doqs'),
            safeCache('media', 'count'),
            handlers);
    }

    function getFeedback(handlers) {
        getRequest(
            "Feedback",
            safeCache('feedback', 'doqs'),
            safeCache('feedback', 'count'),
            handlers);
    }

    function getDoq(guid, handlers) {
        getRequest(
            "Doq",
            safeCache('doqs', guid),
            safeCache('doqs', guid, 'Metadata', 'Count'),
            handlers,
            { "Guid": guid });
    }

    function getMain(handlers) {
        getRequest(
            "Main",
            safeCache('main'),
            safeCache(true, false, 'main', 'Metadata', 'MainCount'),
            handlers);
    }

    function getAssocMediaTo(guid, handlers) {
        getRequest(
            "AssociatedMedia",
            safeCache('doqMedia', guid, 'doqs'),
            safeCache('doqMedia', guid, 'LinqCount'),
            handlers,
            { "Guid": guid });
    }

    function getArtworksAssocTo(guid, handlers) {
        getRequest(
            "ArtworksAssociated",
            safeCache('doqMedia', guid, 'doqs'),
            safeCache('doqMedia', guid, 'LinqCount'),
            handlers,
            { "Guid": guid });
    }

    function getLinq(guid1, guid2, handlers) {
        getRequest(
            "Linq",
            safeCache('linqs', guid1, guid2, 'linq'),
            safeCache(false, false, 'linqs', guid1, guid2, 'Count'),
            handlers,
            { "Guid1": guid1, "Guid2": guid2 });
    }

    function getMaps(guid, handlers) {//given an artwork guid and get all the maps for the artwork
        getRequest(
            "Maps",
            safeCache('doqMaps', guid, 'doqs'),
            safeCache('doqMaps', guid, 'MapCount'),
            handlers,
            { "Guid": guid });

    }

    function getArtworksIn(guid, handlers) {
        getRequest(
            "ArtworksIn",
            safeCache('artIn', guid, 'art'),
            safeCache('artIn', guid, 'Count'),
            handlers,
            { "Guid": guid });
    }

    function getAssocMediaIn(guid, handlers) {
        getRequest(
            "AssocMediaIn",
            safeCache('assocMediaIn', guid, 'assocMedia'),
            safeCache('assocMediaIn', guid, 'Count'),
            handlers,
            { "Guid": guid });
    }

    function postTour(guid, options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.tour, "ChangeTour", throwOnWarn);
        sortedOptions.urlOptions.Guid = guid;
        postRequest(
            'ChangeTour',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postExhibition(guid, options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.exhibition, "ChangeExhibition", throwOnWarn);
        sortedOptions.urlOptions.Guid = guid;
        postRequest(
            'ChangeExhibition',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postArtwork(guid, options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.artwork, "ChangeArtwork", throwOnWarn);
        sortedOptions.urlOptions.Guid = guid;
        postRequest(
            'ChangeArtwork',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postMap(guid, options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.map, "ChangeMap", throwOnWarn);
        sortedOptions.urlOptions.Guid = guid;
        postRequest(
            'ChangeMap',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postHotspot(guid, options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.hotspot, "ChangeHotspot", throwOnWarn);
        sortedOptions.urlOptions.Guid = guid;
        postRequest(
            'ChangeAssociatedMedia',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postIframeAssocMedia(options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.hotspot, "CreateIframeAssocMedia", throwOnWarn);
        postRequest(
            'CreateIframeAssocMedia',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true);
    }

    function postMain(options, handlers, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.main, "ChangeMain", throwOnWarn);
        postRequest(
            'Main',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            true,
            safeCache('main', 'Metadata', 'MainCount').get());
    }


    function putTour(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.tour, "CreateTour", throwOnWarn);
        putRequest(
            'CreateTour',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq,
            true);
    }

    function putExhibition(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.exhibition, "CreateExhibition", throwOnWarn);
        putRequest(
            'CreateExhibition',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq,
            true);
    }

    function putFeedback(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.feedback, "CreateFeedback", throwOnWarn);
        putRequest(
            'CreateFeedback',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq);
    }

    function putArtwork(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.artwork, "CreateArtwork", throwOnWarn);
        putRequest(
            'CreateArtwork',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq,
            true);
    }

    function putMap(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.artwork, "CreateArtwork", throwOnWarn);
        putRequest(
            'CreateMap',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq,
            true);
    }

    function putHotspot(options, handlers, returnDoq, throwOnWarn) {
        options = options || {};
        var sortedOptions = checkKeys(options, _static.params.hotspot, "CreateHotspot", throwOnWarn);
        putRequest(
            'CreateHotspot',
            handlers,
            sortedOptions.urlOptions,
            sortedOptions.bodyOptions,
            returnDoq,
            true);
    }


    function deleteDoq(guid, handlers) {
        deleteRequest(
            'Doq',
            handlers,
            { Guid: guid },
            true);
    }

    function deleteLinq(guid, handlers) {
        deleteRequest(
            'Linq',
            handlers,
            { Guid: guid },
            true);
    }

    /////////////////////
    // PRIVATE METHODS //
    /////////////////////

    /*
      handlers:
        success
        error
        errorCache

      cacheLoc is a cache location returned from safeCache containing the doq/qos
      clientCount is a cache location returned from safeCache containg the doq's count
      cacheFn is generally not required, but allows you to set a custom caching function
      secure makes the request use https
    */
    function getRequest(type, cacheLoc, clientCount, handlers, urlOptions, cacheFn, secure) {
        handlers = handlers || {};
        urlOptions = urlOptions || {};
        var cacheFn = cacheFn || cacheFunc(cacheLoc, clientCount);
        var count = -1;
        if (typeof clientCount.get === "function") {
            count = clientCount.get();
            if (!count && count !== 0) {
                count = -1;
            }
        }
        urlOptions.Count = count;
        var ajaxHandlers = {
            200: _static.convertToDocHandler(_util.multiFnHandler(handlers.success, cacheFn, doqCache), handlers.error),
            304: _util.safeCallHandler(handlers.success, cacheLoc.get()),
            401: handleAuth(handlers.unauth),
            error: _util.multiFnHandler(handlers.error, errorCacheHandler(handlers.errorCache, cacheLoc.get()))
        };
        _static.asyncRequest('GET', type, urlOptions, null, ajaxHandlers, secure);
    }

    function errorCacheHandler(fn, cacheVal) {
        if (cacheVal) {
            return _util.safeCallHandler(fn, cacheVal);
        } else {
            return function () { };
        }
    }

    /*
      handlers:
        success
        error
        unauth

       returnDoq makes the request returnt he doq's xml
    */
    function putRequest(type, handlers, urlOptions, bodyOptions, returnDoq, secure) {
        handlers = handlers || {};
        urlOptions = urlOptions || {};
        urlOptions.Token = LADS.Auth.getToken();
        urlOptions.ReturnDoq = returnDoq;
        var ajaxHandlers = {
            200: (returnDoq && _static.convertToDocHandler(handlers.success, handlers.error)) || handlers.success,
            401: handleAuth(handlers.unauth),
            error: handlers.error,
        }
        _static.asyncRequest('PUT', type, urlOptions, bodyOptions, ajaxHandlers, secure);
    }

    /*
      handlers:
        success
        error
        unauth
        conflict
    */
    function deleteRequest(type, handlers, urlOptions, secure) {
        handlers = handlers || {};
        urlOptions = urlOptions || {};
        urlOptions.Token = LADS.Auth.getToken();
        urlOptions.Count = safeCache('doqs', urlOptions.Guid).get().Metadata.Count || 0;

        var ajaxHandlers = {
            200: handlers.success,
            401: handleAuth(handlers.unauth),
            409: handlers.conflict,
            error: handlers.error,
        }
        _static.asyncRequest('DELETE', type, urlOptions, null, ajaxHandlers, secure);
    }

    /*
      handlers:
        success
        error
        unauth
        conflict
      cacheCount is a custom cache counter (used if the count isn't stored in the doq)
    */
    function postRequest(type, handlers, urlOptions, bodyOptions, secure, cacheCount) {
        handlers = handlers || {};
        urlOptions = urlOptions || {};
        urlOptions.Token = LADS.Auth.getToken();
        var cacheLoc = safeCache('doqs', urlOptions.Guid).get();
        if (cacheCount !== 0) {
            cacheCount = cacheCount || (cacheLoc && cacheLoc.Metadata && safeCache('doqs', urlOptions.Guid).get().Metadata.Count) || 0;
        }
        urlOptions.Count = cacheCount;

        var ajaxHandlers = {
            200: handlers.success,
            401: handleAuth(handlers.unauth),
            409: handlers.conflict,
            error: handlers.error,
        }
        _static.asyncRequest('POST', type, urlOptions, bodyOptions, ajaxHandlers, secure);
    }

    /*
        Checks if the keys provided in options are valid in the dictionary provided as params
        throwOnWarn causes an exception if a key isn't found in params
    */
    function checkKeys(options, params, name, throwOnWarn) {
        var urlOptions = {};
        var bodyOptions = {};
        $.each(options, function (key, val) {
            if (!_util.contains(params.url, key) && !_util.contains(params.body, key)) {
                if (throwOnWarn) {
                    throw "'" + key + "' is not a valid request parameter for " + name;
                } else {
                    console.log("Warning: '" + key + "' is not a valid request parameter for " + name);
                }
            }
            if (_util.contains(params.body, key)) {
                bodyOptions[key] = val;
            } else {
                urlOptions[key] = val;
            }
        });
        return {
            bodyOptions: bodyOptions,
            urlOptions: urlOptions,
        };
    }

    /*
        Authentication handler
    */
    function handleAuth(fail) {
        return function (jqXHR, ajaxCall) {
            LADS.Auth.authenticate(function () { ajaxCall.setToken(LADS.Auth.getToken()).call() }, fail)
        }
    }

    /*
        Caches a doq or array of doqs
    */
    function doqCache(doq) {
        if (doq && doq[0]) {
            $.each(doq, function (i, d) {
                safeCache('doqs', d.Identifier).set(d);
            });
        } else if (doq) {
            safeCache('doqs', doq.Identifier).set(doq);
        }
    }

    /*
        Returns an object with the functions set() and get()
        which set and return the cache value at the specified location respectively
        
        Specify the cache location as a varargs argument (ex. safeCache('main', 'Metadata'))
        If the first argument is a boolean then it sets getEnabled which controls whether
        or not the get() function is enabled
        If the second argument is a boolean then it sets setEnabled which controls whether
        or not the set() function is enabled.  This also assumes the ifrst argument is a boolean.
    */
    function safeCache(getEnabled, setEnabled) {
        var stopGet, stopSet;
        var skipArgs = 0;
        if (typeof setEnabled === "boolean") {
            stopSet = !setEnabled;
            stopGet = !getEnabled;
            skipArgs = 2;
        } else if (typeof getEnabled === "boolean") {
            stopGet = !getEnabled;
            skipArgs = 1;
        }
        var args = [];
        for (var j = skipArgs; j < arguments.length; j++) {
            args[j - skipArgs] = arguments[j];
        }
        return {
            set: function (val) {
                if (stopSet) return;
                var current = _cache;
                for (var i = 0; i < args.length - 1; i++) {
                    if (!current[args[i]]) {
                        current[args[i]] = {};
                    }
                    current = current[args[i]];
                }
                current[args[i]] = val;
                writeCache();
            },
            get: function () {
                if (stopGet) return;
                var current = _cache;
                for (var i = 0; i < args.length - 1; i++) {
                    if (!current[args[i]]) {
                        current[args[i]] = {};
                    }
                    current = current[args[i]];
                }
                return current[args[i]];
            }
        }
        return current[arguments[i]];
    }

    /*
        Default caching function for get requests, assumes the new count is in the status text of the response
    */
    function cacheFunc(cacheLoc, cacheCount) {
        return function (data, jqXHR) {
            cacheLoc.set(data);
            cacheCount.set(parseInt(jqXHR.statusText));
        }
    }

    ///////////////////
    // END NEW STUFF //
    ///////////////////

    function setBaseURL(url) {
        _baseURL = url;
    }

    // set server URL
    function setURL(url) {
        _baseURL = url;
    }

    // get server URL
    function getURL() {
        return "http://" + _baseURL + ':' + HTTP_PORT;
    }

    function getSecureURL() {
        var useHttps = LADS.Worktop.Database.checkSetting('UseHTTPS');
        if (useHttps && useHttps.toLowerCase() === 'true') {
            return "https://" + _baseURL + ':' + HTTPS_PORT;
        } else {
            return "http://" + _baseURL + ':' + HTTP_PORT;
        }
    }

    function getFileURL() {
        return "http://" + _baseURL + ':' + FILE_PORT;
    }
};

;
var TAG = TAG || LADS || {};

TAG.Util.makeNamespace("Worktop.Doq");

/*
 * The Worktop.Doq class is used to convert the XML retreived from the server to a more usable
 * javascript object. The doq that is returned converts the XML into the following structure:
 * Object -> Identifier
 *        -> Name
 *        -> Metadata -> Type
 *                    -> Artist
 */

Worktop.Doq = function (xml) {

    // converts the text into xml
    var xmlNode = $.parseXML(xml);
    // converts the xml into a javascript object. however, due to the specific format of the xml returned, 
    // this object is impossible to use until further processing is done (particularly with the metadata)
    var doq = $.xml2json(xmlNode);

    // tells the local database to store the text xml in its cache, which is used to retrieve the XML when making changes in AuthoringMode
    //if (doq.DoqData) {
    //    //There is more than one exhibition
    //    for (var i = 0; i < doq.DoqData.length; i++) {
    //        var obj = doq.DoqData[i];
    //        TAG.Worktop.Database.updateCache(obj.Identifier, xml);
    //    }
    //} else {
    //    TAG.Worktop.Database.updateCache(doq.Identifier, xml);
    //}


    /* 
     * This method basically takes the javascript object and removes all the uneccessary tags that the C#
     * XML serializer was responsible for creating
     */
    function fixMetadata(doq) {
        if (doq != undefined) {

            if (!doq.Metadata)
                return null;

            var metadata = {};
            var metadataElement = doq.Metadata.Dicts["KeyValueOfguidMetadataDictionaryYwP_PEBe9"] ? doq.Metadata.Dicts["KeyValueOfguidMetadataDictionaryYwP_PEBe9"].Value.Dict.KeyValueOfstringanyType : [];
            if (!metadataElement.length) {
                var key = metadataElement["Key"];
                var value = metadataElement["Value"];
                metadata[key] = value;
            } else {
                $.each(metadataElement, function (i) {
                    var key = metadataElement[i].Key;
                    var value = metadataElement[i].Value.text;
                    metadata[key] = value;
                });
            }
            doq.Metadata = metadata;
            if (doq.Metadata && typeof doq.Metadata.InfoFields === "string") {
                try {
                    doq.Metadata.InfoFields = JSON.parse(doq.Metadata.InfoFields);
                } catch (ex) {
                    doq.Metadata.InfoFields = {};
                }
            }
        }
    }

    function fixFolders(doq) {
        if (doq != undefined && doq._Folders) {
            doq.Folders = doq._Folders.FolderData;
        }
    }

    /* 
     * The following code figures out whether the given XML contains and Array of DoqDatas or a single DoqData.
     * If there is an array, then an array of javascript objects is created with the individual javascript objects
     */

    if (doq.DoqData) {
        var arrayOfDoqData = [];

        if (doq.DoqData[0]) {
            $.each(doq.DoqData, function (i) {
                fixMetadata(this);
                fixFolders(this);
                arrayOfDoqData.push(this);
            });
        }
        else {
            fixMetadata(doq.DoqData);
            fixFolders(doq.DoqData);
            arrayOfDoqData.push(doq.DoqData);
        }
        return arrayOfDoqData;
    } else if (doq.LinqData) {
        var arrayOfLinqData = [];

        if (doq.LinqData[0]) {
            $.each(doq.LinqData, function (i) {
                fixMetadata(this);
                arrayOfLinqData.push(this);
            });
        }
        else {
            fixMetadata(doq.LinqData);
            arrayOfLinqData.push(doq.LinqData);
        }
        return arrayOfLinqData;
    } else {
        fixMetadata(doq);
        fixFolders(doq);
        return doq;
    }
}
;
var TAG = TAG || LADS || {};

TAG.Util.makeNamespace("TAG.Worktop.Database");

/*
    Contains static methods for accessing the database.  Holds an instance of Worktop.Database
    where many of the requests are sent to to access the cache, but all requests ultimately
    use asyncRequest.

    See issue #205 (http://tagissuetracker.cs.brown.edu:3000/issues/205) for info on the protocol.
    Refer to individual functions or issue #205 for info on each request.
*/
TAG.Worktop.Database = (function () {
    var _db,
        _main,
        HTTP_PORT = '8080',
        HTTPS_PORT = '9001',
        FILE_PORT = '8086';

    var util = TAG.Util;

    // If true an exception will be thrown if a post/put request is made with an invalid parameter
    var strict = true;

    // Parameters for post/put requests
    // Body parameters MUST be specified properly for the various put/post functions to move
    // the appropriate parameters into the body.
    var params = {
        exhibition: {
            url: ['Name', 'Sub1', 'Sub2', 'Background', 'Img1', 'Img2', 'Private', 'Font', 'SortOptions', 'Timeline','AssocMediaView', 'AddSortOptions'],
            body: ['Description', 'AddIDs', 'RemoveIDs']
        },
        artwork: {
            url: ['Name', 'Title', 'Artist', 'Year', 'Month', 'Day', 'TimelineYear', 'TimelineMonth', 'TimelineDay', 'Preview', 'Thumbnail', 'Deepzoom', 'Source', 'Duration', 'Converted', 'Locked'],
            body: ['Description', 'Location', 'AddIDs', 'RemoveIDs', 'InfoFields', 'Duration', 'RichLocationHistory', 'AddMaps', 'RemoveMaps']
        },
        tour: {
            url: ['Name', 'Thumbnail', 'Private'],
            body: ['Description', 'Content', 'RelatedArtworks']
        },
        hotspot: {
            url: ['Name', 'Year', 'Month', 'Day', 'TimelineYear', 'TimelineMonth', 'TimelineDay', 'ContentType', 'Duration', 'Source', 'LinqTo', 'X', 'Y', 'W', 'H', 'LinqType', 'Thumbnail', "Converted"],
            body: ['Description', 'AddIDs', 'RemoveIDs']
        },
        map: {
            url: ['Name', 'Thumbnail', 'Source'],
            body: ['AdditionalInfo', 'Description']
        },
        feedback: {
            url: ['SourceID', 'SourceType'],
            body: ['Description']
        },
        main: {
            url: ['Name', 'OverlayColor', 'OverlayTrans', 'Location', 'Background', 'Icon', 'IconColor', 'BackgroundColor', 'BackgroundOpacity', 'FontFamily', 'PrimaryFontColor', 'SecondaryFontColor', 'BaseFontSize', 'Font', 'IdleTimerDuration'],
            body: ['Info']
        }
    };

    return {
        HTTP_PORT: HTTP_PORT,
        HTTPS_PORT: HTTPS_PORT,
        FILE_PORT: FILE_PORT,

        getURL: getURL,
        getSecureURL: getSecureURL,
        setURL: setURL,
        getFileURL: getFileURL,

        fixPath: fixPath,
        fixFontFilePath: fixFontFilePath,
        checkAuth: checkAuth,
        changeServer: changeServer,
        checkSetting: checkSetting,

        // Not sure if these should be kept or not
        getMuseumName: getMuseumName,
        getMuseumLoc: getMuseumLoc,
        getMuseumInfo: getMuseumInfo,
        getStartPageBackground: getStartPageBackground,
        getMuseumLogo: getMuseumLogo,
        getMuseumOverlayColor: getMuseumOverlayColor,
        getMuseumOverlayTransparency: getMuseumOverlayTransparency,
        getLogoBackgroundColor: getLogoBackgroundColor,
        getMuseumBackgroundColor: getMuseumBackgroundColor,
        getBackgroundColor: getMuseumBackgroundColor, // TODO merging
        getMuseumBackgroundOpacity: getMuseumBackgroundOpacity,
        getBackgroundOpacity: getMuseumBackgroundOpacity, // TODO merging
        getMuseumFontFamily: getMuseumFontFamily,
        getFontFamily: getMuseumFontFamily, // TODO merging
        getMuseumPrimaryFontColor: getMuseumPrimaryFontColor,
        getPrimaryFontColor: getMuseumPrimaryFontColor, // TODO merging
        getMuseumSecondaryFontColor: getMuseumSecondaryFontColor,
        getSecondaryFontColor: getMuseumSecondaryFontColor, // TODO merging
        getBaseFontSize: getBaseFontSize,
        getOptionalFeatures: getOptionalFeatures,
        getCustomFont: getCustomFont,
        getIdleTimerDuration: getIdleTimerDuration,
        getLocked: getLocked,

        asyncRequest: asyncRequest,
        convertToDocHandler: convertToDocHandler,
        params: params,
        convertToTextHandler: convertToTextHandler,

        // HEAD
        clearToken: clearToken,
        checkToken: checkToken,

        // GET
        getExhibitions: getExhibitions,
        getFeedback: getFeedback,
        getArtworks: getArtworks,
        getTours: getTours,
        getArtworksAndTours: getArtworksAndTours,
        getMain: getMain,
        getAssocMedia: getAssocMedia,
        getLinq: getLinq,
        getAssocMediaTo: getAssocMediaTo,
        getArtworksAssocTo: getArtworksAssocTo,
        getArtworksIn: getArtworksIn,
        getAssocMediaIn: getAssocMediaIn,
        getMaps: getMaps,
        getSalt: getSalt,
        getAuth: getAuth,
        getVersion: getVersion,
        getDoq: getDoq,
        changePass: changePass,
        getConvertedCheck: getConvertedCheck, //video conversion
        getConvertedVideoCheck: getConvertedVideoCheck, //video conversion
        convertVideo: convertVideo,
        // DELETE
        deleteDoq: deleteDoq,
        deleteLinq: deleteLinq,

        // PUT
        createTour: createTour,
        createExhibition: createExhibition,
        createFeedback: createFeedback,
        createArtwork: createArtwork,
        createHotspot: createHotspot,
        createIframeAssocMedia: createIframeAssocMedia,
        createMap: createMap,

        // POST
        changeTour: changeTour,
        changeExhibition: changeExhibition,
        changeArtwork: changeArtwork,
        changeHotspot: changeHotspot,
        changeMap: changeMap,
        changeMain: changeMain,
        addSortOptions: addSortOptions,
        uploadImage: uploadImage,
    }

    ///////////////
    // NEW STUFF //
    ///////////////

    ///////////////////////////////
    // Worktop.Database Wrappers //
    ///////////////////////////////
    // Unless otherwise noted handles (success, unauth, conflict, error) are called
    // with two arguments, the first being the jqXHR object for the request (http://api.jquery.com/jQuery.ajax/#jqXHR)
    // and the second being an object ajaxCall which has two methods, call and force.
    // call will redo the ajaxCall exactly as it was, force will redo the ajax call, but set
    // Force=true in the request overwriting in the case of a conflict.
    //
    // The following handlers exist for the various different function:
    //      success: Called when the request is successful
    //      unauth: Called when the token provided was invalid and the user 
    //              didn't input the password when prompted (ie. they clicked cancel)
    //      conflict: Called when there is a conflict
    //      error: Called for any other error
    //      errorCache: Called if there is an error with the cached doq/doqs as the argument

    ///////////////////
    // HEAD REQUESTS //
    ///////////////////

    /*
        Clears a token from the server so it can no longer be used
            token: The token to clear
            success: See above
            error: See above
    */
    function clearToken(token, success, error) {
        asyncRequest('HEAD', 'ClearToken', { Token: token }, null, { success: success, error: error }, true);
    }

    /*
        Checks if a token is valid
            token: The token to check
            success: See above
            unauth: Called if the token is not valid
            error: See above
    */
    function checkToken(token, success, unauth, error) {
        asyncRequest('HEAD', 'CheckToken', { Token: token }, null, { success: success, 401: unauth, error: error }, true);
    }

    //////////////////
    // GET REQUESTS //
    //////////////////

    /*
        Gets all exhibitions
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getExhibitions(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getExhibitions({ success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all feedback
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getFeedback(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getFeedback({ success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all artworks
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getArtworks(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getArtworks({ success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all tours
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getTours(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getTours({ success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all artworks and all tours. Hacky way to do this right now; should be a separate server function
            success: Called on Success with the doq array as the argument
            error: See above
            errorCache: See above
    */
    function getArtworksAndTours(success, error, errorCache) {
        var components = [];
        getArtworks(function (artworks) {
            components = artworks;
            getTours(function (tours) {
                success(components.concat(tours));
            }, error, errorCache);
        }, error, errorCache);
    }

    /*
        Gets a doq
            guid: The guid of the doq to get
            success: Called on success with the doq as the argument
            error: See above
            errorCache: see above
    */
    function getDoq(guid, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getDoq(guid, { success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets the main doq
            success: Called on success with the doq as the argument
            error: See above
            errorCache: see above
    */
    function getMain(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getMain({
            success: function (main) {
                _main = main;
                success && success(main);
            }, error: error, errorCache: errorCache
        });
    }

    /*
        Gets all associated media
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getAssocMedia(success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getAssocMedia({ success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets the linq between two doqs
            guid1: guid of one doq in the linq
            guid2: guid of the other doq in the linq
            success: Called on success with the linq as the argument
            error: See above
            errorCache: see above
    */
    function getLinq(guid1, guid2, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getLinq(guid1, guid2, { success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all associated media to an artwork (gets all linqs to a doq)
            guid: Guid of the artwork/doq to get doqs linqed to
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getAssocMediaTo(guid, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getAssocMediaTo(guid, { success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all artworks a media is associated to
            guid: Guid of the media
            success: Called on success with the doq array as the argument
            error: see above
            errorCache: see above
    */
    function getArtworksAssocTo(guid, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getArtworksAssocTo(guid, { success: success, error: error, errorCache: errorCache });
    }

    /*
        Gets all artworks in an exhibition
            guid: Guid of the exhibition
            success: Called on success with the doq array as the argument
            error: See above
            errorCache: see above
    */
    function getArtworksIn(guid, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getArtworksIn(guid, { success: success, error: error, errorCache: errorCache });
    }

    function getAssocMediaIn(guid, success, error, errorCache) {
        _db = _db || new Worktop.Database();
        _db.getAssocMediaIn(guid, { success: success, error: error, errorCache: errorCache });
    }
    /*
        Gets maps related to given artwork
            guid: artowork guid
            success: called on success with array of map doqs as argument
            error: see above
            errorCache: see above
    */
    function getMaps(guid, success, error, errorCache) {
        // TODO
        _db = _db || new Worktop.Database();
        _db.getMaps(guid, { success: success, error: error, errorCache: errorCache });
        //success([]);
    }

    /*
        Gets the salt from the server
            success: Called with the salt as the argument
            error: See above
    */
    function getSalt(success, error) {
        asyncRequest(
            'GET',
            'Salt',
            null,
            null,
            { success: convertToTextHandler(success), error: error },
            true);
    }

    /*
        Checks if the password and salt are valid
            password: plain text password
            salt: salt provided by the server (see getSalt)
            success: Called with the token as the argument
            unauth: Called if the login fails because the password was wrong
            error: See above
    */
    function getAuth(password, salt, success, unauth, error) {
        asyncRequest(
            'GET',
            'Auth',
            { Hash: TAG.Auth.hashPass(password, salt) },
            null,
            { success: convertToTextHandler(success), 401: unauth, error: error },
            true);
    }


    /*
        Gets the version of the server
            success: Called on success with the version as a string as the argument
            error: See above
    */
    function getVersion(success, error) {
        _db = _db || new Worktop.Database();
        asyncRequest(
            'GET',
            'CheckVersion',
            null,
            null,
            { success: convertToStatusHandler(success), error: error });
    }

    /*
        Changes the password
            oldpass: Plaintext of the old password
            salt: Salt provided by the server (see getSalt)
            newpass: Plaintext of new password
            success: Called on success with the new token as the argument
            unauth: Called if the password is wrong
            error: See above
    */
    function changePass(oldpass, salt, newpass, success, unauth, error) {
        asyncRequest(
            'POST',
            'ChangePassword',
            { OldHash: TAG.Auth.hashPass(oldpass, salt), NewPass: newpass },
            null,
            { success: convertToTextHandler(success), unauth: unauth, error: error },
            true);
    }
    //check for files. 
    function getConvertedCheck(success, error, fileName,basefilename) {
        asyncRequest(
            'GET',
            'ConvertedCheck',
            {
                "FileName": fileName,
                "BaseFileName": basefilename,
            },
            null,
            { success: convertToTextHandler(success), error: error });
    }

    function getConvertedVideoCheck(success, error, guid) {
        asyncRequest(
            'GET',
            'ConvertedVideoCheck',
            { "guid": guid },
            null,
            { success: convertToStatusHandler(success), error: error });
    }
    function convertVideo(success, error, newFileName, fileExtension, baseFileName, doq,forTour) {
        asyncRequest(
            'POST',
            'ConvertVideo',
            { "FileName": newFileName, "Extension": fileExtension, "BaseFileName": baseFileName, "Identifier": doq,"ForTour":forTour },
            null,
            { success: convertToTextHandler(success), error: error }
            , true);
    }

    //////////////////
    // PUT REQUESTS //
    //////////////////

    /*
        Create a tour
            options: Values for the new tour in a dictionary:
                Name: Name of the tour
                Thumbnail: Thumbnail URL
                Private: Private state
                Description: Tour description
                Content: Tour content (JSON for RIN data)
                RelatedArtworks: JSON of related artworks
            All options are optional.  Providing unspported options in strict mode will throw an exception.

            success: Success handler (called if the tour is successfully created) with the new doq as the argument if returnDOq is true
            unauth: Unauthorized handler (called when a user fails to login)
            error: Called for any other errors
            returnDoq: If true the newly created tour will be returned from the server and passed to the success handler
    */
    function createTour(options, success, unauth, error, returnDoq) {
        _db = _db || new Worktop.Database();
        _db.putTour(options, { success: success, error: error, unauth: unauth }, returnDoq, strict);
    }

    /*
    Create an exhibition
        options: Values for the new exhibition in a dictionary:
            Name: Name of the exhibition
            Sub1: Subheading 1 of the exhibition
            Sub2: Subheading 2 of the exhibition
            Background: BG Image URL
            Img1: Desc image 1 URL
            Img2: Desc image 2 URL (unused)
            Private: Exhibition private state (boolean)
            Description: Exhibition description
            AddIDs: Comma separated list of artwork IDs to add to the exhibition
        All options are optional.  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the tour is successfully created) with the new doq as the argument if returnDOq is true
        unauth: Unauthorized handler (called when a user fails to login)
        error: Called for any other errors
        returnDoq: If true the newly created tour will be returned from the server and passed to the success handler
    */
    function createExhibition(options, success, unauth, error, returnDoq) {
        _db = _db || new Worktop.Database();
        _db.putExhibition(options, { success: success, error: error, unauth: unauth }, returnDoq, strict);
    }

    /*
        Create Feedback
            text: Description text for the feedback
            sourceType: Type of the source (Exhibition, Artwork, Tour)
            sourceID: GUID of the source doq
            success: Called on successful creation
            error: Called on error
    */
    function createFeedback(text, sourceType, sourceID, success, error) {
        _db = _db || new Worktop.Database();
        text = text || "No Text";
        _db.putFeedback({ SourceID: sourceID, SourceType: sourceType, Description: text }, { success: success, error: error }, false, strict);
    }

    /* Create an artwork
        options: Values for the new artwork in a dictionary:
            Name: Name of the artwork
            Title: title of the artork (not used?)
            Artist: Artist of the artwork
            Year: Year of the artwork
            Preview: preview image URL
            Thumbnail: thumbnail image URL
            Deepzoom: Deepzoom URL
            InfoFields: JSON of custom info fields
            Description: Description of artwork
            Location: JSON of location info
            AddIDs: Comma separated list of associated media IDs to add to the exhibition
        All options are optional.  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the artwork is successfully created) with the new doq as the argument if returnDoq is true
        unauth: Unauthorized handler (called when a user fails to login)
        error: Called for any other errors
        returnDoq: If true the newly created artwork will be returned from the server and passed to the success handler
    */
    function createArtwork(options, success, unauth, error, returnDoq) {
        _db = _db || new Worktop.Database();
        _db.putArtwork(options, { success: success, error: error, unauth: unauth }, returnDoq, strict);
    }

    /* Create a hotspot/associated media
        options: Values for the new hotspot in a dictionary:
            Name: Name of the hotspot
            ContentType: Content type of the hotspot
            Duration: Duration of the hotspot
            Source: Source URL for the hotspot
            LinqTo: GUID of a doq to create a linq with
            X: The x position of the linq (requires LinqTo)
            Y: The y position of the linq (requires LinqTo)
            LinqType: The type of the linq (requires LinqTo)
            Description: Description of the hotspot
        All options are optional (except LinqTo if X, Y, or LinqType is set).  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the hotspot is successfully created) with the new doq as the argument if returnDoq is true
        unauth: Unauthorized handler (called when a user fails to login)
        error: Called for any other errors
        returnDoq: If true the newly created hotspot will be returned from the server and passed to the success handler
    */
    function createHotspot(options, success, unauth, error, returnDoq) {
        _db = _db || new Worktop.Database();
        _db.putHotspot(options, { success: success, error: error, unauth: unauth }, returnDoq, strict);
    }

    function createMap(options, success, unauth, error, returnDoq) {
        _db = _db || new Worktop.Database();
        _db.putMap(options, { success: success, error: error, unauth: unauth }, returnDoq, strict);
    }

    ///////////////////
    // POST REQUESTS //
    ///////////////////

    /*
        Change a tour
            options: New values for the tour in a dictionary:
                Name: Name of the tour
                Thumbnail: Thumbnail URL
                Private: Private state
                Description: Tour description
                Content: Tour content (JSON for RIN data)
            All options are optional.  Providing unspported options in strict mode will throw an exception.

            success: Success handler (called if the tour is successfully changed)
            unauth: Unauthorized handler (called when a user fails to login)
            conflict: Called if the client's version of the doq is out of date
            error: Called for any other errors
    */
    function changeTour(guid, options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.postTour(guid, options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    /*
    Change an exhibition
        options: New values for the exhibition in a dictionary:
            Name: Name of the exhibition
            Sub1: Subheading 1 of the exhibition
            Sub2: Subheading 2 of the exhibition
            Background: BG Image URL
            Img1: Desc image 1 URL
            Img2: Desc image 2 URL (unused)
            Private: Exhibition private state (boolean)
            Description: Exhibition description
            AddIDs: Comma separated list of artwork IDs to add to the exhibition
            RemoveIDs: Comma separated list of artwork IDs to remove from the exhibition
            Timeline: whether the timeline for the given collection is shown
        All options are optional.  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the tour is successfully changed)
        unauth: Unauthorized handler (called when a user fails to login)
        conflict: Called if the client's version of the doq is out of date
        error: Called for any other errors
    */
    function changeExhibition(guid, options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.postExhibition(guid, options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    function addSortOptions(guid, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        _db.addSortOptions(guid, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }
    /*
    Change an artwork
        options: New values for the artwork in a dictionary:
            Name: Name of the artwork
            Title: title of the artork (not used?)
            Artist: Artist of the artwork
            Year: Year of the artwork
            Month: Month of artwork
            Day: Day of artwork
            TimelineYear: Year artwork displayed on timeline
            TimelineMonth: Month artwork displayed on timeline
            TimelineDay: Day artwork displayed on timeline
            Preview: preview image URL
            Thumbnail: thumbnail image URL
            Deepzoom: Deepzoom URL
            InfoFields: JSON of custom info fields
            Description: Description of artwork
            Location: JSON of location info
            AddIDs: Comma separated list (string) of associated media IDs to add to the exhibition
            RemoveIDs: Same as addIDs, but associated media to remove
            Duration: duration of a video artwork
            Source: source of video artwork
        All options are optional.  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the artwork is successfully changed)
        unauth: Unauthorized handler (called when a user fails to login)
        conflict: Called if the client's version of the doq is out of date
        error: Called for any other errors
    */
    function changeArtwork(guid, options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.postArtwork(guid, options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    /*
    Change a hotspot/associated media
        options: New values for the hotspot in a dictionary:
            Name: Name of the hotspot
            Year: Year of the media
            Month: Month of media
            Day: Day of media
            TimelineYear: Year media displayed on timeline
            TimelineMonth: Month media displayed on timeline
            TimelineDay: Day media displayed on timeline
            ContentType: Content type of the hotspot
            Duration: Duration of the hotspot
            Source: Source URL for the hotspot
            LinqTo: GUID of a doq to create a linq with or a doq that the hotspot is already linqed to
            X: The x position of the linq (requires LinqTo)
            Y: The y position of the linq (requires LinqTo)
            LinqType: The type of the linq (requires LinqTo)
            Description: Description of the hotspot
            Thumbnail: URL for a thumbnail (used for videos)
        All options are optional (except LinqTo if X, Y, or LinqType are used).  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if the hotspot is successfully changed)
        unauth: Unauthorized handler (called when a user fails to login)
        conflict: Called if the client's version of the doq is out of date
        error: Called for any other errors
    */
    function changeHotspot(guid, options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.postHotspot(guid, options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    // TODO document
    function createIframeAssocMedia(options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        _db.postIframeAssocMedia(options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    /*
    Change a map doq
        guid: guid of map
        options:
            Name: name of the map
            AdditionalInfo: any additional information about the map (e.g., a date string)
            Description: description of the map
        success: success handler called if map is changed successfully
        unauth: see above
        conflict: see above
        error: see above
    */
    function changeMap(guid, options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.postMap(guid, options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    /*
    Change the main doq (start page)
        options: New values for main in a dictionary:
            Name: Museum name
            OverlayColor: Overlay color
            OverlayTrans: Overlay transparency
            Location: Museum loaction
            Background: BG image URL
            Icon: Icon image URL
            IconColor: Icon color
            Info: Museum info
            BackgroundColor: Background color
            BackgroundOpacity: Background Opacity
            PrimaryFontColor: Primary Font Color
            SecondaryFontColor: Secondary Font color
            BaseFontSize: Base Font Size

            surbhi below...
            

            
        All options are optional.  Providing unspported options in strict mode will throw an exception.

        success: Success handler (called if main is successfully changed)
        unauth: Unauthorized handler (called when a user fails to login)
        conflict: Called if the client's version of the doq is out of date
        error: Called for any other errors
    */
    function changeMain(options, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        _db.postMain(options, { success: success, unauth: unauth, conflict: conflict, error: error }, strict);
    }

    /*
        Uploads an image with a data url
            dataURL: data URL for the image
            success: Called on success with the image's url as the argument
            unauth: See above
            error: See above
    */
    function uploadImage(dataURL, success, unauth, error) {
        asyncRequest(
            'POST',
            'FileUploadDataURL',
            { Token: TAG.Auth.getToken() },
            null,
            { success: convertToTextHandler(success), unauth: unauth, error: error },
            true,
            dataURL);

    }

    /////////////////////
    // DELETE REQUESTS //
    /////////////////////

    /*
        Delete a doq
            guid: GUID of the doq to delete
            success: See above
            error: See above
            unauth: See above
            conflict: See above
    */
    function deleteDoq(guid, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.deleteDoq(guid, { success: success, error: error, unauth: unauth, conflict: conflict });
    }

    /*
        Delete a linq
            guid: GUID of the linq to delete
            success: See above
            error: See above
            unauth: See above
            conflict: See above
    */
    function deleteLinq(guid, success, unauth, conflict, error) {
        _db = _db || new Worktop.Database();
        if (typeof guid !== "string" && guid && guid.Identifier) guid = guid.Identifier;
        _db.deleteLinq(guid, { success: success, error: error, unauth: unauth, conflict: conflict });
    }

    /////////////////////////
    // STATIC UTIL METHODS //
    /////////////////////////

    /*
        Converts a function expecting a doq to a handler for asyncRequest
        Returns a function that is the new handler to be used
            handler: A function that takes a doq as an argument
            error: Called if there is an error parsing the doq
    */
    function convertToDocHandler(handler, error) {
        return function (jqXHR, ajaxCall) {
            var doq;
            try {
                doq = new Worktop.Doq(jqXHR.responseText)
            } catch (exception) {
                util.safeCall(error, jqXHR, ajaxCall);
            }
            if (doq && (doq.Name || doq.Offset)) {
                util.safeCall(handler, doq, jqXHR);
            } else if (doq && doq[0]) {
                util.safeCall(handler, doq, jqXHR);
            } else if (doq) {
                util.safeCall(handler, [], jqXHR);
            }
        }
    }

    /*
        Converts a function expecting a string to a handler for asyncRequest
        Returns a functio that is the new handler to be used
            handler: A function that takes a string as an argument
    */
    function convertToTextHandler(handler) {
        return function (jqXHR, ajaxCall) {
            util.safeCall(handler, jqXHR.responseText);
        }
    }

    /*
        Converts a function expecting a string from the status text to a handler for asyncRequest
        Returns a functio that is the new handler to be used
            handler: A functio that takes a string as an argument
    */
    function convertToStatusHandler(handler) {
        return function (jqXHR, ajaxCall) {
            util.safeCall(handler, jqXHR.statusText);
        }
    }

    /*
      Makes an asynchronous request with the 'Type' parameter of the URL set to type
      and the rest of the parameters set according to the urlOptions dictionary.
      The body is populated from the bodyOptions dictionary using the server
      recognized format.
      Handlers is a dictionary of handler functions with the keys being success,
      error, or the error/success code number you want to handle, for example:
      handlers = {
        success: doOnSuccess();
        404: notFound();
        401: notAuthorized();
      }
      Any HTTP response is supported, see the issue tracker (redmine #205) for info on the status
      codes the server might respond with.  Handlers are called with the jqXHR object
      (http://api.jquery.com/jQuery.ajax/#jqXHR) as the first argument, and a function
      to redo the request as the second argument.  This can be useful if the user needs
      to authenticate and the request needs to be repeated.
        method: HTTP method (GET, POST, PUT, DELETE, HEAD)
        type: Type of the request (ex. CreateArtwork)
        urlOptions: key/value options to be put into the url string
        bodyOptions: key/value options to be put into the body of the request
        handlers: see above
        secure: if true the request uses https if the server requires it, otherwise uses http
        customBody: if set then the body of the request is set to this parameter, otherwise the body is created from bodyOptions
                    note that this will overwrite bodyoptions
        customAddress: Uses the specified address instead of the address stoed in _db

      Returns an object with the following methods:
        call: will redo the ajax request exactly as specified
        force: will redo the ajax request with Force=true to force an update if there is a conflict
    */
    function asyncRequest(method, type, urlOptions, bodyOptions, handlers, secure, customBody, customAddress) {
        if (!type) return false;

        handlers = handlers || {};
        urlOptions = urlOptions || {};
        bodyOptions = bodyOptions || {};

        // Temporary override to ignore all conflicts.
        urlOptions.Force = "true";

        // Set up the URL with options
        var url = (customAddress ? customAddress : (secure ? _db.getSecureURL() : _db.getURL())) + "/?Type=" + type;
        $.each(urlOptions, function (key, val) {
            url = url + "&" + key + "=" + escape(val);
        });

        // Set up body with options
        var boundary, body;
        if (Object.keys(bodyOptions).length) {
            boundary = findBoundary(bodyOptions);
            body = "Boundary:" + boundary;
            boundary = "\r\n" + boundary + "\r\n";
            $.each(bodyOptions, function (key, val) {
                body = body + boundary + key + ":" + escape(val);
            });
        }

        var ajaxCall = {
            call: function () {
                $.ajax({
                    type: method,
                    url: url,
                    cache: false,
                    dataType: "text",
                    async: true,
                    processData: false,
                    data: customBody || body,
                    success: function (data, textStatus, jqXHR) {
                        if (!handlers[jqXHR.status])
                            util.safeCall(handlers.success, jqXHR, ajaxCall);

                        util.safeCall(handlers[jqXHR.status], jqXHR, ajaxCall);
                    },
                    error: function (jqXHR, textStatus, errorThrown) {
                        if (!handlers[jqXHR.status])
                            util.safeCall(handlers.error, jqXHR, ajaxCall);

                        util.safeCall(handlers[jqXHR.status], jqXHR, ajaxCall);
                    }
                });
            },
            force: function () {
                url = url + '&Force=true';
                ajaxCall.call();
            },
            setToken: function (token) {
                url = removeToken(url);
                url = url + "&Token=" + token;
                return ajaxCall;
            }
        }
        ajaxCall.call();
    }

    function removeToken(url) {
        var start = url.indexOf('&Token=');
        var end = url.indexOf('&', start + 1);
        var substr = url.substring(start, end);
        return url.replace(substr, '');
    }

    /*
        Finds a boundary for the body of a request given key/value pairs of options
            bodyOptions: key/value pairs to be inserted to the body
        Returns an appropriate boundary that isn't found in the keys or values provided
    */
    function findBoundary(bodyOptions) {
        var boundary = "----";
        var found = false;
        do {
            found = false;
            boundary = boundary + "-";
            $.each(bodyOptions, function (key, val) {
                if (TAG.Util.contains(key, boundary)) {
                    found = true;
                    return false;
                }
                if (TAG.Util.contains(val, boundary)) {
                    found = true;
                    return false;
                }
            });
        } while (found);
        return boundary;
    }



    /////////////////////////////////////
    // ANYTHING BELOW MIGHT BE DELETED //
    /////////////////////////////////////

    function load(repo, callback, error) {
        // Load database
        if (!_db)
            _db = new Worktop.Database(repo);
        _db.getMain({
            success: function (main) {
                _main = main;
                callback(main)
            }, error: error
        });
        //// Populate
        //if (callback) { // not in use right now
        //    var doq;
        //    // use local xml when useServer = false
        //    var name = "Main";
        //    var url;
        //    if (_db.useServer)
        //        url = _db.getURL() + "/?Type=Doq&Name=" + name;
        //    else
        //        url = "testXML/" + name + ".xml";

        //    var request = $.ajax({
        //        url: url,
        //        cache: false, // forces browser to not cache the data
        //        dataType: "text",
        //        async: true,
        //        success: function (data) {

        //            if (request.responseText) {
        //                _main = new Worktop.Doq(request.responseText);

        //                callback();
        //            }

        //        },
        //        error: function (err) {
        //            return;
        //        }
        //    });
        //}
        //else {

        //    _main = _db.getDoqByName("Main");
        //}
    }

    function reloadMain(callback) {
        if (callback) {
            var doq;
            var name = "Main";
            var url;
            if (_db.useServer)
                url = _db.getURL() + "/?Type=Doq&Name=" + name;
            else
                url = "testXML/" + name + ".xml";

            var request = $.ajax({
                url: url,
                cache: false, // forces browser to not cache the data
                dataType: "text",
                async: true,
                success: function (data) {
                    if (request.responseText) {
                        _main = new Worktop.Doq(request.responseText);
                        callback();
                    } else {
                    }
                },
                error: function (err) {
                    return;
                }
            });
        }
        else {
            _main = _db.getDoqByName("Main");
        }
    }

    function checkSetting(key, onSuccess) {
        if (onSuccess) {
            _db.getMain({
                success: function (main) {
                    onSuccess(main.Metadata['Setting_' + key]);
                }
            });
        } else {
            return _main.Metadata['Setting_' + key];
        }
    }

    function isExhibitionDirty() {
        return _exhibitionDirty;
    }

    function setExhibitionDirty(value) {
        _exhibitionDirty = value;
    }

    function getMuseumName() {
        return _main.Metadata["MuseumName"];
    }

    function getLocked() {
        return _main.Metadata["Locked"];
    }

    function getMuseumOverlayColor() {
        return _main.Metadata["OverlayColor"] || '000000';
    }

    function getMuseumOverlayTransparency() {
        return _main.Metadata["OverlayTransparency"];
    }

    function getMuseumLoc() {
        return _main.Metadata["MuseumLoc"];
    }

    function getMuseumInfo() {
        return _main.Metadata["MuseumInfo"];
    }

    /////////
    function getMuseumBackgroundColor() {
        return _main.Metadata["BackgroundColor"] || '000000';
    }

    function getMuseumBackgroundOpacity() {
        return _main.Metadata["BackgroundOpacity"] || '70'; // '0' is true
    }

    function getMuseumPrimaryFontColor() {
        return _main.Metadata["PrimaryFontColor"] || '#FFFFFF';
    }

    function getMuseumSecondaryFontColor() {
        return _main.Metadata["SecondaryFontColor"] || '#FFFFFF';
    }

    function getMuseumFontFamily() {
        return _main.Metadata["FontFamily"] || 'Segoe UI Light';
    }
    //////////
    function getCustomFont() {
        return TAG.Worktop.Database.fixFontFilePath(_main.Metadata["Font"]);
    }

    function getOptionalFeatures() {
        return _main.Metadata["OptionalFeatures"];
    }

    function getBaseFontSize() {
        return _main.Metadata["BaseFontSize"] || "1.77";
    }

    function getStartPageBackground() {
        return TAG.Worktop.Database.fixPath(_main.Metadata["BackgroundImage"]);
    }

    function getMuseumLogo() {
        return TAG.Worktop.Database.fixPath(_main.Metadata["Icon"]);
    }

    function getLogoBackgroundColor() {
        return _main.Metadata["IconColor"];
    }

    function getOverlayColor() {
        return _main.Metadata["OverlayColor"];
    }
    function getOverlayTransparency() {
        return _main.Metadata["OverlayTransparency"];
    }

    function getIdleTimerDuration() {
        return _main.Metadata["IdleTimerDuration"] || '2';
    }

    function getMainGuid() {
        return _main.Identifier;
    }

    function getExhibitionBackgroundImage() {
        // return getExhibitions(true)[0].Metadata["BackgroundImage"];
    }

    // 
    function getDoqXML(guid, callback) {
        if (callback) {
            _db.getDoqByGUID(guid, function () {
                callback(getXML(guid));
            });
        } else {
            _db.getDoqByGUID(guid);
            return getXML(guid);
        }
    }

    // get doq links using GUID - see worktop.database.js
    function getDoqLinqs(guid, callback) {
        if (callback) {
            _db.getDoqLinqsByGUID(guid, callback);
        } else
            return _db.getDoqLinqsByGUID(guid);
    }

    function getLinqXML(guid, callback) {
        if (callback) {
            var linq;
            if (_db.useServer)
                url = _db.getURL() + "/?Type=Linq&Guid=" + guid;
            else
                url = "testXML/" + guid + ".xml";

            var request = $.ajax({
                url: url,
                dataType: "text",
                cache: false, // forces browser to not cache the data
                async: true,
                success: function () {
                    if (request.responseText) {
                        try {
                            new Worktop.Doq(request.responseText);
                            var xmlToParse = getXML(guid);
                            var xmlHotspot = $.parseXML(xmlToParse);
                            callback(false, xmlHotspot);
                        }
                        catch (err) {
                            console.log("error in getLinqXML: " + err);
                            getLinqXML(guid, callback);
                        }
                    }
                }
            });

            request.fail(function (request, error) {
                console.log(error);
            });

        }
        else {

            _db.getLinqByGUID(guid);
            return getXML(guid);
        }

    }

    // helper function for sorting a specified set
    function sortHelper(toSort) {
        toSort.sort(function (a, b) {
            if (a.Name < b.Name) {
                return -1;
            } else if (a.Name > b.Name) {
                return 1;
            } else {
                return 0;
            }
        });
    }

    // get all exhibitions
    //function getExhibitions(callback) {
    //    _db.getExhibitions({ success: callback });
    //    return;
    //    if (_exhibitionDirty) {
    //        if (callback) {
    //            var exhibits;
    //            var guid = _main.Identifier;
    //            var doq, url;
    //            if (_db.useServer)
    //                url = _db.getURL() + "/?Type=DoqsInFolder&Guid=" + guid;
    //            else
    //                url = "testXML/" + guid + "_Content.xml";


    //            var request = $.ajax({
    //                url: url,
    //                dataType: "text",
    //                cache: false, // forces browser to not cache the data
    //                async: true,
    //                success: function (data) {
    //                    _exhibitions = [];
    //                    if (request.responseText) {
    //                        try {
    //                            exhibits = new Worktop.Doq(request.responseText);
    //                            if (exhibits[0]) {
    //                                $.each(exhibits, function (i, e) {
    //                                    if (e.Metadata.Type == "Exhibit") {
    //                                        _exhibitions.push(e);
    //                                    }
    //                                });
    //                            }
    //                            _exhibitionDirty = false;
    //                            sortHelper(_exhibitions);
    //                            callback(_exhibitions);
    //                        }
    //                        catch (err) {
    //                            console.log("error in getExhibitions: " + err);
    //                            callback([]);
    //                        }
    //                    } else {
    //                        callback([]);
    //                    }
    //                },
    //                error: function (err) {
    //                    console.log("ajax fails in getExhibition");
    //                }
    //            });
    //        } else {
    //               _exhibitions = [];
    //                var exhibits = _db.getDoqsInFolderByGUID(_main.Identifier);
    //                if (exhibits[0]) {
    //                    $.each(exhibits, function (i, e) {
    //                        if (e.Metadata.Type == "Exhibit") {
    //                            _exhibitions.push(e);
    //                        }
    //                    });
    //                }

    //                sortHelper(_exhibitions);
    //            return _exhibitions;
    //        }
    //    } else { // if has cache
    //        if (callback) {
    //            sortHelper(_exhibitions);
    //            callback(_exhibitions);

    //        } else {
    //            sortHelper(_exhibitions);
    //            return _exhibitions;
    //        }
    //    }

    //}

    /**
     * Soft delete a hotspot by deleting both the hotspot linq and doq files
     */
    function deleteHotspot(linqID, doqID, onSuccess, onFail, onError) {
        // _db.deleteLinq(linqID);
        var url = _db.getSecureURL() + "/?Type=Linq&Guid=" + linqID + "&token=" + TAG.Auth.getToken();

        var request = $.ajax({
            type: 'DELETE',
            url: url,
            async: true,
            success: function (data) {
                url = _db.getSecureURL() + "/?Type=Doq&Guid=" + doqID + "&token=" + TAG.Auth.getToken();

                $.ajax({
                    type: 'DELETE',
                    url: url,
                    async: true,
                    success: function (data) {
                        onSuccess && onSuccess();
                    },
                    error: function () {
                        if (request.statusText === "Unauthorized")
                            checkAuth(function () { deleteHotspot(linqID, doqID, onSuccess, onFail, onError); }, onFail);
                        else
                            onError && onError();
                    },
                });
            },
            error: function () {
                if (request.statusText === "Unauthorized")
                    checkAuth(function () { deleteHotspot(linqID, doqID, onSuccess, onFail, onError); }, onFail);
                else
                    onError && onError();
            }
        });
    }

    // get URL - see worktop.database.js
    function getURL() {
        return _db.getURL();
    }
    // get URL - see worktop.database.js
    function getSecureURL() {
        return _db.getSecureURL();
    }

    function getFileURL() {
        return _db.getFileURL();
    }

    // set URL - see worktop.databse.js
    function setURL(url) {
        _db.setURL(url);
    }

    // create a new exhibition
    function createNewExhibition(onSuccess, onFail, onError) {
        _exhibitionDirty = true;
        if (onSuccess) {
            var request = $.ajax({
                url: _db.getSecureURL() + "/?Type=CreateExhibition&Guid=" + TAG.Worktop.Database.getCreatorID() + "&token=" + TAG.Auth.getToken(),
                type: "PUT",
                dataType: "text",
                async: true,
                success: function (data) {
                    var result;
                    if (request.responseText) {
                        try {
                            result = new Worktop.Doq(request.responseText);
                            onSuccess && onSuccess(result);
                        }
                        catch (err) {
                            onError && onError();
                        }
                    } else {
                        checkAuth(function () { createNewExhibition(onSuccess, onFail, onError); }, onFail);
                    }
                },
                error: function () {
                    if (request.statusText === "Unauthorized")
                        checkAuth(function () { createNewExhibition(onSuccess, onFail, onError); }, onFail);
                    else
                        onError && onError();
                }
            });
        }
        else {
            _db.createNewExhibition();
        }
    }

    // Non-async version depricated, always give an onSuccess function
    //function createTour(onSuccess, onFail, onError) {
    //    _db.putTour(null, { success: onSuccess, unauth: onFail, error: onError }, true);
    //    return;
    //    setDirty("Tour");
    //    if (onSuccess) {
    //        _db.createTour(onSuccess, onFail, onError);
    //    } else {
    //        return _db.createTour();
    //    }
    //}

    // get all artwork
    function getAllArtworks(callback) {
        _db.getArtworks({ success: callback });
        return;
        _artworkDirty = true;
        if (callback) {

            // TODO: will run if(_artworkDirty){} immediately 
            if (!_db.isUseServer()) {

                var request = $.ajax({
                    url: 'testXML/AllArtworks.xml',
                    dataType: "text",
                    cache: false, // forces browser to not cache the data
                    async: true,
                    success: function () {
                        if (request.responseText) {
                            _artworks = new Worktop.Doq(request.responseText);
                            callback(_artworks);
                        }

                    },
                    error: function (err) {
                    }
                });
            }

            if (_artworkDirty) {
                var doq;
                var url = getURL() + "/?Type=DoqsInFolder&Name=Artworks";

                var request = $.ajax({
                    url: url,
                    dataType: "text",
                    cache: false, // forces browser to not cache the data
                    async: true,
                    success: function () {
                        if (request.responseText) {
                            _artworks = new Worktop.Doq(request.responseText);
                            _artworkDirty = false;
                            callback(_artworks);
                        }
                    },
                    error: function (err) {
                    }
                });
            } else {
                callback(_artworks);
            }
        } else {

            if (!_db.isUseServer()) {

                var request = $.ajax({
                    url: 'testXML/AllArtworks.xml',
                    dataType: "text",
                    cache: false, // forces browser to not cache the data
                    async: false,
                    error: function (err) {
                        return;
                    }
                });
                if (request.responseText) {
                    try {
                        _artworks = new Worktop.Doq(request.responseText);
                    }
                    catch (err) {
                        console.log("error in getAllArtworks: " + err);
                        getAllArtworks(callback);
                    }
                }
                return _artworks;
            }

            if (_artworkDirty) {
                var doq;
                var url = getURL() + "/?Type=DoqsInFolder&Name=Artworks";

                var request = $.ajax({
                    url: url,
                    dataType: "text",
                    cache: false, // forces browser to not cache the data
                    async: false,
                    error: function (err) {
                        return;
                    }
                });

                if (request.responseText) {
                    try {
                        _artworks = new Worktop.Doq(request.responseText);
                    }
                    catch (err) {
                        console.log("error in getAllArtworks: " + err.message);
                        getAllArtworks(callback);
                    }
                }
                _artworkDirty = false;
            }
            return _artworks;
        }
    }

    // get a specified doq by its GUID
    function getDoqByGuid(guid, flag, callback, error) {
        //any reason why this wasn't returning anything before?
        if (callback) {
            var url;
            if (_db.useServer)
                url = _db.getURL() + "/?Type=Doq&Guid=" + guid;
            else
                url = "testXML/" + guid + ".xml";

            var request = $.ajax({
                url: url,
                dataType: "text",
                cache: false, // forces browser to not cache the data
                async: true,
                success: function () {
                    if (request.responseText) {
                        //try {
                        var newDoq = new Worktop.Doq(request.responseText);
                        callback(newDoq, flag);
                        //}
                        //catch (err) {
                        //console.log("bad xml response in getDoqByGuid: " + err.message);
                        // getDoqByGuid(guid, flag, callback);
                        //}
                    }
                },
                error: function (err) {
                    console.log(err);
                    error && error();
                }
            });
        }
        else
            return _db.getDoqByGUID(guid);
    }

    // get doq by name - see Worktop.Database.js
    function getDoqByName(name) {
        return _db.getDoqByName(name);
    }

    function updateCache(guid, xml) {

        _cacheXML[guid] = xml;
    }

    function getXML(guid) {
        return _cacheXML[guid];
    }

    /* 
     * The pushXML(...) method takes an XML object and a GUID. It then parses the XML
     * object, converts it into text, and then sends the text-based XML to the server.
     * If the XML was valid and accepted by the server, the method success() is called.
     */
    function pushXML(data, guid, type, onSuccess, onFail, onError) {

        setDirty(type);

        var xmlstr = "";
        if (typeof data == 'string') {
            xmlstr = data;
        } else {
            xmlstr = parseXML(data.childNodes[0], xmlstr);
        }
        var url = _db.getSecureURL() + "/?Type=Doq&Guid=" + guid + "&token=" + TAG.Auth.getToken();

        var isAsync = !!onSuccess;

        $.ajax({
            type: 'POST',
            url: url,
            data: xmlstr,
            async: isAsync,
            success: function () {
                onSuccess && onSuccess();
            },
            error: function (err, err2, status) {
                if ($("#dialogOverlay").length > 0) {
                    $("#dialogOverlay").hide();
                }
                if (status === "Unauthorized") {
                    checkAuth(function () { pushXML(data, guid, type, onSuccess, onFail, onError); }, onFail);
                }
                else
                    onError && onError();
            },
            dataType: 'text'
        });
    }

    /* 
 * The pushLinq(...) method takes an XML object and a GUID. It then parses the XML
 * object, converts it into text, and then sends the text-based XML to the server.
 * If the XML was valid and accepted by the server, the method success() is called.
 */
    function pushLinq(data, guid, type, onSuccess, onFail, onError) {

        setDirty(type);

        var xmlstr = "";
        if (typeof data == 'string') {
            xmlstr = data;
        } else {
            xmlstr = parseXML(data.childNodes[0], xmlstr);
        }
        var url = _db.getSecureURL() + "/?Type=Linq&Guid=" + guid + "&token=" + TAG.Auth.getToken();

        $.ajax({
            type: 'POST',
            url: url,
            data: xmlstr,
            async: false,
            success: function () {
                onSuccess && onSuccess();
            },
            error: function (err, err2, status) {
                if (status === "Unauthorized")
                    checkAuth(function () { pushLinq(data, guid, type, onSuccess, onFail, onError); }, onFail);
                else
                    onError && onError();
            },
            dataType: 'text'
        });
    }
    /* 
     * The parse(...) method a string   . It then parses the XML
     * object, converts it into text, and then sends the text-based XML to the server.
     * If the XML was valid and accepted by the server, the method success() is called.
     */
    function parseXML(data, xmlstring) {
        if (data.tagName) {
            xmlstring = xmlstring.concat("<" + data.tagName);
            for (var i = data.attributes.length - 1; i >= 0; i--) {
                xmlstring = xmlstring.concat(" " + data.attributes[i].nodeName + "=\"" + data.attributes[i].nodeValue + "\"");
            }
            xmlstring = xmlstring.concat(">");

            for (var i = 0; i < data.childNodes.length; i++) {
                xmlstring = parseXML(data.childNodes[i], xmlstring);
            }

            xmlstring = xmlstring.concat("</" + data.tagName + ">");
        }
        else {
            xmlstring = xmlstring.concat(data.data);
        }
        return xmlstring;
    }

    function createEmptyDoq(getMainCreatorID) {
        return _db.createEmptyDoq(_main.CreatorID);
    }

    function createLinq(guid1, guid2) {
        return _db.createLinq();
    }

    // create image hotspot
    //function createHotspot(creatorID, artworkGUID, onSuccess, onFail, onError) {
    //    if (onSuccess) {
    //        var url = _db.getSecureURL() + "/?Type=CreateHotspot&Guid=" + creatorID + "&Guid2=" + artworkGUID + "&token=" + LADS.Auth.getToken();

    //        var request = $.ajax({
    //            url: url,
    //            type: "PUT",
    //            dataType: "text",
    //            async: true,
    //            success: function () {
    //                onSuccess && onSuccess(true, request.responseXML);
    //            },
    //            error: function () {
    //                if (request.statusText === "Unauthorized")
    //                    checkAuth(function () { createHotspot(creatorID, artworkGUID, onSuccess, onFail, onError); }, onFail);
    //                else
    //                    onError && onError();
    //            },
    //        });

    //    }
    //    else
    //    return _db.createHotspot(creatorID, artworkGUID, onSuccess, onFail, onError);
    //}

    function getCreatorID() {
        return _main.CreatorID;
    }

    // get parent doq
    function parentDoq(guid1, guid2) {
        var url = _db.getURL() + "/?Type=AddParent&Guid=" + guid1 + "&Guid2=" + guid2;

        $.ajax({
            type: 'POST',
            url: url,
            dataType: 'text'
        });

        setDirty("Artwork");
    }

    // set artwork dirty 
    function setArtworkDirty() {
        _artworkDirty = true;
    }

    // bool for dirty artwork
    function isArtworkDirty() {
        return _artworkDirty;
    }

    // upload image
    //function uploadImage(dataurl, onSuccess, onFail, onError) {
    //    var location = _db.uploadImage(dataurl, getCreatorID(), onSuccess, onFail, onError);
    //    return location;
    //}

    function checkAuth(onSuccess, onCancel) {
        TAG.Auth.authenticate(onSuccess, onCancel);
    }

    // get all tours
    function getAllTours(callback) {
        _db.getTours({ success: callback });
        return;
        // bmost: Temporarily making it so that tours don't get cached.
        // If a curator changes a tour on one machine, other machines
        // will have the old tour cached.
        _tourDirty = true;
        if (_tourDirty) {
            if (callback) {
                var name = "Tour";
                var doq, tours;
                _tours = [];
                var url = _db.getURL() + "/?Type=DoqsInFolder&Name=" + name;
                var request = $.ajax({
                    url: url,
                    dataType: "text",
                    cache: false, // forces browser to not cache the data
                    async: true,
                    success: function (data) {
                        _tours = [];
                        if (request.responseText) {
                            try {
                                tours = new Worktop.Doq(request.responseText);

                                if (tours && tours[0]) {
                                    $.each(tours, function (i, t) {
                                        _tours.push(t);
                                    });
                                    _tourDirty = false;
                                } else {
                                    _tourDirty = true;
                                }
                                sortHelper(_tours);
                                callback(_tours);
                            } catch (e) {
                                callback([]);
                            }
                        }
                    },
                    error: function (err) {
                        console.log("ajax fail in getAlltours");
                    }
                });

            }
            else {
                _tours = [];
                var tours = _db.getDoqsInFolderByName("Tour");
                if (tours && tours[0]) {
                    $.each(tours, function (i, t) {
                        _tours.push(t);
                    });
                }
                sortHelper(_tours);
                return _tours;
            }
        } else {
            if (callback) {
                callback(_tours);
            } else {
                return _tours;
            }
        }
    }

    function getAllFeedback(onSuccess, onError) {
        _db.getFeedback({ success: onSuccess, error: onError });
        return;
        var url = _db.getURL() + "/?Type=DoqsInFolder&Name=Feedback";
        var request = $.ajax({
            url: url,
            dataType: "text",
            cache: false, // forces browser to not cache the data
            async: true,
            success: function (data) {
                if (request.responseText) {
                    try {
                        feedback = new Worktop.Doq(request.responseText);
                        onSuccess(feedback[0] ? feedback : []);
                    } catch (e) {
                        console.log(e.message);
                        onError && onError();
                    }
                }
            },
            error: function (err) {
                console.log("ajax fail in getAllFeedback");
                onError && onError();
            }
        });
    }

    function testIp(onSuccess, onError) {
        var name = "Tour";
        var doq, tours;
        _tours = [];
        var url = _db.getURL() + "/?Type=DoqsInFolder&Name=" + name;
        var request = $.ajax({
            url: url,
            dataType: "text",
            cache: false, // forces browser to not cache the data
            async: true,
            success: function (data) {
                onSuccess();
            },
            error: function (err) {
                onError();
            }
        });

    }



    //function checkToken(token, onSuccess, onFail, onError) {
    //    var url = _db.getSecureURL() + "/?Type=CheckToken&Name=" + token;
    //    var request = $.ajax({
    //        type: 'HEAD',
    //        url: url,
    //        async: true,
    //        cache: false,
    //        success: function () {
    //            if (request.statusText === "OK") {
    //                onSuccess && onSuccess();
    //            }
    //            else {
    //                onFail && onFail();
    //            }
    //        },
    //        error: function (err) {
    //            if (request.statusText === "Unauthorized") {
    //                onFail && onFail();
    //            } else {
    //                onError && onError();
    //            }
    //        }
    //    });
    //}

    // use this at some point to validate that the inputted ip address is actually the ip address for a TAG server
    // we can have an array of valid ips on the server
    function validateIp(ip, onSuccess, onError) {
        var url = _db.getURL() + "/?Type=IP&Name=" + ip; // type=IP -- deal with this in server.cs ?
        var request = $.ajax({
            type: 'HEAD',
            url: url,
            async: true,
            password: password,
            success: function () {
                if (request.statusText === "Authorized") {
                    onSuccess();
                }
                else {
                    onError();
                }
            },
            error: function (err) {
                if (request.statusText === "Authorized") {
                    onSuccess();
                }
                else {
                    onError();
                }
            }
        });
    }

    /*
        Change the server to newAddress
        If oldPass is supplied then authoring password for the old
        server is checked
        onConnect is called on successful connection to the new server
        onFail is called otherwise
        After this function is successful everything is updated to use the new server,
        but the current page will need to be reloaded
    */
    function changeServer(newAddress, oldPass, onConnect, onFail) {
        newAddress = TAG.Util.formatAddress(newAddress);
        if (oldPass) {
            getSalt(function (salt) {
                getAuth(oldPass, salt, checkServer, onFail, onFail);
            }, onFail);
        } else {
            checkServer();
        }
        function checkServer() {
            var connectionTimeout,
                timedOut;

            asyncRequest('GET', 'CheckVersion', null, null, { success: success, error: error }, false, null, 'http://' + newAddress + ':8080');
            function success(jqXHR, ajaxCall) {
                if(!timedOut) {
                    clearTimeout(connectionTimeout);
                    var version = jqXHR.statusText;
                    var mainID = jqXHR.responseText;
                    localStorage.ip = newAddress;
                    _db = new Worktop.Database(mainID);
                    onConnect && onConnect();
                }
            }
            function error() {
                if(!timedOut) {
                    clearTimeout(connectionTimeout);
                    onFail && onFail();
                }
            }

            connectionTimeout = setTimeout(function() {
                timedOut = true;
                onFail && onFail();
            }, 10000); // 10 second timeout to show error message
        }
    }

    // set specified screen to dirty
    function setDirty(type) {
        switch (type) {
            case "Exhibition":
            case "Exhibitions":
                _exhibitionDirty = true;
                break;
            case "Artwork":
                _artworkDirty = true;
                break;
            case "Tour":
                _tourDirty = true;
                break;
        }
    }

    function hash(n) {
        return ((0x0000FFFF & n) << 16) + ((0xFFFF0000 & n) >> 16);
    }

    function fixPath(path) {
        if (path) {
            if (path.indexOf('blob:') !== -1) {
                return path;
            } else if (path.indexOf('http') !== -1) {
                path = path.replace(/http.?.?\/\/[^\/]*/, '');
            }
            if (path.indexOf('/') !== 0) {
                path = '/' + path;
            }
            return _db.getFileURL() + path;
        }
    }

    function fixFontFilePath(path) {
        if (path) {
            if (path.indexOf('/') !== 0) path = '/' + path;
            return path;
        }
    }

    function deprecated(fn) {
        var name = "";
        try {
            name = fn.toString().split('function ')[1].split('(')[0].trim() + ' ';
        } catch (exception) {
            console.log(exception);
        }
        return function () {
            console.log("Warning: Call to deprecated function " + name + "in TAG.Worktop.Database");
            var passedArgs = [];
            for (var i = 0; i < arguments.length; i++) {
                passedArgs[i] = arguments[i];
            }
            return fn.apply(null, passedArgs);
        }
    }
})();
;
TAG.Util.makeNamespace("TAG.AnnotatedImage");

/**
 * Representation of deepzoom image with associated media. Contains
 * touch handlers and a method for creating associated media objects.
 * @class TAG.AnnotatedImage
 * @constructor
 * @param {Object} options         some options for the artwork and assoc media
 * @return {Object}                some public methods and variables
 */

TAG.AnnotatedImage = function (options) { // rootElt, doq, split, callback, shouldNotLoadHotspots) {
    "use strict";
    

    var // input options
        root = options.root,           // root of the artwork viewing page
        doq = options.doq,            // doq for the artwork
        callback = options.callback,       // called after associated media are retrieved from server
        noMedia = options.noMedia,        // should we not have assoc media? (set to true in artwork editor)

        // constants
        FIX_PATH = TAG.Worktop.Database.fixPath,   // prepend server address to given path

        // misc initialized variables

        artworkName = doq.Name,        // artwork's title
        associatedMedia = { guids: [] },   // object of associated media objects for this artwork, keyed by media GUID;
                                           // also contains an array of GUIDs for cleaner iteration
        toManip = dzManip,         // media to manipulate, i.e. artwork or associated media
        rootHeight = $('#tagRoot').height(), //tag root height
        rootWidth = $('#tagRoot').width(),  //total tag root width for manipulation (use root.width() instead for things that matter for splitscreen styling)
        outerContainerPivot = {
            x: rootHeight / 2,
            y: rootWidth / 2
        },
        doManipulation = true,      //used in RLH to prevent manipulation of image in certain cases
        aspectRatio = 1, //TODO - how to find this
        artworkFrozen = false,
        descscroll = false,
        scrollingMedia = false,
        disableZoomRLH = options.disableZoom,

        // misc uninitialized variables
        viewerelt,
        viewer,
        assetCanvas;


    var xFadeOffset;

    // get things rolling
    init();

    return {
        getAssociatedMedia: getAssociatedMedia,
        unload: unload,
        dzManip: dzManip,
        dzScroll: dzScroll,
        openArtwork: openArtwork,
        addAnimateHandler: addAnimateHandler,
        getToManip: getToManip,
        getMediaPivot: getMediaPivot,
        dzManipPreprocessing: dzManipPreprocessing,
        viewer: viewer,
        panToPoint: panToPoint,
        isInViewportBounds: isInViewportBounds,
        isInImageBounds: isInImageBounds,
        returnElementToBounds: returnElementToBounds,
        locationOf: locationOf,
        centerElement: centerElement,
        pointFromPixel: pointFromPixel,
        createStartingPoint: createStartingPoint,
        scroll: scroll,
        pauseManip: pauseManip,
        restartManip: restartManip,
        updateOverlay: updateOverlay,
        addOverlay: addOverlay,
        removeOverlay: removeOverlay,
        loadAssociatedMedia: loadAssociatedMedia,
        getOverlayCoordinates: getOverlayCoordinates,
        freezeArtwork: freezeArtwork,
        unfreezeArtwork: unfreezeArtwork,
        initZoom: initZoom
    };


    /**
     * Return applicable manipulation method
     * @method getToManip
     * @return {Object}     manipulation method object
     */
    function getToManip() {
        return toManip;   
    }


    /**
     * Return the dimensions of the active associated media or artwork
     * @method getMediaPivot
     * @return {Object}     object with dimensions
     */
    function getMediaPivot() {
        return outerContainerPivot;   
    }


    /**
     * Return list of associatedMedia
     * @method getAssociatedMedia
     * @return {Object}     associated media object
     */
    function getAssociatedMedia() {
        return associatedMedia;
    }

    /**
     * Open the deepzoom image
     * @method openArtwork
     * @param {doq} doq           artwork doq to open // TODO this shouldn't be necessary -- we know the artwork...
     * @return {Boolean}          whether opening was successful
     */
    function openArtwork(doq) {
        if(!viewer || !doq || !doq.Metadata || !doq.Metadata.DeepZoom) {
            //debugger;
            console.log("ERROR IN openDZI");
            return false;
        }
        viewer.openDzi(FIX_PATH(doq.Metadata.DeepZoom));
        return true;
    }

    /**
     * Wrapper around Seadragon.Drawer.updateOverlay; moves an HTML element "overlay."
     * Used mostly in conjunction with hotspot circles (this function is currently
     * only called from ArtworkEditor.js)
     * @method updateOverlay
     * @param {HTML element} element                   the overlay element to move
     * @param {Seadragon.OverlayPlacement} placement   the new placement of the overlay
     */
    function updateOverlay(element, placement) {
        var $elt = $(element),
            top  = parseFloat($elt.css('top')),
            left = parseFloat($elt.css('left'));
        if (top && left) { // TODO is this check necessary?
            viewer.drawer.updateOverlay(element, viewer.viewport.pointFromPixel(new Seadragon.Point(left, top)), placement);
        }
    }

    /**
     * Wrapper around Seadragon.Drawer.addOverlay; adds an HTML overlay to the seadragon
     * canvas. Currently only used in ArtworkEditor.js.
     * @method addOverlay
     * @param {HTML element} element                   the overlay element to add
     * @param {Seadragon.Point} point                  the point at which to add the overlay
     * @param {Seadragon.OverlayPlacement} placement   the placement at the given point
     */
    function addOverlay(element, point, placement) {
        if (!viewer.isOpen()) {
            viewer.addEventListener('open', function () {
                viewer.drawer.addOverlay(element, point, placement);
                viewer.drawer.updateOverlay(element, point, placement);
            });
        } else {
            viewer.drawer.addOverlay(element, point, placement);
            viewer.drawer.updateOverlay(element, point, placement);
        }
    }

    /**
     * Wrapper around Seadragon.Drawer.removeOverlay. Removes an HTML overlay from the seadragon
     * canvas.
     * @method removeOverlay
     * @param {HTML element}       the ovlerlay element to remove
     */
    function removeOverlay(element) {
        if (!viewer.isOpen()) {
            viewer.addEventListener('open', function () {
                viewer.drawer.removeOverlay(element);
            });
        } else {
            viewer.drawer.removeOverlay(element);
        }
    };

    /**
     * Unloads the seadragon viewer
     * @method unload
     */
    function unload() {
        viewer && viewer.unload();
    }

    /**
     * When the artwork is active, sets the manipulation method and dimensions for the active container
     * @method dzManipPreprocessing
     */
    function dzManipPreprocessing() {
        outerContainerPivot = {
            x: root.width()/ 2,//+ root.offset().left,
            y: root.height() / 2// + root.offset().top
        };
        toManip = dzManip;
        TAG.Util.IdleTimer.restartTimer();
    }

    /**
     * Manipulation/drag handler for makeManipulatable on the deepzoom image
     * @method dzManip
     * @param {Object} res             object containing hammer event info
     */

    function dzManip(res) {

        if (disableZoomRLH) { return; }

        var scale = res.scale,
            trans = res.translation,
            pivot = res.pivot;

        dzManipPreprocessing();

        if (!artworkFrozen) {
            var pivotRel = viewer.viewport.pointFromPixel(new Seadragon.Point(pivot.x, pivot.y));
            var piv = {
                x: pivotRel.x,
                y: pivotRel.y
            };
            var transRel = viewer.viewport.deltaPointsFromPixels(new Seadragon.Point(trans.x, trans.y));
            if (xFadeOffset) {
                
                // testing 
                //var zoom = viewer.viewport.getZoom(true);

                //var correctionRel = new Seadragon.Point(xFadeOffset.x * 1/zoom, xFadeOffset.y * 1/zoom) // ver 1
                //var correctionRel = new Seadragon.Point(xFadeOffset.x, xFadeOffset.y); // ver 2

                //var correctionAbs = viewer.viewport.pixelFromPoint(correctionRel);
                
                //var pivotCorrectedRel = new Seadragon.Point(pivotRel.x - correctionRel.x, pivotRel.y - correctionRel.y);

                //var pivotCorrectedAbs = viewer.viewport.pixelFromPoint(pivotCorrectedRel); // ver 1
                //var pivotCorrectedAbs = new Seadragon.Point(pivot.x + correctionAbs.x, pivot.y + correctionAbs.y); // ver 2
                //var pivotFinal = viewer.viewport.pointFromPixel(pivotCorrectedAbs);

                // begin diagnostic markers
                /*
                if (!correctedMarker) {
                    correctedMarker = $(document.createElement('div'));
                    correctedMarker.css({
                        width: "5px",
                        height: "5px",
                        background: "rgb(0, 0, 255)",
                        position: "absolute",
                        "z-index": "999999"
                    });
                    $('body').append(correctedMarker);
                }
                correctedMarker.css({
                    top: pivotCorrectedAbs.y + "px",
                    left: pivotCorrectedAbs.x + "px"
                });

                if (!pivotMarker) {
                    pivotMarker = $(document.createElement('div'));
                    pivotMarker.css({
                        width: "5px",
                        height: "5px",
                        background: "rgb(255, 0, 0)",
                        position: "absolute",
                        "z-index": "999999"
                    });
                    $('body').append(pivotMarker);
                }
                pivotMarker.css({
                    top: pivot.y + "px",
                    left: pivot.x + "px"
                });
                */
                // end diagnostic markers

                // hacky fix - can't pan while you zoom otherwise stuff blows up
                if (scale !== 1) {
                    viewer.viewport.zoomBy(scale, piv, false);
                } else {
                    viewer.viewport.panBy(transRel, false);
                }
            } else {
                // begin diagnostic markers
                /*
                if (!pivotMarker) {
                    pivotMarker = $(document.createElement('div'));
                    pivotMarker.css({
                        width: "5px",
                        height: "5px",
                        background: "rgb(255, 0, 0)",
                        position: "absolute",
                        "z-index": "999999"
                    });
                    $('body').append(pivotMarker);
                }
                pivotMarker.css({
                    top: pivot.y + "px",
                    left: pivot.x + "px"
                });
                */
                // end diagnostic markers
                viewer.viewport.zoomBy(scale, pivotRel, false);
                viewer.viewport.panBy(transRel, false);
            }
            
            viewer.viewport.applyConstraints();
        }
    }

    function freezeArtwork() {
        artworkFrozen = true;
    }

    function unfreezeArtwork() {
        artworkFrozen = false;
    }
    
    /**
     * Scroll/pinch-zoom handler for makeManipulatable on the deepzoom image
     * @method dzScroll
     * @param {Number} scale          scale factor
     * @param {Object} pivot          location of event (x,y)
     */
    function dzScroll(scale, pivot) {
        if (!disableZoomRLH) {
            dzManip({
                scale: scale,
                translation: {
                    x: 0,
                    y: 0
                },
                pivot: pivot
            });
        }
    }

    /**
    * Reset the deepzoom image (center, zoom out) if an element is not currently visible in the viewport.
    * Used in rich location history.
    * @method panToPoint
    */
    function panToPoint(element) {
        viewer.viewport && function () {
            var ycoord = parseFloat($(element).css('top')) + parseFloat($(element).css('height'));
            var xcoord = parseFloat($(element).css('left')) + 0.5 * parseFloat($(element).css('width'));
            var point = viewer.viewport.pointFromPixel(new Seadragon.Point(xcoord, ycoord));
            var bounds = viewer.viewport.getBounds();
            //if the point is not visible in the current bounds
            if (!((point.x < bounds.getBottomRight().x && point.x > bounds.getTopLeft().x)
                && (point.y < bounds.getBottomRight().y && point.y > bounds.getTopLeft().y))) {
                viewer.viewport.panTo(viewer.viewport.getHomeCenter());
                viewer.viewport.zoomTo(.8 * viewer.viewport.getHomeZoom());
            }
        }();
    };

    /**
    * Sets up the annotated image to allow zoom on double click.  Used in RLH
    * @method initZoom
    */
    function initZoom() {
        if (!disableZoomRLH) {
            viewerelt && function () {
                viewerelt.on('dblclick', function () {
                    zoomToPoint();
                });
            }();
        }
    }

    /**
    * Zooms into the deepzoom image.  Used when double-clicking on a map in rlh.
    * @method zoomToPoint()
    */
    function zoomToPoint() { //TODO zoom to where the mouse is
        viewer.viewport.zoomBy(2);
    }

    /**
    * Returns whether an element is in the viewport's bounds (including a buffer of 10 pixels)
    * Used in rich location history.
    * @method isInViewportBounds
    */
    function isInViewportBounds(element) {
        var bounds = viewer.viewport.getBounds(),
            val = false,
            height = parseFloat($(element).css('height')),
            width = parseFloat($(element).css('width')),
            top = parseFloat($(element).css('top')),
            left = parseFloat($(element).css('left'));

        var topY = pointFromPixel(new Seadragon.Point(1, top - 10)).y,
            bottomY = pointFromPixel(new Seadragon.Point(1, top + height + 10)).y,
            leftX = pointFromPixel(new Seadragon.Point(left - 10, 1)).x,
            rightX = pointFromPixel(new Seadragon.Point(left + width + 10, 1)).x;

        if (((rightX < bounds.getBottomRight().x && leftX > bounds.getTopLeft().x)
            && (bottomY < bounds.getBottomRight().y && topY > bounds.getTopLeft().y))) {
            val = true;
        }
        return val;
    }

    /**
    * Returns whether an element is within the bounds of the deepzoom image (with a margin of .05 in Seadragon coordinates)
    * Used in rich location history.
    * @method isInImageBounds
    */
    function isInImageBounds(element) {

        var val = false;
        var point = locationOf(element);
        if ((point.x < 1.05 && point.x > -0.05) && (point.y > -0.05 && point.y < (1/aspectRatio) + .05)) {
            val = true;
        }
        //console.log(point.x + ', ' + point.y);
        //console.log((1 / aspectRatio) + .05);
        //console.log('inBounds= ' + val);
        return val;
    }

    /**
    * Returns coordinates that an element should be returned to if it is dragged too far from the deepzoom image.
    * (with a margin of .05 in Seadragon coordinates)
    * Used in rich location history.
    * @method returnElementToBounds
    */
    function returnElementToBounds(element) {
        var point = locationOf(element);
        var bounds = viewer.viewport.getBounds();
        if (point.x <= 0 && point.y <= 0) { //TOP LEFT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(0, 0));
        }
        if (point.y <= 0 && point.x >= 1) { //TOP RIGHT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(1, 0));
        }
        if (point.x <= 0 && point.y >= (1 / aspectRatio) + 0) { //BOTTOM LEFT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(0, (1 / aspectRatio)));
        }
        if (point.x >= 1 && point.y >= (1 / aspectRatio) + 0) { //BOTTOM RIGHT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(1, (1 / aspectRatio)));
        }
        if (point.x <= -0.05) { //LEFT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(0, point.y));
        }
        if (point.x >= 1.05) { //RIGHT
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(1, point.y));
        }
        if (point.y <= -0.05) { //TOP
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(point.x, 0));
        }
        if (point.y >= (1 / aspectRatio) + .05) { //BOTTOM
            return viewer.viewport.pixelFromPoint(new Seadragon.Point(point.x, (1 / aspectRatio)));
        }
    }
    
    /**
    * Calculates the location (point) of an element (bottom center)
    * Used in rich location history.
    * @method locationOf
    */
    function locationOf(element) {
        var point;
        (viewer.viewport && element) && function () {
            var ycoord = parseFloat($(element).css('top')) + parseFloat($(element).css('height'));
            var xcoord = parseFloat($(element).css('left')) + 0.5 * parseFloat($(element).css('width'));
            point = viewer.viewport.pointFromPixel(new Seadragon.Point(xcoord, ycoord));
        }();
        return point;
    }

    /**
    * Puts an element in the center of the viewport
    * Used in RLH
    * @method centerElement
    */
    function centerElement(element) {
        var pixel = viewer.viewport.pixelFromPoint(viewer.viewport.getCenter());
        $(element).css({
            top: pixel.y,
            left: pixel.x
        });
    }

    /**
     * Gets a Seadragon point from the given overlay element. Uses BOTTOM as the default OverlayPlacement
     * @method getCoordinate
     * @param {HTML elt} element       the overlay element
     * @return {Seadragon.Point}       the location of the overlay in Seadragon coordinates
     */
    function getOverlayCoordinates(element) {
        var t = parseFloat($(element).css('top')) + $(element).height(),
            l = parseFloat($(element).css('left')) + $(element).width() / 2;

        return viewer.viewport.pointFromPixel(new Seadragon.Point(l, t));
    }

    /** 
    * Returns a Seadragon point corresponding to a pixel
    * Used in RLH
    * @method pointFromPixel
    */
    function pointFromPixel(pixel) {
        return viewer.viewport.pointFromPixel(pixel);
    };

    /** 
    * Returns a Seadragon point in the center of the viewport + a 1% offset (to prevent overlap)
    * Used in RLH to create new pins
    * @method createStartingPoint
    */
    function createStartingPoint() {
        var centerPoint = viewer.viewport.getCenter();
        var bounds = viewer.viewport.getBounds();
        return new Seadragon.Point(centerPoint.x + .01 * (bounds.getBottomRight().x - bounds.getTopLeft().x),
            centerPoint.y + .01 * (bounds.getBottomRight().y - bounds.getTopLeft().y));
    };

    /** 
    * Used for zooming when simultaneously dragging a pin in RLH
    * @method scroll
    */
    function scroll(delta, pivot) {
        dzManip({
            scale: delta,
            translation: {
                x: 0,
                y: 0
            },
            pivot: {
                x: pivot.x,
                y: pivot.y
            }
        });
    }

    /*
    * functions used to stop panning of image in RLH when pins are being dragged
    * @method pauseManip
    */ 
    function pauseManip() {
        doManipulation = false;
    }

    /*
    * functions used to start panning of image in RLH when pins have been set
    * @method restartManip
    */
    function restartManip() {
        doManipulation = true;
    }

    /**
     * Initialize seadragon, set up handlers for the deepzoom image, load assoc media if necessary
     * @method init
     */
    function init() {
        var canvas;

        if(Seadragon.Config) {
            Seadragon.Config.visibilityRatio = 0.8; // TODO see why Seadragon.Config isn't defined; should it be?
            //Seadragon.Config.springStiffness = 0;
            //Seadragon.Config.animationTime = 0;
        }

        viewerelt = $(document.createElement('div'));
        viewerelt.attr('id', 'annotatedImageViewer');
        viewerelt.on('mousedown scroll click mousemove resize', function(evt) {
            evt.preventDefault();
        });
        root.append(viewerelt);

        viewer = new Seadragon.Viewer(viewerelt[0]);
        viewer.setMouseNavEnabled(false);
        viewer.clearControls();

        canvas = $(viewer.canvas);
        canvas.addClass('artworkCanvasTesting');
        if (IS_WINDOWS) {
            TAG.Util.makeManipulatableWin(canvas[0], {
                onScroll: function (delta, pivot) {
                    dzScroll(delta, pivot);
                },
                onManipulate: function (res) {
                    if (doManipulation) {
                        res.translation.x = -res.translation.x;        //Flip signs for dragging
                        res.translation.y = -res.translation.y;
                        dzManip(res);
                    }
                }
            }, null, true); // NO ACCELERATION FOR NOW
        } else {
            TAG.Util.makeManipulatable(canvas[0], {
                onScroll: function (delta, pivot) {
                    dzScroll(delta, pivot);
                },
                onManipulate: function (res) {
                    if (doManipulation) {
                        res.translation.x = -res.translation.x;        //Flip signs for dragging
                        res.translation.y = -res.translation.y;
                        dzManip(res);
                    }
                }
            }, null, true); // NO ACCELERATION FOR NOW
        }

        assetCanvas = $(document.createElement('div'));
        assetCanvas.attr('id', 'annotatedImageAssetCanvas');
        root.append(assetCanvas);

        // this is stupid, but it seems to work (for being able to reference zoomimage in artmode)
        noMedia ? setTimeout(function() { callback && callback() }, 1) : loadAssociatedMedia(callback);
    }

    /**
     * Adds an animation handler to the annotated image. This is used to allow the image to move
     * when the minimap is manipulated.
     * @method addAnimationHandler
     * @param {Function} handler      the handler to add
     */
    function addAnimateHandler(handler) {
        viewer.addEventListener("animation", handler);
    }

    /**
     * Retrieves associated media from server and stores them in the
     * associatedMedia array.
     * @method loadAssociatedMedia
     * @param {Function} callback    function to call after loading associated media
     */
    function loadAssociatedMedia(callback) {
        var done = 0,
            total;

        associatedMedia = {
            guids: []
        };

        TAG.Worktop.Database.getAssocMediaTo(doq.Identifier, mediaSuccess, null, mediaSuccess);

        /**
         * Success callback function for .getAssocMediaTo call above. If the list of media is
         * non-null and non-empty, it gets the linq between each doq and the artwork 
         * @method mediaSuccess
         * @param {Array} doqs        the media doqs
         */
        function mediaSuccess(doqs) {
            var i;
            total = doqs ? doqs.length : 0;
            if (total > 0) {
                for (i = 0; i < doqs.length; i++) {
                    TAG.Worktop.Database.getLinq(doq.Identifier, doqs[i].Identifier, createLinqSuccess(doqs[i]), null, createLinqSuccess(doqs[i]));
                }
            } else {
                callback && callback(associatedMedia);
            }
        }

        /**
         * Helper function for the calls to .getLinq above. It accepts an assoc media doc and returns
         * a success callback function that accepts a linq. Using this information, it creates a new
         * hotspot from the doq and linq
         * @method createLinqSuccess
         * @param {doq} assocMedia        the relevant associated media doq
         */
        function createLinqSuccess(assocMedia) {
            return function (linq) {
                associatedMedia[assocMedia.Identifier] = createMediaObject(assocMedia, linq);
                associatedMedia.guids.push(assocMedia.Identifier);

                if (++done >= total && callback) {
                    callback(associatedMedia);
                }
            }
        }
    }


    /**
     * Creates an associated media object to be added to associatedMedia.
     * This object contains methods that could be called in Artmode.js or
     * ArtworkEditor.js. This could be in its own file.
     * @method createMediaObject
     * @param {mdoq} doq       the media doq
     * @param {linq} linq     the linq between the media doq and the artwork doq
     * @return {Object}       some public methods to be used in other files
     */
    function createMediaObject(mdoq, linq) {
        console.log("CREATING MEDIA OBJECTS")
        var // DOM-related
            outerContainer = $(document.createElement('div')).addClass('mediaOuterContainer'),
            innerContainer = $(document.createElement('div')).addClass('mediaInnerContainer'),
            mediaContainer = $(document.createElement('div')).addClass('mediaMediaContainer'),

            // constants
            IS_HOTSPOT = linq.Metadata.Type ? (linq.Metadata.Type === "Hotspot") : false,
            IS_XFADE = false, //linq.Metadata.Type ? (linq.Metadata.Type === "Layer") : false, //TODO ADD BACK WHEN LAYERS COME BACK
            X = parseFloat(linq.Offset._x),
            Y = parseFloat(linq.Offset._y),
            position = new Seadragon.Point(X, Y),
            rect,   //For layer
            TITLE = unescape(TAG.Util.htmlEntityDecode(mdoq.Name)),
            CONTENT_TYPE = mdoq.Metadata.ContentType,
            SOURCE = mdoq.Metadata.Source,
            DESCRIPTION = unescape(TAG.Util.htmlEntityDecode(mdoq.Metadata.Description)),
            THUMBNAIL = mdoq.Metadata.Thumbnail,
            RELATED_ARTWORK = false,

            // misc initialized variables
            mediaHidden = true,
            hotspotMediaHidden = true,
            outerContainerhidden = true,
            currentlySeeking = false,
            movementTimeouts = [],
            circleRadius = 60,
            // misc uninitialized variables
            circle,
            position,
            mediaLoaded,
            mediaElt,
            mediaController,
            titleDiv,
            descTextSize,
            titleTextHolder,
            descDiv,
            thumbnailButton,
            startLocation,
            play;
        
        // get things rolling
        initMediaObject();

        /**
         * Initialize various parts of the media object: UI, manipulation handlers
         * @method initMediaObject
         */
        function initMediaObject() {

            if (IS_XFADE && linq.Offset && linq.Dimensions) {
                outerContainer.css({
                    'border': '1px solid rgba(255,255,255,0.4)',
                    'background': 'rgba(0,0,0,0)',
                    'width' : parseFloat(parseInt(linq.Dimensions._x) || 50),
                    'height' : parseFloat(parseInt(linq.Dimensions._y) || 50),
                    'position': 'absolute'
                });
                assetCanvas.append(outerContainer);
                outerContainer.hide();
            } else {
                // set up divs for the associated media
                outerContainer.css('width', 0.29 * root.width() + 'px');
                innerContainer.css('backgroundColor', 'rgba(0,0,0,0.65)');
                // for scaling and preventing overflow issues with the close button, we use a holder for the title
                // .remove is safety check for inertia looping issue
                titleDiv && titleDiv.remove();
                titleDiv = $(document.createElement('div'));
                var titleHeight = '20px';
                if (IS_WINDOWS) {
                    titleHeight = '40px';
                }
                titleDiv.css({
                    'display': 'block',
                    'height': titleHeight,
                    'position': 'relative',
                    'margin-bottom': '5px',
                    'width': '100%',
                    });
                titleTextHolder = $(document.createElement('div'));
                titleTextHolder.addClass('annotatedImageMediaTitle');//.css({'text-overflow':'ellipsis','white-space':'nowrap'});

                titleDiv.append(titleTextHolder);
                var titlefontsize = LADS.Util.getMaxFontSizeEM("WWWWW", 0.6, 999999, parseInt(titleHeight)+1, 0.025);
                if (TITLE) {
                    titleTextHolder.text(TITLE);
                } else {
                    titleTextHolder.text('Untitled');
                }

                titleTextHolder.css({
                    'width': (outerContainer.width() - 65) + 'px',
                    'font-size': titlefontsize
                });

                descTextSize = titlefontsize;

                var closeButton = createCloseButton();
                closeButton.on('click', function (evt) {
                    evt.stopPropagation();
                    hideMediaObject();
                });
                titleDiv.append(closeButton[0]);               

                innerContainer.append(titleDiv);
                innerContainer.append(mediaContainer);

                /**
                if (DESCRIPTION) {
                    descDiv = $(document.createElement('div'));
                    descDiv.addClass('annotatedImageMediaDescription');
                    descDiv.html(Autolinker.link(DESCRIPTION, { email: false, twitter: false }));
                    if (IS_WINDOWS) {
                        var links = descDiv.find('a');
                        links.each(function (index, element) {
                            $(element).replaceWith(function () {
                                return $.text([this]);
                            });
                        });
                    }
                    descDiv.css({
                        'top' : innerContainer.height() + 'px';
                    });
                    innerContainer.append(descDiv);
                }
                **/

                if (RELATED_ARTWORK) {
                    // TODO append related artwork button here
                }

                outerContainer.append(innerContainer);
                assetCanvas.append(outerContainer);
                outerContainer.hide();

                // create hotspot circle if need be
                if (IS_HOTSPOT) {
                    circle = $(document.createElement("img"));
                    circle.attr('src', tagPath + 'images/icons/hotspot_circle.svg');
                    circle.addClass('annotatedImageHotspotCircle');
                    circle.click(function () {
                        toggleMediaObject(true);
                    });
                    root.append(circle);
                }

                // allows asset to be dragged, despite the name
                TAG.Util.disableDrag(outerContainer);

                //When the associated media is clicked, set it to active(see mediaManipPreprocessing() above )
                outerContainer.on('click mousedown', function (event) {
                    event.stopPropagation();            //Prevent the click going through to the main container
                    event.preventDefault();
                    TAG.Util.IdleTimer.restartTimer();
                    mediaManipPreprocessing();

                    // If event is initial touch on artwork, save current position of media object to use for animation
                    outerContainer.startLocation = {
                            x: outerContainer.position().left,
                            y: outerContainer.position().top
                    };
                    console.log("startin location is getting set")
                    outerContainer.manipulationOffset = {
                        x: event.clientX - outerContainer.position().left,
                        y: event.clientY - outerContainer.position().top
                    };

                });

                // register handlers
                if (IS_WINDOWS) {
                    TAG.Util.makeManipulatableWin(outerContainer[0], {
                        onManipulate: mediaManipWin,
                        onScroll: mediaScrollWin
                    }, null); // NO ACCELERATION FOR NOW  
                } else {
                    TAG.Util.makeManipulatable(outerContainer[0], {
                        onManipulate: mediaManip,
                        onScroll: mediaScroll
                    }, null, true); // NO ACCELERATION FOR NOW  
                }
            }
        }

        /**
         * Initialize any media controls
         * @method initMediaControls
         * @param {HTML element} elt      video or audio element
         */
        function initMediaControls() {
            var elt = mediaElt,
                $elt = $(elt),
                cpHolder = $(document.createElement('div')),
                controlPanel = $(document.createElement('div')).addClass('annotatedImageMediaControlPanel'),
                vol = $(document.createElement('img')).addClass('mediaVolButton'),
                timeContainer = $(document.createElement('div')).addClass('mediaTimeContainer'),
                currentTimeDisplay = $(document.createElement('div')).addClass('mediaTimeDisplay'),
                playHolder = $(document.createElement('div')).addClass('mediaPlayHolder'),
                volHolder = $(document.createElement('div')).addClass('mediaVolHolder'),
                sliderContainer = $(document.createElement('div')).addClass('mediaSliderContainer'),
                sliderPoint = $(document.createElement('div')).addClass('mediaSliderPoint');

            controlPanel.attr('id', 'media-control-panel-' + mdoq.Identifier);

            play = $(document.createElement('img')).addClass('mediaPlayButton');

            play.attr('src', tagPath + 'images/icons/PlayWhite.svg');
            vol.attr('src', tagPath+'images/icons/VolumeUpWhite.svg');
            currentTimeDisplay.text("00:00");

            // dz17 - don't move this out - these divs are dynamically generated. The holders help with scaled positioning substantially.
            cpHolder.css({
                'width': '100%',
                'margin': '0 auto'
            });

            play.css({
                'position': 'absolute',
                'height': '100%',
                'width': 'auto'
            });

            playHolder.css({
                'position': 'absolute',
                'height': '35px',
                'width': "auto",
                'display': "block",
                'margin': '4px 1% 0px 1%'
            });
            
            sliderContainer.css({
                'position': 'absolute',
                'display': "block",
                'height': '17px',
                'width' :'475px',
                'max-width': '600px',
                'left': '55px',
                'top': '13px' 
            });

            sliderPoint.css({
                'position': 'absolute',
                'height': '100%',
                'background-color': '#3cf',
                'width': '0%',
                'left': '0%',
                'max-width': '100%'
            });

            vol.css({
                'position': 'absolute',
                'height': '100%',
                'width': 'auto',
                'right': '0%'
            });

            volHolder.css({
                'height': '30px',
                'position': 'absolute',
                'display': "block",
                'width': 'auto',
                'right': '2%',
                'top': '6px'
            });

            timeContainer.css({
                'height': '45px',
                'width': '15%',
                'max-width': '70px',
                'right': '56px',
                'display': 'block',
                'position': 'absolute'
            });
            var timefontsize = LADS.Util.getMaxFontSizeEM("00:00", 0.6, 70, 40, 0.025);
            currentTimeDisplay.css({
                'top': '1px',
                'height': '40px',
                'position': 'absolute',
                'font-size': timefontsize,
                'vertical-align': 'middle',
                'text-align': 'center'
            });

            playHolder.append(play);
            sliderContainer.append(sliderPoint);
            volHolder.append(vol);
            
            // set up handlers
            play.on('click', function () {
                if (elt.paused) {
                    elt.play();
                    play.attr('src', tagPath + 'images/icons/PauseWhite.svg');
                } else {
                    elt.pause();
                    play.attr('src', tagPath + 'images/icons/PlayWhite.svg');
                }
            });

            vol.on('click', function () {
                if (elt.muted) {
                    elt.muted = false;
                    vol.attr('src', tagPath + 'images/icons/VolumeUpWhite.svg');
                } else {
                    elt.muted = true;
                    vol.attr('src', tagPath + 'images/icons/VolumeDownWhite.svg');
                }
            });

            $elt.on('ended', function () {
                elt.pause();
                play.attr('src', tagPath + 'images/icons/PlayWhite.svg');
            });

            sliderContainer.on('mousedown', function(evt) {
                var time = elt.duration * ((evt.pageX - $(evt.target).offset().left) / sliderContainer.width()),
                    origPoint = evt.pageX,
                    timePxRatio = elt.duration / sliderContainer.width(),
                    currTime = Math.max(0, Math.min(elt.duration, elt.currentTime)),
                    origTime = time,
                    currPx   = currTime / timePxRatio,
                    minutes = Math.floor(currTime / 60),
                    seconds = Math.floor(currTime % 60),
                    adjMin = (minutes < 10) ? '0'+minutes : minutes,
                    adjSec = (seconds < 10) ? '0'+seconds : seconds;

                evt.stopPropagation();

                if(!isNaN(time)) {
                    currentTimeDisplay.text(adjMin + ":" + adjSec);
                    elt.currentTime = time;
                    sliderPoint.css('width', 100*(currPx / sliderContainer.width()) + '%');
                }

                sliderContainer.on('mousemove.seek', function(e) {
                    var currPoint = e.pageX,
                        timeDiff = (currPoint - origPoint) * timePxRatio;

                    currTime = Math.max(0, Math.min(elt.duration, origTime + timeDiff));
                    currPx   = currTime / timePxRatio;
                    minutes  = Math.floor(currTime / 60);
                    seconds  = Math.floor(currTime % 60);
                    adjMin   = (minutes < 10) ? '0'+minutes : minutes;
                    adjSec   = (seconds < 10) ? '0'+seconds : seconds;

                    if(!isNaN(currTime)) {
                        currentTimeDisplay.text(adjMin + ":" + adjSec);
                        elt.currentTime = currTime;
                        sliderPoint.css('width', 100*(currPx / sliderContainer.width()) + '%');
                    }
                });

                $('body').on('mouseup.seek mouseleave.seek', function() {
                    sliderContainer.off('mouseup.seek mouseleave.seek mousemove.seek');
                    // if(!isNaN(getCurrTime())) {
                    //     currentTimeDisplay.text(adjMin + ":" + adjSec);
                    //     elt.currentTime = getCurrTime();
                    //     sliderPoint.css('width', 100*(currPx / sliderContainer.width()) + '%');
                    // }
                });
            });

            // Update the seek bar as the video plays
            $elt.on("timeupdate", function () {
                var value = 100 * elt.currentTime / elt.duration,
                    timePxRatio = elt.duration / sliderContainer.width(),
                    currPx = elt.currentTime / timePxRatio,
                    minutes = Math.floor(elt.currentTime / 60),
                    seconds = Math.floor(elt.currentTime % 60),
                    adjMin = (minutes < 10) ? '0' + minutes : minutes,
                    adjSec = (seconds < 10) ? '0' + seconds : seconds;

                if(!isNaN(elt.currentTime)) {
                    currentTimeDisplay.text(adjMin + ":" + adjSec);
                    sliderPoint.css('width', 100*(currPx / sliderContainer.width()) + '%');
                }
            });

            mediaContainer.append(elt);
            mediaContainer.append(controlPanel);
            controlPanel.append(cpHolder);
            cpHolder.append(playHolder);
            cpHolder.append(sliderContainer);
            timeContainer.append(currentTimeDisplay);
            cpHolder.append(timeContainer);
            cpHolder.append(volHolder);

            mediaController = controlPanel;
        }

        function reinitMediaControlHandlers() {
            // find shit
            var elt = mediaElt,
                $elt = $(elt),
                vol = $(mediaController.find('.mediaVolButton')[0]),
                timeContainer = $(mediaController.find('.mediaTimeContainer')[0]),
                currentTimeDisplay = $(mediaController.find('.mediaTimeDisplay')[0]),
                sliderContainer = $(mediaController.find('.mediaSliderContainer')[0]),
                sliderPoint = $(mediaController.find('.mediaSliderPoint')[0]),
                playButton = $(mediaController.find('.mediaPlayButton')[0]);

            // set up handlers
            playButton.on('click', function () {
                if (elt.paused) {
                    elt.play();
                    playButton.attr('src', tagPath + 'images/icons/PauseWhite.svg');
                } else {
                    elt.pause();
                    playButton.attr('src', tagPath + 'images/icons/PlayWhite.svg');
                }
            });

            vol.on('click', function () {
                if (elt.muted) {
                    elt.muted = false;
                    vol.attr('src', tagPath + 'images/icons/VolumeUpWhite.svg');
                } else {
                    elt.muted = true;
                    vol.attr('src', tagPath + 'images/icons/VolumeDownWhite.svg');
                }
            });

            $elt.on('ended', function () {
                elt.pause();
                playButton.attr('src', tagPath + 'images/icons/PlayWhite.svg');
            });

            sliderContainer.on('mousedown', function (evt) {
                var time = elt.duration * ((evt.pageX - $(evt.target).offset().left) / sliderContainer.width()),
                    origPoint = evt.pageX,
                    timePxRatio = elt.duration / sliderContainer.width(),
                    currTime = Math.max(0, Math.min(elt.duration, elt.currentTime)),
                    origTime = time,
                    currPx = currTime / timePxRatio,
                    minutes = Math.floor(currTime / 60),
                    seconds = Math.floor(currTime % 60),
                    adjMin = (minutes < 10) ? '0' + minutes : minutes,
                    adjSec = (seconds < 10) ? '0' + seconds : seconds;

                evt.stopPropagation();

                if (!isNaN(time)) {
                    currentTimeDisplay.text(adjMin + ":" + adjSec);
                    elt.currentTime = time;
                    sliderPoint.css('width', 100 * (currPx / sliderContainer.width()) + '%');
                }

                sliderContainer.on('mousemove.seek', function (e) {
                    var currPoint = e.pageX,
                        timeDiff = (currPoint - origPoint) * timePxRatio;

                    currTime = Math.max(0, Math.min(elt.duration, origTime + timeDiff));
                    currPx = currTime / timePxRatio;
                    minutes = Math.floor(currTime / 60);
                    seconds = Math.floor(currTime % 60);
                    adjMin = (minutes < 10) ? '0' + minutes : minutes;
                    adjSec = (seconds < 10) ? '0' + seconds : seconds;

                    if (!isNaN(currTime)) {
                        currentTimeDisplay.text(adjMin + ":" + adjSec);
                        elt.currentTime = currTime;
                        sliderPoint.css('width', 100 * (currPx / sliderContainer.width()) + '%');
                    }
                });

                $('body').on('mouseup.seek mouseleave.seek', function () {
                    sliderContainer.off('mouseup.seek mouseleave.seek mousemove.seek');
                    // if(!isNaN(getCurrTime())) {
                    //     currentTimeDisplay.text(adjMin + ":" + adjSec);
                    //     elt.currentTime = getCurrTime();
                    //     sliderPoint.css('width', 100*(currPx / sliderContainer.width()) + '%');
                    // }
                });
            });

            // Update the seek bar as the video plays
            $elt.on("timeupdate", function () {
                var value = 100 * elt.currentTime / elt.duration,
                    timePxRatio = elt.duration / sliderContainer.width(),
                    currPx = elt.currentTime / timePxRatio,
                    minutes = Math.floor(elt.currentTime / 60),
                    seconds = Math.floor(elt.currentTime % 60),
                    adjMin = (minutes < 10) ? '0' + minutes : minutes,
                    adjSec = (seconds < 10) ? '0' + seconds : seconds;

                if (!isNaN(elt.currentTime)) {
                    currentTimeDisplay.text(adjMin + ":" + adjSec);
                    sliderPoint.css('width', 100 * (currPx / sliderContainer.width()) + '%');
                }
            });
        }

        /**
         * Load the actual image/video/audio; this can take a while if there are
         * a lot of media, so just do it when the thumbnail button is clicked
         * @method createMediaElements
         */
        function createMediaElements() {
            var $mediaElt,
                img,
                iframe,
               // closeButton,
                x,
                y,
                w,
                h;
                //rect;

            if (!mediaLoaded) {
                mediaLoaded = true;
            } else {
                if (mediaHidden) {
                    initMediaObject();
                    if (IS_XFADE) {
                        outerContainer.css({
                            "pointer-events": "none "
                        })
                    } else {
                        if (CONTENT_TYPE === 'Image') {
                            outerContainer.css('min-width', '');
                        } else if (CONTENT_TYPE === 'Video') {
                            outerContainer.css({
                                'width': '675px',
                                'height': 'auto'
                            });
                            reinitMediaControlHandlers();
                        } else if (CONTENT_TYPE === 'Audio') {
                            outerContainer.css({
                                'width': '675px',
                                'height': 'auto'
                            });
                            reinitMediaControlHandlers();
                        } else if (CONTENT_TYPE === 'iframe') {

                            outerContainer.css({
                                'width': '30%',
                            });
                            if (descDiv) {
                                outerContainer.css('height', outerContainer.width() * 1.15);
                            } else {
                                outerContainer.css('height', outerContainer.width() * 0.89);
                            }
                            innerContainer.css({
                                'height': '100%'
                            });
                            var mediaHeight;
                            DESCRIPTION ? mediaHeight = '85%' : mediaHeight = '100%';
                            mediaContainer.css({
                                'height': mediaHeight
                            });
                            /*var iframe = outerContainer.find("iframe");
                            iframe.attr({
                                src: SOURCE + "?modestbranding=1&showinfo=0&fs=0",
                                frameborder: '0'
                            });
                            iframe.css({
                                width: '100%',
                                height: '100%'
                            });*/

                            //Create an overlay to help with interaction (problems with mouse "sticking" to iframe)
                            //Basically, create an overlay that only exists while you have clicked down on the media, and then is removed when you release it (i.e, when you want to actually play the iframe)
                            if (!IS_WINDOWS) {
                                var interactionOverlay = $(document.createElement('div')).addClass("interactionOverlay");
                                interactionOverlay.css({
                                    height: "100%",
                                    width: "100%",
                                    position: "absolute",
                                    left: 0,
                                    top: 0
                                });
                                outerContainer.on('mousedown', function () {
                                    interactionOverlay.css("pointer-events", "auto");
                                });
                                $("body").on('mouseup', function () {
                                    interactionOverlay && interactionOverlay.css("pointer-events", "none")
                                });
                                mediaContainer.append(interactionOverlay)
                            }
                        }
                        if (DESCRIPTION) {
                            descDiv = $(document.createElement('div'));
                            descDiv.addClass('annotatedImageMediaDescription');
                            descDiv.css({
                                'font-size': descTextSize
                            });
                            descDiv.html(Autolinker.link(DESCRIPTION, { email: false, twitter: false }));
                            if (IS_WINDOWS) {
                                var links = descDiv.find('a');
                                links.each(function (index, element) {
                                    $(element).replaceWith(function () {
                                        return $.text([this]);
                                    });
                                });
                            }
                            descDiv.mouseover(function () { descscroll = true });
                            descDiv.mouseleave(function () { descscroll = false; });
                            //if(CONTENT_TYPE === 'iframe'){
                            //    descDiv.css({top:'110%'});
                            //}
                            outerContainer.append(descDiv);
                        }
                        return;
                    }
                } else {
                    return;
                }
            }

            if (IS_XFADE) {
                $mediaElt = $(document.createElement('img')).addClass('xfadeImg');
                $mediaElt.attr({
                    src: FIX_PATH(SOURCE)
                });
                $mediaElt.css({
                    height: '100%',
                    position: 'absolute',
                    width: '100%'
                });
                outerContainer.append($mediaElt);
                outerContainer.css({
                    "pointer-events": "none "
                })

                x = parseFloat(linq.Offset._x || 0);
                y = parseFloat(linq.Offset._y || 0);
                w = parseFloat(linq.Dimensions._x || 50);
                h = parseFloat(linq.Dimensions._y || 50);
                xFadeOffset = {
                    x: x,
                    y: y
                }
                rect = new Seadragon.Rect(x, y, w, h);

                viewer.drawer.addOverlay(outerContainer[0], rect);
            } else {
                //closeButton = createCloseButton();
                //mediaContainer.append(closeButton[0]);
                //closeButton.on('click', function (evt) {
                //        evt.stopPropagation();
                //        hideMediaObject();
                //});

                if (CONTENT_TYPE === 'Image') {
                    img = document.createElement('img');
                    img.src = FIX_PATH(SOURCE);
                    $(img).css({
                        position: 'relative',
                        width: '100%',
                        height: 'auto'
                    });
                    mediaContainer.append(img);
                    outerContainer.css('min-width', '');
                } else if (CONTENT_TYPE === 'Video') {
                    mediaElt = document.createElement('video');
                    $mediaElt = $(mediaElt);

                    $mediaElt.attr({
                        preload: 'none',
                        poster: (THUMBNAIL && !THUMBNAIL.match(/.mp4/)) ? FIX_PATH(THUMBNAIL) : '',
                        src: FIX_PATH(SOURCE),
                        type: 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
                        controls: false
                    });

                    outerContainer.css({
                        'width': '675px',
                        'height': 'auto'
                    });

                    // TODO need to use <source> tags rather than setting the source and type of the
                    //      video in the <video> tag's attributes; see video player code

                    $mediaElt.css({
                        position: 'relative',
                        width: '100%'
                    });

                    initMediaControls(mediaElt);

                } else if (CONTENT_TYPE === 'Audio') {
                    mediaElt = document.createElement('audio');
                    $mediaElt = $(mediaElt);

                    $mediaElt.attr({
                        preload: 'none',
                        type: 'audio/mp3',
                        src: FIX_PATH(SOURCE),
                        controls: false
                    });

                    initMediaControls(mediaElt);
                    $mediaElt.on('error', function () {
                        console.log("Here's an error ");
                    });
                    outerContainer.css({
                        'width': '675px',
                        'height' : 'auto'
                    });
                } else if (CONTENT_TYPE === 'iframe') {
                    outerContainer.css({
                        'width':'30%',
                    });
                    if (descDiv){
                        outerContainer.css('height', outerContainer.width()*1.15);
                    }else{
                        outerContainer.css('height',outerContainer.width()*0.89);
                    }
                    innerContainer.css({
                        'height':'100%'
                    });
                    var mediaHeight;
                    DESCRIPTION ? mediaHeight = '85%' : mediaHeight ='100%';
                    mediaContainer.css({
                        'height': mediaHeight
                    });
                    iframe = $(document.createElement('iframe'));
                    iframe.attr({
                        src: SOURCE + "?modestbranding=1&showinfo=0&fs=0",
                        frameborder: '0'
                    });
                    iframe.css({
                        width: '100%',
                        height: '100%'
                    });
                    mediaContainer.append(iframe);
                    
                    //Create an overlay to help with interaction (problems with mouse "sticking" to iframe)
                    //Basically, create an overlay that only exists while you have clicked down on the media, and then is removed when you release it (i.e, when you want to actually play the iframe)
                    if (!IS_WINDOWS){
                        var interactionOverlay = $(document.createElement('div'))
                        interactionOverlay.css({
                            height: "100%",
                            width: "100%",
                            position: "absolute", 
                            left: 0, 
                            top: 0
                        })

                        outerContainer.on('mousedown', function() {
                            interactionOverlay.css("pointer-events", "auto");
                        });
                        $("body").on('mouseup', function() {
                            interactionOverlay && interactionOverlay.css("pointer-events", "none")
                        });
                        mediaContainer.append(interactionOverlay)
                    }
                }
                if (DESCRIPTION) {
                    descDiv = $(document.createElement('div'));
                    descDiv.addClass('annotatedImageMediaDescription');
                    descDiv.css({
                        'font-size': descTextSize
                    });
                    descDiv.html(Autolinker.link(DESCRIPTION, { email: false, twitter: false }));
                    if (IS_WINDOWS) {
                        var links = descDiv.find('a');
                        links.each(function (index, element) {
                            $(element).replaceWith(function () {
                                return $.text([this]);
                            });
                        });
                    }
                    descDiv.mouseover(function () { descscroll = true });
                    descDiv.mouseleave(function () { descscroll = false; });
                    //if(CONTENT_TYPE === 'iframe'){
                    //    descDiv.css({top:'110%'});
                    //}
                    outerContainer.append(descDiv);
                }
            }
        }

        /**
         * Stores the dimensions and points to the media manipulation method  of the active associated media, also sends it to the front
         * media manip.
         * @method mediaManipPreprocessing
         */
        function mediaManipPreprocessing() {
            var w = outerContainer.width(),
                h = outerContainer.height();
            outerContainerPivot = {
                x: w / 2,// - (outerContainer.offset().left - root.offset().left),
                y: h / 2// - (outerContainer.offset().top - root.offset().top)
            };
            if (IS_XFADE) {
                toManip = dzManip;
            } else {
                toManip = mediaManip;
                $('.mediaOuterContainer').css('z-index', 1000);
                outerContainer.css('z-index', 1001);
            }
            TAG.Util.IdleTimer.restartTimer();
        }



        function mediaManipWin(res) {
            var t = outerContainer.css('top');
            var l = outerContainer.css('left');
            var w = outerContainer.css('width');
            var h = outerContainer.css('height');
            var neww = parseFloat(w) * res.scale;

            var minConstraint;
            if (CONTENT_TYPE === 'Video' || CONTENT_TYPE === 'Audio') {
                minConstraint = 450;
            } else {
                minConstraint = 200;
            }

            //if the new width is in the right range, scale from the point of contact and translate properly; otherwise, just translate and clamp
            var newClone;
            if ((neww >= minConstraint) && (neww <= 800)) {
                if (0 < parseFloat(t) + parseFloat(h) && parseFloat(t) < rootHeight && 0 < parseFloat(l) + parseFloat(w) && parseFloat(l) < rootWidth && res) {
                    outerContainer.css("top", (parseFloat(t) + res.translation.y + (1.0 - res.scale) * (res.pivot.y)) + "px");
                    outerContainer.css("left", (parseFloat(l) + res.translation.x + (1.0 - res.scale) * (res.pivot.x)) + "px");
                }
            } else {
                if (0 < parseFloat(t) + parseFloat(h) && parseFloat(t) < rootHeight && 0 < parseFloat(l) + parseFloat(w) && parseFloat(l) < rootWidth && res) {
                    outerContainer.css("top", (parseFloat(t) + res.translation.y) + "px");
                    outerContainer.css("left", (parseFloat(l) + res.translation.x) + "px");
                    neww = Math.min(Math.max(neww, minConstraint), 800);
                }
            }
            outerContainer.css("width", neww + "px");
            if (CONTENT_TYPE === 'Audio') {
                outerContainer.css('height', 'auto');
            } else {
                var newH = (neww * h) / w;
                outerContainer.css('height', newH + 'px');
            }
            outerContainer.find('.annotatedImageMediaTitle').css({
                'width': (neww - 65) + 'px'
            });

            if (CONTENT_TYPE === 'Video') {
                outerContainer.find('.mediaSliderContainer').css({
                    'width': (neww - 200) + 'px'
                });
            }
            mediaManipPreprocessing();

            checkForOffscreen();

            function checkForOffscreen() {
                var offscreenBuffer = (!IS_WINDOWS ? root.width() / 8 : 0);
                var finalPosition = {
                    x: parseInt(outerContainer.css('left')),
                    y: parseInt(outerContainer.css('top'))
                };
                var finalDims = {
                    w: parseInt(outerContainer.css('width')),
                    h: parseInt(outerContainer.css('height'))
                }
                if (!(
                    (0 < finalPosition.y + finalDims.h - offscreenBuffer) //top
                    && (finalPosition.y + offscreenBuffer < root.height()) //bottom
                    && (0 < finalPosition.x + finalDims.w - offscreenBuffer) //left
                    && (finalPosition.x + offscreenBuffer < root.width()))) { //right
                    hideMediaObject();
                    pauseResetMediaObject();
                    //for debugging (trying to figure out if we can turn off inertia after the media leaves the screen)
                    //if (IS_WINDOWS) {
                    //res.grEvent.target.isInertial = false;
                    //res.grEvent.target.velocities.linear.x = 0;
                    //res.grEvent.target.velocities.linear.y = 0;
                    //res.grEvent.stop();
                    //}
                    return;
                    IS_WINDOWS && (outerContainer.manipulationOffset = null);
                }
            }
        }

        function mediaScrollWin(res, pivot) {
            mediaManip({
                scale: res,
                translation: {
                    x: 0,
                    y: 0
                },
                pivot: {
                    x: pivot.x + root.offset().left,// + (outerContainer.offset().left - root.offset().left),
                    y: pivot.y + root.offset().top// + (outerContainer.offset().top - root.offset().top)
                }
            });
        }

    /**
     * I/P {Object} res     object containing hammer event info
     * Drag/manipulation handler for associated media
     * Manipulation for touch and drag events
     */
        function mediaManip(res, evt, fromSeadragonControls) {
            res && res.grEvent && (res.grEvent.target.autoProcessInertia = false);

            if (descscroll === true) {
                return;
            }

            if (res.scale !== 1) {
                mediaScroll(res.scale, res.pivot);
                return;
            }
            var top         = outerContainer.position().top,
                left        = outerContainer.position().left,
                width       = outerContainer.width(),
                height = outerContainer.height(),
                finalPosition;

            // Target location (where object should be moved to)
            if (fromSeadragonControls) {
                finalPosition = {
                    x: left + res.translation.x,
                    y: top + res.translation.y
                }
            } else if (IS_WINDOWS) {
                if (!outerContainer.manipulationOffset) return;
                finalPosition = {
                    x: left + res.pivot.x + root.offset().left - outerContainer.manipulationOffset.x,
                    y: top + res.pivot.y + root.offset().top - outerContainer.manipulationOffset.y
                }
            } else {
                // finalPosition = {
                //     x: left + res.pivot.x  - outerContainer.manipulationOffset.x,
                //     y: top + res.pivot.y  - outerContainer.manipulationOffset.y
                // } 
                //  
              finalPosition = {
                    x: (res.center.pageX - res.startEvent.center.pageX) + outerContainer.startLocation.x,
                    y: (res.center.pageY - res.startEvent.center.pageY) + outerContainer.startLocation.y
                };
            }

            // Animate to target location (or don't, if you're on the win8 app)
            outerContainer.stop()
            if (IS_WINDOWS) {
                outerContainer.css({
                    top: finalPosition.y,
                    left: finalPosition.x
                });
                checkForOffscreen();
            }
            else {
                outerContainer.animate({
                    top: finalPosition.y,
                    left: finalPosition.x
                }, 300, function () {
                    checkForOffscreen();
                });
            }

            /**
             * @method checkForOffscreen()
             * check whether or not asset is still on screen
             * If object is not on screen, reset and hide it
             */
            function checkForOffscreen() {
                var offscreenBuffer = (!IS_WINDOWS ? root.width() / 8: 0);
                if (!(
                    (0 < finalPosition.y + height - offscreenBuffer) //top
                    && (finalPosition.y + offscreenBuffer < root.height()) //bottom
                    && (0 < finalPosition.x + width - offscreenBuffer) //left
                    && (finalPosition.x + offscreenBuffer < root.width()))) { //right
                    hideMediaObject();
                    pauseResetMediaObject();
                    //for debugging (trying to figure out if we can turn off inertia after the media leaves the screen)
                    //if (IS_WINDOWS) {
                        //res.grEvent.target.isInertial = false;
                        //res.grEvent.target.velocities.linear.x = 0;
                        //res.grEvent.target.velocities.linear.y = 0;
                        //res.grEvent.stop();
                    //}
                    return;
                    IS_WINDOWS && (outerContainer.manipulationOffset = null);
                }
            }
        }

    /**
     * I/P {Number} scale     scale factor
     * I/P {Object} pivot     point of contact (with regards to image container, NOT window)
     * Zoom handler for associated media (e.g., for mousewheel scrolling)
     */
        function mediaScroll(scale, pivot) {
            if (descscroll === true) {
                return;
            } else if (CONTENT_TYPE === 'Audio') {
                // disallowing resizing of audio - doesn't make sense anyway
                return;
            }
            var t       = outerContainer.position().top,
            l       = outerContainer.position().left,
            w       = outerContainer.width(),
            h       = outerContainer.height(),
            newW    = w * scale,
            newH,
            maxW,
            minW,
            newX,
            newY;
        scrollingMedia = true;
        if (CONTENT_TYPE === 'Video') {
            minW = 450;
            maxW = 800;
        } else {
            minW = 250;
            maxW = 800;
        }
        if (CONTENT_TYPE === "iframe") {
            minW = parseInt(rootWidth * 0.33);
            maxW = parseInt(rootWidth * 0.75);
        }

        // Constrain new width
        if((newW < minW) || (newW > maxW)) {
            newW    = Math.min(maxW, Math.max(minW, newW));
        };

        // Update scale, new X and new Y according to newly constrained values.
        scale   = newW / w;
        newH = h * scale;
        newX = l + pivot.x * (1 - scale);
        newY = t + pivot.y * (1 - scale);

        //Animate outerContainer to this new position
        outerContainer.stop()
        outerContainer.css({
            top: newY,
            left: newX,
            width: newW,
            height: newH
        });

        outerContainer.find('.annotatedImageMediaTitle').css({
            'width': (newW - 65) + 'px'
        });

        if (CONTENT_TYPE === 'Video') {
            outerContainer.find('.mediaSliderContainer').css({
                'width': (newW - 200) + 'px'
            });
        }
        setTimeout(function () {
            scrollingMedia = false;
        }, 100);
    }
        
        /**
         * Create a closeButton for associated media
         * @method createCloseButton
         * @return {HTML element} the button as a 'div'
         */
        function createCloseButton() {
            var closeButton = $(document.createElement('img'));
            closeButton.attr('src', tagPath + 'images/icons/x.svg');
            closeButton.text('X');
            var cssHeight = IS_WINDOWS ? '30px' : '15px';
            closeButton.css({
                'position': 'absolute',
                'width': cssHeight,
                'height': cssHeight,
                'min-width': '30px',
                'z-index': '1',
                'right': '1.5%',
                'margin-top': '7px'
            });
            return closeButton;
        }
         
        /**
         * Show the associated media on the seadragon canvas. If the media is not
         * a hotspot, show it in a slightly random position.
         * @method showMediaObject
         */
        function showMediaObject(isHotspotIcon) {
            var t,
                l,
                h = outerContainer.height(),
                w = outerContainer.width(),
                splitscreenOffset = 0;
            outerContainer && outerContainer.detach();

            // temporary crashfix for errors where viewport isn't properly initialized
            // need to root-cause this issue ASAP
            if (!viewer.viewport) {
                console.log("[DIAGNOSTIC] viewer or viewer.viewport is null in showMediaObject() call for " + (TITLE ? TITLE : "untitled") + "asset");
                return;
            }

            if (IS_XFADE) {
                //console.log(appending);
                //assetCanvas.append(outerContainer);
                outerContainer.show();
                root.find('.xfadeImg').css("opacity", root.find('#xfadeSliderPoint').width() / root.find('#xfadeSlider').width());
                viewer.viewport.fitBounds(rect, false);
                viewer.viewport.applyConstraints()
            } else {
                //If associated media object is a hotspot, then position it next to circle.  Otherwise, put it in a slightly random position near the middle
                if (IS_HOTSPOT) {
                    if (!isHotspotIcon) {
                        circle.css('visibility', 'visible');
                        addOverlay(circle[0], position, Seadragon.OverlayPlacement.CENTER);
                    }
                    viewer.viewport.panTo(position, false);
                    viewer.viewport.applyConstraints()
                    t = viewer.viewport.pixelFromPoint(position).y - h / 2 + circleRadius / 2;
                    l = viewer.viewport.pixelFromPoint(position).x + circleRadius;
                }
                 else {
                    (root.data('split') === 'R') && (splitscreenOffset =  - root.find('#sideBar').width());
                    (root.data('split') === 'L') && (splitscreenOffset =   root.find('#sideBar').width());
                    t = root.height() * 1 / 10 + Math.random() * root.height() * 2 / 10;
                    l = (root.width() + splitscreenOffset)/3 + (.5 - Math.random()) * root.width()/8  ;
                };
                outerContainer.css({
                    'top': t + "px",
                    'left': l + "px",
                    'position': "absolute",
                    'z-index': 1000,
                    'pointer-events': 'all'
                });

                assetCanvas.append(outerContainer);
                outerContainer.show();
            }

            mediaHidden = false;

            if (hotspotMediaHidden) {
                hotspotMediaHidden = false;
            }
            var toHideID = '#thumbnailButton-' + mdoq.Identifier;
            if (outerContainer.parents('#metascreen-R').length) {
                toHideID += 'R';
            }

            if (!thumbnailButton) {
                thumbnailButton = $(toHideID);
            }
            
            thumbnailButton.css({
                'color': 'black',
                'background-color': 'rgba(255,255,255, 0.3)'
            });

            // TODO is this necessary? 
            // dz17: this WAS necessary due to scaling. Please ask before disabling anything to do with resizing
            // if ((info.contentType === 'Video') || (info.contentType === 'Audio')) {
            //     resizeControlElements();
            // }

        }

        /**
         * Hide the associated media
         * @method hideMediaObject
         */
        function hideMediaObject(isHotspotIcon) {
            //TAG.Util.removeYoutubeVideo();
            outerContainer.stop();

            var toHideID = '#thumbnailButton-' + mdoq.Identifier;
            if (outerContainer.parents('#metascreen-R').length) {
                toHideID += 'R';
            } 
            if (!thumbnailButton) {
                thumbnailButton = $(toHideID);
            }

            if (!isHotspotIcon) {
                thumbnailButton.css({
                    'color': 'white',
                    'background-color': ''
                });
                mediaHidden = true;
            } else {
                hotspotMediaHidden = true;
            }
            TAG.Util.IdleTimer.restartTimer();
            dzManipPreprocessing();                     //When an object is hidden, set the artwork as active

            // removed below because xfades are gone for 2.1
            if (IS_XFADE) { // slightly repeated code, but emphasizes that this is all we need to do for xfades
                outerContainer.hide();
            } else {
                pauseResetMediaObject();
                if (!isHotspotIcon) {
                    IS_HOTSPOT && removeOverlay(circle[0]); 
                    outerContainer.remove();
                    outerContainer = $(document.createElement('div'));
                }else {
                    outerContainer.hide();
                }
            }

        }

        /* SAM custom build */
        function showHotspot() {
            createMediaElements();
            showMediaObject();
            hideMediaObject();
        }

        /**
         * Show if hidden, hide if shown
         * @method toggleMediaObject
         */
        function toggleMediaObject(isHotspotIcon) {
            if (hotspotMediaHidden) {
                showMediaObject(isHotspotIcon);
            } else {
                mediaHidden ? showMediaObject(isHotspotIcon) : hideMediaObject(isHotspotIcon);
            }

            outerContainerhidden = mediaHidden;
        }

        /**
         * Returns whether the media object is visible
         * @method isVisible
         * @return {Boolean}
         */
        function isVisible() {
            return !mediaHidden;
        }

        function toggleHotspot() {
            if (outerContainerhidden) {
                outerContainer.show();
                outerContainerhidden = false;
            } else {
                outerContainer.hide();
                outerContainerhidden = true;
            }
        }
        /**
         * Pauses and resets (to time 0) the media if the content type is video or audio
         * @pauseResetMediaObject
         */
        function pauseResetMediaObject() {
            if(!mediaElt || mediaElt.readyState < 4) { // see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
                return;
            }
            mediaElt.currentTime = 0;
            mediaElt.pause();
            play.attr('src', tagPath + 'images/icons/PlayWhite.svg');
        }


        return {
            doq:                 mdoq,
            linq:                linq,
            show:                showMediaObject,
            hide:                hideMediaObject,
            create:              createMediaElements,
            pauseReset:          pauseResetMediaObject,
            toggle: toggleMediaObject,
            showHotspot: showHotspot,
            createMediaElements: createMediaElements,
            isVisible:           isVisible,
            mediaManipPreprocessing: mediaManipPreprocessing
        };
    }
};

;
var TAG = TAG || {};

TAG.Auth = (function () {
    "use strict";
    if (!TAG.AuthOverlay) {
        var overlay = generateOverlay();
        TAG.AuthOverlay = overlay.overlay;
        TAG.AuthSubmit = overlay.submit;
        TAG.AuthCancel = overlay.cancel;
        TAG.AuthInput = overlay.input;
        TAG.AuthError = overlay.error;
        TAG.AuthCircle = overlay.circle;
        var successFunction;
        var passwordDialogBox;
        
    }

    return {
        getToken: getToken,
        clearToken: clearToken,
        authenticate: authenticate,
        hashPass: hashPass,
        checkPassword: checkPassword,
        changePassword: changePassword,
    };

    

    /*function submitOnClick() {   // store the authoring mode password submit button's on click function
                TAG.AuthError.hide();
                TAG.AuthCircle.show();
                TAG.AuthSubmit.hide();
                TAG.AuthCancel.hide();
                checkPassword(TAG.AuthInput.val(), function () {
                    TAG.AuthError.hide();
                    TAG.AuthCircle.hide();
                    TAG.AuthOverlay.remove();
                    successFunction();
                }, function () {
                    TAG.AuthError.html('Invalid Password. Please try again...');
                    TAG.AuthError.show();
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                }, function () {
                    TAG.AuthError.html('There was an error contacting the server. Contact a server administrator if this error persists.');
                    TAG.AuthError.show();
                    TAG.AuthError.css({'bottom': '30%'});
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                });
            } */


    function getToken() {
        return TAG.AuthToken || null;
    }

    function clearToken() {
        TAG.Worktop.Database.clearToken(TAG.AuthToken);
        TAG.AuthToken = null;
    }

    function hashPass(passwd, salt) {
        var string = passwd + salt;
        var hash = CryptoJS.SHA256(string);
        for (var i = 0; i < 1023; i++) {
            hash = CryptoJS.SHA256(hash);
        }
        return hash;
    }

    function checkPassword(passwd, onSuccess, onFail, onError) {
        TAG.Worktop.Database.getSalt(function (salt) {
            TAG.Worktop.Database.getAuth(passwd, salt,
                function (token) {
                    TAG.AuthToken = token;
                    onSuccess();
                },
                onFail,
                onError);
        }, onError);
    }

    function changePassword(oldpass, newpass, onSuccess, onFail, onError) {
        if (!checkValidPassword(newpass)) {
            onFail('Password must contain at least 8 characters with 3 of the following types:<br>Lowercase letter<br>Uppercase letter<br>Number<br>Symbol');
            return;
        }
        TAG.Worktop.Database.getSalt(function (salt) {
            TAG.Worktop.Database.changePass(oldpass, salt, newpass,
                function (token) {
                    TAG.AuthToken = token;
                    onSuccess();
                },
                onFail,
                onError);
        });
    }

    function checkValidPassword(pass) {
        if (pass && pass.length >= 8) {
            var matches = 0;
            if (pass.match(/(?=.*[a-z])/)) {
                matches++;
            }
            if (pass.match(/(?=.*[A-Z])/)) {
                matches++;
            }
            if (pass.match(/(?=.*[\d])/)) {
                matches++;
            }
            if (pass.match(/(?=.*[\W])/)) {
                matches++;
            }
            if (matches >= 3) {
                return true;
            }
        }
        return false;
    }

  

    function authenticate(onSuccess, onCancel) {
        successFunction = onSuccess;
        if (TAG.AuthToken) {
            TAG.Worktop.Database.checkToken(TAG.AuthToken, onSuccess, showForm, showForm);
        } else { 
            showForm(); 
        }
        function showForm() {
            $("#tagRoot").append(TAG.AuthOverlay);
            TAG.AuthInput.val('');
            TAG.AuthOverlay.fadeIn(500);
            TAG.AuthInput.focus();
            TAG.AuthSubmit.show();
            TAG.AuthCancel.show();
            TAG.AuthCancel.click(function () {
                TAG.AuthError.hide();
                TAG.AuthCircle.hide();
                TAG.AuthOverlay.fadeOut(500, function () {
                    TAG.AuthOverlay.remove();
                    if (onCancel) {
                        onCancel();
                    }
                });
            });

        

            TAG.AuthSubmit.click(function () {
                
                TAG.AuthError.hide();
                TAG.AuthCircle.show();
                TAG.AuthSubmit.hide();
                TAG.AuthCancel.hide();
                checkPassword(TAG.AuthInput.val(), function () {
                    TAG.AuthError.hide();
                    TAG.AuthCircle.hide();
                    TAG.AuthOverlay.remove();
                    onSuccess();
                }, function () {
                    TAG.AuthError.html('Invalid Password. Please try again...');
                    TAG.AuthError.show();
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                }, function () {
                    TAG.AuthError.html('There was an error contacting the server. Contact a server administrator if this error persists.');
                    TAG.AuthError.show();
                    TAG.AuthError.css({'bottom': '30%'});
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                });
            });
            
            //Enter can be pressed to submit the password form...
            TAG.AuthInput.keypress(function(e){

                if (e.which===13) {  // enter key press
                    
                    TAG.AuthError.hide();
                    TAG.AuthCircle.show();
                    TAG.AuthSubmit.hide();
                    TAG.AuthCancel.hide();
                    checkPassword(TAG.AuthInput.val(), function () {
                        TAG.AuthError.hide();
                        TAG.AuthCircle.hide();
                        TAG.AuthOverlay.remove();
                        onSuccess();
                
                    }, function () {
                
                    TAG.AuthError.html('Invalid Password. Please try again...');
                    TAG.AuthError.show();
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                
                   }, function () {
               
                    TAG.AuthError.html('There was an error contacting the server. Contact a server administrator if this error persists.');
                    TAG.AuthError.show();
                    TAG.AuthError.css({'bottom': '30%'});
                    TAG.AuthCircle.hide();
                    TAG.AuthSubmit.show();
                    TAG.AuthCancel.show();
                  
                    });
                }
            });
        }
    }


    function generateOverlay(onSuccess, onCancel) {
       

        var overlay = $(document.createElement('div'));
        overlay.attr('id', 'loginOverlay');
        var loginDialog = $(document.createElement('div'));
        loginDialog.attr('id', 'loginDialog');

        passwordDialogBox = loginDialog;


        overlay.css({
            display: 'none',
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'background-color': 'rgba(0,0,0,0.6)',
            'z-index': 100000002,
        });


        ///

        var loginDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),

        {
            center_h: true,
            center_v: true,
            width: 0.5,
            height: 0.35,
            max_width: 560,
            max_height: 210,
        });

        loginDialog.css({
            position: 'absolute',
            top: loginDialogSpecs.y + 'px',
            width: loginDialogSpecs.width-200 + 'px',
            height: loginDialogSpecs.height - 55+ 'px',
            left: loginDialogSpecs.x + 'px',
            border: '3px double white',
            'background-color': 'black',
        });
        
        ///


        //loginDialog.css({
        //    position: 'absolute',
        //    left: '34%',
        //    width: 'auto',
        //    top: '30%',
        //    border: '3px double white',
        //    'background-color': 'black',
        //    'padding': '2.5% 2.5%',
        //});
        overlay.append(loginDialog); 
        var dialogTitle = $(document.createElement('div'));
        dialogTitle.attr('id', 'dialogTitle');
        dialogTitle.css({

            color: 'white',
            'width': '80%',
            'height': '15%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '50%',
            //'font-size': '1.25em',
            'position': 'relative',
            'text-align': 'center',
            //'overflow': 'hidden',
        });
        dialogTitle.text('Please enter authoring mode password.');

        var passwdInput = $(document.createElement('input'));
        passwdInput.attr({
            type: 'password',
            id: 'password',
            name: 'password',
            placeholder: 'password',
        });
        passwdInput.css({
            display: 'block',
            'position':'relative',
            margin: 'auto',
            'margin-top': '8%',
            'margin-bottom': '4%'
        });



        var errorMessage = $(document.createElement('div'));
        errorMessage.attr('id', 'errorMessage');
        errorMessage.css({
            color: 'white',
            //'font-size': '1.25em',
            'margin-bottom': '10px',
            'left': '10%',
            'width': '80%',
            'font-size': '50%',
            'text-align': 'center',
            'bottom': '25%',
            'position': 'absolute',
        });
        errorMessage.html('Invalid Password. Please try again...'); //<br/>Please contact <a href="mailto:brown.touchartgallery@gmail.com">brown.touchartgallery@gmail.com</a> for password.');
        errorMessage.hide();

        var buttonRow = $(document.createElement('div'));
        buttonRow.css({
            //'margin-top': '10px',
            'position': 'relative',
            'display': 'block',
            'width': '70%',
            'left': '10%',
            'bottom': '-6%'
        });
        var submitButton = $(document.createElement('button'));
        submitButton.css({
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
            'margin-left': '-7%',
            'display': 'inline-block',
        });
        var circle = $(document.createElement('img'));
        circle.css({
            'width': '20px',
            'height': 'auto',
            'display': 'none',
            'margin-right': '3%',
            'margin-top': '2.5%',
            'float': 'right'
        });
        circle.attr('src', tagPath+'/images/icons/progress-circle.gif');


        submitButton.text('Submit');
        
        var authFailed = function () {
            errorMessage.show();
            circle.hide();
        };
        var submit = function () {
            errorMessage.hide();
            circle.show();
        };

        var cancelButton = $(document.createElement('button'));
        cancelButton.attr('type', 'button');
        cancelButton.css({
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
            'float': "right",
            'margin-right': '-21%',
            'display': 'inline-block',
    });
        cancelButton.text('Cancel');
        loginDialog.append(dialogTitle);
        loginDialog.append(passwdInput);
        loginDialog.append(errorMessage);
        loginDialog.append(buttonRow);
        buttonRow.append(cancelButton);
        buttonRow.append(submitButton);
        buttonRow.append(circle);

        return {
            overlay: overlay,
            input: passwdInput,
            submit: submitButton,
            cancel: cancelButton,
            error: errorMessage,
            circle: circle
        };
    }
})();
;
TAG.Util.makeNamespace("TAG.Layout.StartPage");


/**
* The start page for TAG, which contains mueseum info, server preferences and credits.
* @class TAG.Layout.StartPage
* @constructor
*
* @param {Object} options
* @param {Function} startPageCallback
* @return {Object} that                 collection of public methods and properties
*/
TAG.Layout.StartPage = function (options, startPageCallback) {
    "use strict"; ////////////////////////////////////////////////

    var isPreview;
    options && function () {isPreview = options.isPreview; }();
    options = TAG.Util.setToDefaults(options, TAG.Layout.StartPage.default_options);
    options.tagContainer = $("#tagRoot");

    var root = TAG.Util.getHtmlAjax('../tagcore/html/SplashScreenOverlay.html'), // use AJAX to load html from .html file
        //overlay = root.find('#overlay'),
        //primaryFont = root.find('.primaryFont'),
        //secondaryFont = root.find('.secondaryFont'),
        //serverTagBuffer = root.find('#serverTagBuffer'),
        //serverSetUpContainer = root.find('#serverSetUpContainer'),
        //authoringButtonContainer = root.find('#authoringButtonContainer'),
        //authoringButtonBuffer = root.find('#authoringButtonBuffer'),
        //loginDialog = root.find('#loginDialog'),
        goToCollectionsButton = root.find('#goToCollectionsButton'),
        serverInput = root.find('#serverInput'),
        authoringInput = root.find('#passwordInput'),
        serverError = root.find('#serverError'),
        passwordError = root.find('#passwordError'),
        serverSubmit = root.find('#serverSubmit'),
        passwordSubmit = root.find('#passwordSubmit'),
        //tutorialButton = root.find('#tutorialButton'),
        serverURL,
        tagContainer,
        newUser = options.newUser,
        mainDoq,
        PRIMARY_FONT_COLOR,
        SECONDARY_FONT_COLOR;
    serverInput.attr('placeholder', localStorage.ip);
    serverInput.attr('value', localStorage.ip);

    //PREVIEW STYLING
    isPreview && function () {
        serverInput.css({ 'min-height': '0px','min-width': '0px',});
        serverSubmit.css({ 'min-height': '0px', 'min-width': '0px', });
        authoringInput.css({ 'min-height': '0px', 'min-width': '0px', });
        passwordSubmit.css({ 'min-height': '0px', 'min-width': '0px', });
    }();

    //INFO POPUP - todo styl

    /*tutorialButton.attr('src', tagPath + 'images/icons/question_mark.svg')
        .addClass('bottomButton')
        .on('mousedown', function () {
            TAG.Util.createTutorialPopup();
        }).css({
            'cursor': 'pointer',
            'display': 'block',
            'float': 'left',
            'height': '3.5%',
            'max-height': '50px',
            'width': 'auto',
            'bottom': '0%',
            'margin': '0px 0px 1.5% 1.5%',
            'position': 'absolute',
        });*/

    // TODO merging TAG.Telemetry.register(goToCollectionsButton, 'click', 'start_to_collections');
    //                     tobj.mode = 'Kiosk';
    if (localStorage.ip && localStorage.ip.indexOf(':') !== -1) {
        localStorage.ip = localStorage.ip.split(':')[0];
    }
    
    serverURL = 'http://' + (localStorage.ip ? localStorage.ip + ':8080' : "browntagserver.com:8080");
    tagContainer = options.tagContainer || $('body');

    //Comment out this conditional block to disable access to authoring for the web
    if (!IS_WINDOWS) {
        authoringInput.prop('disabled', true);
        authoringInput.css('opacity', '0.5');
        passwordSubmit.css('opacity', '0.5');
    }
    
    testConnection();
    if(newUser){
        telemetryDialogDisplay();
    }

    
    //applyCustomization();
    function telemetryDialogDisplay(){
        var tagContainer = $('#tagRoot');
        var telemetryDialogoverlay = $(TAG.Util.UI.PopUpConfirmation(function(){
            TELEMETRY_SWITCH = 'off';
            localStorage.tagTelemetry = "off";
            //telemetryDialogOverlay.remove();
        },
            "To improve the Touch Art Gallery experience, we're trying to collect more information about how users like you use our application. Do you mind us collecting information on your usage?",
            "Yes, I mind",null,
            function(){
                TELEMETRY_SWITCH = 'on';
                localStorage.tagTelemetry = "on";
                //telemetryDialogOverlay.remove();
            },
            tagContainer,null,null,true
        ));

        
        root.append(telemetryDialogoverlay);
        
        telemetryDialogoverlay.show();
        adjustHeights(document.getElementById("popupmessage"));

        function adjustHeights(elem) {
            var fontstep = 0.1;
            if ($(elem).height() > $(elem).parent().height() || $(elem).width() > $(elem).parent().width()) {
                $(elem).css('font-size', (($(elem).css('font-size').substr(0, 2) - fontstep)) + 'px').css('line-height', (($(elem).css('font-size').substr(0, 2))) + 'px');
                adjustHeights(elem);
            }
        }
        // Creating Overlay
        /*
        var telemetryDialogOverlay = $(document.createElement('div'));
        telemetryDialogOverlay.attr('id', 'telemetryDialogOverlay');
        telemetryDialogOverlay.addClass('dialogBoxOverlay');
        tagContainer.prepend(telemetryDialogOverlay);

        // Creating Dialog Box Container (required for centering)
        var telemetryDialogContainer = $(document.createElement('div'));
        telemetryDialogContainer.attr('id', 'telemetryDialogContainer');
        telemetryDialogContainer.addClass('dialogBoxContainer');
        telemetryDialogOverlay.append(telemetryDialogContainer);
        telemetryDialogContainer.css({
                'position': 'relative'
        });

        // Creating Dialog Box
        var telemetryDialog = $(document.createElement('div'));
        telemetryDialog.attr('id', 'telemetryDialog');
        telemetryDialog.addClass('dialogBox');
        telemetryDialogContainer.append(telemetryDialog);
        telemetryDialog.css({
                'height':'26%'
        });

        // Content
        var telemetryDialogPara = $(document.createElement('p'));
        telemetryDialogPara.attr('id', 'dialogBoxPara');
        //telemetryDialogPara.css({"margin-top": "5%"});
        telemetryDialogPara.text("To improve the Touch Art Gallery experience, we're trying to collect more information about how users like you use our application. Do you mind us collecting information on your usage?");
        telemetryDialog.append(telemetryDialogPara);

        // Button Container
        var telemetryButtonRow = $(document.createElement('div'));
        telemetryButtonRow.attr('id', 'telemetryButtonRow');
        telemetryDialog.append(telemetryButtonRow);
        telemetryButtonRow.css({
            'display': 'block',
            'height' : '13%',
            'position': 'relative',
            'width': '90%',
            'margin-left': '5%',
            'margin-top':'10%'
        });

        var yesButton = $(document.createElement('button'));
        yesButton.attr('id', 'yesButton');
        yesButton.text('Yes, I mind');
        telemetryButtonRow.append(yesButton);
        yesButton.css({
            'position': 'relative',
            'width': '30%',
            'height': '100%',
            'color': '#fff',
            'font-family': '"Segoe UI",serif',
            'font-size': '80%',
            'font-weight': 'normal',
            'background-color': 'transparent',
            'cursor': 'pointer',
            'padding': '0px 0px 0px 0px',
            'border-radius' : '3.5px',
            'border' : '1px solid white',
            'margin': '0',
            'float': 'left',
            'margin-left' : '0%',
            'margin-top' : '1px'
        });

        var noButton = $(document.createElement('button'));
        noButton.attr('id', 'noButton');
        noButton.text('No, I don\'t mind');
        telemetryButtonRow.append(noButton);
        noButton.css({
            'position': 'relative',
            'width': '40%',
            'height': '100%',
            "background-color": "white",
            'color': 'black',
            'font-family': '"Segoe UI",serif',
            'font-weight': 'normal',
            'cursor': 'pointer',
            'float': 'right',
            'font-size': '80%',
            'padding': '0px 0px 0px 0px',
            'border-radius' : '3.5px',
            'border' : '1px solid white'
        });

        noButton.click(function () {
            TELEMETRY_SWITCH = 'on';
            localStorage.tagTelemetry = "on";
            telemetryDialogOverlay.remove();
        });

        yesButton.click(function(){
            TELEMETRY_SWITCH = 'off';
            localStorage.tagTelemetry = "off";
            telemetryDialogOverlay.remove();
        });
        */


    }

    /**
     * Test internet and server connections
     * @param options             Object
     *            internetURL     url of alternate site against which we'll test connectivity
     */
    function testConnection(options) {
        var internetURL = (options && options.internetURL) || "http://www.google.com/",
            connectionTimeout,
            timedOut;

        //console.log("checking server url: " + serverURL);
        $.ajax({
            url: serverURL,
            dataType: "text",
            async: true,
            cache: false,
            success: function () {
                if (!timedOut) {
                    clearTimeout(connectionTimeout);
                    successConnecting();
                }
            },
            error: function (err) {
                if(!timedOut) {
                    clearTimeout(connectionTimeout);
                    $.ajax({  // TODO: not a solid way to do this
                        url: internetURL,
                        dataType: "text",
                        async: false,
                        cache: false,
                        success: function () {
                            if (!timedOut) {
                                clearTimeout(connectionTimeout);
                                tagContainer.empty();
                                tagContainer.append((new TAG.Layout.InternetFailurePage("Server Down")).getRoot());
                            }
                        },
                        error: function (err) {
                            if(!timedOut) {
                                clearTimeout(connectionTimeout);
                                tagContainer.empty();
                                tagContainer.append((new TAG.Layout.InternetFailurePage("No Internet")).getRoot());
                            }
                        }
                    });
                }
            }
        });

        connectionTimeout = setTimeout(function() {
            timedOut = true;
            tagContainer.empty();
            tagContainer.append((new TAG.Layout.InternetFailurePage("Server Down")).getRoot());
        }, 10000); // 10 second timeout to show internet failure page
    }

    function successConnecting() {
        TAG.Worktop.Database.getVersion(function (ver) {
            if (parseFloat(ver) < 1.5) {
                tagContainer.empty();
                tagContainer.append((new TAG.Layout.InternetFailurePage("Old Server")).getRoot());
            } else {
                TAG.Worktop.Database.getMain(loadHelper, function () {
                    tagContainer.empty();
                    tagContainer.append((new TAG.Layout.InternetFailurePage("Server Down")).getRoot());
                });
            }
        }, function () {
            tagContainer.empty();
            tagContainer.append((new TAG.Layout.InternetFailurePage("Server Down")).getRoot());
        });
    }

    var that = {};    
    var backgroundColor,
        logoContainer,
        touchHint,
        handGif;    

    /**
    * sets up the entire visual layout and images of the splash screen
    * @method loadHelper
    * @param {Object} main     contains all image paths and museum info
    */
    function loadHelper(main) {
        mainDoq = main;
        PRIMARY_FONT_COLOR = mainDoq.Metadata["PrimaryFontColor"];
        SECONDARY_FONT_COLOR = mainDoq.Metadata["SecondaryFontColor"];

        if (SECONDARY_FONT_COLOR[0] !== '#') {
            SECONDARY_FONT_COLOR = '#' + SECONDARY_FONT_COLOR;
        }
        if (PRIMARY_FONT_COLOR[0] !== '#') {
            PRIMARY_FONT_COLOR = '#' + PRIMARY_FONT_COLOR;
        }
        if (startPageCallback) {
            startPageCallback(root);
        }

        TAG.Util.Constants.set("START_PAGE_SPLASH", tagPath+"images/birdtextile.jpg");
        //if(!allowServerChange) {
        //  $('#serverTagBuffer').remove();
        //}
    
        // if(!allowAuthoringMode){
        //     $('#authoringButtonBuffer').remove();
        // }
        
        if (TAG.Worktop.Database.getLocked() != undefined && TAG.Worktop.Database.getLocked() != "undefined") {
            goToCollectionsButton.text("Go to Artwork");
        }
        
        goToCollectionsButton.on('click', function () {
            if (TAG.Worktop.Database.getLocked()) {
                TAG.Worktop.Database.getArtworks(function (result) {
                    $.each(result, function (index, artwork) {
                        if (artwork.Identifier === TAG.Worktop.Database.getLocked()) {
                            if (artwork.Metadata.Type === "VideoArtwork") { // video                  
                                var videoPlayer = TAG.Layout.VideoPlayer(artwork);
                                TAG.Util.UI.slidePageLeftSplit(root, videoPlayer.getRoot());

                                currentPage.name = TAG.Util.Constants.pages.VIDEO_PLAYER;
                                currentPage.obj = videoPlayer;

                            } else {
                                var artworkViewer = TAG.Layout.ArtworkViewer({
                                    doq: artwork,
                                });
                                var newPageRoot = artworkViewer.getRoot();
                                newPageRoot.data('split', root.data('split') === 'R' ? 'R' : 'L');

                                TAG.Util.UI.slidePageLeftSplit(root, newPageRoot);

                                currentPage.name = TAG.Util.Constants.pages.ARTWORK_VIEWER;
                                currentPage.obj = artworkViewer;
                            }
                               
                        }
                    });
                });

                return false;
            } else {
                switchPage();
            }
        });
        
        setImagePaths(main);
        setUpCredits();
        setUpInfo(main);
        applyCustomization(main);
        initializeHandlers();

        openDialog();
        // authoringButtonBuffer.on('click', function (evt) {
        //     evt.stopPropagation();
        // });

        //opens the collections page on touch/click
        function switchPage() {
            var collectionsPage;

            goToCollectionsButton.off('click');
            collectionsPage = TAG.Layout.CollectionsPage(); // TODO merging
            TAG.Util.UI.slidePageLeft(collectionsPage.getRoot());

            currentPage.name = 2; // TODO merging TAG.Util.Constants.pages.COLLECTIONS_PAGE;
            currentPage.obj  = collectionsPage;
        }

        // Test for browser compatibility
        if(!isBrowserCompatible()) {
            handleIncompatibleBrowser();
        }
    }   
    
    var saveClick = $.debounce(500, false, function (e) {
        var address = serverInput.val();
        switch (address) {
            case 'tagunicorn':
                var unicorn = $(document.createElement('img'));
                unicorn.attr('src', tagPath + 'images/unicorn.jpg');
                unicorn.css({
                    width: '100%',
                    height: '100%',
                    'z-index': 2147483647, // we really want this unicorn to show up
                    display: 'none',
                    position: 'absolute',
                });
                tagContainer.append(unicorn);
                unicorn.fadeIn(500);
                setTimeout(function () {
                    $('img').attr('src', tagPath + 'images/unicorn.jpg');
                    $('.background').css('background-image', 'url(' + tagPath + '"images/unicorn.jpg")');
                    unicorn.fadeOut(500, function () { unicorn.remove(); });
                }, 5000);
                return;
            case 'tagtest':
            case 'tagtestserver.cloudapp.net':
                address = 'tagtestserver.cloudapp.net';
                break;
            case 'tagdemo':
            case 'tagdemo.cloudapp.net':
                address = 'tagdemo.cloudapp.net';
                break;
            case 'taglive':
            case 'browntagserver.com':
                address = 'browntagserver.com';
                break;
            case 'taglocal':
            case '10.116.71.58':
                address = '10.116.71.58';
                break;
            case 'sam':
            case 'seattleartmuseum':
            case 'tag.seattleartmuseum.org':
                address = 'tag.seattleartmuseum.org'
                break;
            default:
                break;
        }
        serverError.html('Connecting...');
        serverError.css({ "visibility": "visible" });
        TAG.Worktop.Database.changeServer(address, false, function () {
            TAG.Layout.StartPage(null, function (page) {
                TAG.Util.UI.slidePageRight(page);
            });
        }, function () {
            serverError.html('Server connection failed. Contact the server administrator.');
            serverError.css({ "visibility": "visible" });
        });
    });

    serverSubmit.on('click', saveClick);
    serverInput.keypress(function(e){
        if (e.which === 13) {
            saveClick();
        }
    });
    serverSubmit.on("mousedown", function () {
        serverSubmit.css({"background-color": PRIMARY_FONT_COLOR, "color": "black"});
    });
    
    passwordSubmit.on("mouseleave", function () {
        passwordSubmit.css({ "background-color": "transparent", "color": PRIMARY_FONT_COLOR });

    })
    goToCollectionsButton.on("mouseleave", function () {
        goToCollectionsButton.css({ "background-color": "white", "color": "black" });

    })

    serverInput.focusout(function () {
        if (!serverInput.val()) {
            serverInput.attr('value', localStorage.ip);
        }
    });
    var passwordClick = $.debounce(500, false, function(e){
        e.preventDefault();
        e.stopPropagation();

        //To disable access to authoring for the web:
        //Comment out the if statement and the entire else block. 
        //Only leave the TAG.Auth.checkPassword() statement in.

        if(IS_WINDOWS) {
            TAG.Auth.checkPassword(authoringInput.val(), function () { 
                enterAuthoringMode();
            }, function () {
                passwordError.html('Invalid Password. Please try again...');
                passwordError.css({'visibility':'visible'});
            }, function () {
                passwordError.html('There was an error contacting the server. Contact a server administrator if this error persists.');
                passwordError.css({'visibility':'visible', 'color': 'rgba(255, 255, 255)'});                    
            });  
            
        } else {
            passwordError.html('Authoring mode is only accessible from the Windows 8 app');
            passwordError.css({'visibility':'visible'});
            passwordError.css({'color':'rgba(255, 255, 255, 1)'});
        }
    });


    function authClick(){
        passwordSubmit.on('click', passwordClick);

        passwordSubmit.on("mousedown", function () {
            passwordSubmit.css({ "background-color": PRIMARY_FONT_COLOR, "color": "black" });
        });
    
    //Enter can be pressed to submit the password form...
        authoringInput.keypress(function (e) {
            if (e.which === 13) {  // enter key press
                e.preventDefault();
                e.stopPropagation();
                TAG.Auth.checkPassword(authoringInput.val(), function () {
                    enterAuthoringMode()
                }, function () {
                    passwordError.html('Invalid Password. Please try again...');
                    passwordError.css({'visibility':'visible'});
                }, function () {
                    passwordError.html('There was an error contacting the server. Contact a server administrator if this error persists.');
                    passwordError.css({'visibility':'visible'});
                });
            }
        });
    }

      
    var serverCircle = $(document.createElement('img'));
    serverCircle.css({
        'width': '20px',
        'height': 'auto',
        'display': 'none',
        'margin-right': '3%',
        'margin-top': '2.5%',
        'float': 'right'
    });
    serverCircle.attr('src', tagPath+'images/icons/progress-circle.gif');



       
    /**
    * Checks if TAG is compatible with the current browser.
    *
    * @method isBrowserCompatible
    * @author Athyuttam Eleti
    * @return true if the browser is compatible with TAG, false if it isn't
    */
    function isBrowserCompatible() {
        //console.log("\n///// Browser Compatibility /////")
        var userAgent = navigator.userAgent.toLowerCase();
        //console.log("userAgent: " + navigator.userAgent);

        // Android and iOS are incompatible
        if(userAgent.indexOf('android') >= 0 || userAgent.indexOf('iphone') >= 0 || userAgent.indexOf('ipad') >= 0 || userAgent.indexOf('ipod') >= 0) {
            if(userAgent.indexOf('android') >= 0) {
                console.log("Detected Android Device. Unsupported browser.");
            } else if (userAgent.indexOf('iphone') >= 0) {
                console.log("Detected iPhone. Unsupported browser.");
            } else if (userAgent.indexOf('ipad') >= 0) {
                console.log("Detected iPad. Unsupported browser.");
            } else if(userAgent.indexOf('ipod') >= 0) {
                console.log("Detected iPod. Unsupported browser.");
            }
            return false;
        } else {
            var browser = getBrowserVersion();
            //console.log("Browser Version: " + browser);

            browser = browser.toLowerCase();
            var version = 0;

            // Opera is incompatible
            if(browser.indexOf('opera') >= 0 || userAgent.indexOf('opr') >= 0) {
                console.log("Detected Opera. Unsupported browser.");
                return false;
            } 
            // Chrome 31+
            else if(browser.indexOf('chrome') >= 0) {
                version = browser.substring(browser.indexOf(' ') + 1, browser.indexOf("."));
                console.log("Detected Chrome Version: " + version);
                return(version >= 31);
            } 
            // Safari 7+
            else if(browser.indexOf('safari') >= 0) {
                var detailedVersion = browser.substring(browser.indexOf(' ', browser.indexOf(' ') + 1) + 1);
                version = detailedVersion.substring(0, detailedVersion.indexOf("."));
                console.log("Detected Safari Version: " + version);
                return(version >= 7);
            } 
            // Firefox 28+
            else if(browser.indexOf('firefox') >= 0) {
                version = browser.substring(browser.indexOf(' ') + 1, browser.indexOf("."));
                console.log("Detected Firefox Version: " + version);
//                var popupMsg = $(TAG.Util.UI.popUpMessage(null,"Pinch zoom is not currently well supported in Firefox. When viewing artwork, please use two-finger scroll."),"OK");
//                root.append(popupMsg);
//                popupMsg.show();
                //document.getElementsByName("viewport")[0].content="width=device-width, maximum-scale=1.0";
                //$('meta[name=viewport]').attr('content','width='+$(window).width()+',user-scalable=no, maximum-scale=1.0');
                return(version >= 28);
            } 
            // Internet Explorer 10+
            else if(browser.indexOf('msie') >= 0 || browser.indexOf('ie') >= 0) {
                version = browser.substring(browser.indexOf(' ') + 1, browser.indexOf("."));
                //console.log("Detected IE Version: " + version);
                return(version >= 10);
            } 
            // Other browsers are incompatible
            else {
                console.log("Unsupported browser.");
                return false;
            }
        }
    }

    /** 
    * Finds the current browser version.
    * Code from http://stackoverflow.com/questions/5916900/detect-version-of-browser
    *
    * @method getBrowserVersion
    * @author Athyuttam Eleti
    * @return Browser name followed by version e.g. "Chrome 34.0.1847.116"
    */
    function getBrowserVersion() {
        var ua= navigator.userAgent, tem, 
        M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) || [];

        if(/trident/i.test(M[1])){
            tem=  /\brv[ :]+(\d+(\.\d+)?)/g.exec(ua) || [];
            return 'IE '+(tem[1] || '');
        }

        M= M[2]? [M[1], M[2]]:[navigator.appName, navigator.appVersion, '-?'];
        if((tem= ua.match(/version\/([\.\d]+)/i))!= null) M[2]= tem[1];

        return M.join(' ');
    }

    /**
    * Displays a dialog box indicating that the user is using an
    * incompatible browser. Points them to links to download the latest
    * version of supported browsers such as IE, Chrome, Safari and Firefox.
    *
    * @method handleIncompatibleBrowser
    * @author Athyuttam Eleti
    */
    function handleIncompatibleBrowser() {
        var tagContainer = $('#tagRoot');

        // Creating Overlay
        var browserDialogOverlay = $(document.createElement('div'));
        browserDialogOverlay.attr('id', 'browserDialogOverlay');
        browserDialogOverlay.addClass('dialogBoxOverlay');
        tagContainer.prepend(browserDialogOverlay);

        // Creating Dialog Box Container (required for centering)
        var browserDialogContainer = $(document.createElement('div'));
        browserDialogContainer.attr('id', 'browserDialogContainer');
        browserDialogContainer.addClass('dialogBoxContainer');
        browserDialogOverlay.append(browserDialogContainer);

        // Creating Dialog Box
        var browserDialog = $(document.createElement('div'));
        browserDialog.attr('id', 'browserDialog');
        browserDialog.addClass('dialogBox');
        browserDialogContainer.append(browserDialog);

        // Content
        var browserDialogPara = $(document.createElement('p'));
        browserDialogPara.attr('id', 'dialogBoxPara');
        browserDialogPara.text("Touch Art Gallery is not supported in your browser. Please download or update to a newer browser.");
        browserDialog.append(browserDialogPara);

        // Browser Icon Container
        var browserIcons = $(document.createElement('div'));
        browserIcons.attr('id', 'browserIcons');
        browserDialog.append(browserIcons);

        // Browser Icon Links
        var ieIconLink = $(document.createElement('a')).attr('href', 'http://windows.microsoft.com/ie');
        var chromeIconLink = $(document.createElement('a')).attr('href', 'https://www.google.com/chrome');
        var firefoxIconLink = $(document.createElement('a')).attr('href', 'http://www.firefox.com');
        var safariIconLink = $(document.createElement('a')).attr('href', 'http://www.apple.com/safari');

        var linksArray = [ieIconLink, chromeIconLink, firefoxIconLink, safariIconLink];
        for(var i = 0; i < linksArray.length; i++) {
            var current = linksArray[i]
            current.attr('target', '_blank'); // Set target="_blank" to open links in new tab
            current.addClass('browserIconLink'); // Set the corresponding CSS class to each link
        }

        browserIcons.append(ieIconLink, chromeIconLink, firefoxIconLink, safariIconLink);

        // Browser Icon Images
        var ieIcon = $(document.createElement('img')).attr('title', 'Internet Explorer').attr('src', tagPath+'images/icons/browserIcons/ie.png');
        var chromeIcon = $(document.createElement('img')).attr('title', 'Google Chrome').attr('src', tagPath+'images/icons/browserIcons/chrome.png'); 
        var firefoxIcon = $(document.createElement('img')).attr('title', 'Firefox').attr('src', tagPath+'images/icons/browserIcons/firefox.png');
        var safariIcon = $(document.createElement('img')).attr('title', 'Safari').attr('src', tagPath+'images/icons/browserIcons/safari.png');

        ieIconLink.append(ieIcon);
        chromeIconLink.append(chromeIcon);
        firefoxIconLink.append(firefoxIcon);
        safariIconLink.append(safariIcon);

        $('#browserIcons a img').addClass('browserIcon');
    }
    
    /**
    * adjusts the text to fit the screen size
    * @method fixText
    */
    function fixText() { // TODO fix this up, make it cleaner
            var nameDivSize,
                nameSpanSize,
                fontSizeSpan,
                subheadingFont;
            if (TAG.Util.elementInDocument(museumName)) {
                subheadingFont = parseInt($(museumLoc).css('font-size'), 10);
                nameDivSize = $(museumName).height();
                fontSizeSpan = $(museumName).height();
                
                var museumNameSpan = document.getElementById("museumNameSpan"); //can't seem to find this variable in scope
                $(museumNameSpan).css('height', nameSpanSize);               
            }
        }

    /**
    * initializes the handlers for various 'click' functions including setting up a server
    * @method initializeHandlers
    */
    function initializeHandlers(){
        logoContainer.on('click', function (evt) {
            evt.stopPropagation();
        });

        // serverSetUpContainer.on('click', function() {
        //     TAG.Util.UI.ChangeServerDialog();
        // });

        // serverTagBuffer.on('click', function (evt) {
        //     evt.stopPropagation();
        // });

        goToCollectionsButton.css({ "border": "1px solid #fff" });

        goToCollectionsButton.on('click', 'a', function (evt) {
            // this === the link that was clicked
            var href = $(this).attr("href");
            evt.stopPropagation();
        });
        goToCollectionsButton.on("mousedown", function () {
            goToCollectionsButton.css({"background-color": "transparent", "color": "white"});
        });
    }


    /**
    * gets the paths for all the images displayed on the splash screen
    * @method setImagePaths
    * @param {Object} main    contains all the image links
    */
    function setImagePaths(main){
        var fullScreen,
            overlayColor,
            overlayTransparency,
            imageBgColor,
            logo;
            
            
        // set image paths
        // root.find('#expandImage').attr('src', tagPath+'images/icons/Left.png');
        // root.find('#handGif').attr('src', tagPath+'images/RippleNewSmall.gif');

        fullScreen = root.find('#innerContainer');
        fullScreen.css('background-image', "url(" + TAG.Worktop.Database.fixPath(main.Metadata["BackgroundImage"]) + ")");
        //fullScreen.css({'opacity':'0.9'});

        overlayColor = main.Metadata["OverlayColor"];
        overlayTransparency = main.Metadata["OverlayTransparency"];

        backgroundColor = TAG.Util.UI.hexToRGB(overlayColor) + overlayTransparency + ')';

        imageBgColor = '#' + main.Metadata["IconColor"];
        logoContainer = root.find('#logoRow');
        logoContainer.css({ 'background-color': 'transparent' });

        // logo = root.find('#logo');
        // logo.attr('src', TAG.Worktop.Database.fixPath(main.Metadata["Icon"]));
    }

    
    /**
    * Sets up the credits box with its content including text and images. Also includes function for animation of credits.
    * @method setUpCredits
    */
    function setUpCredits(){
        var brownInfoBox,
            expandInfoButton,
            expandImage,
            tagName,
            fullTag,
            infoExpanded,
            brownPeople,
            sponsoredText,
            microsoftLogo,
            brownLogo;

        // brownInfoBox = root.find('#brownInfoBox');
        // brownInfoBox.on('click', expandInfo);

        // expandInfoButton = root.find('#expandInfoButton');
        // expandImage = root.find('#expandImage');
        // tagName = root.find('#tagName');
        // fullTag = root.find('#fullTag');

        // infoExpanded = false; //used to expand/collapse info
        // brownPeople = $(document.createElement('div'));
        // brownPeople.attr('id', 'brownPeople');
        // brownPeople.text('Brown University \nHello');

        // sponsoredText = $(document.createElement('label'));
        // sponsoredText.attr('id', 'sponsoredText');
        // sponsoredText.css('overflow', 'hidden');
        // sponsoredText.css('white-space', 'pre');
        // sponsoredText.text('Sponsored by');

        microsoftLogo = root.find('#msLogo');
        // microsoftLogo.attr('id', 'microsoftLogo');
        microsoftLogo.attr('src', tagPath+'images/microsoft_logo_transparent.png');

        brownLogo = root.find('#brownLogo');
        brownLogo.attr('src', tagPath + 'images/brown_logo_transparent.png');


        /**
        * animation of credits when user clicks 
        * @method expandInfo
        * @param {Object} event     the trigger event for animation, in this case a click
        */
        // function expandInfo(event) {
        //     event.stopPropagation();
        //     if (infoExpanded) {
        //         infoExpanded = false;
        //         expandImage.css({ 'transform': 'scaleX(1)' });
        //         expandInfoButton.animate({ width: '15%', 'border-top-left-radius': '0px' }, 700);
        //         brownInfoBox.animate({ width: '20%', height: '10%', right: "0%", 'border-top-left-radius': '0px' }, 700);
        //         sponsoredText.remove();
        //         microsoftLogo.remove();
        //         fullTag.animate({ left: '20%', top: '60%', 'font-size': '90%' }, 700);
        //         tagName.animate({ left: '20%', top: '10%', 'font-size': '200%' }, 700);
        //         brownPeople.animate({ "left": "75%", "top": "75%", 'font-size': '0%' }, 500);
        //     }
        //     else {
        //         infoExpanded = true;
        //         expandInfoButton.animate({ width: '8%', 'border-top-left-radius': '20px' }, 700);
        //         brownInfoBox.animate({ width: '60%', height: '25%', right: "0%", 'border-top-left-radius': '20px' }, 700);
        //         brownInfoBox.append(brownPeople);
        //         brownInfoBox.append(sponsoredText);
        //         brownInfoBox.append(microsoftLogo);
        //         expandImage.css({ 'transform': 'scaleX(-1)' });
        //         brownPeople.css({ "right": "0%", "bottom": "0%", "position": "absolute", "font-size": "0%" });
        //         brownPeople.animate({ "left": "12%", "top": "51%", "position": "absolute", "font-size": "61%" }, 700, 'swing', function () { $(brownPeople).fitText(5); });
        //         tagName.animate({ left: '12%', top: '3%', 'font-size': '300%' }, 700);
        //         fullTag.animate({ left: '12%', top: '35%', 'font-size': '130%' }, 700);
        //     }
        // }
    }

    
    /**
    * sets up the info div which contains all the museum information
    * @method setUpInfo
    * @param {Object} main    contains all the museum information
    */
    function setUpInfo(main){
        // var infoTextHolder,
        //     infoDiv;
        
        // infoTextHolder = root.find('#infoTextHolder');
        // infoDiv = root.find('#infoDiv');
        // infoDiv.css({
        //     'background-color': backgroundColor
        // });

        // touchHint = root.find('#touchHint');
        // handGif = root.find('#handGif');

        // setUpMuseumInfo(main);
    }

    /**
    * Applying Customization Changes
    * @method applyCustomization
    */
    function applyCustomization(main) {
        var color = '#' + main.Metadata["PrimaryFontColor"];
        $('.primaryFont').css({ 
            'color': color
            //'font-family': main.Metadata["FontFamily"]
        });
        serverInput.css({
            'border-color': color,
            'color' : color
        });
        serverSubmit.css({
            'border-color': color
        });
        authoringInput.css({
            'border-color': color,
            'color' : color
        });
        passwordSubmit.css({
            'border-color': color
        });
        serverError.css({
            'color': color
        });
        passwordError.css({
            'color': color
        });
    }

    /**
    * Fills in all museum info including name and location
    * @method setUpMuseumInfo
    * @param {Object} main     contains all the museum information
    */
    function setUpMuseumInfo(main){
        // var museumName,
        //     museumNameSpan,
        //     tempName,
        //     museumLoc,
        //     museumLocSpan,
        //     tempLoc,
        //     museumInfoDiv,
        //     museumInfoSpan,
        //     tempInfo,
        //     primaryFontColor,
        //     secondaryFontColor;

        
        // primaryFontColor = options.primaryFontColor ? options.primaryFontColor : main.Metadata["PrimaryFontColor"];
        // secondaryFontColor = options.secondaryFontColor ? options.secondaryFontColor : main.Metadata["SecondaryFontColor"];
        // museumName = root.find('#museumName');
        // museumNameSpan = root.find('#museumNameSpan');
        // tempName = main.Metadata["MuseumName"];
        // if (tempName === undefined) {
        //     tempName = "";
        // }
        // museumNameSpan.text(tempName);

        // museumLoc = root.find('#museumLoc');
        // museumLocSpan = root.find('#museumLocSpan');
        // tempLoc = main.Metadata["MuseumLoc"];
        // if (tempLoc === undefined) {
        //     tempLoc = "";
        // }

        // museumLocSpan.text(tempLoc);

        // that.fixText = fixText;

        // museumInfoDiv = root.find('#museumInfoDiv');

        // museumInfoSpan = root.find('#museumInfoSpan');
        // tempInfo = main.Metadata["MuseumInfo"];
        // if (!tempInfo) {
        //     tempInfo = "";
        // }

        // if (IS_WINDOWS) {
        //     museumInfoSpan.html(tempInfo);
        // } else {
        //     museumInfoSpan.html(Autolinker.link(tempInfo , {email: false, twitter: false}));
        // }
        
        // $(primaryFont).css({ 
        //     'color': '#' + primaryFontColor,
        //     'font-family': main.Metadata["FontFamily"]
            
        // });
        // $(secondaryFont).css({
        //     'color': '#' + secondaryFontColor,
        //     'font-family': main.Metadata["FontFamily"]

        // });

    }

    /**Opens authoring mode password dialog
     * @method openDialog
     */
    function openDialog() {
         authClick();

         if(localStorage.ip === 'tagtestserver.cloudapp.net') {
             $('#authoringInput').attr('value', 'Test1234');
        } else if (localStorage.ip === 'localhost') {
             $('#authoringInput').attr('value', 'admin');
         }
    }

    /**Loads authoring mode Settings View
     * @method enterAuthoringMode
     */
    function enterAuthoringMode() {
        goToCollectionsButton.on('click', function() {;});
        // authoringButtonContainer.off('click');
        var authoringMode = new TAG.Authoring.SettingsView();
        TAG.Util.UI.slidePageLeft(authoringMode.getRoot());
    }
 
    /**
    * @method getRoot
    * @return    the root of the splash screen DOM
    */
    function getRoot() {
        return root;
    }
    that.getRoot = getRoot;

    return that;
};

TAG.Layout.StartPage.default_options = {
    repository: "http://cs.brown.edu/research/lads/LADS2.0Data/repository.xml",
};

;
TAG.Util.makeNamespace("TAG.Layout.ArtworkViewer");

/**
 * The artwork viewer, which contains a sidebar with tools and thumbnails as well
 * as a central area for the deepzoom image.
 * @class TAG.Layout.ArtworkViewer
 * @constructor
 * @param {Object} options              some options for the artwork viewer page
 * @param {HTML Element} container      the root container 
 * @return {Object}                     some public methods
 */
TAG.Layout.ArtworkViewer = function (options, container) { // prevInfo, options, exhibition) {
    "use strict";

    options = options || {}; // cut down on null checks later

    var // DOM-related
        root                = TAG.Util.getHtmlAjax('Artmode.html'),
        sideBar             = root.find('#sideBar'),
        toggler             = root.find('#toggler'),
        togglerImage        = root.find('#togglerImage'),
        backButton          = root.find('#backButton'),
        linkButton          = root.find('#linkButton'),
        linkButtonContainer = root.find('#linkContainer'),
        //locHistoryDiv       = root.find('#locationHistoryDiv'),
        info                = root.find('#info'),
        loadingArea          = root.find('#loadingArea'),
        locHistory          = root.find('#locationHistory'),
        locHistoryContainer = root.find('#locationHistoryContainer'),
        locationPanelDiv = null,
        locHistoryToggle = null,
        locHistoryToggleSign = null,
        isOpen = false,
        that = this,
        locked = TAG.Worktop.Database.getLocked(),     //Check for locked
        // constants
        FIX_PATH = TAG.Worktop.Database.fixPath,
        PRIMARY_FONT_COLOR = options.primaryFontColor ? options.primaryFontColor : TAG.Worktop.Database.getMuseumPrimaryFontColor(),
        SECONDARY_FONT_COLOR = options.secondaryFontColor ? options.secondaryFontColor : TAG.Worktop.Database.getMuseumSecondaryFontColor(),
        FONT = TAG.Worktop.Database.getMuseumFontFamily(),

        // input options
        doq                 = options.doq,              // the artwork doq
        prevPage            = options.prevPage,         // the page we came from (string)
        prevScroll          = options.prevScroll || 0,  // scroll position where we came from
        prevCollection      = options.prevCollection,   // collection we came from, if any
        prevTag             = options.prevTag,          // sort tag of collection we came from, if any
        prevMult            = options.prevMult, 
        prevPreview         = options.prevPreview,      //previous artwork/media that was previewing (could be different than doq for assoc media view)     
        prevPreviewPos       = options.prevPreviewPos,
        previewing 	        = options.previewing, 	   // if we are previewing in authoring (for styling)
        assocMediaToShow    = options.assocMediaToShow,
        wasOnAssocMediaView = options.onAssocMediaView,

        // misc initialized vars  
        locHistoryActive = false,                   // whether location history is open
        locClosing       = false,                   // whether location history is closing
        locOpening       = false,                   // whether location history is opening
        drawers          = [],                      // the expandable sections for assoc media, tours, description, etc...
        mediaHolders     = [],                      // array of thumbnail buttons
        loadQueue        = TAG.Util.createQueue(),  // async queue for thumbnail button creation, etc
        screenWidth      = $('#tagRoot').width(),      // Width of entire tag screen (for split screen styling)
        

        // misc uninitialized vars
        locationList,                               // location history data
        customMapsLength,
        map,                                        // Bing Maps map for location history
        annotatedImage,                             // an AnnotatedImage object
        associatedMedia,                            // object of associated media objects generated by AnnotatedImage
        manipulate;                                 // Manipulation method
                               
    // get things rolling if doq is defined (it better be)
    doq && init();

    return {
        getRoot: getRoot,
    };
    root.attr('unselectable','on');
    root.css({'-moz-user-select':'-moz-none',
           '-o-user-select':'none',
           '-khtml-user-select':'none', 
           '-webkit-user-select':'none',
           '-ms-user-select':'none',
           'user-select':'none'
        });
    root.bind('selectstart', function(){ return false; });
    sideBar.disableSelection();
    sideBar.attr('unselectable','on');
    sideBar.css({'-moz-user-select':'-moz-none',
           '-o-user-select':'none',
           '-khtml-user-select':'none', 
           '-webkit-user-select':'none',
           '-ms-user-select':'none',
           'user-select':'none'
        });
    sideBar.bind('selectstart', function(){ return false; });
    /**
     * Initiate artmode with a root, artwork image and a sidebar on the left
     * @method init
     */
    function init() {
        var head,
            script,
            meta;

        if (!idleTimer && !previewing) {
            idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
            idleTimer.start();
        }
        if (idleTimer && previewing) {
            idleTimer.kill();
        }
        if (locked === doq.Identifier) {
            idleTimer.kill();
        }

        var progressCircCSS = {
            'position': 'absolute',
            'z-index': '50',
            'height': 'auto',
            'width': '5%',
            'left': '47.5%',
            'top': '42.5%'
        };
        
        TAG.Util.showProgressCircle(loadingArea, progressCircCSS, '0px', '0px', false);
        var loadingLabel = $(document.createElement('label'));
        loadingLabel.css({
            'position': 'absolute',
            'left': '40%',
            'top': '55%',
            'font-size': '200%',
            'color': 'white',
            'opacity': '1'
        });
        loadingLabel.text('Loading Viewer');
        loadingArea.append(loadingLabel);

        // add script for displaying bing maps
        
        head = document.getElementsByTagName('head').item(0);
        script = document.createElement("script");
        script.charset = "UTF-8";
        script.type = "text/javascript";
        script.src = "http://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0";
        head.appendChild(script);
        meta = document.createElement('meta');
        meta.httpEquiv = "Content-Type";
        meta.content = "text/html; charset=utf-8";
        head.appendChild(meta);
        
        locationList = TAG.Util.UI.getLocationList(doq.Metadata);

        annotatedImage = TAG.AnnotatedImage({
            root: root,
            doq:  doq,
            callback: function () {
                associatedMedia = annotatedImage.getAssociatedMedia();
                associatedMedia.guids.sort(function (a, b) {
                    return associatedMedia[a].doq.Name.toLowerCase() < associatedMedia[b].doq.Name.toLowerCase() ? -1 : 1;
                });
                try { // TODO figure out why loadDoq sometimes causes a NetworkError (still happening?)
                    annotatedImage.openArtwork(doq);
                } catch(err) {
                    debugger;
                    console.log(err); // TODO if we hit a network error, show an error message
                }
                TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                initSplitscreen();
                createSeadragonControls();
                TAG.Worktop.Database.getMaps(doq.Identifier, function (mps) {
                    customMapsLength = mps.length;
                    makeSidebar();
                });
                    
                
                loadingArea.hide();
            },
            noMedia: false
        });
    }

    /**
     * Initializes splitscreen functionality
     * @method initSplitscreen
     */
    function initSplitscreen() {
        var splitscreenContainer = $(document.createElement('div')),
            splitscreenIcon = $(document.createElement('img'));

        splitscreenContainer.attr('id', 'splitscreenContainer');
        splitscreenContainer.css({
            'background-color': 'rgba(0,0,0,0.6)',
            'border-top-left-radius': '3.5px',
            'height': '10%',
            'position': 'absolute',
            'right': '0%',
            'text-align': 'center',
            'top': '90%',
            'vertical-align': 'center',
            'width': '10%',
            'z-index': '500'
        });

        splitscreenIcon.attr({
            id: 'splitscreen-icon',
            src: tagPath+'images/SplitWhite_dotted.svg'
        });
        splitscreenIcon.css({
            height: '50%',
            left: '2%',
            opacity: '0.6',
            //position: 'absolute',
            'margin-top': '8%',
            width: '75%'
        });

        splitscreenContainer.on('click', function () {
            var collectionsPage,
                collectionsPageRoot;
            if (!TAG.Util.Splitscreen.isOn()) {
                if (isOpen) {
                    locationPanelDiv.animate({ width: '0%' }, 350, function () {
                        locHistory.text("Maps");
                        locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
                        locHistoryContainer.css({ "background-color": "transparent" });
                        locationPanelDiv.hide();
                        locHistoryToggle.hide();
                        locHistoryToggleSign.attr("src", tagPath + 'images/icons/plus.svg');
                        isOpen = false;
                        toggler.show();

                        collectionsPage = TAG.Layout.CollectionsPage();

                        collectionsPageRoot = collectionsPage.getRoot();
                        collectionsPageRoot.data('split', 'R');

                        splitscreenContainer.css('display', 'none');
                        TAG.Util.Splitscreen.init(root, collectionsPageRoot);
                        annotatedImage.viewer.scheduleUpdate();
                        //annotatedImage.viewer.viewport.applyConstraints();
                        TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                    });
                } else {
                    locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
                    collectionsPage = TAG.Layout.CollectionsPage();
                    collectionsPage.getRoot().find('#mainCollection').css('width', '60%');

                    collectionsPageRoot = collectionsPage.getRoot();
                    collectionsPageRoot.data('split', 'R');

                    splitscreenContainer.css('display', 'none');
                    TAG.Util.Splitscreen.init(root, collectionsPageRoot);
                    annotatedImage.viewer.scheduleUpdate();
                    //annotatedImage.viewer.viewport.applyConstraints();
                    TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                }
                
            }
        });

        splitscreenContainer.append(splitscreenIcon);

        var splitScreenLabel = $(document.createElement('div')).css({'font-size':'40%', 'bottom':'0%', 'margin-top':'-2%'}).text('Splitscreen').appendTo(splitscreenContainer);

        root.append(splitscreenContainer);
        if (TAG.Util.Splitscreen.isOn()) {
            splitscreenContainer.css('display', 'none');
        }
    }

    /**
     * Add controls and key handlers for manual Seadragon manipulation
     * @method createSeadragonControls
     */
    function createSeadragonControls() {
        var container        = root.find('#seadragonManipContainer'),
            slideButton      = root.find('#seadragonManipSlideButton'),
            tagRoot          = $('#tagRoot'),
            top              = 0,
            count            = 0,
            panDelta         = 20,
            zoomScale        = 1.1,
            containerFocused = true,
            interval;

        // splitscreen
        if (root.data('split') === 'R' && TAG.Util.Splitscreen.isOn()) {
            container.css({
                'right': 'auto',
                'left': '0%'
            });
            slideButton.css({ //fix the rounded edge to be on the correct side
                'border-bottom-left-radius': '0px',
                'border-bottom-right-radius': '3.5px',
            });
        }

        //To-do figure out best max-width, min width
        if (previewing) {
            return;
        }
        container.css('width', Math.max(160,Math.min($('#tagRoot').width() * 0.19,400)));
        var containerHeight = container.width()*(111/163)
        container.css({
            'height': containerHeight + 'px',
            'top' : '-' + containerHeight + 'px',
            'min-width' : container.width()
        });
        slideButton.css({
            'padding-top': 0.05 * container.width() + 'px',
            'padding-bottom': 0.05 * container.width() + 'px'
        })


        slideButton.on('click', function () {
            count = 1 - count;
            container.animate({
                top: top
            });
            if (count === 0){
                top = '0px';
                slideButton.html("Show Controls");
            } else {
                top = '-' + containerHeight + 'px';
                slideButton.html('Hide Controls');
            }   
        });
        
        TAG.Telemetry.register(slideButton,'click','seadragon_button_panel_toggled',function(tobj){
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
            tobj.mode = 'Kiosk';
        });
        container.append(slideButton);
        var sdleftbtn = createButton('leftControl', tagPath + 'images/icons/zoom_left.svg'),
            sdrightbtn = createButton('rightControl', tagPath + 'images/icons/zoom_right.svg'),
            sdupbtn = createButton('upControl', tagPath + 'images/icons/zoom_up.svg'),
            sddownbtn = createButton('downControl', tagPath + 'images/icons/zoom_down.svg');
        container.append(sddownbtn);
        container.append(sdupbtn);

        if (sddownbtn.width()) {
            console.log("got valid height"+ sddownbtn.height());
            sdleftbtn.css('height', sddownbtn.width());
            sdrightbtn.css('height', sddownbtn.width());
        }
        container.append(sdleftbtn);
        container.append(sdrightbtn);

        var radius = (sdrightbtn.position().left - sdleftbtn.position().left + sdrightbtn.width()) / 2;
        var centery = sdleftbtn.position().top + sdleftbtn.height() / 2;
        //sdupbtn.css('top', centery - radius +5+ 'px');
        //sddownbtn.css('top', centery + radius -sdleftbtn.width() +15+ 'px');
        container.append(createButton('zinControl',   tagPath+'images/icons/zoom_plus.svg'));
        container.append(createButton('zoutControl',  tagPath+'images/icons/zoom_minus.svg'));

        var crossfadeSlider = $(document.createElement('input')).attr({
            'id': 'crossfadeSlider',
            'type': 'range',
            'value': 1,
            'min': 0,
            'max': 1,
            'step': 0.05
        });

        crossfadeSlider.on('change mousemove', function() {
            $('.mediaOuterContainer').css('opacity', crossfadeSlider.val());
        });
        crossfadeSlider.on('touchmove', function(e) {
            e.preventDefault();
            $('.mediaOuterContainer').css('opacity', crossfadeSlider.val());
        });


        /**
         * Create a seadragon control button
         * @method createButton
         * @param {String} id        the id for the new button
         * @param {String} imgPath   the path to the button's image
         * @param {Number} left      css left property for button
         * @param {Number} top       css top property for button
         * @return {jQuery obj}      the button
         */
        function createButton(id, imgPath, left, top) {
            var img = $(document.createElement('img'));

            img.attr({
                src: imgPath,
                id:  id
            });

            img.removeAttr('width');
            img.removeAttr('height');
            
            img.css({
                left: left + "px",
                top: top + "px"
            });

            if (id === 'leftControl' || id === 'rightControl'){
                img.addClass('seadragonManipButtonLR');
            } else if (id === 'upControl'|| id === 'downControl'){
                img.addClass('seadragonManipButtonUD');
            } else if (id === 'zinControl'|| id === 'zoutControl'){
                img.addClass('seadragonManipButtoninout');
            }

            return img;
        }
        
        TAG.Telemetry.register(root.find("#leftControl,#rightControl,#downControl,#upControl,#zoutControl,#zinControl"), 'click', 'seadragon_control_clicked', function (tobj) {
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);;
            tobj.mode = 'Kiosk';
        });
        
        /**
         * Keydown handler for artwork manipulation; wrapper around doManip that first
         * prevents default key behaviors
         * @method keyHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function keyHandler(evt, direction) {
            evt.preventDefault();
            clearInterval(interval);
            doManip(evt, direction);
        }

        /**
         * Click handler for button in given direction; a wrapper around doManip that also
         * executes doManip in an interval if the user is holding down a button
         * @method buttonHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function buttonHandler(evt, direction) {
            doManip(evt, direction);
            clearInterval(interval);
            interval = setInterval(function() {
                doManip(evt, direction);
            }, 100);
        }

        /**
         * Do fixed manipulation in response to seadragon controls or key presses
         * @method doManip
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function doManip(evt, direction) {
            var pivot = annotatedImage.getMediaPivot();
            manipulate = annotatedImage.getToManip();

            if (direction === 'left') {
                manipulate({pivot: pivot, translation: {x: -panDelta, y: 0}, scale: 1}, null, true);
            } else if (direction === 'up') {
                manipulate({pivot: pivot, translation: {x: 0, y: -panDelta}, scale: 1}, null, true);
            } else if (direction === 'right') {
                manipulate({pivot: pivot, translation: {x: panDelta, y: 0}, scale: 1}, null,  true);
            } else if (direction === 'down') {
                manipulate({pivot: pivot, translation: {x: 0, y: panDelta}, scale: 1}, null, true);
            } else if (direction === 'in') {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: zoomScale});
            } else if (direction === 'out') {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: 1/zoomScale});
            }   
        }


        // tabindex code is to allow key press controls (focus needs to be on the TAG container)
        $('#tagContainer').attr("tabindex", -1);
        $("[tabindex='-1']").focus();
        $("[tabindex='-1']").css('outline', 'none');
        $("[tabindex='-1']").on('click', function() {
            $("[tabindex='-1']").focus();
            containerFocused = true;
            annotatedImage.dzManipPreprocessing();     //Tell AnnotatedImage that the main artwork is active
        });
        $("[tabindex='-1']").focus(function() {
            containerFocused = true;
        });
        $("[tabindex='-1']").focusout(function() {
            containerFocused = false;
        });

        // TODO merge: need to fix the $(...) calls above for splitscreen

        

        $(document).on('keydown', function(evt) {
            if(containerFocused) {
                switch(evt.which) {
                    case 37:
                        keyHandler(evt, 'left');
                        break;
                    case 38:
                        keyHandler(evt, 'up');
                        break;
                    case 39:
                        keyHandler(evt, 'right');
                        break;
                    case 40:
                        keyHandler(evt, 'down');
                        break;
                    case 187:
                    case 61:
                        keyHandler(evt, 'in');
                        break;
                    case 189:
                    case 173:
                        keyHandler(evt, 'out');
                        break;
                }
            }
        });

        $(document).keyup(function(evt){
            clearInterval(interval);
        });

        root.find('#seadragonManipContainer').on('click', function(evt) {
            evt.stopPropagation(); //Prevent the click going through to the main container
            evt.preventDefault();
            TAG.Util.IdleTimer.restartTimer();
        });

        root.find('#leftControl').on('mousedown', function(evt) {
            buttonHandler(evt, 'left');
        });
        root.find('#upControl').on('mousedown', function(evt) {
            buttonHandler(evt, 'up');
        });
        root.find('#rightControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'right');
        });
        root.find('#downControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'down');
        });
        root.find('#zinControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'in');
        });
        root.find('#zoutControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'out');
        });

        root.find('.seadragonManipButtonLR').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        root.find('.seadragonManipButtonUD').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        root.find('.seadragonManipButtoninout').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        TAG.Telemetry.register($("[tabindex='-1']"),'keydown','seadragon_key_pressed',function(tobj){
            if (containerFocused===false){
                return true;
            }
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
             tobj.mode = 'Kiosk';
        });
    }

    /**
     * Makes the artwork viewer sidebar
     * @method makeSidebar
     */
    function makeSidebar(mapslength) {
        var backBttnContainer = root.find("#backBttnContainer"),
            sideBarSections = root.find('#sideBarSections'),
            sideBarInfo = root.find('#sideBarInfo'),
            infoTitle = root.find('#infoTitle'),
            infoArtist = root.find('#infoArtist'),
            infoYear = root.find('#infoYear'),
            assetContainer = root.find('#assetContainer'),
            isBarOpen = true,
            currBottom = 0,
            item,
            fieldTitle,
            fieldValue,
            infoCustom,
            i,
            curr,
            button,
            descriptionDrawer,
            tourDrawer,
            locHistoryButton,
            mediaDrawer,
            xfadeDrawer,
            xfadeSlider,
            xfadeSliderPoint,
            isFading = false;

        sideBarInfo.css({
            'height' : sideBarSections.height()-25 + 'px'
        });
        if (locked !== doq.Identifier) {
            backButton.attr('src', tagPath + 'images/icons/Back.svg');
        } else {
            backButton.hide();
        }
        
        togglerImage.attr("src", tagPath + 'images/icons/Close.svg');
        infoTitle.text(doq.Name);
        infoArtist.text(doq.Metadata.Artist);
        infoYear.text(doq.Metadata.Year);
        infoTitle.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        infoArtist.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        infoYear.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });
        locHistory && locHistory.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        // splitscreen
        if (root.data('split') === 'R' && TAG.Util.Splitscreen.isOn()) {
            sideBar.css({
                'left': 'auto',
                'right': '0%'
            });
            toggler.css({
                left: '-12%',
                'border-top-left-radius': '3.5px',
                'border-top-right-radius': '0px',
                'border-bottom-right-radius': '0px',
                'border-bottom-left-radius': '3.5px'
            });
            togglerImage.attr('src', tagPath + 'images/icons/Open.svg')
                        .css('right','0%');
        } else {
            togglerImage.css('left', '0%');
        }
        if (!previewing){
        	sideBar.css('min-width', 0.22 * screenWidth);
        }

        // toggler to hide/show sidebar
        toggler.on('click', function () {
            var opts = {},
                isLeft = root.data('split') === 'L';

            if(isLeft) {
                opts.left = isBarOpen ? '-' + (0.22*screenWidth) + 'px' : '0%';
            } else {
                opts.right = isBarOpen ? '-' + (0.22 * screenWidth) + 'px' : '0%';
            }

            isBarOpen = !isBarOpen;

            sideBar.animate(opts, 1000, function () {
                togglerImage.attr('src', tagPath + 'images/icons/' + ((!!isBarOpen)^(!isLeft) ? 'Close.svg' : 'Open.svg'));
            });
        });

        TAG.Util.UI.setUpBackButton(backButton, goBack);
        TAG.Telemetry.register(backButton, 'click', 'artwork_to_collections', function(tobj) {

            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
            tobj.mode = 'Kiosk';
 
        });
        
        if (IS_WEBAPP && !locked) {
            linkButton.attr('src', tagPath+'images/link.svg');
            linkButton.on('click', function() {
                var linkOverlay = TAG.Util.UI.showPageLink(urlToParse, {
                    tagpagename: 'artwork',
                    tagguid: doq.Identifier,
                    prevpage: prevCollection.Identifier
                });

                root.append(linkOverlay);
                linkOverlay.fadeIn(500, function() {
                    linkOverlay.find('.linkDialogInput').select();
                });
            });
        } else {
            linkButtonContainer.remove();
        }

        function goBack() {
            TAG.Util.removeYoutubeVideo();
            var collectionsPage,
                collectionsPageRoot;
            backButton.off('click');

            //idleTimer && idleTimer.kill();
            //idleTimer = null;

            annotatedImage && annotatedImage.unload();
     
            collectionsPage = TAG.Layout.CollectionsPage({
                backScroll:     prevScroll,
                backPreviewPos: prevPreviewPos,
                backArtwork:    prevPreview,
                backCollection: prevCollection,
                backTag : prevTag,
                backMult : prevMult,
                wasOnAssocMediaView: wasOnAssocMediaView,
                splitscreen: root.data('split')
            });
            //if (root.data('split') === 'R') {

            //}
            collectionsPageRoot = collectionsPage.getRoot();
            collectionsPageRoot.data('split', root.data('split') === 'R' ? 'R' : 'L');

            TAG.Util.UI.slidePageRightSplit(root, collectionsPageRoot, function () {
                if (!IS_WINDOWS) {
                    if (collectionsPage.getState().exhibition === prevCollection) {
                        collectionsPage.showArtwork(prevPreview, prevMult && prevMult)();
                    }
                }
            });

            currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
            currentPage.obj  = collectionsPage;
        }


        // add more information for the artwork if curator added in the authoring mode
        for (item in doq.Metadata.InfoFields) {
            if(doq.Metadata.InfoFields.hasOwnProperty(item)) {
                fieldTitle = item;
                fieldValue = doq.Metadata.InfoFields[item];
                infoCustom = $(document.createElement('div'));
                infoCustom.addClass('infoCustom');
                infoCustom.text(fieldTitle + ': ' + fieldValue);
                infoCustom.css({
                    'color': '#' + PRIMARY_FONT_COLOR,
                    //'font-family': FONT
                });
                infoCustom.appendTo(info);
            }
        }

        // make sure the info text fits in the div (TODO is this necessary?)
        TAG.Util.fitText(info, 1.1);

        // create drawers
        if (doq.Metadata.Description) {
            descriptionDrawer = createDrawer("Description");
            descriptionDrawer.contents.html(Autolinker.link(doq.Metadata.Description.replace(/\n/g, "<br />"), {email: false, twitter: false}));
            if (IS_WINDOWS) {
                var links = descriptionDrawer.find('a');
                links.each(function (index, element) {
                    $(element).replaceWith(function () {
                        return $.text([this]);
                    });
                });
            }
            assetContainer.append(descriptionDrawer);
            currBottom = descriptionDrawer.height();
        }
 
        if (customMapsLength>0 || locationList.length > 0) {
            locHistoryButton = initlocationHistory();
            assetContainer.append(locHistoryButton);
            currBottom += locHistoryButton.height();
        } else {
            root.find('#locationHistoryContainer').remove();
        }

        var drawerToggleFn = null;
        if (associatedMedia.guids.length > 0) {
            for (i = 0; i < associatedMedia.guids.length; i++) {
                curr = associatedMedia[associatedMedia.guids[i]];
                /*if (curr.linq.Metadata.Type === 'Layer') {
                    if (!xfadeDrawer) {
                        xfadeSlider = $(document.createElement('div'))
                            .attr('id', 'xfadeSlider');
                        xfadeSlider.css({
                            border: '2px solid rgba(255,255,255,0.8)',
                            height: '25px',
                            left: '10%',
                            margin: '5px 0px 5px 0px',
                            position: 'relative',
                            width: '80%'
                        });
                        xfadeSliderPoint = $(document.createElement('div'))
                            .attr('id', 'xfadeSliderPoint');
                        xfadeSliderPoint.css({
                            'background-color': 'rgba(255,255,255,0.8)',
                            height: '100%',
                            left: '0%',
                            position: 'absolute',
                            top: '0%',
                            width: '50%'
                        });
                        xfadeSlider.append(xfadeSliderPoint);

                        var updateOverlay = function(evt){
                            if (isFading){
                                var leftPercent =  (evt.clientX - xfadeSlider.offset().left)/ xfadeSlider.width();
                                xfadeSliderPoint.css('width', Math.min(leftPercent * 100, 100) + '%');
                                root.find('.xfadeImg').css('opacity', leftPercent);
                            }
                        }

                        xfadeSlider.on('mousedown', function(evt) {
                            isFading = true;
                            updateOverlay(evt)
                        });
                        xfadeSlider.on('mousemove', function (evt) {
                                updateOverlay(evt)
                        });

                        root.on('mouseup', function(evt){
                            isFading = false;
                        });
                        
                        xfadeDrawer = createDrawer('Layers', xfadeSlider);
                    }
                    loadQueue.add(createMediaButton(xfadeDrawer.contents, curr));
                } else { */

                if (!mediaDrawer) {
                    mediaDrawer = createDrawer('Associated Media', null, assocMediaToShow);
                    if (mediaDrawer.drawerToggle) {
                        drawerToggleFn = mediaDrawer.drawerToggle;
                    }
                }

                loadQueue.add(createMediaButton(mediaDrawer.contents, curr));
                //} //TODO ADD BACK LAYERS FUNCTIONALITY
            }
            if (mediaDrawer) {
                assetContainer.append(mediaDrawer);
                currBottom += mediaDrawer.height();
            }
            if (xfadeDrawer) {
                assetContainer.append(xfadeDrawer);
                currBottom += xfadeDrawer.height();
            }
            if (drawerToggleFn && (typeof drawerToggleFn === "function")) {
                loadQueue.add(drawerToggleFn);
            }
        }

        /**
         * Creates a tour thumbnail button
         * @method createTourButton
         * @param {jQuery obj} container     the element to which we'll append this button
         * @param {doq} tour                 the tour doq
         */
        function createTourButton(container, tour) {
            return function() {
                container.append(TAG.Util.Artwork.createThumbnailButton({
                    title: TAG.Util.htmlEntityDecode(tour.Name),
                    year: TAG.Util.htmlEntityDecode(tour.Year|| ""),
                    handler:     tourClicked(tour),
                    buttonClass: 'tourButton',
                    src:         (tour.Metadata.Thumbnail ? FIX_PATH(tour.Metadata.Thumbnail) : tagPath+'images/tour_icon.svg')
                }));
            }
        }

        /**
         * Creates a thumbnail button for an associated media
         * @method createMediaButton
         * @param {jQuery obj} container       the element to which we'll append the button
         * @param {Object} media               an associated media object (from AnnotatedImage)
         */
        function createMediaButton(container, media) {
            return function() {
                var src = '',
                    metadata = media.doq.Metadata,
                    thumb = metadata.Thumbnail;
                switch (metadata.ContentType) {
                    case 'Audio':
                        src = tagPath+'images/audio_icon.svg';
                        break;
                    case 'Video':
                        src = (thumb && !thumb.match(/.mp4/)) ? FIX_PATH(thumb) : tagPath + 'images/video_icon.svg';
                        break;
                    case 'Image':
                        src = thumb ? FIX_PATH(thumb) : FIX_PATH(metadata.Source);
                        break;
                    case 'iframe':
                        src = tagPath + 'images/video_icon.svg';
                        break;
                    default:
                        src = tagPath + 'images/text_icon.svg';
                        break;
                }
                var toAppend = TAG.Util.Artwork.createThumbnailButton({
                    title: TAG.Util.htmlEntityDecode(media.doq.Name),
                    year: TAG.Util.htmlEntityDecode(media.doq.Year || ""),
                    handler: mediaClicked(media),
                    buttonClass: 'mediaButton',
                    buttonID: 'thumbnailButton-' + media.doq.Identifier,
                    src: src
                });
                container.append(toAppend);
                if (toAppend.parents('#metascreen-R').length) {
                    toAppend.attr('id', toAppend.attr('id') + 'R');
                }
            }
        }

        /**
         * Generates a click handler for a specific associated media object
         * Also used when entering from collections page to open a specific associated media (hence the error check for evt)
         * @method mediaClicked
         * @param {Object} media       the associated media object (from AnnotatedImage)
         */
        function mediaClicked(media) {
            //var toggleFunction = toggleLocationPanel;
            return function (evt) {
                evt && evt.stopPropagation();
                locHistoryActive = true;
                media.create(); // returns if already created
                media.toggle();
                TAG.Util.IdleTimer.restartTimer();
                //(media.linq.Metadata.Type !== 'Layer') && media.mediaManipPreprocessing();   // Set the newly opened media as active for manipulation
                media.mediaManipPreprocessing(); //todo delete when layers functionality is added back in
                media.pauseReset();
                // toggleLocationPanel();
            };
        }

        // Load tours and filter for tours associated with this artwork
        TAG.Worktop.Database.getTours(function (tours) {
            var relatedTours,
                maxHeight;

            relatedTours = tours.filter(function (tour) {
                var relatedArtworks;
                if (!tour.Metadata || !tour.Metadata.RelatedArtworks || tour.Metadata.Private === "true") {
                    return false;
                }
                relatedArtworks = JSON.parse(tour.Metadata.RelatedArtworks);
                if(!relatedArtworks || !relatedArtworks.length) {
                    return false;
                }
                return relatedArtworks.indexOf(doq.Identifier) >= 0;
            });

            if (relatedTours.length > 0) {
                tourDrawer = createDrawer('Tours');
                assetContainer.append(tourDrawer);
                currBottom += tourDrawer.height();

                tourDrawer.contents.text('');
                for(i=0; i<relatedTours.length; i++) {
                    loadQueue.add(createTourButton(tourDrawer.contents, relatedTours[i]));
                }
            }

            // set max height of drawers to avoid expanding into minimap area

            maxHeight = Math.max(1, assetContainer.height() - currBottom ); //to account for the height of the drawerLabel of the current drawer.

            root.find(".drawerContents").css({
                "max-height": maxHeight*.75 + "px", //TODO this
                //'max-height':2*0.19 * $('#tagRoot').height() + 'px', //height of two thumbnails
            });
        });

        function tourClicked(tour) {
            return function () {
                TAG.Util.removeYoutubeVideo();
                var rinData,
                    parentid,
                    prevInfo,
                    rinPlayer,
                    confirmationBox;

                if (TAG.Util.Splitscreen.isOn()) {
                    confirmationBox = $(TAG.Util.UI.PopUpConfirmation(function () {
                            TAG.Util.Splitscreen.exit(root.data('split') || 'L');
                            tourClicked(tour)();
                            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
                        },
                        "By opening this tour, you will exit splitscreen mode. Would you like to continue?",
                        "Continue",
                        false,
                        function () {
                            confirmationBox.remove();
                        },
                        root
                    ));
                    confirmationBox.css({
                        'z-index': 10001,
                        'font-size': '60%'
                    });
                    root.append(confirmationBox);
                    confirmationBox.show();
                } else {
                    annotatedImage.unload();
                    prevInfo = { artworkPrev: "artmode", prevScroll: prevScroll, prevTag: prevTag };
                    rinData = JSON.parse(unescape(tour.Metadata.Content));
                    rinPlayer = new TAG.Layout.TourPlayer(rinData, prevCollection, prevInfo, options,tour);

                    TAG.Util.UI.slidePageLeftSplit(root, rinPlayer.getRoot(), rinPlayer.startPlayback);
                }
            };
        }

        /*************************************************************************
         * MINIMAP CODE. bleveque: didn't rewrite this; separate issue
         *                         if some variable names are off now, let me know
         */

        //Create minimapContainer...
        var minimapContainer = root.find('#minimapContainer');

        //if the #info div exceeds the half the length of the sidebar, the div's max-height is set to its default with an auto scroll property.
        info.css({
            'overflow-y' : 'auto',
            'max-height' : sideBar.height()*2/5- (info.offset().top - sideBar.offset().top)+ 'px',

        });

        var minimapDescription = $(document.createElement('div'))
            .addClass('minimapDescription')
            .css({
                'font-size': '80%',
                'margin-top': '-13%',
                'text-align':'center'
            })
            .text('Navigation');
        minimapContainer.append(minimapDescription);
       

    
    //when the #info div's size is not too large, the text inside metadata fields is made as much visible as possible
        assetContainer.css({
            'max-height': sideBarInfo.height()-info.height()+ (info.offset().top - sideBar.offset().top) + 'px',

        });

        

        sideBarSections.append(minimapContainer);

        //A white rectangle for minimap to show the current shown area for artwork
        var minimaprect = root.find('#minimaprect');

        //Load deepzoom thumbnail. 
        var img = new Image();
        var loaded = false;
        var AR = 1;//ratio between width and height.
        var minimapw = 1;//minimap width
        var minimaph = 1;//minimap height
        var minimap;

        /*
        **Load the image of artwork and initialize the minimap rectangle
        * @method minimapLoaded
        */
        function minimapLoaded() {
            if (loaded) return;
            loaded = true;
            //load the artwork image
            minimap = root.find('#minimap');
            minimap.attr('src', TAG.Worktop.Database.fixPath(doq.URL));

            //make the minimap not moveable. 
            minimap.mousedown(function () {
                return false;
            });

            //TAG.Util.disableDrag(minimapContainer);

            AR = img.naturalWidth / img.naturalHeight;
            var heightR = img.naturalHeight / $(minimapContainer).height();//the ratio between the height of image and the container.
            var widthR = img.naturalWidth / $(minimapContainer).width();//ratio between the width of image and the container.
            //make sure the whole image shown inside the container based on the longer one of height and width.
            if (heightR > widthR) {
                minimap.removeAttr("height");
                minimap.removeAttr("width");
                minimap.css({ "height": "100%" });
            }
            else {
                minimap.removeAttr("height");
                minimap.removeAttr("width");
                minimap.css({ "width": "100%" });
            }

            //make the image manipulatable. 
            if (IS_WINDOWS) {
                var gr = TAG.Util.makeManipulatableWin(minimap[0], {
                    onManipulate: onMinimapManipWin,
                    onScroll: onMinimapScrollWin,
                    onTapped: onMinimapTappedWin
                }, false);
            } else {
                var gr = TAG.Util.makeManipulatable(minimap[0], {
                    onManipulate: onMinimapManip,
                    onScroll: onMinimapScroll,
                    onTapped: onMinimapTapped
                }, true);
            }
            /**********************/
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);
            minimaprect.css({
                width: (minimapw - 1) + "px",
                height: (minimaph - 1) + "px",
                top: minimapt + "px",
                left: (minimapl - 1) + "px"
            });
            /*********************/
        }
        /*
        **Implement manipulation function from makeManipulatable.
        * @method onMinimapManip
        * @param {Object} evt        object containing hammer event info 
        */
        function onMinimapManip(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            //find pivot and translation of manipulation event
            var px = evt.pivot.x + (minimap.offset().left - minimapContainer.offset().left);
            var py = evt.pivot.y + (minimap.offset().top - minimapContainer.offset().top);
            var tx = evt.translation.x;
            var ty = evt.translation.y;

            var x = px + tx;
            var y = py + ty;
            x = (x - minimapl) / minimapw;
            y = (y - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1 + (1 - evt.scale);
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /*
        **Implement manipulation function from makeManipulatableWin in win8 app.
        * @method onMinimapManipWin
        * @param {Object} evt        object containing windows event info 
        */
        function onMinimapManipWin(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var px = evt.pivot.x;
            var py = evt.pivot.y;
            var tx = evt.translation.x;
            var ty = evt.translation.y;

            var x = px + tx;
            var y = py + ty;
            x = (x - minimapl) / minimapw;
            y = (y - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));

            var s = 1 + (1 - evt.scale);
            if (s) {
                annotatedImage.viewer.viewport.zoomBy(s, false);
            }
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /**Implement scroll function from makeManipulatable
         * @method onMinimapScroll
         * @param {Number} scale     scale factor
         * @param {Object} pivot     x and y location of event
         */
        function onMinimapScroll(scale, pivot) {
            //create hammer event and pass into onMinimapManip
            onMinimapManip({
                scale: scale,
                translation: {
                    x: 0,
                    y: 0
                },
                pivot: pivot
            });    
        }

        /**Implement scroll function in win8app from makeManipulatableWin
         * @method onMinimapScrollWin
         * @param {Number} delta     change
         * @param {Object} pivot     x and y location of event
         */
        function onMinimapScrollWin(delta, pivot) {
            annotatedImage.viewer.viewport.zoomBy(delta, annotatedImage.viewer.viewport.pointFromPixel(new Seadragon.Point(pivot.x, pivot.y)));
            annotatedImage.viewer.viewport.applyConstraints();
        }


        /**Implement tapped function from makeManipulatable
        * @method onMinimapTapped
        * @param {Object} evt        object containing hammer event info
        */
        function onMinimapTapped(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var xPos = evt.position.x; //+ minimap.offset().left;
            var yPos = evt.position.y; //+ minimap.offset().top;
            var x =(xPos-minimapl)/ minimapw;
            var y = (yPos-minimapt)/minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1;
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /**Implement tapped function in win8 from makeManipulatableWin
        * @method onMinimapTapped
        * @param {Object} evt        object containing windows event info
        */
        function onMinimapTappedWin(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var xPos = evt.position.x;
            var yPos = evt.position.y;
            var x = (xPos - minimapl) / minimapw;
            var y = (yPos - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1;
            if (s) {
                annotatedImage.viewer.viewport.zoomBy(s, false);
            }
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        img.onload = minimapLoaded;
        //should be complete image of artwork NOT thumbnail
        img.src = TAG.Worktop.Database.fixPath(doq.URL);
        if (img.complete) {
            minimapLoaded();
        }
        /*
        **Move the minimap rectangle based on the manipulation of the image
        * @method dzMoveHandler
        * @param {event} evt            manipulation event of the image
        */
        function dzMoveHandler(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);

            var viewport = evt.viewport;
            var rect = viewport.getBounds(true);
            var tl = rect.getTopLeft();
            var br = rect.getBottomRight();
            var x = tl.x;
            var y = tl.y;
            var xp = br.x;
            var yp = br.y;
            if (x < 0) x = 0;
            if (y < 0) y = 0;
            if (xp > 1) xp = 1;
            if (yp > 1 / AR) yp = 1 / AR;
            y = y * AR;
            yp = yp * AR;
            yp = yp - y;
            xp = xp - x;
            x = minimapl + x * minimapw;
            y = minimapt + y * minimaph;
            xp = xp * minimapw;
            yp = yp * minimaph;
            minimaprect.css({
                width: (xp-1) + "px",
                height: (yp - 1) + "px",
                top: y + "px",
                left: (x-1) + "px"
            });
        }
        
        /*
         * END MINIMAP CODE
         ******************/

        annotatedImage.addAnimateHandler(dzMoveHandler);
        assocMediaToShow && loadQueue.add(mediaClicked(associatedMedia[assocMediaToShow.Identifier]));
        //PART OF CUSTOM BUILD FOR THE SAM
        /*for (i = 0; i < associatedMedia.guids.length; i++) {
            //console.log("THIS THIS: " + Object.keys(associatedMedia[associatedMedia.guids[i]]));
            if (associatedMedia[associatedMedia.guids[i]].linq.Metadata.Type && (associatedMedia[associatedMedia.guids[i]].linq.Metadata.Type === "Hotspot")) {
                loadQueue.add(associatedMedia[associatedMedia.guids[i]].showHotspot());
            }
        };*/
    }



    /**
     * Create a drawer with a disclosure button used to display
     * hotspots, assets, tours. The returned jQuery object has
     * a property called "contents" which should be used to add
     * buttons or messages to the contents of the drawer.
     *
     * @param title, the display title for the drawer
     * @author jastern
     */
    function initlocationHistory() {
        var RLH,
            toggleContainer = $(document.createElement('div')).addClass('drawerToggleContainer');
            //toggle          = $(document.createElement('img')).addClass("drawerPlusToggle")
            //    .attr("src", tagPath+'images/icons/plus.svg');      
        isOpen = false;

        locHistoryToggleSign = $(document.createElement('img')).addClass("drawerPlusToggle")
                .attr("src", tagPath+'images/icons/plus.svg'); 
        locHistoryContainer.on('click', function () { toggleLocationOpen(); });
        toggleContainer.append(locHistoryToggleSign);
        locHistoryContainer.append(toggleContainer);

        //panel that slides out when location history is clicked
        RLH = TAG.Util.RLH({
            artwork: doq,
            root: root,
            authoring: false
        });
        locationPanelDiv = RLH.init();
        locationPanelDiv.css({"width":"0%"});
        locHistoryToggle = $(document.createElement('div'))
            .attr("id", "locHistoryToggle")
            .css({
                "left": '100%',
                'border-top-right-radius': '10px',
                'border-bottom-right-radius': '10px',
                "background-color":"rgba(0,0,0,0.7)",
                "top": "43%",
                "width": "4%",
                "height": "14%",
                "z-index": "100",
                "position": "relative"
            });
        var locHistoryToggleImage = $(document.createElement('img'))
            .attr('src', tagPath + 'images/icons/Close.svg')
            .attr("id", "locHistoryToggleImage")
            .css({
                'left': '0%',
                "position":"absolute",
	            "top": "30%",
	            "width":"72%",
	            "height":"42%"
	        });
        locationPanelDiv.append(locHistoryToggle);
        locHistoryToggle.append(locHistoryToggleImage);
        locHistoryToggle.on('click', function () { toggleLocationOpen(); });
        function toggleLocationOpen() {
            isOpen ? locationClose() : locationOpen();    
        }
        if (TAG.Util.Splitscreen.isOn()) {
            locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
        }
        function locationOpen() { 
            if (!isOpen) {
                if (!TAG.Util.Splitscreen.isOn()) {

                    //close other drawers if any are open
                    root.find(".drawerPlusToggle").attr({
                        src: tagPath+'images/icons/plus.svg',
                        expanded: false
                    });
                    root.find(".drawerContents").slideUp();

                    //and open RLH
                    locationPanelDiv.css({ display: 'inline' });
                    locHistoryToggleSign.attr("src", tagPath + 'images/icons/minus.svg');
                    isOpen = true;
                    toggler.hide();
                    locationPanelDiv.show();
                    locationPanelDiv.animate({ width: '65%' }, 350, function () { locHistoryToggle.show(); });
                }
            }
        }

        function locationClose() {
            if (isOpen) {
                locHistoryToggleSign.attr("src", tagPath + 'images/icons/plus.svg');
                locHistory.text("Maps");
                locHistoryContainer.css({ "background-color": "transparent" });
                isOpen = false;
                locationPanelDiv.animate({ width: '0%' }, 350, function () { locationPanelDiv.hide(); locHistoryToggle.hide(); toggler.show(); });
            }
        }

        that.locationClose = locationClose

        return locHistoryContainer;
    }

    /**
     * Create a drawer (e.g., for list of related tours or the artwork's description) 
     * @param {String} title            title of the drawer
     * @param {jQuery obj} topContents  an element to be included before the main contents of the drawer
     * @return {jQuery obj}             the drawer
     */
    function createDrawer(title, topContents, assocMediaToShow) {
        var drawer          = $(document.createElement('div')).addClass('drawer'),
            drawerHeader    = $(document.createElement('div')).addClass('drawerHeader'),
            label           = $(document.createElement('div')).addClass('drawerLabel'),
            toggleContainer = $(document.createElement('div')).addClass('drawerToggleContainer'),
            toggle          = $(document.createElement('img')).addClass("drawerPlusToggle"),
            drawerContents  = $(document.createElement('div')).addClass("drawerContents"),
            i;
       
        label.addClass('primaryFont');
        label.text(title);
        label.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });
        toggle.attr({
            src: tagPath+'images/icons/plus.svg',
            expanded: false
        });

        drawer.append(drawerHeader);
        drawerHeader.append(label);
        drawerHeader.append(toggleContainer);
        toggleContainer.append(toggle);
   
        drawer.append(drawerContents);
        topContents && drawerContents.append(topContents);
        var drawerToggle = function (evt) {
            if (toggle.attr('expanded') !== 'true') {
                root.find(".drawerPlusToggle").attr({
                    src: tagPath + 'images/icons/plus.svg',
                    expanded: false
                });

                root.find(".drawerContents").slideUp();

                toggle.attr({
                    src: tagPath + 'images/icons/minus.svg',
                    expanded: true
                });
            } else {
                toggle.attr({
                    src: tagPath + 'images/icons/plus.svg',
                    expanded: false
                });

            }

            drawerContents.slideToggle();
            isOpen && that.locationClose()
        }

        //have the toggler icon minus when is is expanded, plus otherwise.
        drawerHeader.on('click', drawerToggle);

        drawer.contents = drawerContents;
        if (assocMediaToShow && title === 'Associated Media') {
            //drawerHeader.click();
            drawer.drawerToggle = drawerToggle;
        }
        return drawer;
    }

    /**
     * Return art viewer root element
     * @method
     * @return {jQuery obj}    root jquery object
     */
    function getRoot() {
        return root;
    }

    /**
     * Make the map for location History.
     * @method makeMap
     * @param {Function} callback     function to be called when map making is complete
    */
    function makeMap(callback) {
        var mapOptions,
            viewOptions;

        mapOptions = {
            credentials:         "AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj",
            mapTypeID:           Microsoft.Maps.MapTypeId.road,
            showScalebar:        true,
            enableClickableLogo: false,
            enableSearchLogo:    false,
            showDashboard:       true,
            showMapTypeSelector: false,
            zoom:                2,
            center:              new Microsoft.Maps.Location(20, 0)
        };
        
        viewOptions = {
            mapTypeId: Microsoft.Maps.MapTypeId.road,
        };
        
        map = new Microsoft.Maps.Map(document.getElementById('lpMapDiv'), mapOptions);
        map.setView(viewOptions);

        callback && callback();
    }

};

TAG.Layout.ArtworkViewer.default_options = {
    catalogState: {},
    doq: null,
    split: 'L',
};


;
TAG.Util.makeNamespace("TAG.Layout.CollectionsPage");

/**
 * The collections page
 * @class TAG.Layout.CollectionsPage
 * @constructor
 * @param {Object} options         some options for the collections page
 * @return {Object}                some public methods
 */
TAG.Layout.CollectionsPage = function (options) { // backInfo, backExhibition, container, forSplitscreen) {
    "use strict";

    options = options || {}; // cut down on null checks later

    var // DOM-related
        root = TAG.Util.getHtmlAjax('NewCatalog.html'), // use AJAX to load html from .html file
        infoDiv = root.find('#infoDiv'),
        tileDiv = $(document.createElement("div")).attr("id", "tileDiv"),//root.find('#tileDiv'),
        displayArea = root.find("#displayArea"),
        collectionArea = root.find('#collectionArea'),
        backArrowArea = root.find('#backArrowArea'),
        backArrow = root.find('#backArrow'),
        nextArrowArea = root.find('#nextArrowArea'),
        nextArrow = root.find('#nextArrow'),
        collectionHeader = root.find('#collectionHeader'),
        collectionDotHolder = root.find('#collectionDotHolder'),
        bgimage = root.find('#bgimage'),
        bottomContainer = root.find('#bottomContainer'),
        catalogDiv = root.find('#catalogDiv'),
        infoTilesContainer = root.find('#infoTilesContainer'),
        sortRow = root.find('#sortRow'),
        searchInput = root.find('#searchInput'),
        searchTxt = root.find('#searchTxt'),
        buttonRow = root.find('#buttonRow'),
        artworksButton = root.find('#artworksButton'),
        assocMediaButton = root.find('#assocMediaButton'),
        toggleRow = root.find('#toggleRow'),
        selectedArtworkContainer = root.find('#selectedArtworkContainer'),
        timelineArea = root.find('#timelineArea'),
        topBar = root.find('#topBar'),
        loadingArea = root.find('#loadingArea'),
        infoButton = root.find('#infoButton'),
        tutorialButton = root.find('#tutorialButton'),
        linkButton = root.find('#linkButton'),
        // splitscreenIcon          = root.find('#splitscreenIcon'),
        overlay = root.find('#overlay'),
        tileLoadingArea = root.find('#tileLoadingArea'),
        nextCollection = $(document.createElement('div')).attr('id', 'nextCollection'),
        prevCollection = $(document.createElement('div')).attr('id', 'prevCollection'),

        // input options
        scrollPos = options.backScroll || null,     // horizontal position within collection's catalog
        previewPos = options.backPreviewPos || null,
        currCollection = options.backCollection,      // the currently selected collection
        currentArtwork = options.backArtwork,         // the currently selected artwork
        currentTag = options.backTag,             // current sort tag for collection
        multipleShown = options.backMult,            // whether multiple artworks shown at a specific year, if applicable
        //wasOnAssocMediaView     = options.wasOnAssocMediaView || false,   //whether we were on associated media view       
        previewing = options.previewing || false,   // whether we are loading for a preview in authoring (for dot styling)

        // misc initialized vars
        loadQueue = TAG.Util.createQueue(),           // an async queue for artwork tile creation, etc
        artworkSelected = false,                            // whether an artwork is selected
        visibleCollections = [],                               // array of collections that are visible and published
        collectionDots = {},                               // dict of collection dots, keyed by collection id
        artworkCircles = {},                               // dict of artwork circles in timeline, keyed by artwork id                  
        artworkTiles = {},                               // dict of artwork tiles in bottom region, keyed by artwork id
        firstLoad = true,                             // TODO is this necessary? what is it doing?
        currentArtworks = [],                               // array of artworks in current collection
        infoSource = [],                               // array to hold sorting/searching information
        timelineEventCircles = [],                               // circles for timeline
        timelineTicks = [],                               // timeline ticks
        scaleTicks = [],                               // timeline scale ticks
        artworkYears = {},                               // dict of artworks keyed by yearKey for detecting multiple artworks at one year    
        scaleTicksAppended = false,                            // if scale ticks have been appended
        tileDivHeight = 0,                                // Height of tile div (before scroll bar added, should equal height of catalogDiv)
        artworkShown = false,                            // whether an artwork pop-up is currently displayed
        timelineShown = true,                             // whether current collection has a timeline
        onAssocMediaView = options.wasOnAssocMediaView || false,                            // whether current collection is on assoc media view
        previouslyClicked = null,
        artworkInCollectionList = [],

        // constants
        BASE_FONT_SIZE = TAG.Worktop.Database.getBaseFontSize(),       // base font size for current font
        FIX_PATH = TAG.Worktop.Database.fixPath,                 // prepend server address to given path
        MAX_YEAR = (new Date()).getFullYear(),                   // Maximum display year for the timeline is current year
        EVENT_CIRCLE_WIDTH = Math.min(30, Math.max(20, $("#tagRoot").width() / 50)),  // width of the circles for the timeline                                
        COLLECTION_DOT_WIDTH = Math.max(7, $("#tagRoot").width() / 120),  // width of the circles for the timeline                      
        LEFT_SHIFT = 9,                                                    // pixel shift of timeline event circles to center on ticks 
        TILE_BUFFER = $("#tagRoot").width() / 100,                  // number of pixels between artwork tiles
        TILE_HEIGHT_RATIO = 200,                                          //ratio between width and height of artwork tiles
        TILE_WIDTH_RATIO = 255,
        ANIMATION_DURATION = 800,                                         // duration of timeline zoom animation
        DIMMING_FACTOR = 1.7,                                          //dimming of unhighlighted text
        PRIMARY_FONT_COLOR = options.primaryFontColor ? options.primaryFontColor : TAG.Worktop.Database.getMuseumPrimaryFontColor(),
        SECONDARY_FONT_COLOR = options.secondaryFontColor ? options.secondaryFontColor : TAG.Worktop.Database.getMuseumSecondaryFontColor(),
        FONT = TAG.Worktop.Database.getMuseumFontFamily(),

        // misc uninitialized vars
        fullMinDisplayDate,             // minimum display date of full timeline
        fullMaxDisplayDate,             // maximum display date of full timeline
        currentTimeline,                // currently displayed timeline
        currTimelineCircleArea,         // current timeline circle area
        currentDefaultTag,              // current default tag if 'Year' and  'Title' sorts don't exist
        toShowFirst,                    // first collection to be shown (by default)
        toursIn,                        // tours in current collection
        imgDiv,                         // container for thumbnail image
        descriptiontext,                // description of current collection or artwork
        loadingArea,                    // container for progress circle
        moreInfo,                       // div holding tombstone information for current artwork
        artistInfo,                     // artist tombstone info div
        yearInfo,                       // year tombstone info div
        justShowedArtwork,              // for telemetry; helps keep track of artwork tile clicks
        comingBack,                     // if you are coming back from a viewer
        defaultTag,                     // default sort tag
        showArtworkTimeout,
        tileCircle;                     // loading circle for artwork tiles

    if (SECONDARY_FONT_COLOR[0] !== '#') {
        SECONDARY_FONT_COLOR = '#' + SECONDARY_FONT_COLOR;
    }
    if (PRIMARY_FONT_COLOR[0] !== '#') {
        PRIMARY_FONT_COLOR = '#' + PRIMARY_FONT_COLOR;
    }
    root[0].collectionsPage = this;
    root.data('split',options.splitscreen);
        options.backCollection ? comingBack = true : comingBack = false;
        var cancelLoadCollection = null;

    // get things rolling
    init();

    /**
     * Sets up the collections page UI
     * @method init
     */
    function init() {
        if (previewing && idleTimer) {
            idleTimer.kill();
        }
        var progressCircCSS,
            circle,
            oldSearchTerm;
        
        cancelLoadCollection = null;
        progressCircCSS = {
            'position': 'absolute',
            'z-index': '50',
            'height': 'auto',
            'width': '5%',
            'left': '47.5%',
            'top': '42.5%'
        };
        
        circle = TAG.Util.showProgressCircle(loadingArea, progressCircCSS, '0px', '0px', false);
        var loadingLabel = $(document.createElement('div'));
        loadingLabel.css({
            'position': 'absolute',
            'left': '37%',
            'top': '55%',
            'font-size': '200%',
            'color': 'white',
            'opacity': '1'
        });
        loadingLabel.text('Loading Collections');
        loadingArea.append(loadingLabel);

        //Or else the search bar loses focus immediately when you come back from artwork viewer
        $('#tagContainer').off();
        
        // search on keyup
        searchInput.on('keyup', function (e) {
            if (!searchInput.val()) {
                searchTxt.text("");
                drawCatalog(currentArtworks, currentTag, 0, false);
            }
            else if (e.which === 13) {
                doSearch();
            }

        });
        
        searchInput.css({
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size' : 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position':'8px center'
        });

        searchInput.on('focusin', function () { 
            searchInput.css({ 'background-image': 'none' }); 
        });
        
        searchInput.on('focusout', function () { 
            if (!searchInput.val()) {
                searchInput.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });
            } 
        });
          
        // initSplitscreen();

        infoButton.attr('src', tagPath+'images/icons/info.svg')
            .addClass('bottomButton')
        infoButton.on('mousedown', function () {
            createInfoPopUp();
        });

        tutorialButton.attr('src', tagPath + 'images/icons/question_mark.svg')
            .addClass('bottomButton')
            .on('mousedown', function () {
                TAG.Util.createTutorialPopup();
            });

        if (IS_WEBAPP) {
            linkButton.attr('src', tagPath + 'images/link.svg')
                        .addClass('bottomButton')
                        .on('mousedown', function () {
                            var linkOverlay = TAG.Util.UI.showPageLink(urlToParse, {
                                tagpagename: 'collections',
                                tagcollectionid: currCollection.Identifier,
                                tagartworkid: currentArtwork ? currentArtwork.Identifier : ''
                            });
                root.append(linkOverlay);
                linkOverlay.fadeIn(500, function () {
                    linkOverlay.find('.linkDialogInput').select();
                });
            });
            
        } else {
            linkButton.remove();
        }

        if (root.data('split') === 'R' && TAG.Util.Splitscreen.isOn()) {
            $('.mainCollection').css('width', '60%');
        }
        if (root.data('split') === 'L' && TAG.Util.Splitscreen.isOn()) {
            infoButton.hide();
            tutorialButton.hide();
            linkButton.css("float", "left");
            root.find('#mainCollection').css('width', '60%');
        }
        //Scrolling closes popup
        if (bottomContainer[0].addEventListener) {
            // IE9, Chrome, Safari, Opera
            bottomContainer[0].addEventListener("mousewheel", 
                function(){
                    currentArtwork && hideArtwork(currentArtwork)()
                }, false);
            // Firefox
            bottomContainer[0].addEventListener("DOMMouseScroll", 
                function(){
                    currentArtwork && hideArtwork(currentArtwork)()
                }, false);
        } else { 
            // IE 6/7/8
            bottomContainer[0].attachEvent("onmousewheel",
                function(){
                    currentArtwork && hideArtwork(currentArtwork)()
                }, false);
        };


        var progressCircCSS = {
            'position': 'absolute',
            'float'   : 'left',
            'left'    : '40%',
            'z-index' : '50',
            'height'  : '10%',
            'width'   : 'auto',
            'top'     : '22%',
        };
        /*
        var tileCircle = TAG.Util.showProgressCircle(tileDiv, progressCircCSS, '0px', '0px', false);
        tileLoadingArea.append(tileCircle);
        */

        TAG.Worktop.Database.getExhibitions(getCollectionsHelper, null, getCollectionsHelper);
        applyCustomization();
    }

    /**
     * Create info pop-up for 'i' info icon on collections page
     * @method createInfoPopUp
     */
    function createInfoPopUp() {
        var infoOverlay = $(TAG.Util.UI.blockInteractionOverlay());
        var infoBox = $(document.createElement('div'));
        var infoTitle = $(document.createElement('div'));
        var infoMain = $(document.createElement('div'));
        var infoLogo = $(document.createElement('div'));
        var infoTitleLeft = $(document.createElement('div'));
        var infoTitleRight = $(document.createElement('div'));
        var infoMainTop = $(document.createElement('div'));
        var infoMainBottom = $(document.createElement('div'));
        var microsoftLogoDiv = $(document.createElement('div'));
        var brownLogoDiv = $(document.createElement('div'));
        var microsoftLogo = $(document.createElement('img'));
        var brownLogo = $(document.createElement('img'));
        var closeButton = createCloseButton();
        var string = 'cs.brown.edu/research/ptc/tag';
        microsoftLogo.attr('src', tagPath + 'images/microsoft_logo_transparent.png');
        brownLogo.attr('src', tagPath + 'images/brown_logo_transparent.png');
        microsoftLogoDiv.css({
            'background': 'transparent',
            'width': '25%',
            'min-width':'120px',
            'height': '100%',
            'float': 'right',
            'display':'inline-block'
        });
        brownLogoDiv.css({
            'background': 'transparent',
            'width': '10%',
            'min-width': '40px',
            'height': '100%',
            'float': 'right',
            'display': 'inline-block'
        });
        microsoftLogo.css({
            'height': 'auto',
            'width': '100%',
            'min-width':'120px',
            'margin-top': '4%'
        });
        brownLogo.css({
            'height': 'auto',
            'width': '80%',
            'min-width': '40px',
            'margin-top': '-16%'
        });
       
        infoOverlay.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);
        infoOverlay.append(infoBox);
        infoBox.css({
            'background-color': 'black',
            'color': 'white',
            'height': '50%',
            'width': '50%',
            'margin-top': '15%',
            'margin-left': '25%',
        });
        infoTitle.css({
            'background-color': 'black',
            'margin': '0%',
            'display': 'block',
            'color': 'white',
            'border-top-left-radius':'3.5px',
            'border-top-right-radius':'3.5px'
        });
        infoTitle.append(infoTitleLeft);
        infoTitle.append(infoTitleRight);

        closeButton.css({
            'height': '4%',
            'width': '4%',
            'min-height': '20px',
            'min-width':'20px',
            'margin-left': '0%',
            'margin-bottom': '0%',
            'margin-top': '1%',
            'margin-right':'1%',
            'top':'0%',
            'display': 'block',
            'float':'right'
        });

        infoBox.append(closeButton);
        infoTitleLeft.css({
            'color': 'white',
            'background-color': 'black',
            'display': 'inline-block',
            'font-weight': 'bold',
            'font-size': '2em',
            'margin-left': '5%',
            'margin-top': '2%'
        });
        infoTitleLeft.text('TAG');

        infoTitleRight.css({
            'color': 'white',
            'background-color': 'black',
            'display': 'inline-block',
            'font-size': '1.5em',
            'margin-left': '3%'
        });
        infoTitleRight.text('Touch Art Gallery');

        infoMain.css({
            'background-color': 'black',
            'display': 'block',
            'color': 'white'
        });
        infoMainTop.css({
            'color': 'white',
            'background': 'black',
            'display': 'block',
            'font-size': '0.75em',
            'margin-left': '5%',
            'margin-top': '3%',
            'margin-right': '6%'
        });
        infoMainBottom.css({
            'color': 'white',
            'background': 'black',
            'display': 'block',
            'font-size': '0.65em',
            'margin-left': '5%',
            'margin-top': '3%',
            'margin-right': '6%'
        });
        infoMainTop.text('Touch Art Gallery is a free webapp and Win8 application, funded by Microsoft Reasearch and created by the Graphics Lab at Brown University. You can learn more about this project at http://cs.brown.edu/research/ptc/tag.');
        infoMainBottom.text('Andy van Dam, Alex Hills, Yudi Fu, Benjamin LeVeque, Karthik Battula, Karishma Bhatia, Gregory Chatzinoff, John Connuck, David  Correa, Mohsan Elahi, Aisha Ferrazares, Jessica Fu, Kaijan Gao, Jessica Herron, Ardra Hren, Hak Rim Kim, Lucy van Kleunen, Inna Komarovsky, Ryan Lester, Josh Lewis, Jinqing Li, Jeffery Lu, Xiaoyi Mao, Ria Mirchandani, Julie Mond, Ben Most, Jonathan Poon, Dhruv Rawat, Emily Reif, Surbhi Madan, Tanay Padhi, Jacob Rosenfeld, Qingyun Wan, Jing Wang, David Weinberger, Anqi Wen, Dan Zhang, Libby Zorn');
        infoMain.append(infoMainTop);
        infoMain.append(infoMainBottom);

        infoLogo.css({
            'background-color': 'black',
            'display': 'block',
            'color': 'white',
            'height': '17%',
            'padding':'5%',
            'border-bottom-right-radius':'3.5px',
            'border-bottom-left-radius':'3.5px'
        });
        infoLogo.append(brownLogoDiv);
        infoLogo.append(microsoftLogoDiv);

        brownLogoDiv.append(brownLogo);
        microsoftLogoDiv.append(microsoftLogo);

        infoBox.append(infoTitle);
        infoBox.append(infoMain);
        infoBox.append(infoLogo);
        root.append(infoOverlay);
        infoOverlay.fadeIn();

        closeButton.on('mousedown', function () {
            infoOverlay.fadeOut();
        });
    }

    function prepareNextView() {
        onAssocMediaView = false;
        currentTag = null;
        currentArtwork = null;
        currCollection = null;
        loadQueue.clear();
        comingBack = false;
        tileDiv.empty();
        tileCircle.show();
        if (cancelLoadCollection) cancelLoadCollection();
    }

    /**
     * Create a closeButton for associated media
     * @method createCloseButton
     * @return {HTML element} the button as a 'div'
     */
    function createCloseButton() {
        var closeButton = $(document.createElement('img'));
        closeButton.attr('src', tagPath + 'images/icons/x.svg');
        closeButton.text('X');
        closeButton.css({
            'height': '3%',
            'width': '3%',
            'margin-left': '39%',
            'margin-bottom': '3.5%'
        });
        return closeButton;
    }

    /**
     * Return the type of work
     * @method getWorkType
     * @param {doq} work       the doq representing the current work
     * @return {String}        a string describing type of work ('artwork', 'video', or 'tour')
     */
    function getWorkType(work) {
        if (currentArtwork.Type === "Empty") {
            if (currentArtwork.Metadata.ContentType === "iframe"){
                return 'iframe';
            } else {
                return 'tour';
            }
        } else if (currentArtwork.Metadata.Type === 'VideoArtwork') {
            return 'video';
        }
        return 'artwork';
    }

    /**
     * Helper function to add collections to top bar.  Also creates an array of visible artworks
     * @method getCollectionsHelper
     * @param collections               list of collections to add to page
     */
    function getCollectionsHelper(collections) {
        var i,
           privateState,   // Is collection private?
           c,
           j,
           lastCollectionIndex,
           firstCollectionIndex,
           collectionDot,
           collectionsToShow = false;
        // Iterate through entire list of collections to to determine which are visible/not private/published.  Also set toShowFirst
        for (i = 0; i < collections.length; i++) {
            c = collections[i];
            privateState = c.Metadata.Private ? (/^true$/i).test(c.Metadata.Private) : false;
            if (!privateState && TAG.Util.localVisibility(c.Identifier)) {
                collectionsToShow = ((collectionsToShow) ? collectionsToShow : true);
                toShowFirst = toShowFirst || c;
                visibleCollections.push(collections[i]);
            }
        }
        if (!collectionsToShow && !previewing) {
            var infoOverlay = $(document.createElement('div'));
            infoOverlay.text("No collections to display");
            infoOverlay.css({ "color": "white", "text-align": "center", "font-size": "200%", "margin-top": "20%" });
            root.append(infoOverlay);
            $('#catalogDivContainer').hide();
            TAG.Util.hideLoading(bottomContainer);
        }

        // Iterate through visible/not private/published collections, and set their prev and next values
        // Also create a scroll dot for each (under main collection title)
        collectionDotHolder.empty();
        var uiDocfrag = document.createDocumentFragment();
        for(i = 0; i < visibleCollections.length; i++) {
            if(visibleCollections.length<=2){ 
                lastCollectionIndex = null;
                firstCollectionIndex = null;
            } else {
                lastCollectionIndex = visibleCollections.length - 1;
                firstCollectionIndex = 0;
            }
            visibleCollections[i].prevCollectionIndex = visibleCollections[i - 1] ? i - 1 : lastCollectionIndex;
            visibleCollections[i].nextCollectionIndex = visibleCollections[i + 1] ? i + 1 : firstCollectionIndex;
            
            if (previewing) {
                COLLECTION_DOT_WIDTH = root.width() / 120; //for previewing collections page in authoring
            }
            collectionDot = $(document.createElement('div'))
                        .addClass('collectionDot')
                        .css({
                            "width": COLLECTION_DOT_WIDTH,
                            "height":  COLLECTION_DOT_WIDTH,
                            "border-radius": COLLECTION_DOT_WIDTH / 2,
                            "margin": COLLECTION_DOT_WIDTH/4
                        }).on('click', function(j){
                           return function(){
                                prepareNextView();
                                loadCollection(visibleCollections[j])();
                            }
                        }(i))
            uiDocfrag.appendChild(collectionDot[0]);
            //collectionDotHolder.append(collectionDot);
            collectionDots[visibleCollections[i].Identifier] = collectionDot;
        }
        collectionDotHolder.append($(uiDocfrag));
        // Load collection
        if (currCollection) {
            //Quick check for specific load
            for(i = 0; i < visibleCollections.length; i++) {
                if (currCollection.Identifier === visibleCollections[i].Identifier){
                    currCollection = visibleCollections[i]
                }
            }

            //If ou didnt find the collection you're trying to load in the visible collections, just load the first one instead
            if (visibleCollections.indexOf(currCollection) === -1) {
                if (previewing) {
                    loadCollection(currCollection, null, currentArtwork)();
                } else {
                    loadFirstCollection();
                }
                
            } else {
                loadCollection(currCollection, null, currentArtwork)();
            }
        } else if (toShowFirst) {
            loadFirstCollection();
        }
        loadingArea.hide();
        searchInput.show();
    }

    /**
     * Applies customization changes to main divs
     * @method applyCustomization
     */
    function applyCustomization() {
        var dimmedColor = TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR,DIMMING_FACTOR);
        $('.primaryFont').css({
            'color': PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });
        $('.secondaryFont').css({
            'color': SECONDARY_FONT_COLOR,
            //'font-family': FONT
        });
        $('.nextPrevCollection').css({
            'color' : dimmedColor
        })
    }

    /**
     * Shows collection and title
     * @method loadCollection
     * @param {jQuery obj} collection     the element currently being clicked
     * @param {Number} sPos               if undefined, set scroll position to 0, otherwise, use this
     * @param {doq} artwrk                if undefined, set currentArtwork to null, otherwise, use this
     */
    function loadCollection(collection, sPos, artwrk) {
        return function (evt) {
            var cancelLoad = false;
            assocMediaButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
            assocMediaButton.attr('disabled', 'disabled');
            artworksButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
            artworksButton.attr('disabled', 'disabled');
            var i,
                title = TAG.Util.htmlEntityDecode(collection.Name),
                nextTitle,
                prevTitle,
                mainCollection = root.find('#mainCollection'),
                titleBox = root.find('.collection-title'),
                collectionMedia = [],
                counter = 0,
                collectionLength,
                collectionDescription = $(document.createElement('div')),
                dummyDot,
                dimmedColor = TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR,DIMMING_FACTOR),
                str,
                text = collection.Metadata && collection.Metadata.Description ? TAG.Util.htmlEntityDecode(collection.Metadata.Description) : "" + "\n\n   ",
                progressCircCSS = {
                    'position': 'absolute',
                    'float'   : 'left',
                    'left'    : '12%',
                    'z-index' : '50',
                    'height'  : '20%',
                    'width'   : 'auto',
                    'top'     : '22%',
                };
            artworkShown = false;
            // if the idle timer hasn't started already, start it
            if (!idleTimer && evt && !previewing) { // loadCollection is called without an event to show the first collection
                idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
                idleTimer.start();
            }
            //Set background image
            if (collection.Metadata.BackgroundImage) {
                bgimage.css('background-image', "url(" + FIX_PATH(collection.Metadata.BackgroundImage) + ")");
            }
            //Change timeline shown based on saved metadata
            if (collection.Metadata.Timeline === "true" || collection.Metadata.Timeline === "false") {
                collection.Metadata.Timeline === "true" ? timelineShown = true : timelineShown = false;
            } else {
                timelineShown = true; //default to true for backwards compatibility
            }
            //If on associated media view and there are no associated media with valid dates, hide the timeline
            if (onAssocMediaView && collection.collectionMediaMinYear===Infinity){
                timelineShown = false;
            }
            buttonRow.empty();

            if (collection.Metadata.AssocMediaView && collection.Metadata.AssocMediaView === "true"){ 
                TAG.Worktop.Database.getAssocMediaIn(collection.Identifier, function (mediaDoqs) {
                    if (cancelLoad) return;
                    for (i=0;i<mediaDoqs.length;i++){
                        collectionMedia.push(mediaDoqs[i]);
                    }
                    collection.collectionMedia = collectionMedia;
                    if (sortByYear(collectionMedia,true).min()){
                        collection.collectionMediaMinYear = sortByYear(collectionMedia,true).min().yearKey;
                    }
                })   
            }

            // Clear search box
            searchTxt.text("");

            //re-display the magnifying glass icon
            searchInput.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });

            // Clear catalog div (with info and artwork tiles)
            catalogDiv.empty();
            catalogDiv.stop();

            

            if (!collectionDots[collection.Identifier]){
                //For previewing unpublished collections in authoring: add a collection dot and highlight it. 
                dummyDot = $(document.createElement('div'))
                    .addClass('collectionDot')
                    .css({
                        "width": COLLECTION_DOT_WIDTH,
                        "height":  COLLECTION_DOT_WIDTH,
                        "border-radius": COLLECTION_DOT_WIDTH / 2,
                        "margin": COLLECTION_DOT_WIDTH/4,
                        "background-color":'white'
                    });
                collectionDotHolder.append(dummyDot);
                backArrowArea.css('display', 'none');
            } else {
                //Make collection dot white and others gray
                for(i = 0; i < visibleCollections.length; i++) { 
                    collectionDots[visibleCollections[i].Identifier].css('background-color','rgb(170,170,170)');
                }
                collectionDots[collection.Identifier].css('background-color', 'white');
            }                

            // Add collection title
            mainCollection.addClass('mainCollection');
            titleBox.addClass('collection-title primaryFont').html(title);

            var uiDocfrag = document.createDocumentFragment();
            // Add previous and next collection titles
            if (collection.prevCollectionIndex||collection.prevCollectionIndex===0){
                prevTitle = TAG.Util.htmlEntityDecode(visibleCollections[collection.prevCollectionIndex].Name)
                backArrowArea.addClass('arrowArea');
                
                backArrowArea.css('left', '0%')
                    .off()
                    .on('mousedown', function(j){
                        return function () {
                            prepareNextView();
                            loadCollection(visibleCollections[j.prevCollectionIndex])();
                        }
                    }(collection));
                backArrow.attr('src', tagPath + 'images/icons/Close.svg');
                backArrow.addClass('arrow');    
                backArrowArea.show();
                prevCollection.addClass('nextPrevCollection')
                            .addClass('primaryFont')
                            //.attr({
                            //   'id': 'collection-' + visibleCollections[collection.prevCollectionIndex].Identifier
                            //})
                            .css('left','3%')
                            .html(prevTitle)
                            .off()
                            .on('mousedown', function(j){
                                return function () {
                                    prepareNextView();
                                    loadCollection(visibleCollections[j.prevCollectionIndex])();
                                }
                            }(collection));
                //collectionArea.append(prevCollection);
                uiDocfrag.appendChild(prevCollection[0]);
                prevCollection.show();
                TAG.Telemetry.register(backArrowArea, 'mousedown', 'collection_title', function(tobj){
                    tobj.custom_1 = CryptoJS.SHA1(prevTitle).toString(CryptoJS.enc.Base64);
                    tobj.mode = 'Kiosk';

                });
                TAG.Telemetry.register(prevCollection, 'mousedown', 'collection_title', function(tobj){
                    tobj.custom_1 = CryptoJS.SHA1(prevTitle).toString(CryptoJS.enc.Base64);
                    tobj.mode = 'Kiosk';
                });
            }

            if (prevCollection){
                prevCollection.css('width', (.95 * collectionArea.width() - mainCollection.width())/2 - backArrowArea.width());
                // prevCollection.css('color', '#' + PRIMARY_FONT_COLOR);
            }
            if (collection.nextCollectionIndex||collection.nextCollectionIndex===0){
                nextTitle = TAG.Util.htmlEntityDecode(visibleCollections[collection.nextCollectionIndex].Name)
                nextArrowArea.addClass('arrowArea');
                nextArrowArea.css({'right': '0%'})
                            .off()
                            .on('mousedown', function(j){
                                return function () {
                                    prepareNextView();
                                    loadCollection(visibleCollections[j.nextCollectionIndex])();
                                }
                            }(collection));
                nextArrowArea.show();
                // collectionArea.append(nextArrowArea);
                nextArrow.attr('src', tagPath + 'images/icons/Open.svg');
                nextArrow.addClass('arrow');
                nextCollection.addClass('nextPrevCollection')
                              .addClass('primaryFont')
                              //.attr({
                              //   'id': 'collection-' + visibleCollections[collection.nextCollectionIndex].Identifier
                              // })
                              .html(nextTitle)
                              .css({
                                  'right': 0 + nextArrowArea.width()/2,
                                  'width': (.95 * collectionArea.width() - mainCollection.width())/2 - nextArrowArea.width(),
                                  //'color': '#' + PRIMARY_FONT_COLOR
                              })
                            .off()
                            .on('mousedown', function(j){
                                return function(){
                                    prepareNextView();
                                    loadCollection(visibleCollections[j.nextCollectionIndex])();
                                }
                            }(collection));
                nextCollection.show();
                TAG.Telemetry.register(nextArrowArea, 'mousedown', 'collection_title', function(tobj){
                    tobj.custom_1 = CryptoJS.SHA1(nextTitle).toString(CryptoJS.enc.Base64);
                    tobj.mode = 'Kiosk';
                });
                TAG.Telemetry.register(nextCollection, 'mousedown', 'collection_title', function(tobj){
                    tobj.custom_1 = CryptoJS.SHA1(nextTitle).toString(CryptoJS.enc.Base64);
                    tobj.mode = 'Kiosk';
                });
                //collectionArea.append(nextCollection);
                uiDocfrag.appendChild(nextCollection[0]);
            }
            collectionArea.append($(uiDocfrag));

            if (collection.prevCollectionIndex===null && !collection.nextCollectionIndex===null) {
                backArrowArea.hide();
                nextArrowArea.hide();
            } else if (collection.prevCollectionIndex === null) {
                backArrowArea.hide();
                prevCollection.hide();
            } else if (collection.nextCollectionIndex === null) {
                nextArrowArea.hide();
                nextCollection.hide();
            }
            collectionDescription.attr('id', 'collectionDescription');
            collectionDescription.addClass('secondaryFont');
            collectionDescription.css({'word-wrap': 'break-word', "height": "98%", "color": SECONDARY_FONT_COLOR});
                str = collection.Metadata.Description ? collection.Metadata.Description.replace(/\n\r?/g, '<br />') : "";
                collectionDescription.css({
                    'font-size': 0.2 * TAG.Util.getMaxFontSizeEM(str, 1.5, 0.55 * $(infoDiv).width(), 0.915 * $(infoDiv).height(), 0.1),
                });
                collectionDescription.html(Autolinker.link(str, {email: false, twitter: false}));
                if (IS_WINDOWS) {
                    if (collectionDescription) {
                        var links = collectionDescription.find('a');
                        links.each(function (index, element) {
                            $(element).replaceWith(function () {
                                return $.text([this]);
                            });
                        });
                    }
                }

            //If there's no description, change UI so that artwork tiles take up entire bottom area
            if (collection.Metadata.Description && !onAssocMediaView) {
                infoDiv.css('width', '25%'); 
            } else { 
                infoDiv.css('width', '0%');
            }

            // Hide selected artwork container, as nothing is selected yet
            selectedArtworkContainer.css('display', 'none');
            ;

            tileDiv.empty();
            catalogDiv.append(tileDiv);
            infoDiv.empty();
            infoDiv.append(collectionDescription);
            catalogDiv.append(infoDiv);
            timelineArea.empty();
            styleBottomContainer();

            //Show loading circle
            tileCircle = TAG.Util.showProgressCircle(catalogDiv, progressCircCSS, catalogDiv.width()/2, catalogDiv.height()/2, true);
            catalogDiv.append(tileCircle);

            if (collection.Metadata.AssocMediaView && collection.Metadata.AssocMediaView === "true"){

                toggleRow.css({
                    'display': 'block',
                });
                if (TAG.Util.Splitscreen.isOn()) {
                    toggleRow.css('width', '40%');
                }
                artworksButton.off()
                              .on('mousedown', function(){
                                    artworksButton.css('color', SECONDARY_FONT_COLOR);
                                    assocMediaButton.css('color', dimmedColor);
                                    if (onAssocMediaView){
                                        artworkShown = false;
                                        onAssocMediaView = false;
                                        loadCollection(currCollection)();
                                    }
                               });
                
                assocMediaButton.off()
                                .on('mousedown', function(){
                                    artworksButton.css('color', dimmedColor);
                                    assocMediaButton.css('color', SECONDARY_FONT_COLOR);  
                                    if (!onAssocMediaView) {
                                        currentArtwork && hideArtwork(currentArtwork)()
                                        onAssocMediaView = true;
                                        loadCollection(currCollection)();
                                    }
                                });
            } else {
                toggleRow.css('display','none');
            }
           
            currCollection = collection;
            currentArtwork = artwrk || null;
            //loadCollection.call($('#collection-'+ currCollection.Identifier), currCollection);
            //scrollPos = sPos || 0;
            applyCustomization();
            if (!onAssocMediaView || !currCollection.collectionMedia) {
                getCollectionContents(currCollection, null, function () { return cancelLoad;});
            } else {
                if (onAssocMediaView && artworkInCollectionList.length == 0) {
                    TAG.Worktop.Database.getArtworksIn(collection.Identifier,
                        function (contents) {
                            artworkInCollectionList = [];
                            for (var i = 0; i < contents.length; i++) {
                                artworkInCollectionList.push(contents[i].Identifier);
                            }

                            createArtTiles(currCollection.collectionMedia);
                            loadSortTags(currCollection, currCollection.collectionMedia)
                            initSearch(currCollection.collectionMedia);
                        }, null, null);
                } else {
                    createArtTiles(currCollection.collectionMedia);
                    loadSortTags(currCollection, currCollection.collectionMedia)
                    initSearch(currCollection.collectionMedia);
                }
            }
            cancelLoadCollection = function () { cancelLoad = true; };

        }
    }
    this.loadCollection = loadCollection;

    /**
     * Helper function to load first collection
     * @method loadFirstCollection
     */
    function loadFirstCollection() {
        loadCollection(toShowFirst, null,currentArtwork && currentArtwork)();
    }

    /*helper function to load sort tags
        * @method loadSortTags
        * @param {Object} collection
        * @param {Object} contents (of collection, to check for tours)  
        */
    function loadSortTags(collection,contents) {
        var sortOptions = [],
            sortButton,
            sortButtonTags = {}; 
        if (!onAssocMediaView && collection.Metadata.SortOptions) {
            var sortOptionsObj = JSON.parse(collection.Metadata.SortOptions || "{}");
            /*TAG.Worktop.Database.getDoq(collection.Metadata.SortOptionsGuid, function getSortOptions(sortOptionsDoq){
            var sortObjects = sortOptionsDoq.Metadata,
                sortText,
                sortObjArray;
            if (sortObjects){
                for (var sortObj in sortObjects){
                    if (sortObjects.hasOwnProperty(sortObj) && sortObj !== "__Created" && sortObj !== "Count") {
                        if (sortObj.charAt(0) === '?') {
                            sortText = sortObj.substr(1);
                        } else {
                            sortText = sortObj;
                        }
                        sortObjArray = sortObjects[sortObj].split(",");
                        if ((sortObjArray.length === 2 && sortObjArray[1] === "true" || sortObjArray[1] === true)
                                        || (sortObjArray[0] === true || sortObjArray[0] === "true")) {
                            sortOptions.push(sortText);
                        }
                    }
                }
            }*/
            for (var sortTag in sortOptionsObj){
                if (sortOptionsObj[sortTag] === true) {
                    sortOptions.push(sortTag);
                    //sortTag.style.marginTop = "30%";
                }
            }
            appendTags();
            //});
        } else if (onAssocMediaView){
            sortOptions = ["Date","Title"];
            appendTags();
        } else {
            sortOptions = ["Date", "Title", "Artist"];
            /*if (!sortCatalog(contents,"Tour").isEmpty()){
                sortOptions.push("Tour");
            }*/
            appendTags();
        }
        /**Callback function to create the sort tag buttons
        * @method appendTags
        */
        function appendTags() {
            var i,
                text;
            buttonRow.empty();
            var uiDocfrag = document.createDocumentFragment();
            for (i = 0; i < sortOptions.length; i++) {
                sortButton = $(document.createElement('div'));
                uiDocfrag.appendChild(sortButton[0]);
                //Because stored on server as "Tour" but should be displayed as "Tours"
                sortOptions[i]==="Tour" ? text = "Tours" : text = sortOptions[i];
                sortButton.addClass('secondaryFont');
                sortButton.addClass('rowButton')
                            .text(text)   
                            .attr('id', sortOptions[i].toLowerCase() + "Button")
                         .off()
                            .on('mousedown', function () {
                                //currentArtwork = null;
                                changeDisplayTag(currentArtworks, sortButtonTags[$(this).attr('id')]);
                            });
               
                //var spec = {
                //    height: .7,
                //    width:1,
                //    center_v: true,
                //};
                //var newPos = TAG.Util.constrainAndPosition(0, buttonRow.height(), spec); // give a random width cuz when try to get the centered yPos, width doesn't matter
                //sortButton.css("top", newPos.y + 'px');
                //sortButton.css("height", newPos.height + 'px');
                //buttonRow.append(sortButton);
                sortButtonTags[sortButton.attr('id')] = sortOptions[i];
                //TO-DO: test this telemetry handler
                TAG.Telemetry.register(sortButton, 'mousedown', '', function (tobj) {
                    tobj.ttype = 'sort_by_' + sortButtonTags[$(sortButton).attr('id')].toLowerCase();
                    tobj.mode = 'Kiosk';
                });
            }
            buttonRow.append($(uiDocfrag));
            if (!comingBack || !currentTag) {
                //If currentTag not defined currentTag is either 'year' or 'title' depending on if timeline is shown
                if (timelineShown && (sortOptions.indexOf('Date')>=0)) {
                    currentTag = "Date";
                    currentDefaultTag = "Date";
                } else if (sortOptions.indexOf('Title')>=0) {
                    currentTag = "Title";
                    currentDefaultTag = "Title";
                } else {
                    //if no year or title sort currentTag is first sortButton, or null if there are no sortOptions.
                    sortOptions[0] ? currentTag = sortOptions[0] : currentTag = null;
                    currentDefaultTag = currentTag;
                }
            }
            colorSortTags(currentTag);
        }

    }
    /**
     * Get contents (artworks, videos, tours) in the specified collection and make catalog
     * @method getCollectionContents
     * @param {doq} collecion         the collection whose contents we want
     * @param {Function} callback     a function to call when the contents have been retrieved
     */
    function getCollectionContents(collection, callback, cancel) {
        TAG.Worktop.Database.getArtworksIn(collection.Identifier, contentsHelper, null, contentsHelper);

        /**
         * Helper function to process collection contents
         * @method contentsHelper
         * @param {Array} contents     array of doq objects for each of the contents of this collection
         */
        function contentsHelper(contents) {
            artworkInCollectionList = [];
            for (var i = 0; i < contents.length; i++){
                artworkInCollectionList.push(contents[i].Identifier);
            }
            if (!contents.length) {
                var emptyCollectionDiv = $(document.createElement('div'));
                emptyCollectionDiv.addClass("primaryFont");
                emptyCollectionDiv.text("There are no artworks in this collection at present.");
                emptyCollectionDiv.css({ "text-align": "center", "margin-top": "20%", "color": PRIMARY_FONT_COLOR });
                catalogDiv.append(emptyCollectionDiv);
            }
            if (cancel && cancel()) return;
            loadSortTags(collection,contents);
            createArtTiles(contents, cancel);
            initSearch(contents);
            callback && callback();
        }

        
    }

    /**
     * Store the search strings for each artwork/tour
     * @method initSearch
     * @param {Array} contents    the contents of this collection (array of doqs)
     */
    function initSearch(contents) {
        var info,
            i,
            cts;

        searchInput[0].value = "";
        infoSource = [];

        $.each(contents, function (i, cts) {
            if (!cts) {
                return false;
            }
            info = ((cts.Name) ? cts.Name : "") + " " + ((cts.Metadata.Artist) ? cts.Metadata.Artist : "") + " " + ((cts.Metadata.Year) ? cts.Metadata.Year : "") + " " + ((cts.Metadata.Description) ? cts.Metadata.Description : "") + " " + ((cts.Metadata.Type) ? cts.Metadata.Type : "");
            if (cts.Metadata.InfoFields) {
                $.each(cts.Metadata.InfoFields, function (field, fieldText) {           //Adding custom metadata fields: both keys and values
                    info += " " + field;
                    info += " " + fieldText;
                });
            }
            infoSource.push({
                "id": i,
                "keys": info.toLowerCase()
            });
        });
    }

    /**
     * Search collection using string in search input box
     * @method doSearch
     */
    function doSearch() {
        var content = searchInput.val().toLowerCase(),
            matchedArts = [],
            unmatchedArts = [],
            i;

        if (!content) {
            searchTxt.text("");
            drawCatalog(currentArtworks, currentTag, 0, false);
            return;
        }

        for (i = 0; i < infoSource.length; i++) {
            if (infoSource[i].keys.indexOf(content) > -1) {
                matchedArts.push(currentArtworks[i]);
            } else {
                unmatchedArts.push(currentArtworks[i]);
            }
        }

        //searchTxt.text(matchedArts.length > 0 ? "Results Found" : "No Matching Results");

        drawCatalog(matchedArts, currentTag, 0, true);
        drawCatalog(unmatchedArts, currentTag, matchedArts.length, false);
    }

    /**
     * Create tiles for each artwork/tour in a collection
     * @method createArtTiles
     * @param {Array} artworks     an array of doq objects
     */
    function createArtTiles(artworks, cancel) {
        currentArtworks = artworks;
        currentTag && colorSortTags(currentTag);
        drawCatalog(currentArtworks, currentTag, 0, null, cancel);
        //drawCatalog(artworks, currentTag, 0);
    }

    /**
     * Draw the collection catalog
     * @method drawCatalog
     * @param {Array} artworks    the contents of the collection
     * @param {String} tag        current sorting tag
     * @param {Number} start      starting at start-th artwork total (note NOT start-th artwork in artworks)
     * @param {Boolean} onSearch  whether the list of artworks is a list of works matching a search term
     */
    function drawCatalog(artworks, tag, start, onSearch) {
        if (!currCollection) {
            return;
        }

        if (start === 0) {
            loadQueue.clear();
            drawHelper();
            
        } else {
            drawHelper();
        }

        /**
         * helper function to perform the actual drawing (to make sure we deal with async correctly)
         * @method drawHelper
         */
        function drawHelper() {
            var sortedArtworks,
                minOfSort,
                currentWork,
                works,
                progressCircCSS,
                paddingDiv,
                circle,
                i, h, w, j;


            if (!artworks || artworks.length === 0){
                tileCircle.hide();
                if (onAssocMediaView) {
                    assocMediaButton.css({ "color": SECONDARY_FONT_COLOR });
                    artworksButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                } else {
                    assocMediaButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                    artworksButton.css({ "color": SECONDARY_FONT_COLOR });
                }
                assocMediaButton.removeAttr('disabled');
                artworksButton.removeAttr('disabled');
                return;
            }

            if (tag){
                sortedArtworks = sortCatalog(artworks, tag);
                minOfSort      = sortedArtworks.min();
                currentWork    = minOfSort ? minOfSort.artwork : null;
                works = sortedArtworks.getContents();
            } else {
                //If no sort options
                works = artworks;
                currentWork = artworks[0];
            }
            i = start;
            h = catalogDiv.height() * 0.48;
            w = h * 1.4;
                
            tileDiv.empty();
            tileDivHeight = tileDiv.height();

            
            for (j = 0; j < works.length; j++) {
                if (tag){
                    loadQueue.add(drawArtworkTile(works[j].artwork, tag, onSearch, i+j, j === works.length-1));
                }
                else{
                    loadQueue.add(drawArtworkTile(works[j], null, onSearch, i+j, j === works.length-1));
                }
            }
            if (works.length == 0) {

                if (onAssocMediaView) {
                    assocMediaButton.css({ "color": SECONDARY_FONT_COLOR });
                    artworksButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                } else {
                    assocMediaButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                    artworksButton.css({ "color": SECONDARY_FONT_COLOR });
                }

                assocMediaButton.removeAttr('disabled');
                artworksButton.removeAttr('disabled');
                
            }
            loadQueue.add(function () {
                if (works.length > 0) {
                    paddingDiv = $(document.createElement("div"))
                        .css({
                            'height': "100%",
                            "width": TILE_BUFFER,
                            "pointer-events": "none",
                            'position': 'absolute',
                            "margin": "none",
                            'left': tileDiv.children().eq(-1).position().left + tileDiv.children().eq(-1).width() // to get last child position
                        });
                    tileDiv.append(paddingDiv);
                }
            })
       
            loadQueue.add(function () {
            	tileCircle.hide();
            })
            if (IS_WINDOWS){
            loadQueue.add(function () {
                showArtwork(currentArtwork, multipleShown && multipleShown)();
            })
            }
            tileDiv.css({'left': infoDiv.width()});
            if (infoDiv.width()===0){
                tileDiv.css({'margin-left':'2%'});
            } else{
                tileDiv.css({'margin-left':'0%'});
            }
            catalogDiv.append(tileDiv);
            clearTimeline(artworks);
           
        }
    }
        
    /**
        * helper function to reset and clear timeline
        * @method drawHelper
        */
    function clearTimeline(artworks){
        timelineEventCircles = [];
        timelineTicks = [];
        scaleTicks = [];
        artworkYears = {};
        timelineArea.empty();
        if (currentTimeline){
            currentTimeline.stop(true, true);
            currentArtwork = null;
        }
        if (currTimelineCircleArea){
            currTimelineCircleArea.stop(true,true);
        }
        if (timelineShown && artworks) {
            if (onAssocMediaView) {
                var loadAssocMediaTimeline;
                setTimeout(function () { initTimeline(artworks) }, 1000);
            } else {
                initTimeline(artworks);
            }
        }
        styleBottomContainer();
    }

    /* Helper method to style bottom container based on if timeline is shown
        * @method styleBottomContainer
        */
    function styleBottomContainer(){
        if (timelineShown){   
                bottomContainer.css({
                    'height' : '69%',
                    'top' : '25%',
                    'z-index': '',
                });
                selectedArtworkContainer.css({
                    'height' :'110%',
                    'bottom' : '-5%'
                });
        } else {
            bottomContainer.css({
                'height':'79%',
                'top':'15%',
                'z-index':'100005',
            });
            selectedArtworkContainer.css({
                'height': '100%',
                'bottom':'-4%'
            })
        }
    }

    /**
     * Creates an artwork tile in a collection's catalog
     * @method drawArtworkTile
     * @param {doq} currentWork     the artwork/tour for which we're creating a tile
     * @param {String} tag          current sort tag
     * @param {Boolean} onSearch    whether this work is a match after searching
     * @param {Number} i            index into list of all works in this collection
     */
    var tileDivDocFrag = document.createDocumentFragment();
    tileDivDocFrag.appendChild(tileDiv[0]);
    function drawArtworkTile(currentWork, tag, onSearch, i, last) {
        return function () {
            var main      = $(document.createElement('div')),
                artTitle  = $(document.createElement('div')),
                artText   = $(document.createElement('div')),
                tileImage = $(document.createElement('img')),
                yearTextBox  = $(document.createElement('div')),
                yearText,
                tourLabel,
                videoLabel,
                showLabel = true;
  
            //var uiDocfrag = document.createDocumentFragment();
            //uiDocfrag.appendChild(main[0]);

            artworkTiles[currentWork.Identifier] = main;
            main.addClass("tile");
            tileImage.addClass('tileImage');
            artTitle.addClass('artTitle');
            artText.addClass('artText');
            artText.addClass('secondaryFont');
            artText.css({
                'color': SECONDARY_FONT_COLOR,
                //'font-family': FONT
            });
            yearTextBox.addClass('yearTextBox');
            yearTextBox.addClass('secondaryFont');
            yearTextBox.css({
                'color': SECONDARY_FONT_COLOR,
                //'font-family': FONT
            });

            /* @function doubleClickHandler
                * Opens artwork directly on double click
                * Basically, sets a timeout during which the artwork can be clicked again to be opened
                * @returns handler function
                */
            function doubleClickHandler() {
                return function () {
                    if (currentWork.Metadata.Type === "Artwork" || currentWork.Metadata.ContentType === "tour" || currentWork.Metadata.Type === "VideoArtwork") {

                        if (previouslyClicked === main) {
                            switchPage(currentWork, null, getContainerLeft(currentWork, false))();
                        } else {
                            previouslyClicked = main;
                            setTimeout(function () { previouslyClicked = null }, 1000)
                        }
                    } else {
                        TAG.Worktop.Database.getArtworksAssocTo(currentWork.Identifier, function (doqs) {
                            if (previouslyClicked === main) {
                                switchPage(doqs[0], currentWork, getContainerLeft(currentWork,false))();
                            } else {
                                previouslyClicked = main;
                                setTimeout(function () { previouslyClicked = null }, 1000);
                            }
                        }, function () {
                            
                        }, function () {
                            
                        });
                    }

                }();
            } 
                main.on('click', function () {
                    doubleClickHandler()

                    // if the idle timer hasn't started already, start it
                    if (!idleTimer && !previewing) {
                        idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
                        idleTimer.start();
                    }
                    //Timeout so that double click is actually captured at all (otherwise, it scrolls out of the way too quickly for second click to occur)
                    setTimeout(function () { showArtwork(currentWork, false)() }, 10)
                    zoomTimeline(artworkCircles[currentWork.Identifier])
                    justShowedArtwork = true;
                })         
            
            TAG.Telemetry.register(main, 'click', '', function(tobj) {
                var type;
                tobj.ttype = 'artwork_tile';
                tobj.custom_1 = CryptoJS.SHA1(currentWork.Name).toString(CryptoJS.enc.Base64);
                tobj.mode = 'Kiosk';
                justShowedArtwork = false;
            });

            // Set tileImage to thumbnail image, if it exists
            if(currentWork.Metadata.Thumbnail && currentWork.Metadata.ContentType !== "Audio" ) {
                main.css('overflow','hidden');
                
                tileImage.attr("src", FIX_PATH(currentWork.Metadata.Thumbnail));
                
                var w, h;
                $("<img/>") // preload the image to "crop" it
                    .attr("src", tileImage.attr("src"))
                    .load(function() {
                        w = this.width;   
                        h = this.height; 
                        var mainh=tileImage.height();
                        var mainw=tileImage.width();
                        if(mainw/mainh<w/h){
                            mainh = tileImage.height();
                            var neww= w/h*mainh;
                            tileImage.css({
                                'height':mainh,
                                'width':neww,
                            });
                        }else{
                            mainw = tileImage.width();
                            var newh = h/w*mainw;
                            tileImage.css({
                                'width':mainw,
                                'height':newh,
                            });
                        }
                    });
            } else if (currentWork.Metadata.ContentType === "Audio" ){
                tileImage.css('background-color','black');
                tileImage.attr('src', tagPath+'images/audio_thumbnail.svg');
            } else if (currentWork.Metadata.Medium=== "Video"|| currentWork.Metadata.ContentType==="Video"||currentWork.Metadata.ContentType ==="iframe"){
                showLabel = false;
                tileImage.css('background-color','black');
                tileImage.attr('src', tagPath + 'images/video_thumbnail.svg');
            } else if (currentWork.Metadata.ContentType === "Image") {
                if (currentWork.Metadata.Thumbnail) {
                    tileImage.attr("src", FIX_PATH(currentWork.Metadata.Thumbnail));
                } else if (currentWork.Metadata.Source) {
                    tileImage.attr("src", FIX_PATH(currentWork.Metadata.Source));
                } else {
                    tileImage.attr("src", tagPath + 'images/image_icon.svg');
                }
            } else if (currentWork.Type === "Empty" || currentWork.Type === "Tour" || currentWork.Metadata.Type === "Tour" || currentWork.Metadata.ContentType === "Tour") {
                tileImage.css('background-color', 'black');
                if (currentWork.Metadata.Thumbnail) {
                    tileImage.attr('src', FIX_PATH(currentWork.Metadata.Thumbnail));
                } else {
                    tileImage.attr('src', FIX_PATH("/Images/default.jpg"));
                }
            }else{
                tileImage.attr("src", tagPath+'images/no_thumbnail.svg'); 
            } 
            

            // Add title
            if (tag === 'Title') {
                artText.text(TAG.Util.htmlEntityDecode(currentWork.Name));
            } else if (tag === 'Artist') {
                artText.text(TAG.Util.htmlEntityDecode(currentWork.Name) ); 
                yearTextBox.css('visibility', 'visible');
                yearText = currentWork.Metadata.Artist;
                if (!yearText) {
                    yearTextBox.text('')
                        .css('visibility', 'hidden');
                } else {
                    yearTextBox.text(yearText);
                }
            } else if (tag === 'Date') {
                yearTextBox.css('visibility','visible');
                yearText = getDateText(getArtworkDate(currentWork,true));
                if (currentWork.Type === 'Empty' || !yearText){
                    yearTextBox.text('')
                        .css('visibility','hidden');
                } else {
                    yearTextBox.text(yearText);
                }
                var nameText = TAG.Util.htmlEntityDecode(currentWork.Name);
                artText.text(nameText);
            } else if (tag === 'Tours') {
                artText.text(TAG.Util.htmlEntityDecode(currentWork.Name));
            } else if(tag) {
                //If using custom tag
                artText.text(TAG.Util.htmlEntityDecode(currentWork.Name));
                yearTextBox.css('visibility', 'visible');
                yearText = currentWork.Metadata.InfoFields[tag];
                if (!yearText) {
                    yearTextBox.text('')
                        .css('visibility', 'hidden');
                } else {
                    yearTextBox.text(yearText);
                }
            } else {
                //no sort tag
                artText.text(TAG.Util.htmlEntityDecode(currentWork.Name));
            }
            artTitle.append(artText);

            // Styling for searches
            if (!onSearch && searchInput.val() !== '') {
                main.css({ 'opacity': '0.2' });
                main.css('border', '1px solid black');
            } else if (onSearch) {
                tileImage.css({ 'opacity': '1.0'});
                main.css('border', '1px solid rgba(255, 255, 255, 0.5)');
            }
            main.append(tileImage)
                .append(artTitle)
                .append(yearTextBox);

            if (currentWork.Type === "Empty" && currentWork.Metadata.ContentType !== "iframe" && currentWork.Metadata.Type !== "VideoArtwork") {
                tourLabel = $(document.createElement('img'))
                    .addClass('tourLabel')
                    .attr('src', tagPath+'images/icons/catalog_tour_icon.svg');
                main.append(tourLabel);
            } else if (currentWork.Metadata.Medium === "Video"|| currentWork.Metadata.ContentType==="Video") {
                if (showLabel){
                    videoLabel = $(document.createElement('img'))
                        .addClass('videoLabel')
                        .attr('src', tagPath + 'images/icons/catalog_video_icon.svg');
                    main.append(videoLabel);
                }
            }

            tileDiv.append(main);
            
            //base height off original tileDivHeight (or else changes when scroll bar added on 6th tile)
            var tileHeight = (0.45) * tileDivHeight;
            main.css({'height': (0.45) * tileDivHeight});
            main.css({'width': (tileHeight/TILE_HEIGHT_RATIO)*TILE_WIDTH_RATIO});
             // Align tile so that it follows the grid pattern we want
            main.css({
                'left': Math.floor(i / 2) * (main.width() + TILE_BUFFER), 
                'top' : Math.floor(i % 2) * (main.height() + TILE_BUFFER)
            });

            //Add scrollbar to catalog div if needed
            /**
            if (main.position().left + main.width() > main.parent().width()) {
                catalogDiv.css("overflow-x", "scroll")
            }      
            **/
            if (last) {
                if (onAssocMediaView) {
                    assocMediaButton.css({ "color": SECONDARY_FONT_COLOR });
                    artworksButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                } else {
                    assocMediaButton.css({ "color": TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR, DIMMING_FACTOR) });
                    artworksButton.css({ "color": SECONDARY_FONT_COLOR });
                }
                
                assocMediaButton.removeAttr('disabled');
                artworksButton.removeAttr('disabled');
                displayArea.append($(tileDivDocFrag));
            }
            if (artworkShown) {
                main.css({ "opacity": .5 });
            };
        };
    }

    /** styles a circle for the timeline
    * @method styleTimelineCircle
    * @param  {HTML element} element      element to be styled
    * @param  {bool} selected             Whether or not circle is selected
    */
    function styleTimelineCircle(element, selected) {
        if (previewing) {
            EVENT_CIRCLE_WIDTH = root.width()/ 40; // for collections page preview in authoring
        }
        if (selected) {
            element.css({
                'height': EVENT_CIRCLE_WIDTH*3/2,
                'width': EVENT_CIRCLE_WIDTH*3/2,
                'border-radius': EVENT_CIRCLE_WIDTH*3 / 4,
                'top': -EVENT_CIRCLE_WIDTH*3 / 4,
                'opacity': "1"
            });
           element.timelineDateLabel.css({
                'visibility': 'visible',
                'color' : 'white',
                'font-size' : '110%',
                'bottom': "100%",
                'left': element.width()/2 - element.timelineDateLabel.width()*1.1 / 2
            }); 
        } else {
            element.css({
                'height': EVENT_CIRCLE_WIDTH,
                'width': EVENT_CIRCLE_WIDTH,
                'border-radius': EVENT_CIRCLE_WIDTH / 2,
                'top': -EVENT_CIRCLE_WIDTH / 2,
                'opacity': .5
            });
            element.timelineDateLabel.css({
                'color': 'rgb(170,170,170)',
                'font-size': "100%",
                'bottom': "100%",
                'left': EVENT_CIRCLE_WIDTH / 2 - element.timelineDateLabel.width() / 2
            });
        }
    }

    /**Initializes timeline for a collection of artworks
     * @method initTimeline
     * @param  {Array} artworks              list of artworks in the collection
     */
    function initTimeline(artworks) {
        var avlTree,
            maxNode,
            maxDate,
            minDate,
            timelineDate;
        if (!artworks || artworks.length === 0){
            return;
        };

        //Sort artworks by year and find the minimum and maximum
        avlTree = sortByYear(artworks, true);
        maxNode = avlTree.max();

        //Hide timeline if there are no compatible dates-- mostly for backwards compatibility
        if (avlTree.min().yearKey === Number.POSITIVE_INFINITY){
            timelineShown = false;
            clearTimeline();
            //TO-DO coming back isn't right here, so coming back from artwork viewer fails in this specific case
            if (!comingBack){
                if ($('#titleButton')){
                    currentTag = "Title";
                } else {
                    currentTag = currentDefaultTag || null;
                }
            }
            changeDisplayTag(artworks,currentTag);
            colorSortTags(currentTag);
            return;
        }
        
        //Skip before tours and artworks with incompatible dates
        while (maxNode.yearKey === Number.POSITIVE_INFINITY){
            maxNode = avlTree.findPrevious(maxNode);
        }

        maxDate = parseInt(maxNode.yearKey);
        minDate = parseInt(avlTree.min().yearKey);

        //Save the original maximum and minimum display date
        fullMaxDisplayDate = maxDate;
        fullMinDisplayDate = minDate;

        //TO-DO: calculate and pass in numTicks based on number of years
        currentTimeline = prepTimelineArea(minDate, maxDate);
        currTimelineCircleArea = prepTimelineCircles(avlTree, minDate, maxDate);
        setTimeout(function() {
            currentArtwork && zoomTimeline(artworkCircles[currentArtwork.Identifier]);
        }, 100);

        /**Helper function to prepare timeline area including 'ticks'
        * @method prepTimelineArea
        * @param  {Integer} minDate          minimum artwork date
        * @param  {Integer} maxDate          maximum artwork date
        * @param  {Integer} numTicks         optional specification for number of timeline ticks
        * @return {Object}  timeline         div representing timeline ticks 
        */
        function prepTimelineArea(minDate, maxDate){
            var timeline = $(document.createElement('div')),
                i,
                dateRange = maxDate - minDate,
                numTicks = 101,
                tick;

            timeline.addClass('timeline');
            timelineArea.append(timeline);

            //Create ticks
            for (i = 0; i < numTicks; i++) { 
                tick = $(document.createElement('div'));
                tick.addClass('timelineTick');
                tick.css({
                    'left' : (i/(numTicks-1)*100 - .05) + '%'
                });
                tick.Offset = i/numTicks;
                timeline.append(tick);
                timelineTicks.push(tick);
            }
            return timeline;
        }

        /**Helper function to prepare and append the timeline event circles
        * @method prepTimelineCircles
        * @param  {AVLTree} avlTree        avlTree for access to artworks in year order
        * @param  {Number}  minDate        minimum date of artworks in collection
        * @param  {Number}  maxDate        maximum date of artworks in collection
        */
        function prepTimelineCircles(avlTree, minDate, maxDate){
            var curr,
                timeRange,
                art,
                positionOnTimeline,
                eventCircle,
                timelineCircleArea = $(document.createElement('div')),
                yearText,
                timelineDateLabel,
                prevNode,
                circleOverlap,
                labelOverlap,
                zoomLevel = 1,
                currOffset;
            var uiDocfrag = document.createDocumentFragment();
            timeRange = maxDate - minDate;

            timelineCircleArea.addClass('timelineCircleArea');
            timelineArea.append(timelineCircleArea);

            curr = avlTree.min();
            art = curr.artwork;
       
            while (curr&& curr.yearKey!==Number.POSITIVE_INFINITY){
                if (!isNaN(curr.yearKey)){
                    positionOnTimeline = 100*(curr.yearKey - minDate)/timeRange;
                    var correctedPosition = (positionOnTimeline - 1.25);
                    //Create and append event circle
                    eventCircle = $(document.createElement('div'));
                    uiDocfrag.appendChild(eventCircle[0]);
                    eventCircle.addClass('timelineEventCircle')
                                .css('left', correctedPosition + '%')
                                .on('click', (function(art, eventCircle) {
                                    return function() {
                                    if (artworkShown === true && currentArtwork === art) {
                                        hideArtwork(art)();
                                        artworkShown = false;
                                    } else {
                                        if (!artworkTiles[art.Identifier]) {
                                            return;
                                        }
                                        zoomTimeline(eventCircle)
                                        showArtwork(art,true)();
                                        artworkShown  = true;
                                        } 
                                    }      
                                })(art, eventCircle));
                    //timelineCircleArea.append(eventCircle);

                    //Shift circles left by half their width so they are centered on ticks
                    //TO-DO: add this back in so that it works with new animations (all relative positioning)
                    //eventCircle.css('left', eventCircle.position().left - LEFT_SHIFT + 'px');

                    yearText = getDateText(getArtworkDate(curr.artwork, true));

                    //Create and append timeline date labels
                    timelineDateLabel = $(document.createElement('div'))
                            .text(yearText)
                            .addClass('timelineDateLabel');
                    eventCircle.append(timelineDateLabel);

                    eventCircle.yearKey = curr.yearKey;
                    eventCircle.timelineDateLabel = timelineDateLabel;
                    eventCircle.Offset = positionOnTimeline/100;
                    eventCircle.artwork = art;                    
                    timelineEventCircles.push(eventCircle);
                    artworkCircles[curr.artwork.Identifier] = eventCircle;
                    displayLabels(eventCircle);
                    
                    if (!artworkYears[yearText]){
                        artworkYears[yearText] = [curr.artwork];
                    } else {
                        artworkYears[yearText].push(curr.artwork);
                    }
                }
                curr = avlTree.findNext(curr);
                if(curr) { art = curr.artwork; }

            }
            timelineCircleArea.append($(uiDocfrag));
            //Set intitial style of timeline event circles and set their zoomLevel
            for (var i = 0; i < timelineEventCircles.length; i++) { // Make sure all other circles are grayed-out and small
                timelineEventCircles[i].zoomLevel = getZoomLevel(timelineEventCircles[i]);
                styleTimelineCircle(timelineEventCircles[i], false);
                displayLabels(timelineEventCircles[i]);
                //Label of last circle should always be shown
                if (i === timelineEventCircles.length-1){
                    displayLabels(timelineEventCircles[i],null,i);
                }
            };

            return timelineCircleArea;

            function getZoomLevel(circle){
                var center = .5,
                    nextCircle = timelineEventCircles[timelineEventCircles.indexOf(circle) + 1],
                    prevCircle = timelineEventCircles[timelineEventCircles.indexOf(circle) - 1],
                    lastCircle = timelineEventCircles[timelineEventCircles.length - 1],
                    firstCircle = timelineEventCircles[0],
                    spacing = .05;
                    zoomLevel = 1;

                currOffset = center - circle.Offset;
                if ((location(lastCircle) - center) < center) { 
                    zoomLevel = (center)/(lastCircle.Offset - circle.Offset)
                }
                if (center - (location(firstCircle)) < center) { 
                    zoomLevel = (center)/(firstCircle.Offset - circle.Offset)
                }
                if(Math.abs(zoomLevel) === Infinity){
                    zoomLevel = 1
                };
                if (nextCircle && ((location(nextCircle) - center) < spacing) && (location(nextCircle) - center) > 0) { 
                    zoomLevel = (spacing)/(nextCircle.Offset - circle.Offset)
                }
                if (prevCircle && ((center - location(prevCircle)) < spacing) && (center - location(prevCircle)) > 0) { 
                    zoomLevel = (spacing)/(prevCircle.Offset - circle.Offset)
                }
                return Math.abs(zoomLevel);
            }
            function location(dot){
                return ((currOffset + dot.Offset)  - .5) * Math.abs(zoomLevel)  + .5;
            }
        };
    };

    function displayLabels(circ, selectedCircle, numCircles){
        var prevNode,
            labelOverlap,
            timelineDateLabel = circ.timelineDateLabel,
            nextCircle = timelineEventCircles[timelineEventCircles.indexOf(circ) + 1],
            prevCircle = timelineEventCircles[timelineEventCircles.indexOf(circ) - 1];

        //Decide whether to display labels:
        if (circ === timelineEventCircles[0]){
            timelineDateLabel.css('visibility', 'visible');
        }
        if (prevCircle){
            //Find the previous visible timeline label:
            while (timelineEventCircles[timelineEventCircles.indexOf(prevCircle) - 1] && prevCircle.timelineDateLabel.css('visibility')!=='visible'){
                prevCircle = timelineEventCircles[timelineEventCircles.indexOf(prevCircle) - 1];
            }
            //Check to see if the label of the current circle would overlap that of the previously labelled artwork:
            labelOverlap = labelsAreOverlapping(prevCircle.position().left, circ.position().left, prevCircle.timelineDateLabel.width()); 
            //Overlapping circles should only have 1 label: 
            if (prevCircle && !labelOverlap){
                timelineDateLabel.css('visibility', 'visible');
                //prevCircle.timelineDateLabel.css('visibility','visible');
            } else{
                timelineDateLabel.css('visibility', 'hidden');    
                if (numCircles && timelineEventCircles.indexOf(circ) === numCircles){
                    timelineDateLabel.css('visibility','visible');
                    prevCircle.timelineDateLabel.css('visibility','hidden');
                }          
            } 
        }

        // Always show current circle, and if there are other circles with the same date, hide them
        if (selectedCircle && circ.yearKey === selectedCircle.yearKey){ 
            if (circ === selectedCircle){
                timelineDateLabel.css('visibility', 'visible');
            } else {
                timelineDateLabel.css('visibility', 'hidden'); 
            }
            return;
        };
    }
    
    function zoomTimeline(circle) {
        var i,
            j,
            k,
            tick,
            tickTarget,
            center = .5,
            currOffset = circle ? center - circle.Offset : 0,
            zoomLevel = circle ? circle.zoomLevel : 1,
            circleTarget,
            otherCircle;

        for (i = 0; i < timelineEventCircles.length ; i++) {
            otherCircle = timelineEventCircles[i]
            circleTarget = location(otherCircle)
            otherCircle.stop();
            otherCircle.css({ "transition-property": "left", "transition-duration": "1s", "transition-timing-function": "ease-in-out" });
            otherCircle.css({ "-webkit-transition-property": "left", "-webkit-transition-duration": "1s", "-webkit-transition-timing-function": "ease-in-out" });
            otherCircle.css(            //ANIMATEALERT
                { "left": parseInt(circleTarget * otherCircle.parent().width()) - EVENT_CIRCLE_WIDTH * 15 / 20 });
            //When last animation done, loop through and hide/show date labels
            if (i === timelineEventCircles.length-1){
                otherCircle.on('webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd', function () {
                    for (k=0; k < timelineEventCircles.length; k++){
                        displayLabels(timelineEventCircles[k], circle);
                        if (k===timelineEventCircles.length -1){
                           displayLabels(timelineEventCircles[k],null,k); 
                        }
                    }
                });
                //If last dot doesn't change position, transition event never fires, so use timeout
                if (otherCircle.position().left === parseInt(circleTarget * otherCircle.parent().width()) - EVENT_CIRCLE_WIDTH * 15 / 20){ 
                    setTimeout(function() {
                    for (k=0; k < timelineEventCircles.length; k++){
                        displayLabels(timelineEventCircles[k], circle);
                        if (k===timelineEventCircles.length -1){
                           displayLabels(timelineEventCircles[k],null,k); 
                        }
                    }
                    },1100); // timeout would need to be changed if animation time changed (should use transitionend event in other cases for slow connections)
                }
            }   
        }

        for (j = 0; j < timelineTicks.length; j++) {
            tick = timelineTicks[j]
            tickTarget = location(tick)
            tick.stop()
            tick.css({ "transition-property": "left", "transition-duration": "1s", "transition-timing-function": "ease-in-out" });
            tick.css({ "-webkit-transition-property": "left", "-webkit-transition-duration": "1s", "-webkit-transition-timing-function": "ease-in-out" });
            tick.css(               //ANIMATEALERT
                { "left": (tickTarget * 100) + "%" });
        }
         
        function location(dot){
            var target =  ((currOffset + dot.Offset)  - center) * zoomLevel  + center;
            return target;
        }
    }

    /*Helper function to determine if the labels of two event cirlces are overlapping
     * @method labelsAreOverlapping
     * @param  {Number} position1       left pixel position of the circle that is further left
     * @param  {Number} position2       left pixel position of the circle that is further right
     * @param  {Number} labelWidth      the width of the label of the circle that is further left
     * @return {Boolean}                whether the labels of the two circles are overlapping
     */
    function labelsAreOverlapping(position1, position2, labelWidth){
        //40% of labels width padding between labels for clarity 
        return Math.round(position1) + labelWidth*1.4 > position2;
    }

    /**
      * Close the pop-up outset box of an artwork preview in the collections page
      * @method hideArtwork
      * @param {doq} artwork        the artwork doq to be hidden
      */
    function hideArtwork(artwork) {
        return function () {
            var i;
            currentArtwork = null;
            if (!artwork) {
                return;
            }
            selectedArtworkContainer.animate({'opacity': 0}, ANIMATION_DURATION/5, function(){
                selectedArtworkContainer.css('display', 'none')
                });
            root.find('.tile').css('opacity','1');
            if (artworkCircles[artwork.Identifier]){
                styleTimelineCircle(artworkCircles[artwork.Identifier], false);
            }
            zoomTimeline();
            catalogDiv.stop(true,false);
            artworkShown = false;
        };
    }

    function getContainerWidth(artwork, showAllAtYear){
        var previewWidth,
            artworksForYear,
            containerWidth;
        artworksForYear = artworkCircles[artwork.Identifier] && artworkYears[artworkCircles[artwork.Identifier].timelineDateLabel.text()];
        previewWidth = (0.38) * $("#tagRoot").width();
        if (showAllAtYear && artworksForYear){
            containerWidth = Math.min(($("#tagRoot").width()*.80), (artworksForYear.length) * previewWidth);
        } else {
            containerWidth = previewWidth;
        }
        return containerWidth || 0;
    }

    function getContainerLeft(artwork, showAllAtYear){
        var rootWidth,
            infoWidth,
            tileWidth,
            tilePos,
            shift,
            leftOffset,
            containerLeft;
            rootWidth = root.width();
            infoWidth = infoDiv.width();
            if (comingBack && previewPos){
                containerLeft = previewPos;
            } else {
                if (artworkTiles[artwork.Identifier]){
                    tileWidth = artworkTiles[artwork.Identifier].width();
                    tilePos = artworkTiles[artwork.Identifier].position().left;
                }
                shift = (getContainerWidth(artwork,showAllAtYear)-tileWidth)/2;
                leftOffset = parseFloat(tileDiv.css('margin-left')) + tilePos + infoWidth - catalogDiv.scrollLeft();
                //if artwork tile at beginning of window
                if (leftOffset < shift){
                    shift = 0;
                }
                //if there are more than 3 artworks associated with the date year
                if (showAllAtYear && artworkCircles[artwork.Identifier] && artworkYears[artworkCircles[artwork.Identifier].timelineDateLabel.text()].length >= 3){
                    selectedArtworkContainer.css("overflow-x", "scroll")
                    leftOffset = bottomContainer.width()/10
                    shift = 0;
                }
                //if artwork tile at end of window
                if (Math.ceil(leftOffset + tileWidth + TILE_BUFFER) >= rootWidth){ 
                   shift = shift*2 + TILE_BUFFER;
                }
                containerLeft = leftOffset - shift;
                }   
            return containerLeft || 0;
            }

    /**
     * Shows an artwork as an outset box and shows name, description, etc
     * @method showArtwork
     * @param {doq} artwork     the artwork doq to be shown
     * @param {showAllAtYear}       whether all of the artworks at a specific year should be shown
     */
    function showArtwork(artwork, showAllAtYear) {
        return function () {
            
            var rootWidth,
                infoWidth,
                tileWidth,
                //shift,
                //leftOffset,
                previewWidth,
                containerWidth,
                containerLeft,
                newScrollPos,
                duration,
                newTile,
                previewTile,
                firstDescSpan = $(document.createElement('div')),
                progressCircCSS,
                timelineDateLabel,
                circle,
                artworksForYear,
                closeButton,
                tilePos,
                i,
                currentThumbnail;

            if (!artwork) {
                return;
            }

            selectedArtworkContainer.off();

            if (artworkShown) {
                selectedArtworkContainer.animate(
                        {"opacity": 0}, 
                        0, //JessF: took out animation fade in and out because it causes problems with double clicks
                        function () {
                            animateCatalogDiv();
                        }
                )
            } 
            else {
                animateCatalogDiv();
            }
                

        function animateCatalogDiv(){
            //scroll catalogDiv to center the current artwork
            catalogDiv.stop(true,false);
            rootWidth = root.width();
            infoWidth = infoDiv.width();
            if (comingBack && scrollPos){
                newScrollPos = scrollPos;
                duration = ANIMATION_DURATION/5;
            } else {
                if (artworkTiles[artwork.Identifier]){
                    tileWidth = artworkTiles[artwork.Identifier].width();       
                    tilePos = artworkTiles[artwork.Identifier].position().left; 
                }
                duration = ANIMATION_DURATION/3;
                newScrollPos = tilePos - rootWidth/2 + infoWidth + tileWidth/2 - TILE_BUFFER;
            }   

            if (newScrollPos<0){
                newScrollPos = 0;
            }
            //Don't animate if not actually scrolling
            if (parseInt(newScrollPos) === catalogDiv.scrollLeft()){
                duration = 0;
            }
            catalogDiv.animate({
                scrollLeft: newScrollPos
            }, duration, "easeInOutQuint", function(){
                //}, duration, null, function(){
                //center selectedArtworkContainer over current artwork thumbnail
                fillSelectedArtworkContainer();
                selectedArtworkContainer.css({
                    'width' : getContainerWidth(artwork,showAllAtYear),
                    'left' : getContainerLeft(artwork,showAllAtYear),
                    'display': 'inline',
                    'opacity':1
                });
                if (showAllAtYear && artworkCircles[artwork.Identifier] && artworkYears[artworkCircles[artwork.Identifier].timelineDateLabel.text()].length >= 3) {
                    selectedArtworkContainer.css({
                        "overflow-x": "scroll"
                    });
                }
                //add back handlers
                if (selectedArtworkContainer[0].addEventListener) {
                    // IE9, Chrome, Safari, Opera
                    selectedArtworkContainer[0].addEventListener("mousewheel", 
                        function(e){
                            e.stopPropagation();
                        }, false);
                    // Firefox
                    selectedArtworkContainer[0].addEventListener("DOMMouseScroll",
                        function(e){
                            e.stopPropagation();
                        }, false);
                } else { 
                    // IE 6/7/8
                    selectedArtworkContainer[0].attachEvent("onmousewheel",
                        function(e){
                            e.stopPropagation();
                        }, false);
                }
                //selectedArtworkContainer.children().animate({"opacity": 1},ANIMATION_DURATION/5);
                scrollPos = tilePos;
                comingBack = false;
            });
        }
            currentArtwork = artwork;
            artworkSelected = true;
            artworkShown = true;
            multipleShown = showAllAtYear;

            // Set selected artwork to hide when anything else is clicked
            root.on('mouseup', function(e) {
                var subject = selectedArtworkContainer;
                if (e.target.id != subject.attr('id') && !$(e.target).hasClass('tileImage') &&!$(e.target).hasClass('timelineEventCircle') && !subject.has(e.target).length){    
                    if (artworkShown){
                        hideArtwork(currentArtwork)();
                    }
                }
            });

            function fillSelectedArtworkContainer(){
                //Set up elements of selectedArtworkContainer
                previewWidth = (0.38) * $("#tagRoot").width();

                selectedArtworkContainer.empty();

                closeButton = $(document.createElement('img'));
                closeButton.attr('src', tagPath + 'images/icons/x.svg');
                closeButton.text('X');
                closeButton.css({
                    'position': 'absolute',
                    'top': '1.5%',
                    'width': '4%',
                    'height': '4%',
                    'min-height': '15px',
                    'min-width': '15px',
                    'background-color': '',
                    'left': '1.5%'
                });
                closeButton.on('mousedown', function () {
                    hideArtwork(currentArtwork)();
                });
                
                artworksForYear = artworkCircles[artwork.Identifier] && artworkYears[artworkCircles[artwork.Identifier].timelineDateLabel.text()];
               
                //If there are multiple artworks that should all be shown, selectedArtworkContainer will contain all of them and be larger
                if (showAllAtYear && artworksForYear){
                    for (i = 0; i < artworksForYear.length; i++) {
                        newTile = createOnePreviewTile(artworksForYear[i],i);
                        newTile.css({
                            'left': (i * previewWidth) + 'px',
                            'width': previewWidth
                        });
                        if (i===0){
                            newTile.append(closeButton);
                        }
                    }
                    containerWidth = Math.min(($("#tagRoot").width()*.80), (artworksForYear.length) * previewWidth);
                } else {
                    newTile = createOnePreviewTile(artwork,0);
                    newTile.css('left', '0%');
                    newTile.append(closeButton);
                    containerWidth = previewWidth;
                }
            }

            /* Helper method to create a preview tile for an artwork and append to selectedArtworkContainer
             * @method createOnePreviewTile
             * @param {Object} artwork       //artwork to create preview tile for
             * @param {Number}  num            //number previewer it is if multiple
             * @return {Object} previewTile    //preview tile just created
             */
            function createOnePreviewTile(artwork, num){
                var previewTile,
                    miniTilesLabel,
                    tileTop,
                    tileBottom,
                    titleSpan,
                    imgDiv,
                    prevArrow,
                    nextArrow,
                    descSpan,
                    exploreTab,
                    exploreText,
                    exploreIcon,
                    infoText,
                    artistInfo,
                    artText,
                    yearInfo,
                    descText,
                    miniTilesHolder,
                    miniTile;
                var uiDocfrag = document.createDocumentFragment();
                //Entire tile
                previewTile = $(document.createElement('div'))
                    .addClass('previewTile');
                uiDocfrag.appendChild(previewTile[0]);

                //Top portion of the tile (with image, title, and subtitle)
                tileTop = $(document.createElement('div'))
                    .addClass('tileTop');

                //Tile title
                titleSpan = $(document.createElement('div'))
                    .addClass('titleSpan')
                         .text(TAG.Util.htmlEntityDecode(artwork.Name))
                    .css({
                        'color': SECONDARY_FONT_COLOR,
                        //'font-family': FONT,
                    });

                //Image div
                imgDiv = $(document.createElement('div'))
                    .addClass('imgDiv');

                //Explore div
                exploreTab = $(document.createElement('div'))
                    .addClass('exploreTab');
                if (!onAssocMediaView) {
                    exploreTab.on('mousedown', switchPage(artwork))
                } 

                //Explore text
                exploreText = $(document.createElement('div'))
                    .addClass('exploreText')
                    .css("font-size",  BASE_FONT_SIZE*2/3 + 'em')
                    .text(onAssocMediaView ? "Select an Associated Artwork Below" : "Tap to Explore");

                exploreTab.append(exploreText)

                //Thumbnail image

                currentThumbnail = $(document.createElement('img'))
                    .addClass('currentThumbnail');
                if (artwork.Metadata.Thumbnail && artwork.Metadata.ContentType !== "Audio") {
//                    currentThumbnail.attr("src", FIX_PATH(artwork.Metadata.Thumbnail));
                    currentThumbnail = $(document.createElement('div'));
                    currentThumbnail.css({
                        'background': 'url(' + FIX_PATH(artwork.Metadata.Thumbnail + ') no-repeat center'),
                        'background-size':'contain',
                        'height':'100%',
                    })
//                    background: url(url) no-repeat center;
                } else if (artwork.Metadata.ContentType === "Audio") {
                    currentThumbnail.css('background-color', 'black');
                    currentThumbnail.attr('src', tagPath + 'images/audio_thumbnail.svg');
                } else if (artwork.Metadata.Medium === "Video" || artwork.Metadata.ContentType === "Video" || artwork.Metadata.ContentType === "iframe") {
                        currentThumbnail.css('background-color', 'black');
                        currentThumbnail.attr('src', tagPath + 'images/video_thumbnail.svg');
                } else if (artwork.Metadata.ContentType === "Image") {
                    if (artwork.Metadata.Thumbnail) {
                        currentThumbnail.attr("src", FIX_PATH(artwork.Metadata.Thumbnail));
                    } else if (artwork.Metadata.Source) {
                        currentThumbnail.attr("src", FIX_PATH(artwork.Metadata.Source));
                    } else {
                        currentThumbnail.attr("src", tagPath + 'images/image_icon.svg');
                    }
                } else if (artwork.Type === "Empty" || artwork.Type === "Tour" || artwork.Metadata.Type === "Tour" || artwork.Metadata.ContentType === "Tour") {
                    currentThumbnail.css('background-color', 'black');
                    if (artwork.Metadata.Thumbnail) {
                        currentThumbnail.attr('src', FIX_PATH(artwork.Metadata.Thumbnail));
                    } else {
                        currentThumbnail.attr('src', FIX_PATH("/Images/default.jpg"));
                    }
                }else {
                    currentThumbnail.attr("src", tagPath + 'images/no_thumbnail.svg');
                }
                !onAssocMediaView && currentThumbnail.on('mousedown', switchPage(artwork));

                //Telemetry stuff
                TAG.Telemetry.register($("#currentThumbnail,#exploreTab"), 'mousedown', '', function(tobj) {
                    if (!artwork || !artworkSelected) {
                        return true; // abort
                    }
                    tobj.custom_1 = CryptoJS.SHA1(artwork.Name).toString(CryptoJS.enc.Base64);
                    tobj.ttype     = 'collection_to_' + getWorkType(artwork);
                    tobj.mode = 'Kiosk'; 
                });

                //Div for artist and year info, directly below image thumbnail
                infoText = $(document.createElement('div'))
                    .addClass('infoText');

                //Artist name
                artistInfo = $(document.createElement('div'))
                    .addClass('artistInfo')
                    .css({ 
                    'font-size': 11 * BASE_FONT_SIZE / 30 + 'em',
                    'color': SECONDARY_FONT_COLOR,
                    'font-style':'italic'
                    //'font-family': FONT
                });

                //Year of creation
                yearInfo = $(document.createElement('div'))
                    .addClass('yearInfo')
                    .css({ 
                    'font-size': 11 * BASE_FONT_SIZE / 30 + 'em',
                    'color': SECONDARY_FONT_COLOR,
                    'font-style': 'italic'
                    //'font-family': FONT
                });

                //Set texts of labels
                if (artwork.Type !== "Empty") {
                    artwork.Metadata.Artist ? artText = "" + artwork.Metadata.Artist : artText = ' ';
                    artistInfo.text(artText);
                    yearInfo.text(getDateText(getArtworkDate(artwork,false)) || " ");
                } else {
                    artistInfo.text("(Interactive Tour)" );
                    yearInfo.text(" " );
                }

                //Bottom portion of the tile (with thumbnails, description, etc)
                tileBottom = $(document.createElement('div'))
                    .addClass('tileBottom');

                //Description of art
                num===0 ? descSpan = firstDescSpan: descSpan = $(document.createElement('div'));
                descSpan.addClass('descSpan');

                //Div for above description
                descText = $(document.createElement('div'))
                    .addClass('descText secondaryFontColor')
                    .html(Autolinker.link(artwork.Metadata.Description ? artwork.Metadata.Description.replace(/\n/g, '<br />') : '', {email: false, twitter: false}))
                    .css({
                    'color': SECONDARY_FONT_COLOR,
                    //'font-family': FONT,
                    'font-size': "80%"
                });
                if (IS_WINDOWS) {
                    if (descText){
                        var links = descText.find('a');
                        links.each(function (index, element) {
                            $(element).replaceWith(function () {
                                return $.text([this]);
                            });
                        });
                    }
                   
                }

                function addAssociationRow(numberAssociatedDoqs){
                    var tileSpacing;
                	if (numberAssociatedDoqs === 0){
                		miniTilesHolder.hide();
                		descSpan.css({"height": "92%"});
                        TAG.Util.removeProgressCircle(circle);
                	} else {
                        descSpan.css({'height':'33%'});
                        miniTilesLabel.text(onAssocMediaView ? "Artworks" : "Associated Media");
                        tileSpacing = miniTilesHolder.height()/10;
                	    if (numberAssociatedDoqs* (miniTilesHolder.height() + tileSpacing) - tileSpacing > miniTilesHolder.width()){
                		    prevArrow = $(document.createElement('img'))
                    			.addClass("miniTilesArrow")
                    			.attr('src', tagPath + 'images/icons/Close.svg')
                    			.on('mousedown', function(){
                        				miniTilesHolder.stop();
                        				miniTilesHolder.animate({
                            			scrollLeft: miniTilesHolder.scrollLeft() - 50
                        			}, ANIMATION_DURATION/2)
                    			});

                		    nextArrow = $(document.createElement('img'))
                    			.addClass("miniTilesArrow")
                    			.attr('src', tagPath + 'images/icons/Open.svg')
                    			.css('left', "94%")
                    			.on('mousedown', function(){
                        			miniTilesHolder.stop();
                        			miniTilesHolder.animate({
                            		scrollLeft: miniTilesHolder.scrollLeft() + 50
                        		}, ANIMATION_DURATION/2)
                    		});
                    	    tileBottom.append(prevArrow);
                    	    tileBottom.append(nextArrow);
                	   }
                    }
                }


                /**
                * @method addMediaMiniTiles
                * @param {Array} doqs    array of media or artworks doqs to with which the mini tiles are created
                */
                function addMiniTiles(doqs){
                    var src,
                        metadata,
                        thumb;
                    numberAssociatedDoqs = doqs.length;
                    var j = 0;
                    //Loop through media doqs and create tiles from them
                    for (i = 0; i < doqs.length; i++) {
                        if (onAssocMediaView && artworkInCollectionList.indexOf(doqs[i].Identifier)==-1) {
                            continue;
                        }

                        src = '';
                        metadata = doqs[i].Metadata;
                        thumb = metadata.Thumbnail;

                        !onAssocMediaView && (doqs[i].artwork = artwork);

                        miniTile = $(document.createElement('img'))
                            .addClass('miniTile')
                            .css({
                                'width': .35 * (.45 * selectedArtworkContainer.height())
                            })
                            .on('mousedown',
                                    onAssocMediaView ? switchPage(doqs[i], artwork) : switchPage(artwork, doqs[i])
                                )
                        miniTile.css('left', j * (miniTile.width() + miniTilesHolder.height() / 10));


                        switch (metadata.ContentType) {
                            case 'Audio':
                                src = tagPath + 'images/audio_icon.svg';
                                break;
                            case 'Video':
                                src = (thumb && !thumb.match(/.mp4/)) ? FIX_PATH(thumb) : tagPath + 'images/video_icon.svg';
                                break;
                            case 'iframe':
                                src = tagPath + 'images/video_icon.svg';
                                break;
                            case 'Image':
                                if (thumb) {
                                    src = FIX_PATH(thumb);
                                } else if (metadata.Source) {
                                    src = FIX_PATH(metadata.Source);
                                } else {
                                    src = tagPath + 'images/no_thumbnail.svg';
                                }
                                break;
                            case 'Text':
                                src = tagPath + 'images/text_icon.svg';
                            default:
                                if (thumb) {
                                    src = FIX_PATH(thumb);
                                } else if (metadata.Source) {
                                    src = FIX_PATH(metadata.Source);
                                } else {
                                    src = tagPath + 'images/no_thumbnail.svg';
                                }
                                break;
                        }
                        if (onAssocMediaView && metadata.Type === "Artwork") {
                            if (thumb) {
                                src = FIX_PATH(thumb);
                            } else if (metadata.Source) {
                                src = FIX_PATH(metadata.Source);
                            } else {
                                src = tagPath + 'images/no_thumbnail.svg';
                            }

                        }
                        miniTile.attr("src", src);
                        miniTilesHolder.append(miniTile);                        
                        j++;
                    }

                	addAssociationRow(numberAssociatedDoqs); 
                	TAG.Util.removeProgressCircle(circle);

                                        //Also add handlers to switch to first artwork if in assoc media view
                	if (onAssocMediaView) {
                	    exploreTab.on('mousedown', switchPage(doqs[0], artwork, getContainerLeft(artwork, false)));
                	    currentThumbnail.on('mousedown', switchPage(doqs[0], artwork, getContainerLeft(artwork, false)));
                	}
                }

                //Append everything
                infoText.append(artistInfo)
                        .append(yearInfo);

                imgDiv.append(currentThumbnail)
                    .append(exploreTab)  
                    .append(infoText);

                tileTop.append(imgDiv)
                    .append(titleSpan)
                    .append(infoText);

                descSpan.append(descText);
                tileBottom.append(descSpan);

                miniTilesLabel = $(document.createElement('div'))
                    				.addClass("miniTilesLabel");
				miniTilesHolder = $(document.createElement('div'))
                    				.addClass('miniTilesHolder');
                tileBottom.append(miniTilesHolder)
                    	   .append(miniTilesLabel);

                previewTile.append(tileTop)
                    	   .append(tileBottom);

                //selectedArtworkContainer.append(previewTile);
                selectedArtworkContainer.append($(uiDocfrag));
                root.find('.tile').css('opacity','0.5');
  
                var numberAssociatedDoqs = 0;
                var tileLoadQueue = TAG.Util.createQueue();
                tileLoadQueue.add(function(){
                    onAssocMediaView && TAG.Worktop.Database.getArtworksAssocTo(artwork.Identifier, addMiniTiles, null, addMiniTiles);
                    !onAssocMediaView && TAG.Worktop.Database.getAssocMediaTo(artwork.Identifier, addMiniTiles, null, addMiniTiles);
                });

                return previewTile;         
            }

            for (i = 0; i < timelineEventCircles.length; i++) { // Make sure all other circles are grayed-out and small
                styleTimelineCircle (timelineEventCircles[i], false)
            };            

            // Make current circle larger and white           
            if (artworkCircles[artwork.Identifier]){
                styleTimelineCircle(artworkCircles[artwork.Identifier], true)
            };    

            progressCircCSS = {
                'position': 'absolute',
                'float'   : 'left',
                'left'    : '35%',
                'z-index' : '50',
                'height'  : '60%',
                'width'   : 'auto',
                'top'     : '15%',
            };
            var miniTilesHolder = $('.miniTilesHolder');
            circle = TAG.Util.showProgressCircle(miniTilesHolder, progressCircCSS, '0px', '0px', false);
                 
        };
    }
    this.showArtwork = showArtwork;

    /**
     * Generates a comparator function for catalog sorting
     * @method sortComparator
     * @param {String} primary     the primary sorting property
     * @param {String} secondary   the secondary sorting property
     *                                if left undefined, a.artwork.Identifier is used
     *                                as the secondary property
     */
    function sortComparator(primary, secondary) {
        return function(a, b) {
            var aSecondary,
                bSecondary;
            if (a[primary] < b[primary]) {
                return -1;
            } else if (a[primary] > b[primary]) {
                return 1;
            } else {
                aSecondary = secondary ? a[secondary] : a.artwork.Identifier;
                bSecondary = secondary ? b[secondary] : b.artwork.Identifier;
                if (aSecondary < bSecondary) {
                    return -1;
                } else if (aSecondary > bSecondary) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
    }

    /**
     * Generates a valuation function for catalog sorting
     * @method sortValuation
     * @param {String} property     valuation property name
     */
    function sortValuation(property) {
        return function(value, compareToNode) {
            if (!compareToNode) {
                return null;
            } else if (value < compareToNode[property]) {
                return -1;
            } else if (value > compareToNode[property]) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    /**
     * Sort the catalog by the given criterium
     * @method sortCatalog
     * @param {Array} artworks    an array of doq objects to be sorted
     * @param {String} tag        the sort type
     * @return {AVLTree}          an avl tree for easy sorting
     */
    function sortCatalog(artworks, tag) {
        var comparator,
            valuation,
            avlTree,
            artNode,
            i;

        if (tag === 'Title') {
            var titleKey;
            comparator = sortComparator('nameKey');
            valuation = sortValuation('nameKey');
            avlTree = new AVLTree(comparator, valuation);
            avlTree.clear();
            for (i = 0; i < artworks.length; i++) {
                if (artworks[i].Name) {
                    titleKey = artworks[i].Name.toLowerCase();
                } else {
                    titleKey = '~~~~';
                }
                artNode = {
                    artwork: artworks[i],
                    nameKey: titleKey,
                };
                avlTree.add(artNode);
            }
            return avlTree;
        } else if (tag === 'Artist') {
            var artistKey;
            comparator = sortComparator('artistKey');
            valuation  = sortValuation('artistKey');
            avlTree = new AVLTree(comparator, valuation);
            for (i = 0; i < artworks.length; i++) {
                if (artworks[i].Metadata.Artist) {
                    artistKey = artworks[i].Metadata.Artist.toLowerCase();
                } else {
                    artistKey = '~~~~';
                }
                artNode = {
                    artwork: artworks[i],
                    artistKey: artworks[i].Type === 'Empty' ? '~~~~' : artistKey // tours show up at end
                };
                avlTree.add(artNode);
            }
            return avlTree;
        } else if (tag === 'Date') {
            return sortByYear(artworks,true);
        } else if (tag === 'Tours') {
            var tourName;
            comparator = sortComparator('nameKey');
            valuation  = sortValuation('nameKey');
            avlTree = new AVLTree(comparator, valuation);
            for (i = 0; i < artworks.length; i++) {
                if (artworks[i].Type === 'Empty') {
                    if (artworks[i].Name) {
                        tourName = artworks[i].Name.toLowerCase();
                    } else {
                        tourName = '';
                    }

                } else {
                    tourName = '~~~~~~';
                }
                artNode = {
                    artwork: artworks[i],
                    nameKey: tourName,
                };
                    
                avlTree.add(artNode);
            }
            return avlTree;
        }
        //For custom sort tags
        else if (tag){
            var sortKey;
            comparator = sortComparator('sortKey');
            valuation = sortValuation('sortKey');
            avlTree = new AVLTree(comparator,valuation);
            avlTree.clear();
            for (i = 0; i < artworks.length; i++) {
                if (artworks[i].Metadata.InfoFields && artworks[i].Metadata.InfoFields[tag]) {
                    sortKey = artworks[i].Metadata.InfoFields[tag].toLowerCase();
                } else {
                    sortKey = null;
                }
                artNode = {
                    artwork: artworks[i],
                    sortKey: sortKey
                };
                if (artNode.sortKey) {
                    avlTree.add(artNode);
                }
            }
            return avlTree;
        }

        return null; // error case: falsy tag
    }

    /**Helper function for sorting artwork tiles and timeline markers
     * Also used to catch common non-integer input date forms and generate timeline 
     * years for their display. 
     * @method sortByYear
     * @param  {Object} artworks      list of artworks to sort9
     * @param {Boolean} timelineDate  whether you are sorting by timeline date (for now both timeline and tiles do)
     * @return {AVLTree} avlTree      sorted tree so order can be easily accessed
    **/
    function sortByYear(artworks, timelineDate){
        var comparator,
            valuation,
            avlTree,
            artNode,
            artworkDate,
            yearKey,
            nameKey,
            i;
        comparator = sortComparator('yearKey', 'nameKey');
        valuation  = sortValuation('yearKey');
        avlTree = new AVLTree(comparator, valuation);
        for (i = 0; i < artworks.length; i++) {
            if (timelineDate){
                artworkDate = getArtworkDate(artworks[i],true);
            } else {
                artworkDate = getArtworkDate(artworks[i],false);
            }
            if (artworks[i].Name) {
                nameKey = artworks[i].Name.toLowerCase();
            } else {
                nameKey = '~~~~';
            }
            yearKey = TAG.Util.parseDateToYear(artworkDate);
            if (!isNaN(yearKey)){
                artNode = {
                    artwork: artworks[i],
                    nameKey: nameKey,
                    yearKey: artworks[i].Type === 'Empty' ? Number.POSITIVE_INFINITY : yearKey //Tours set to Infinity to show up at end of 'Year' sort
                };
            } else{                        
                artNode = {
                    artwork: artworks[i],
                    nameKey: nameKey,
                    yearKey: Number.POSITIVE_INFINITY //Set unintelligible dates to show up at end of 'Year' sort 
                };
            }
            avlTree.add(artNode);
        }
        return avlTree;
    }

    /* Get a date object representing temporal metadata for an artwork
    * @method getArtworkDate
    * @param {Object} artwork       artwork we care about
    * @param {Boolean} timelineDate     whether we want the metadata date or the timeline date
    * @return {Object} artworkDate      object containing year, month, day attributes
    */
    function getArtworkDate(artwork, timelineDate){
        var artworkDate;
        //second conditional checks to see if that metadata field exists in the server (backwards compatibility)
        if (timelineDate && (artwork.Metadata.TimelineYear||artwork.Metadata.TimelineYear==='')){
                artworkDate = {
                    year : artwork.Metadata.TimelineYear,
                    month : artwork.Metadata.TimelineMonth,
                    day : artwork.Metadata.TimelineDay
                }
            } else {
                 artworkDate = {
                    year : artwork.Metadata.Year,
                    month : artwork.Metadata.Month,
                    day : artwork.Metadata.Day
                }
            }
        return artworkDate;
    }

    /*Get the text to display based on a date object
    * @method getDateText
    * @param {Object} date     object containing year, month, day attributes
    * @return {String} dateText    text to display in mm/dd/yyyy or mm/yyyy format (Note- would need to change for internationalization)
    */   
    function getDateText(date){
        var yearText,
            neg = false,
            monthDict,
            month,
            monthText,
            dayText,
            dateText;
        yearText = TAG.Util.parseDateToYear({year: date.year});
        if (yearText<0){
            yearText = -yearText;
            neg = true;
        } 
        dateText = yearText;
        monthDict = {
                    "January": 1,
                    "February:": 2,
                    "March": 3,
                    "April": 4,
                    "May": 5,
                    "June": 6,
                    "July": 7,
                    "August": 8,
                    "September": 9,
                    "October": 10,
                    "November":11,
                    "December": 12
                }
        if (date.month){
            month = date.month;
            monthText = monthDict[month];
            if (date.day){
               dayText = date.day;
               dateText = monthText + '/' + dayText + '/' + dateText; 
            } else {
                dateText = monthText + '/' + dateText;
            }
        }
        if (neg){
            dateText = dateText + ' BCE';
        }
        return dateText;
    }

    /** 
     * Set the colors of the sort tags
     * @method colorSortTags
     * @param {String} tag    the name of the sort tag
     */
    function colorSortTags(tag) {
       var unselectedColor = TAG.Util.UI.dimColor(SECONDARY_FONT_COLOR,DIMMING_FACTOR);
       $('.rowButton').css('color', unselectedColor);
       if (tag){
            $('#' + tag.toLowerCase() + 'Button').css('color', SECONDARY_FONT_COLOR);
       }
    }

    /**
     * Changes the selected tag and re-sorts
     * @method changeDisplayTag
     * @param {Array} artworks     the array of artwork doqs to sort
     * @param {String} tag         the name of the sort tag
     */
    function changeDisplayTag(artworks, tag) {
        var guidsSeen = [],
            toursArray  = [],
            artsArray   = [],
            videosArray = [],
            bigArray    = [],
            i;
        currentArtwork && hideArtwork(currentArtwork)();
        currentTag = tag;
        colorSortTags(currentTag);
        drawCatalog(artworks, currentTag, 0, false);
        doSearch(); // search with new tag
    }

    /**
     * Switch to the tour player
     * @method switchPageTour
     * @param {doq} tour    the relevant tour doq
     */
    function switchPageTour(tour, containerLeft) {
        var rinData,
            rinPlayer,
            prevInfo,
            messageBox,
            collectionOptions,
            parentid;

            if (TAG.Util.Splitscreen.isOn()) {
                    confirmationBox = $(TAG.Util.UI.PopUpConfirmation(function () {
                            TAG.Util.Splitscreen.exit(root.data('split') || 'L');
                            tourClicked(tour)();
                            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
                        },
                        "By opening this tour, you will exit splitscreen mode. Would you like to continue?",
                        "Continue",
                        false,
                        function () {
                            confirmationBox.remove();
                        },
                        root
                    ));

                    confirmationBox.css('z-index', 10000001);
                    root.append(confirmationBox);
                    confirmationBox.show();
                }


        rinData = JSON.parse(unescape(tour.Metadata.Content));

        if (!rinData || !rinData.data) {
            messageBox = $(TAG.Util.UI.popUpMessage(null, "Cannot play empty tour.", null));
            messageBox.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 7);
            root.append(messageBox);
            messageBox.fadeIn(500);
            return;
        }

        collectionOptions = {
            prevScroll: catalogDiv.scrollLeft(),
            prevPreviewPos: containerLeft || selectedArtworkContainer.position().left,
            backCollection: currCollection,
            prevTag : currentTag,
            backArtwork: tour,
            prevMult : multipleShown
        }

        rinPlayer = TAG.Layout.TourPlayer(rinData, currCollection, collectionOptions, null, tour);

        TAG.Util.UI.slidePageLeftSplit(root, rinPlayer.getRoot(), rinPlayer.startPlayback);

        currentPage.name = TAG.Util.Constants.pages.TOUR_PLAYER;
        currentPage.obj  = rinPlayer;
    }

    /**
     * Switch to the video player
     * @method switchPageVideo
     * @param {doq} video         the video to which we'll switch
     */
    function switchPageVideo(video, containerLeft) {
        var prevInfo,
            videoPlayer;

        prevInfo = {
            artworkPrev: null,
            prevScroll: catalogDiv.scrollLeft(),
            prevPreviewPos : containerLeft || selectedArtworkContainer.position().left,
            prevTag: currentTag,
            prevMult: multipleShown
        };
        videoPlayer = TAG.Layout.VideoPlayer(video, currCollection, prevInfo);
        TAG.Util.UI.slidePageLeftSplit(root, videoPlayer.getRoot());

        currentPage.name = TAG.Util.Constants.pages.VIDEO_PLAYER;
        currentPage.obj = videoPlayer;
    }

    /**
     * Switch to the artwork viewer or tour player
     * @method switchPage
     * @param {Object} artwork      artwork to return to after switching
     */
    function switchPage(artwork, associatedMedia, containerLeft) {
        return function() {
            var artworkViewer,
                newPageRoot,
                splitopts = 'L',
                opts = getState(),
                confirmationBox,
                prevInfo;

            if (!artwork|| !artworkSelected) {
                return;
            }

            if (artwork.Type === "Empty" && artwork.Metadata.Type !== "VideoArtwork" && artwork.Metadata.ContentType !== "iframe") { // tour
                if (TAG.Util.Splitscreen.isOn()) {
                    confirmationBox = $(TAG.Util.UI.PopUpConfirmation(function () {
                            TAG.Util.Splitscreen.exit(root.data('split') || 'L');
                            switchPageTour(artwork);
                            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
                        },
                        "By opening this tour, you will exit split screen mode. Would you like to continue?",
                        "Continue",
                        false,
                        function () {
                            confirmationBox.remove();
                        },
                        root
                    ));
                    confirmationBox.css('z-index', 1000000001);
                    root.append(confirmationBox);
                    confirmationBox.show();
                } else {
                    switchPageTour(artwork, containerLeft);
                }
            } else if (artwork.Metadata.Type === "VideoArtwork") { // video
                if (TAG.Util.Splitscreen.isOn()) {
                    confirmationBox = $(TAG.Util.UI.PopUpConfirmation(function () {
                            TAG.Util.Splitscreen.exit(root.data('split') || 'L');
                            switchPageVideo(artwork);
                            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
                        },
                        "By opening this video, you will exit split screen mode. Would you like to continue?",
                        "Continue",
                        false,
                        function () {
                            confirmationBox.remove();
                        },
                        root
                    ));
                    confirmationBox.css('z-index', 100000001);
                    root.append(confirmationBox);
                    confirmationBox.show();
                } else {
                    switchPageVideo(artwork, containerLeft);
                }
            } else { // deepzoom artwork
                artworkViewer = TAG.Layout.ArtworkViewer({
                    doq: artwork,
                    prevPreview: currentArtwork,
                    prevTag : currentTag,
                    prevScroll: catalogDiv.scrollLeft(),
                    prevPreviewPos: containerLeft || selectedArtworkContainer.position().left,
                    prevCollection: currCollection,
                    prevPage: 'catalog',
                    prevMult: multipleShown,
                    assocMediaToShow: associatedMedia,
                    onAssocMediaView : onAssocMediaView
                });
                newPageRoot = artworkViewer.getRoot();
                newPageRoot.data('split', root.data('split') === 'R' ? 'R' : 'L');

                TAG.Util.UI.slidePageLeftSplit(root, newPageRoot);

                currentPage.name = TAG.Util.Constants.pages.ARTWORK_VIEWER;
                currentPage.obj  = artworkViewer;
            }
            root.css({ 'overflow-x': 'hidden' });
        }
    }

    //UNCOMMENT IF WE EVER WANT SPLITSCREEN ACCESS FROM CATALOG
    //     /**
    //  * Initializes splitscreen functionality
    //  * @method initSplitscreen
    //  */
    // function initSplitscreen() {
    //     splitscreenIcon.attr({
    //             src: tagPath+'images/SplitWhite_dotted.svg'
    //         })
    //         .addClass('bottomButton')
    //     if (TAG.Util.Splitscreen.isOn()) {
    //         splitscreenIcon.css('display', 'none');
    //     }
    //     splitscreenIcon.on('click', function () {
    //         var collectionsPage,
    //             collectionsPageRoot,
    //             newCollectionsPage,
    //             newCollectionsPageRoot;

    //         if (!TAG.Util.Splitscreen.isOn()) {
    //             TAG.Util.Splitscreen.setOn(true);
    //             collectionsPage = TAG.Layout.CollectionsPage();
    //             collectionsPageRoot = collectionsPage.getRoot();
    //             collectionsPageRoot.data('split', 'R');

    //             newCollectionsPage = TAG.Layout.CollectionsPage();
    //             newCollectionsPageRoot = newCollectionsPage.getRoot();
    //             newCollectionsPageRoot.data('split', 'L');
    //             setTimeout(function(){
    //                 root.detach();
    //                 root = newCollectionsPageRoot;
    //                 newCollectionsPage.loadCollection(currCollection, scrollPos, currentArtwork)
    //                 infoButton.css("float", "left");
    //                 linkButton.css("float", "left");
    //             }, 1000);
    //             TAG.Util.Splitscreen.init(newCollectionsPageRoot, collectionsPageRoot);
    //         }
    //     });
    // }

    /**
     * Gets the current state of the collections page
     * @method getState
     * @return {Object}    object containing state
     */
    function getState() {
        return {
            exhibition: currCollection,
            currentTag: currentTag,
            currentImage: currentArtwork
        };
    }

    /**
     * Returns the root of the collections page
     * @method getRoot
     * @return {jQuery Object}    root of the collections page
     */
    function getRoot() {
        return root;
    }

    return {
        getRoot: getRoot,
        loadCollection: loadCollection,
        loadFirstCollection: loadFirstCollection,
        showArtwork : showArtwork,
        getState : getState
    };
};

TAG.Layout.CollectionsPage.default_options = {};
;
TAG.Util.makeNamespace("TAG.Layout.InternetFailurePage");
TAG.Util.makeNamespace("TAG.Layout.InternetFailure");

TAG.Layout.InternetFailure.lastOverlay = {};

/*
    BM - Using this for more than internet failure, should
    be renamed/refactored in the future.
*/

/**
 * Internet failure page, which appears when TAG detects a loss of internet.
 * @class TAG.Layout.InternetFailurePage.js
 * @constructor
 * @param errorType // finish documenting
 * @param detach
 */
TAG.Layout.InternetFailurePage = function (errorType, detach) {
    "use strict";

    this.getRoot = function () {
        return root;
    };

    var root,
        mainPanel,
        needPassword = false, // used to determine whether password input box appears
        DATA_LIMIT = "Data Limit",
        SERVER_DOWN = "Server Down",
        NO_INTERNET = "No Internet",
        INTERNET_LOST = "Internet Lost",
        OLD_SERVER = "Old Server";
    init();

    /**
     * Sets up internet failure page (handlers, etc) using the input errorType
     * @method init
     */

    function init() {
        root = TAG.Util.getHtmlAjax('InternetFailurePage.html');
        root.css("width", $("#tagRoot").width());
        root.css("height", $("#tagRoot").height());
    	mainPanel=root.find("#mainPanel");
    	mainPanel.css("width", $("#tagRoot").width());
        mainPanel.css("height", $("#tagRoot").height());

        var sadface = root.find('#sadFace');
        var noticeBox = root.find('#noticeBox');

        var noticeLabel = root.find('#noticeLabel');//$(document.createElement('label'));
        // noticeLabel.css({ 'color': 'white', 'font-size': '30px', 'left-margin': '4%', 'width': '96%' });

        var noticeText = getNoticeText(errorType);

        noticeLabel.text(noticeText);
        noticeBox.append(noticeLabel).append("<br>");

        var reconnectButton = root.find('#reconnectButton');
        var changeServerButton = root.find('#changeServerButton');

	    changeServerButton.text('Change Server');
        //changeServerButton.css({ 'font-size': '150%', 'position': 'relative', 'left': '50%', 'top': '5%' });

        changeServerButton.on('click', TAG.Util.UI.ChangeServerDialog);

        if (errorType === DATA_LIMIT) {
            reconnectButton.text('I Agree');

            var disagreeButton = $(document.createElement('button'));
            disagreeButton.text('I Disagree');
            disagreeButton.css({ 'font-size': '150%', 'position': 'relative', 'left': '45%', 'top': '5%' });
            noticeBox.append(disagreeButton);
            disagreeButton.click(function () {
                window.close();
            });
            reconnectButton.click(function () {
                localStorage.acceptDataUsage = "true";
                if (!detach) {
                    TAG.Layout.StartPage(null, function (root) {
                        TAG.Util.Splitscreen.setOn(false);
                        TAG.Util.UI.slidePageRight(root);
                    }, true);
                } else {
                    root.remove();
                }
            });

        }
        else if (errorType === SERVER_DOWN) {
            reconnectButton.text('Reconnect');
            //reconnectButton.css({ 'font-size': '150%', 'position': 'relative', 'left': '30%', 'top': '5%' });
        } else if (errorType === OLD_SERVER) {
            reconnectButton.hide();
        }else {
            reconnectButton.text('Reconnect');
            //reconnectButton.css({ 'font-size': '150%', 'position': 'relative', 'left': '53%', 'top': '5%' });
        }


        if (errorType !== DATA_LIMIT) {
            reconnectButton.click(function () {
                var connectionTimeout,
                    timedOut;

                noticeLabel.text("Reconnecting...");
                reconnectButton.hide();
                sadface.hide();

                setTimeout(function () { // this timeout is here because the label didn't have time to reset itself otherwise
                    $.ajax({
                        url: 'http://' + localStorage.ip + ':8080',
                        dataType: "text",
                        async: false,
                        cache: false,
                        success: function () {
                            if(!timedOut) {
                                clearTimeout(connectionTimeout);
                                if (!detach) {
                                    TAG.Layout.StartPage(null, function (root) {
                                        TAG.Util.Splitscreen.setOn(false);
                                        TAG.Util.UI.slidePageRight(root);
                                    }, true);
                                
                                } else {
                                    root.remove();
                                }
                            }
                        },
                        error: function (err) {
                            if(!timedOut) {
                                clearTimeout(connectionTimeout);
                                $.ajax({
                                    url: "http://google.com",
                                    dataType: "text",
                                    async: true,
                                    cache: false,
                                    success: function () {
                                        if(!timedOut) {
                                            clearTimeout(connectionTimeout);
                                            noticeLabel.text(getNoticeText("Server Down"));
                                            reconnectButton.show();
                                        }
                                    },
                                    error: function (err) {
                                        if(!timedOut) {
                                            clearTimeout(connectionTimeout);
                                            noticeLabel.text(getNoticeText((errorType === "Internet Lost" ? "Internet Lost" : "No Internet")));
                                            reconnectButton.show();
                                        }
                                    }
                                });
                            }
                        }
                    });
                }, 100);

                connectionTimeout = setTimeout(function() {
                    timedOut = true;
                    noticeLabel.text(getNoticeText("Server Down"));
                    reconnectButton.show();
                }, 10100); // 10.1 second timeout to show server down notice (10 sec after the ajax request is sent off)
            });
        }

        /**
         * Returns a notice message given a certain connectivity error.
         * @method getNoticeText
         * @param {String} error       the error type
         * @return {String}            an error message to be displayed
         */
        function getNoticeText(error) {
            if (error == SERVER_DOWN)
                return "The server is currently unavailable. Please contact the museum administrator for further information.";
            else if (error == NO_INTERNET)
                return 'No internet connection was detected. The TAG application requires internet connectivity. Please ensure that you are connected to the internet and try again.';
            else if (error === INTERNET_LOST)
                return 'Internet connection lost. The TAG application requires internet connectivity. Please ensure that you are connected to the internet and try again.';
            else if (error === OLD_SERVER)
                return "The server you are trying to connect to is not compatible with this version of the Touch Art Gallery client";
            else if (error === DATA_LIMIT)
                return 'We have detected that you are on a limited data connection. TAG downloads large images, audio, and videos that can significantly increase your data usage.  By clicking "I Agree" you agree to allow TAG to download images, audio, and videos.  Clicking "I Disagree" will exit TAG.';
            return "";
        }

        var quitButton = $(document.createElement('button'));
        quitButton.text('Exit');

        quitButton.click(function () {

        });
	
	    noticeBox.append(changeServerButton);
        noticeBox.append(reconnectButton);

        mainPanel.append(sadface);
        mainPanel.append(noticeBox);
 	
        root.append(mainPanel);

        TAG.Layout.InternetFailure.lastOverlay.root = root;
        TAG.Layout.InternetFailure.lastOverlay.type = errorType;
    }
};

;
TAG.Util.makeNamespace("TAG.Layout.MetroSplitscreenMessage");

/*
    BM - Using this for more than internet failure, should
    be renamed/refactored in the future.
*/
TAG.Layout.MetroSplitscreenMessage = function () {
    "use strict";

    this.getRoot = function () {
        return root;
    };

    var root = $(document.createElement('div'));
    root.css({
        'position': 'fixed',
        'left': '0px',
        'top': '0px',
        'width': '100%',
        'height': '100%',
        'background-color': 'rgb(50,75,107)',
        'color': 'white',
        'z-index': '1000000000',
    });

    var tag = $(document.createElement('label'));
    tag.css({
        'font-size': '380%',
        'position': 'relative',
        'display': 'block',
        'text-align': 'center',
        'top': '25%',
    });
    tag.text('TAG');

    var info = $(document.createElement('label'));
    info.css({
        'font-size': '120%',
        'position': 'relative',
        'top': '45%',
        'display': 'block',
        'text-align': 'center',
    });
    info.text('TAG must be run in full screen mode');

    root.append(tag).append('<br>').append(info);
};
;
TAG.Util.makeNamespace("TAG.Layout.TourPlayer");

/**
 * Player for RIN tours
 * @param tour         RIN tour in Javascript object (pre-parsed from JSON)
 * @param exhibition   exhibition we came from (if any) (doq object)
 * @param prevInfo   object containing previous page info 
 *    artworkPrev      value is 'artmode' when we arrive here from the art viewer
 *    prevScroll       value of scrollbar from new catalog page
 * @param artmodeOptions      options to pass into TAG.Layout.ArtworkViewer
 * @param tourObj      the tour doq object, so we can return to the proper tour in the collections screen
 */
TAG.Layout.TourPlayer = function (tour, exhibition, prevInfo, artmodeOptions, tourObj) {
    "use strict";
    var artworkPrev;
    var prevScroll = prevInfo.prevScroll;
    var prevPreviewPos = prevInfo.prevPreviewPos;
	var prevExhib = exhibition;
    var prevTag = prevInfo.prevTag;
    var prevMult = prevInfo.prevMult;
    var prevS
    var rinPath = IS_WINDOWS ? tagPath+'js/WIN8_RIN/web' : tagPath+'js/RIN/web';
    var ispagetoload = pageToLoad && (pageToLoad.pagename === 'tour');

    var tagContainer = $('#tagRoot');

    var player,
        root = TAG.Util.getHtmlAjax('TourPlayer.html'),
        rinPlayer = root.find('#rinPlayer'),
        backButtonContainer = root.find('#backButtonContainer'),
        backButton = root.find('#backButton'),
        linkButtonContainer = root.find('#linkContainer'),
        linkButton = root.find('#linkButton'),
        overlayOnRoot = root.find('#overlayOnRoot'),
        bigThumbnailContainer = root.find('#bigThumbnailContainer'),
        bigThumbnail = root.find('#bigThumbnail'),
        bigPlayButton = root.find('#bigPlayButton'),
        w = $('#tagRoot').width(),
        h = $('#tagRoot').height();

    if (h * 16 / 9 < w) { // make sure player is 16:9
        root.css({
            'width': h * 16 / 9 + 'px',
            'left': (w - h*16/9)/2 + 'px'
        });
    } else if (w * 9/16 < h) {
        root.css({
            'height': w * 9 / 16 + 'px',
            'top': (h - w * 9 / 16) / 2 + 'px'
        });
    }

    // UNCOMMENT IF WE WANT IDLE TIMER IN TOUR PLAYER
    // idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
    // idleTimer.start();
    idleTimer && idleTimer.kill();
    idleTimer = null;

    backButton.attr('src', tagPath+'images/Back_wshadow.svg');

    //clicked effect for back button
    backButton.on('mousedown', function(){
        TAG.Util.UI.cgBackColor("backButton", backButton, false);
    });
    backButton.on('mouseleave', function () {
        TAG.Util.UI.cgBackColor("backButton", backButton, true);
    });

    backButton.on('click', goBack);

    if(IS_WEBAPP) {
        linkButton.attr('src', tagPath+'images/link.svg');
        linkButton.on('click', function() {
            var linkOverlay = TAG.Util.UI.showPageLink(urlToParse, {
                tagpagename: 'tour',
                tagguid: tourObj.Identifier,
                prevpage: prevExhib.Identifier,
                tagonlytour: false
            });

            root.append(linkOverlay);
            linkOverlay.fadeIn(500, function() {
                linkOverlay.find('.linkDialogInput').select();
            });
        });
    } else {
        linkButtonContainer.remove();
    }

    if(ispagetoload) {
        pageToLoad.pagename = '';
        if(pageToLoad.onlytour) {
            backButtonContainer.remove();
            linkButtonContainer.remove();
        } else {
            backButtonContainer.css('display', 'none');
            linkButtonContainer.css('display', 'none');
        }
        if(tourObj && tourObj.Metadata && tourObj.Metadata.Thumbnail) {
            bigThumbnail.attr('src', TAG.Worktop.Database.fixPath(tourObj.Metadata.Thumbnail));
            bigPlayButton.attr('src', tagPath + 'images/icons/Play.svg');
            bigThumbnailContainer.css('display', 'block');

            bigPlayButton.on('click', startTour);
            bigThumbnail.on('click', startTour);
        }
    }

    /**
     * Simulate a click on the RIN play button. Used by tour embedding code.
     * 
     * bleveque: I wrote, but strongly dislike, this. I would prefer to
     * call the click handler directly rather than fake a click event. The handler for 
     * the play button is somewhere in the RIN code; instead of digging
     * for it, calling it, and making sure that it also changes the button
     * element, I decided to do this and wait for ITE to make everything better. 
     *
     * @method startTour
     */
    function startTour() {
        bigThumbnailContainer.remove();
        $('.rin_PlayPauseContainer').find('input').trigger('click');
        if(!pageToLoad.onlytour) {
            backButtonContainer.css('display', 'block');
            linkButtonContainer.css('display', 'block');
        }
    }

    function goBack () {

        var artmode, collectionsPage;

        // UNCOMMENT IF WE WANT IDLE TIMER IN TOUR PLAYER
        // idleTimer.kill();
        // idleTimer = null;
        
        if(player) {
            player.pause();
            player.screenplayEnded.unsubscribe();
            player.unload();
        }

        if(!player || rinPlayer.children().length === 0) {
            return; // if page hasn't loaded yet, don't exit (TODO -- should have slide page overlay)
        }

        backButton.off('click'); // prevent user from clicking twice

        if (artmodeOptions) {
            artmode = new TAG.Layout.ArtworkViewer(artmodeOptions);
            TAG.Util.UI.slidePageRightSplit(root, artmode.getRoot());

            currentPage.name = TAG.Util.Constants.pages.ARTWORK_VIEWER;
            currentPage.obj  = artmode;
        } else {
            var backInfo = { backArtwork: tourObj, backScroll: prevScroll };
            collectionsPage = new TAG.Layout.CollectionsPage({
                backScroll: prevScroll,
                backArtwork: tourObj,
                backCollection: exhibition,
                backTag : prevTag,
                backMult : prevMult,
                backPreviewPos : prevPreviewPos
            });
            TAG.Util.UI.slidePageRightSplit(root, collectionsPage.getRoot(), function () {
                artworkPrev = "catalog";
                if (!IS_WINDOWS) {
                    if (collectionsPage.getState().exhibition === exhibition) {
                        collectionsPage.showArtwork(tourObj, prevMult && prevMult)();
                    }
                }
			});
        
            currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
            currentPage.obj  = collectionsPage;         
        }
        // TODO: do we need this next line?
        // tagContainer.css({ 'font-size': '11pt', 'font-family': "'source sans pro regular' sans-serif" }); // Quick hack to fix bug where rin.css was overriding styles for body element -jastern 4/30
    }

    return {
        getRoot: function () {
            return root;
        },
        startPlayback: function () { // need to call this to ensure the tour will play when you exit and re-enter a tour, since sliding functionality and audio playback don't cooperate
            rin.processAll(null, rinPath).then(function () {
                var options = 'systemRootUrl='+rinPath+'/&autoplay='+(ispagetoload ? 'false' : 'true')+'&loop=false';
                // create player
                player = rin.createPlayerControl(rinPlayer[0], options);
                for (var key in tour.resources) {
                    if (tour.resources.hasOwnProperty(key)) {
                        if (typeof tour.resources[key].uriReference === 'string') {
                            tour.resources[key].uriReference = TAG.Worktop.Database.fixPath(tour.resources[key].uriReference);
                        }
                    }
                }
                player.loadData(tour, function () {});
                if(!ispagetoload) {
                    player.screenplayEnded.subscribe(function() { // at the end of a tour, go back to the collections view
                        setTimeout(goBack, 1000);
                    });
                }
            });
        }
    };

};

;
TAG.Util.makeNamespace("TAG.Layout.VideoPlayer");

/**
 * TAG video player -- a wrapper around the standard html5 video element
 * @class TAG.Layout.VideoPlayer
 * @constructor
 * @param {Doq} videoSrc     the doq representing our video
 * @param {Doq} collection   the parent collection of this video
 * @param {Object} prevInfo  some info about where we came from on the collections page:
 *                   .artworkPrev     string representing where we came from
 *                   .prevScroll      value of the scrollbar from new catalog page
 * @return {Object}          the object representing public information about the video page
 *                           (at the moment, just the root of the DOM)
 */
TAG.Layout.VideoPlayer = function (videoSrc, collection, prevInfo) {
    "use strict";

    var artworkPrev,
        prevScroll = 0,
        prevTag,
        prevMult,
        prevPreviewPos,
	    prevExhib = collection;

    if (prevInfo) {
        artworkPrev = prevInfo.artworkPrev,
        prevScroll = prevInfo.prevScroll || 0,
        prevMult = prevInfo.prevMult,
        prevTag = prevInfo.prevTag,
        prevPreviewPos = prevInfo.prevPreviewPos;
    }

    var that = {};

    var root = TAG.Util.getHtmlAjax('VideoPlayer.html'),
        video = root.find('#video'),
        sourceMP4,
        sourceWEBM,
        sourceOGG,
        videoElt = video[0],
        DURATION = parseFloat(videoSrc.Metadata.Duration),
        bottomBar = root.find('#bottomBar'),
        topBar = root.find('#topBar'),
        play = root.find('#playPauseButton'),
        vol = root.find('#videoControlsButton'),
        loop = root.find('#loopButton'),
        sliderPoint = root.find("#sliderPoint"),
        sliderContainer = root.find('#sliderContainer'),
        currTime,
        poster = (videoSrc.Metadata.Thumbnail && !videoSrc.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(videoSrc.Metadata.Thumbnail) : '',
        source = TAG.Worktop.Database.fixPath(videoSrc.Metadata.Source),
        locked = TAG.Worktop.Database.getLocked(),     //Check for locked
        sourceWithoutExtension = source.substring(0, source.lastIndexOf('.')),
        currentTimeDisplay = root.find('#currentTimeDisplay'),
        backButton = root.find('#backButton'),
        linkButton = root.find('#linkButton'),
        linkButtonContainer = root.find('#linkContainer');

    // UNCOMMENT IF WE WANT IDLE TIMER IN Video PLAYER
    // idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
    // idleTimer.start();

    // init the video player status
    initPage();
    timeToZero();
    initVideoPlayHandlers();

    /**
     * Return to the collections page from the video player.
     * @method goBack
     */
    function goBack() {
        videoElt.pause();
        video.attr('src', "");

        // UNCOMMENT IF WE WANT IDLE TIMER IN TOUR PLAYER
        // idleTimer.kill();
        // idleTimer = null;

        var backInfo = { backArtwork: videoSrc, backScroll: prevScroll };
        var collectionsPage = TAG.Layout.CollectionsPage({
            backScroll: prevScroll,
            backArtwork: videoSrc,
            backCollection: collection,
            backTag : prevTag,
            backMult : prevMult,
            backPreviewPos : prevPreviewPos
        });

        // collectionsPage.getRoot().css({ 'overflow-x': 'hidden' }); // TODO should be default in .styl file
        TAG.Util.UI.slidePageRightSplit(root, collectionsPage.getRoot(), function () {
            artworkPrev = "catalog";
            if (!IS_WINDOWS) {
                if (collectionsPage.getState().exhibition === collection) {
                    collectionsPage.showArtwork(videoSrc, prevMult && prevMult)();
                }
            }
        });

        currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
        currentPage.obj  = collectionsPage;
    }

    function loop(){

    }

    /**
     * Take video to time 0 and pause.
     * @method timeToZero
     */
    function timeToZero() {
        if (videoElt.currentTime !== 0) {
            videoElt.currentTime = 0;
            videoElt.pause();
        }
        play.attr('src', tagPath+'js/rin/web/systemResources/themeresources/images/play.png');
    }

    /**
     * Play video and change play button image
     * @method playVideo
     */
    function playVideo() {
        videoElt.play();
        topBar.css('display', 'none');
        play.attr('src', tagPath+'js/rin/web/systemResources/themeresources/images/pause.png');
    }

    /**
     * Pause video and change play button image
     * @method pauseVideo
     */
    function pauseVideo() {
        videoElt.pause();
        topBar.css('display','inline');
        play.attr('src', tagPath+'js/rin/web/systemResources/themeresources/images/play.png');
    }

    /**
     * Play or pause video depending on its current state
     * @method toggleVideo
     */
    function toggleVideo() {
        videoElt.paused ? playVideo() : pauseVideo();
    }

    /**
     * Set up handlers for video element and play/pause button
     * @method initVideoPlayHandlers
     */
    function initVideoPlayHandlers() {
        video.on('loadedmetadata', initSeekHandlers);

        // set up play button
        play.attr('src', tagPath+'js/rin/web/systemResources/themeresources/images/play.png');
        play.on('click', toggleVideo);

        // set up mute button
        vol.attr('src', tagPath+'js/rin/web/systemResources/themeresources/images/volume.png');
        $(vol).on('click', function () {
            videoElt.muted = !videoElt.muted;
            vol.css("opacity", (videoElt.muted ? ".5" : "1"))
        });

        // when video ends, return to collections page after a short delay
        video.on('ended', function () {
            setTimeout(goBack, 300);
        });

        // set up loop button
        loop.on('click', function() {

        });

        // Update the seek bar as the video plays
        video.on("timeupdate", function () {
            var value,
                minutes,
                seconds,
                adjMin;

            // Calculate the slider value and update the slider value
            value = ($('#sliderContainer').width() / videoElt.duration) * videoElt.currentTime;
            sliderPoint.css('width',value);

            minutes = Math.floor(videoElt.currentTime / 60);
            seconds = Math.floor(videoElt.currentTime % 60);
            if (String(minutes).length < 2) {
                adjMin = '0' + minutes;
            } else {
                adjMin = minutes;
            }
            currentTimeDisplay.text(adjMin + ":" + (seconds < 10 ? "0" : "") + seconds);
        });

        if (!IS_WEBAPP){
            bottomBar.css({
                'height': '7%',
                'background-color': "rgba(0, 0, 0, .5)"
            });
            sliderPoint.css('background-color','white');

            sliderContainer.css({
                "border" : "1px solid rgb(250,250,250)",
                "width": "70%",
                "left": '15%',
                "height": "20%",
                "bottom":"40%"
            })



        }
    }

    /**
     * Set up handlers for the seekbar
     * @method initSeekHandlers
     */
    function initSeekHandlers() {
        sliderContainer.on('mousedown', function(evt) {
            var time = videoElt.duration * (evt.offsetX / $('#sliderContainer').width());    
            if (!isNaN(time)) {
                videoElt.currentTime = time;
            }
        });

        // set up mousedown handler for the seekbar
        sliderContainer.on('mousedown', function(e) {
            e.stopPropagation();
            var origPoint = e.pageX,
                origTime = videoElt.currentTime,
                timePxRatio = DURATION / sliderContainer.width(), // sec/px
                currPx,
                minutes,
                seconds;
            
            currTime = Math.max(0, Math.min(DURATION, origTime));
            currPx   = currTime / timePxRatio;
            minutes  = Math.floor(currTime / 60);
            seconds  = Math.floor(currTime % 60);

            if((""+minutes).length < 2) {
                minutes = "0" + minutes;
            }

            // set up mousemove handler now that mousedown has happened
            $('body').on('mousemove.seek', function(evt) {
                var currPoint = evt.pageX,
                    timeDiff = (currPoint - origPoint) * timePxRatio;

                currTime = Math.max(0, Math.min(DURATION, origTime + timeDiff));
                currPx   = currTime / timePxRatio;
                minutes  = Math.floor(currTime / 60);
                seconds  = Math.floor(currTime % 60);

                if((""+minutes).length < 2) {
                    minutes = "0" + minutes;
                }

                // Update the video time and slider values
                if (!isNaN(currTime)) {
                    $('#currentTimeDisplay').text(minutes + ":" + (seconds < 10 ? "0" : "") + seconds);
                    videoElt.currentTime = currTime;
                    sliderPoint.css('width', currPx);
                }

            });

            // when the mouse is released or leaves iframe, remove the mousemove handler and set time
            $('body').on('mouseup.seek mouseleave.seek', function() {
                $('body').off('mousemove.seek');
                $('body').off('mouseup.seek');
                $('body').off('mouseleave.seek');
		        $('#currentTimeDisplay').text(minutes + ":" + (seconds < 10 ? "0" : "") + seconds);
                videoElt.currentTime = currTime;
		        sliderPoint.css('width', currPx);
            });
        });
    }

    /**
     * Initialize misc parts of the video player
     * @method initPage
     */
    function initPage() {
        idleTimer && idleTimer.kill();
        idleTimer = null;
        // set attributes of video element
        video.attr({
            poster: poster,
            controls: false,
            preload: 'metadata'
        });

        //Adding sources for the video file
        sourceMP4  = sourceWithoutExtension + ".mp4";
        sourceWEBM = sourceWithoutExtension + ".webm";
        sourceOGG  = sourceWithoutExtension + ".ogg";
        
        //video[0] converts the jQuery object 'video' into an HTML object, allowing us to use innerHTML on it
        videoElt.innerHTML  = '<source src="' + sourceMP4  + '" type='+"'"+'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'+"'"+'>';
        videoElt.innerHTML += '<source src="' + sourceWEBM + '" type='+"'"+'video/webm; codecs="vorbis, vp8"'+"'"+'>';
        videoElt.innerHTML += '<source src="' + sourceOGG  + '" type='+"'"+'video/ogg; codecs="theora, vorbis"'+"'"+'>';

        // set text of time display
        currentTimeDisplay.text("00:00");
    
        // set up back button
        if (locked !== videoSrc.Identifier) {
            backButton.attr('src', tagPath + 'images/icons/Back.svg');
        } else {
            backButton.hide();
        }
        backButton.on('mousedown', function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, false);
        });
        backButton.on('mouseleave', function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, true);
        });

        backButton.on('click', goBack);

        //add bottom fade
        bottomBar.css({

            });

        if(IS_WEBAPP) {
            linkButton.attr('src', tagPath + 'images/link.svg');
            linkButton.on('click', function() {
                var linkOverlay = TAG.Util.UI.showPageLink(urlToParse, {
                    tagpagename: 'video',
                    tagguid: videoSrc.Identifier,
                    prevpage: prevExhib.Identifier
                });

                root.append(linkOverlay);
                linkOverlay.fadeIn(500, function() {
                    linkOverlay.find('.linkDialogInput').select();
                });
            });
        } else {
            linkButtonContainer.remove();
        }
    }

    /**
     * Return the root of the video page
     * @method getRoot
     * @return {jQuery object}   root of the video page
     */
    function getRoot() {
        return root;
    }
    that.getRoot = getRoot;

    return that;
};

;
TAG.Util.makeNamespace("TAG.Layout.ArtworkEditor");

/**
 * The layout definition for the artwork editor. 
 * Click 'Edit Artwork Info' in the Authoring Mode to enter.
 * Contains info, location, and media editors.
 * @class TAG.Layout.ArtworkEditor
 * @constructor
 * @param {doq} artwork          doq of the relevant artwork (see github wiki for doq structure)
 * @return {Object}              any public methods or properties
 */

TAG.Layout.ArtworkEditor = function (artwork) {
    "use strict";

    var // DOM-related
        root = $(document.createElement('div')),                    // get via Util.getHtmlAjax in web app
        topbar = $(document.createElement('div')),                  // get via root.find(...) in web app, set up in JADE
        mainPanel = $(document.createElement('div')),
        titleArea = $(document.createElement('div')),
        //rightbarLoadingDelete = $(document.createElement('div')),

        // misc initialized variables
        helpText = "To select a location, type into the search field or \
                    right-click/long-press on the map and drag the pushpin \
                    to the desired location, then click on the desired \
                    address and click 'Confirm.'",                                        // location history hint text
        credentials = "AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj", // bing maps credentials
        locationList = [],                                                                // list of locations in location history
        artworkMetadata = {},                                                             // will be populated by HTML elements whose values have artwork metadata
        textMetadata = {},                                                                // deprecated -- for text metadata
        loadQueue = TAG.Util.createQueue(),                                               // async queue for loading UI elements                                                  
        topbarHeight = 8,                                                                 // % height of top bar
        METADATA_EDITOR = MetadataEditor(),                                               // MetadataEditor object to deal with metadata-related business
        THUMBNAIL_EDITOR = ThumbnailEditor(),                                             // ThumbnailEditor object to deal with setting up thumbnail editing
        LOCATION_HISTORY = RichLocationHistory(),                                         // RichLocationHistory object ................................
        MEDIA_EDITOR = AssocMediaEditor(),                                                // AssocMediaEditor object ................................
       
        // misc uninitialized variables
        annotatedImage,               // AnnotatedImage object
        associatedMedia,
        metadataButton,               // "Information" sidebar button
        rightArrow,                   // right arrow in "Information" button
        editThumbnailButton,          // "Edit Thumbnail" button
        rightArrowEditThumb,          // right arrow in "Edit Thumbnail" button
        editLocButton,                // "Edit Location History" button
        rightArrowEditLoc,            // right arrow in "Edit Location History" button
        sidebarHideButtonContainer;   // tab to expand/contract side bar
   
    LADS.Util.UI.getStack()[0] = null;
        
    root.attr("class", "rootPage");
    // get things rolling
    init();

    return {
        getRoot: getRoot
    };
    
    /**
     * Loads deepzoom image and creates UI (via a call to initUI)
     * @method init
     */
    function init() {
        //$(document).off();
        root.css({ // TODO STYL
            "background-color": "rgb(219,217,204)",
            "color": "black",
            "width": "100%",
            "height": "100%"
        });
        mainPanel.css({ // TODO JADE/STYL
            width: '100%',
            height: (100 - topbarHeight) + '%'
        }).addClass("mainPanel");

        //creates deep zoom image
        if (artwork) {
            
            annotatedImage = new TAG.AnnotatedImage({
                root: root,
                doq: artwork,
                callback: function () {

                    if (!(annotatedImage.openArtwork(artwork))) { // if artwork load is unsuccessful...
                        var popup = TAG.Util.UI.popUpMessage(function () {
                            TAG.Authoring.SettingsView("Artworks", function (settingsView) {
                                TAG.Util.UI.slidePageRight(settingsView.getRoot());
                            }, null, artwork.Identifier);
                        }, "There was an error loading the image.", "Go Back", true);
                        root.append(popup);
                        $(popup).show();
                    }
                    initUI();
                },
                noMedia: true
            });
        } else {
            initUI();
        }
    }

    /**
     * Initializes the artwork editor UI (side bar, top bar, etc)
     * @method initUI
     */
    function initUI() {
        createTopBar();
        root.append(mainPanel);     // TODO JADE
        makeSidebar();
        METADATA_EDITOR.init();     // initialize different parts of the editor
        LOCATION_HISTORY.init();
        THUMBNAIL_EDITOR.init();
        MEDIA_EDITOR.init();
    }

    /**
     * Creates the artwork editor top bar (back button, save changes button, etc)
     * @method createTopBar
     */
    function createTopBar() { // TODO most of this can be factored to J/S
        var backButton = $(document.createElement('img')), // TODO JADE
            topBarLabel = $(document.createElement('div')), // TODO JADE
            topBarLabelSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08, { // TODO should be able to do this in STYL file
                width: 0.4,
                height: 0.9,
            }),
            titleAreaSpecs,
            aefontsize;

        topbar.css({ // TODO JADE/STYL
            "background-color": "rgb(63,55,53)",
            "color": "rgb(175,200,178)",
            "width": '100%',
            'height': topbarHeight + '%',
            'position': 'relative',
            'z-index': 1 // above any moving layers
        }).addClass("topbar");

        backButton.attr('src', tagPath+'images/icons/Back.svg'); // TODO add tagpath in web app
        backButton.css({ // TODO STYL
            'height': '63%',
            'margin-left': '1.2%',
            'float': 'left',
            'width': 'auto',
            'top': '18.5%',
            'position': 'relative',
        });
        topbar.append(backButton); // TODO JADE

        // TODO use TAG.Util.setUpBackButton in web app to combine mousedown/mouseleave/click
        backButton.on('mousedown', function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, false);
        });
        backButton.on('click', function () {
            TAG.Util.removeYoutubeVideo();
            var authoringHub;
            var transOverlay = $(TAG.Util.UI.blockInteractionOverlay(0.6));
            $("#tagRoot").append(transOverlay);
            var vert = $("#tagRoot").height() / 2;
            var horz = $("#tagRoot").width() / 2;
            var progressCircCSS = {
                'position': 'absolute',
                'z-index': '50',
                'height': 'auto',
                'width': ($("#tagRoot").width() * 0.1) +"px"
            };
            var circle = TAG.Util.showProgressCircle(transOverlay, progressCircCSS, horz, vert, true);
            transOverlay.show();
            MEDIA_EDITOR.close();
            backButton.off('click');
            if (shouldSave) {
                saveMetadata();
            } else {
                var authoringHub = new LADS.Authoring.SettingsView("Artworks", null, null, artwork.Identifier);
                TAG.Util.UI.slidePageRight(authoringHub.getRoot());
            }
            
        });
 
        topBarLabel.css({ // TODO STYL (see constrainAndPosition comment above)
            'margin-right': '2%',
            'margin-top': 8 * 0.045 + '%', // ?
            'color': 'white',
            'position': 'absolute',
            'text-align': 'right',
            'right': '0px',
            'top': '0px',
            'height': topBarLabelSpecs.height + 'px',
            'width': topBarLabelSpecs.width + 'px',
        });

        // TODO see if you can do this in STYL file as well
        aefontsize = TAG.Util.getMaxFontSizeEM('Artwork Editor', 0.5, topBarLabelSpecs.width, topBarLabelSpecs.height * 0.8);
        topBarLabel.css({ 'font-size': aefontsize });

        topBarLabel.text('Artwork Editor'); // TODO JADE

        // TODO STYL
        titleAreaSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08, {
            center_v: true,
            width: 0.55,
            height: 0.5,
            x_offset: 0.05,
            x_max_offset: 60,
        });

        titleArea.text(artwork.Name);

        // TODO STYL (try to eliminate need for constrainAndPosition)
        titleArea.css({
            'margin-left': '3.25%',
            'position': 'absolute',
            'color': 'white',
            'font-size': aefontsize,
            'margin-top': 8 * 0.045 + '%', // ?
            'left': titleAreaSpecs.x + 'px',
            width: titleAreaSpecs.width + 'px',
            height: topBarLabelSpecs.height + 'px',
            overflow: 'hidden',
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap'
        });
        titleArea.attr('id', 'titleArea'); // TODO JADE

        topbar.append(titleArea); // TODO JADE

        // TODO JADE
        topbar.append(topBarLabel);
        root.append(topbar);
        TAG.Telemetry.register(root.find('.artworkInfoLabel'),'click','artworkeditor_info',function(tobj){
            tobj.mode = 'artwork editor';
        });

         TAG.Telemetry.register(root.find('.addRemoveMedia'),'click','artworkeditor_media_addremove',function(tobj){
             tobj.mode = 'artwork editor';
        });

        TAG.Telemetry.register(root.find('#locationHistoryAddLocationButton'),'click','artworkeditor_addlocation',function(tobj){
            tobj.mode = 'artwork editor';
        });

        TAG.Telemetry.register(root.find('#locationHistorySortLocationsByTitleButton'),'click','artworkeditor_sort_title',function(tobj){
            tobj.mode = 'artwork editor';
        });

        TAG.Telemetry.register(root.find('#locationHistorySortLocationsByDateButton'),'click','artworkeditor_sort_date',function(tobj){
            tobj.mode = 'artwork editor';
        });

        TAG.Telemetry.register(root.find('#locationHistoryDeleteButton'),'click','artworkeditor_sort_title',function(tobj){
            tobj.mode = 'artwork editor';
        });

        TAG.Telemetry.register(root.find('#locationHistoryImportMapButton'),'click','artworkeditor_sort_title',function(tobj){
            tobj.mode = 'artwork editor';
        });
    }   


    /**
     * Reloads the specified associate media in the associate media list
     * @method reloadAssocMedia
     * @param {String} assocMediaIdentifier       the identifier string for the associate media to be reloaded
     */
    function reloadAssocMedia(assocMediaIdentifier) {
        annotatedImage.loadAssociatedMedia(function(mediaList) {
            var assocMediaHolder = $('#' + assocMediaIdentifier);
            mediaList = annotatedImage.getAssociatedMedia();
            for (var i = 0; i < mediaList.guids.length; i++) {
                var mediadoq = mediaList[mediaList.guids[i]].doq;
                if (mediadoq.Identifier == assocMediaIdentifier) {
                    loadQueue.add(reloadMediaHolder(assocMediaHolder, mediadoq));
                    assocMediaHolder.on('click', thumbnailButtonClick(mediaList[mediaList.guids[i]]));
                }
            }

        });
    }

    /**
    * Returns a function that refreshes the title of the specified associate media in the associate media list
    * @method reloadMediaHolder
    * @param {jQuery obj} container         the holder element containing the element for the title of the associate media
    * @parem {Object} asset         the asset of info about the associate media 
    * @return {Function}        the function that refreshes the title of the specified associate media in the associate media list
    */
    function reloadMediaHolder(container, asset) { 
        return function () {
            var $holder = container;
            var $title = $holder.find('.thumbnailButtonTitle');
            $title.text(LADS.Util.htmlEntityDecode(asset.Name));
        };
    }

    /**
     * Creates associated media list in left panel
     * @method createMediaList
     * @param {jQuery obj} container        the element containing this list
     */
    function createMediaList(container) {
        TAG.Util.showLoading(container || $('.assetContainer'), '20%', '40%', '40%');
        annotatedImage.loadAssociatedMedia(function (mediaList) {
            container = container || $('.assetContainer');
            container.empty();
            mediaList = annotatedImage.getAssociatedMedia();
            var i,
                src;

            // sort alphabetically
            mediaList.guids.sort(function (a, b) {
                return mediaList[a].doq.Name < mediaList[b].doq.Name ? -1 : 1;
            });

            // create divs for each media
            for (i = 0; i < mediaList.guids.length; i++) {
                var mediadoq = mediaList[mediaList.guids[i]].doq;
                switch (mediadoq.Metadata.ContentType) {
                    case 'Audio':
                        src = tagPath + 'images/audio_icon.svg';
                        break;
                    case 'Video':
                        src = ((mediadoq.Metadata.Thumbnail && !mediadoq.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(mediadoq.Metadata.Thumbnail) : tagPath + 'images/video_icon.svg');
                        break;
                    case 'Image':
                        if (mediadoq.Metadata.Thumbnail) {
                            src= TAG.Worktop.Database.fixPath(mediadoq.Metadata.Thumbnail);
                        }else if (mediadoq.Metadata.Source){
                            src = TAG.Worktop.Database.fixPath(mediadoq.Metadata.Source);
                        } else {
                            src=tagPath + 'images/image_icon.svg';
                        }
                        break;
                    case 'iframe':
                        src = tagPath + 'images/video_icon.svg';
                        break;
                    default:
                        src = tagPath + 'images/text_icon.svg';
                        break;
                }
                loadQueue.add((function (j) {
                     var thumbnailButton = TAG.Util.Artwork.createThumbnailButton({
                        title: mediadoq.Name,
                        handler: thumbnailButtonClick(mediaList[mediaList.guids[j]]),
                        buttonClass: "assetHolder",
                        src: src
                    });
                    thumbnailButton.attr("id", mediadoq.Identifier);
                    container.append(thumbnailButton);
                })(i));
            }
            TAG.Util.hideLoading(container);
        });

    }

    /**
     * Click handler for an associated media thumbnail button. Opens the media editing pane.
     * @method thumbnailButtonClick
     * @param {Object} asset            associated media object
     * @param {jQuery obj} holder       the thumbnail button
     */
    function thumbnailButtonClick(asset) { // TODO in the web app, pass this in to TAG.Util.Artwork.createThumbnailButton
        return function (evt) {
            if (!($(document.getElementById(asset.doq.Identifier)).css('background-color') === 'rgba(255, 255, 255, 0.4)')) {
                closeAllPanels();
                MEDIA_EDITOR.open(asset, MEDIA_EDITOR.createMediaWrapper(asset), function () {
                    //Initially disable the save button
                    $(".addbutton").prop('disabled', true);
                    $(".addbutton").css('opacity', '0.4');
                    $('.assetHolder').css('background-color', '');
                    $(document.getElementById(asset.doq.Identifier)).css({
                        'background-color': 'rgba(255, 255, 255, 0.4)',
                    });
                });
            } else {
                //$('.assetHolder').css('background-color', '');
                //$('.closeEditAssocMedia').click();
            }
        };
    }

    /**
     * Make the artwork editing side bar.
     * @method makeSidebar
     */
    function makeSidebar() {
        var i,                 // iteration index
            sidebar,           // div for whole side bar
            buttonContainer,   // contains information, loc history, and thumbnail buttons
            artworkInfoLabel,  // "Artwork Information" label
            buttonCSS,         // some button css
            newButtonCSS,      // some more button css (do both of these in STYL)
            sidePanelFontSize, // result of call to Util.getMaxFontSizeEM (can try to do this in STYL after some trial and error)
            titleFontSize,     // font size of "Artwork Information" header (STYL)
            metaDataLabel,     // "Information" label
            editLocLabel,      // "Edit Location History" label
            editThumbLabel,    // "Edit Thumbnail" label
            assocMediaLabel,   // "Associated Media" label
            addRemoveMedia,    // "Add/Remove Media" button
            assetContainer,    // contains assoc media thumbnail buttons
            sidebarHideButton, // button to toggle side bar visibility
            sidebarHideIcon,   // arrow icon in the side bar hide button
            expanded = true;   // whether the side bar is expanded or contracted

        buttonCSS = { // TODO STYL
            'margin-top': '2%',
            'margin-bottom': '3%',
            'width': '81%',
            'position': 'relative',
        };

        newButtonCSS = { // TODO STYL
            'margin-top': '1%',
            'margin-bottom': '1.5%',
            'width': '100%',
            'height': root.height() * 0.06,
            'color': 'white',
            'position': 'relative'
        };
        
        sidePanelFontSize = TAG.Util.getMaxFontSizeEM("Edit Maps", 1, root.width() * 0.11, 0.5 * root.height() * 0.07);
        titleFontSize = TAG.Util.getMaxFontSizeEM("Artwork Properties", 1, root.width() * 0.15, root.height() * 0.07);

        sidebar = $(document.createElement('div')); // TODO JADE/STYL
        sidebar.addClass("sidebar");
        sidebar.css({
            'width': '20%',
            'height': '100%',
            'position': 'relative',
            'left': '0%',
            'float': 'left',
            'background-color': 'rgba(0,0,0,0.85)',
            'z-index': 100
        });

        buttonContainer = $(document.createElement('div')); // TODO JADE/STYL
        buttonContainer.attr('class', 'buttonContainer');
        buttonContainer.css({
            position: 'relative',
            'margin-top': '4%',
            'text-align':'center'
        });
        sidebar.append(buttonContainer);

        // change calculation of max font size to be non-dependent on div size
        // copy constant over
        artworkInfoLabel = $(document.createElement('div')); // TODO JADE/STYL
        artworkInfoLabel.addClass('artworkInfoLabel');
        artworkInfoLabel.text('Artwork Properties');
        artworkInfoLabel.css({
            'color': 'white',
            'font-size': titleFontSize,
            'margin-top': '2%',
            'margin-bottom': '3%',
            'font-weight': 'bold',
            'height': newButtonCSS.height * 0.6
        });
        buttonContainer.append(artworkInfoLabel);

        rightArrow = $(document.createElement('img')); // TODO J/S
        rightArrow.attr('src', tagPath+'images/icons/Right.png'); // TODO keep this in js, tack on tagPath in web app
        rightArrow.css({
            "position": "absolute",
            "right": "5%",
            top: "30%",
            width: "auto",
            height: "40%"
        });

        metadataButton = $(document.createElement('div')) // TODO J/S
                            .css(newButtonCSS);
        metadataButton.append(rightArrow);

        metaDataLabel = $(document.createElement('label')); // TODO J/S
        metaDataLabel.text("Metadata  ");
        metaDataLabel.css({
            "width": "100%",
            "height": "100%",
            "text-align": "center",
            "line-height": metadataButton.height() + "px",
            "font-size": sidePanelFontSize
        });

        metadataButton.append(metaDataLabel);
        buttonContainer.append(metadataButton);

        rightArrowEditLoc = $(document.createElement('img')); // TODO J/S
        rightArrowEditLoc.attr('src', tagPath+'images/icons/Right.png');
        rightArrowEditLoc.css({ "position": "absolute", "right": "5%", top: "30%", width: "auto", height: "40%" });

        editLocLabel = $(document.createElement('label')); // TODO J/S
        editLocLabel.text("Edit Maps  ");
        editLocLabel.css({ "width": "100%", "height": "100%", "line-height": "100%", "text-align": "center" });

        editLocButton = $(document.createElement('div')); // TODO J/S
        editLocButton.css(newButtonCSS);
        buttonContainer.append(editLocButton);
        editLocButton.append(rightArrowEditLoc);
        editLocButton.append(editLocLabel);
        editLocLabel.css({ "line-height": editLocButton.height() + "px", "font-size": sidePanelFontSize });

        editThumbLabel = $(document.createElement('label')); // TODO J/S
        editThumbLabel.text("Capture Thumbnail  ");
        editThumbLabel.css({ "width": "100%", "height": "100%", "line-height": "100%", "text-align": "center" });

        rightArrowEditThumb = $(document.createElement('img')); // TODO J/S
        rightArrowEditThumb.attr('src', tagPath+'images/icons/Right.png');
        rightArrowEditThumb.css({ "position": "absolute", "right": "5%", top: "30%", width: "auto", height: "40%" });

        editThumbnailButton = $(document.createElement('div')); // TODO J/S
        editThumbnailButton.addClass("editThumbnailButton");
        editThumbnailButton.attr('type', 'button');
        editThumbnailButton.css(newButtonCSS);

        buttonContainer.append(editThumbnailButton); // TODO J/S
        editThumbnailButton.append(rightArrowEditThumb);
        editThumbnailButton.append(editThumbLabel);
        editThumbLabel.css({ "line-height": editLocButton.height() + "px", "font-size": sidePanelFontSize });

        // toggles metadata form and button
        metadataButton.on('click', function () {
            METADATA_EDITOR.toggle();
        });

        // toggles location history editing panel and button
        editLocButton.on('click', function () {
            LOCATION_HISTORY.toggle();
        });
        
        // toggles edit thumbnail functionality
        editThumbnailButton.on('click', function () {
            THUMBNAIL_EDITOR.toggle();
        });

        assocMediaLabel = $(document.createElement('div')); // TODO JADE/STYL
        assocMediaLabel.addClass('assocMediaLabel');
        assocMediaLabel.text('Associated Media');
        assocMediaLabel.css({
            color: 'white',
            'font-size': titleFontSize,
            'margin-top': '6%',
            'margin-bottom': "2%",
            'font-weight': 'bold'
        });
        buttonContainer.append(assocMediaLabel);

        addRemoveMedia = $(document.createElement('button')); // TODO JADE/STYL
        addRemoveMedia.addClass('addRemoveMedia');
        addRemoveMedia.text('Add/Remove').css('border-radius', '3.5px');
        addRemoveMedia.attr('type', 'button');
        addRemoveMedia.css(buttonCSS);
        addRemoveMedia.css({'font-size':TAG.Util.getMaxFontSizeEM("Add/Remove Media", 0.5, root.width() * 0.1, 0.5 * newButtonCSS.height)});
        buttonContainer.append(addRemoveMedia);

        // open media picker on button click
        addRemoveMedia.on('click', createMediaPicker);
        addRemoveMedia.on('mousedown', function () {
            addRemoveMedia.css({ "background-color": "white","color":"black" });
        });

        addRemoveMedia.on("mouseleave", function () {
            addRemoveMedia.css({ "background-color": "transparent","color":"white"});
        });
        /**
         * Create the associated media selection picker
         * @method createMediaPicker
         */
        function createMediaPicker() {
            TAG.Util.UI.createAssociationPicker(root,
                "Choose the media you wish to associate with this artwork",
                {comp: artwork, type: 'artwork'},
                "artwork",
                [{
                    name: "all media",
                    getObjs: TAG.Worktop.Database.getAssocMedia,
                }, {
                    name: "currently associated",
                    getObjs: TAG.Worktop.Database.getAssocMediaTo,
                    args: [artwork.Identifier]
                }], {
                    getObjs: TAG.Worktop.Database.getAssocMediaTo,
                    args: [artwork.Identifier]
                }, function () { // TODO (low priority) -- shouldn't need to reload entire list here
                    $('.assetContainer').empty();
                    createMediaList($('.assetContainer'));
                });
        }

        assetContainer = $(document.createElement('div')); // TODO JADE/STYL
        assetContainer.attr('class', 'buttonContainer');
        assetContainer.css({
            position: 'relative',
            top: '0%,',
            'margin-top': '2%',
            padding: '0px 8% 0px 4%',
            width:'82%',
            left:'5%',
            'overflow-x': 'hidden',
            'overflow-y': 'auto',
            'text-overflow': 'ellipsis',
            'word-wrap': 'break-word',
            height: '54%'
        });
        assetContainer.addClass('assetContainer');
        sidebar.append(assetContainer);

        createMediaList(assetContainer);

        // sidebar toggle button
        sidebarHideButtonContainer = $(document.createElement('div')); // TODO J/S
        sidebarHideButtonContainer.addClass('sidebarHideButtonContainer');
        sidebarHideButtonContainer.css({
            'top': '0%',
            'right': '0%',
            'position': 'relative',
            'width': '2%',
            'height': '100%',
            'float': 'left',
            'z-index': 1000
        });

        sidebarHideButton = $(document.createElement('div')); // TODO J/S
        sidebarHideButton.css({
            'top': '45%',
            'right': '0%',
            'position': 'relative',
            'width': '100%',
            'height': '10%',
            'background-color': 'rgba(0,0,0,.85)',
            'border-bottom-right-radius': '10px',
            'border-top-right-radius': '10px'
        });

        sidebarHideIcon = $(document.createElement('img')); // TODO J/S
        sidebarHideIcon.css({ 'top': '30%', 'width': '40%', 'height': 'auto', 'position': 'relative', 'left': '20%' });
        sidebarHideIcon.attr('src', tagPath+'images/icons/Left.png'); // TODO keep this in js, use tagPath + ....
        sidebarHideButton.append(sidebarHideIcon);

        sidebarHideButtonContainer.append(sidebarHideButton);

        sidebarHideButtonContainer.on('click', function () {
            var left = expanded ? '-20%' : '0%';
            sidebarHideIcon.attr('src', expanded ? tagPath+'images/icons/Right.png' : tagPath+'images/icons/Left.png'); // TODO tagPath + ... in web app
            sidebar.animate({ 'left': left }, 600);
            sidebarHideButtonContainer.animate({ 'left': left }, 600);
            expanded = !expanded;
        });

        mainPanel.append(sidebar); // TODO JADE
        mainPanel.append(sidebarHideButtonContainer);
    }

    /**
     * If we have an out-of-date doq (e.g., if another TAG
     * client updated the doq while we were working), force
     * the call anyway, which will overwrite their changes.
     * This may not be the best behavior, so if you think of
     * a well-defined solution, please rewrite this function!
     * @method conflict
     * @param {jqXHR} jqXHR         async request object (see http://api.jquery.com/Types/#jqXHR)
     * @param {Object} ajaxCall     see documentation in TAG.Worktop.Database (and the code in asyncRequest in that file)
     */
    function conflict(jqXHR, ajaxCall) {
        ajaxCall && ajaxCall.force && ajaxCall.force();
    }

    /**
     * Return root of artwork editor DOM.
     * @method getRoot
     * @return {jQuery obj}       root of artwork editor DOM
     */
    function getRoot() {
        return root;
    }

    /**
     * Closes all open panels (metadata editing panel, location history
     * panel, and thumbnail editing panel).
     * @method closeAllPanels
     */
    function closeAllPanels() {
        THUMBNAIL_EDITOR.close();
        LOCATION_HISTORY.close();
        METADATA_EDITOR.close();
    }

    /**
     * Thumbnail editing code. Just a wrapper around some thumbnail functions to clean things up.
     * @method ThumbnailEditor
     * @return {Object}         an object with "public" thumbnail editing methods
     */
    function ThumbnailEditor() {
        var tnBorderWrapper,
            isOpen = false,
            mainPanelHeight,
            mainPanelWidth,
            ratio,
            tnSave;

        /**
         * Initialize the thumbnail editor. Mostly UI stuff here.
         * @method init
         */
        function init() { // TODO most of this could be moved to JADE/STYL (the only thing that should be necessary here is binding click handlers)
            var tnBorderCenter,
                tnBorderLeft,
                tnBorderTop,
                tnBorderBottom,
                tnBorderRight,
                tnHelp,
                tnHelpPadding,
                tnHelpBorder,
                tnBottomWidth;

            mainPanelHeight = $('.mainPanel').height(),
            mainPanelWidth = $('.mainPanel').width(),
            ratio = 1.564,

            tnBorderWrapper = $(document.createElement('div'));
            tnBorderWrapper.addClass('tnBorderWrapper');
            tnBorderWrapper.css({
                position: 'relative',
                top: '0px',
                left: '0px',
                height: '100%',
                width: '100%',
                display: 'none',
            });

            tnBorderCenter = $(document.createElement('div'));
            tnBorderCenter.addClass("tnBorderCenter");
            tnBorderCenter.css({
                position: 'absolute',
                top: '15%',
                left: '25%',
                height: 50 + '%',
                width: ((50 * mainPanelHeight * ratio) / mainPanelWidth) + '%',
                'background-color': 'transparent',
                border: '2px solid white',
                'z-index': 60,
            });

            tnBorderLeft = $(document.createElement('div'));
            tnBorderLeft.addClass("tbBorderLeft");
            tnBorderLeft.css({
                position: 'absolute',
                top: '0%',
                left: 0,
                height: '100%',
                width: '25%',
                'background-color': 'rgba(0,0,0,.6)',
                'z-index': 50,
            });

            tnBorderTop = $(document.createElement('div'));
            tnBorderTop.addClass("tnBorderTop");
            tnBorderTop.css({
                position: 'absolute',
                top: '0%',
                left: '25%',
                height: '15%',
                width: $(tnBorderCenter).width() + '%',
                'background-color': 'rgba(0,0,0,.6)',
                'z-index': 50,
            });

            tnBorderBottom = $(document.createElement('div'));
            tnBorderBottom.addClass("tnBorderBottom");
            tnBorderBottom.css({
                position: 'absolute',
                top: (15 + $(tnBorderCenter).height()) + '%',
                left: '25%',
                height: (100 - $(tnBorderCenter).height() - $(tnBorderTop).height()) + '%',
                width: $(tnBorderCenter).width() + '%',
                'background-color': 'rgba(0,0,0,.6)',
                'z-index': 55,
            });

            tnBorderRight = $(document.createElement('div'));
            tnBorderRight.addClass("tnBorderRight");
            tnBorderRight.css({
                position: 'absolute',
                top: '0%',
                left: (25 + $(tnBorderCenter).width()) + '%',
                height: '100%',
                width: (100 - 25 - $(tnBorderCenter).width()) + '%',
                'background-color': 'rgba(0,0,0,.6)',
                'z-index': 50,
            });

            tnHelp = $(document.createElement('div')); // TODO this help box looks weird
            tnHelp.addClass('tnHelp');
            tnHelp.css({
                position: 'relative',
                top: '5%',
                left: '0%',
                width: '100%',
                padding: '1%',
                'text-align': 'center',
                'font-size': '120%',
                color: 'white',
            });
            tnHelp.text("Move and resize the artwork within the thumbnail window, and select “Save Thumbnail” when you’re happy with the composition.");
            tnHelpPadding = (parseInt($(tnHelp).css('padding'), 10) / 100) * ($(tnBorderBottom).innerWidth() / 100) * root.width();
            tnHelpBorder = parseInt($(tnHelp).css('border'), 10);
            tnBottomWidth = ($(tnBorderBottom).innerWidth() / 100) * root.width();
            tnHelp.width(tnBottomWidth - 2 * tnHelpBorder - 2 * tnHelpPadding);

            tnSave = $(document.createElement('button'));
            tnSave.text("Save Thumbnail").css('border-radius', '3.5px');
            tnSave.css({
                position: 'relative',
                'top': '8%',
                'float': 'right'
            });
            tnSave.on("click", save);

            tnBorderBottom.append(tnHelp);
            tnBorderBottom.append(tnSave);
            tnBorderWrapper.append(tnBorderTop);
            tnBorderWrapper.append(tnBorderLeft);
            tnBorderWrapper.append(tnBorderCenter);
            tnBorderWrapper.append(tnBorderBottom);
            tnBorderWrapper.append(tnBorderRight);
            mainPanel.append(tnBorderWrapper);
        }

        /**
         * Toggle the thumbnail editor in and out.
         * @method toggle
         */
        function toggle() {
            isOpen ? close() : open();
            //if (isOpen) {
            //    tnBorderWrapper.fadeOut();
            //} else {
            //    closeAllPanels();
            //    open();
            //}
            //if (locPanelOpen) {
            //    $('.locationPanelDiv').hide("slide", { direction: 'left' }, 500, function () {
            //        $('.sidebarHideButtonContainer').show();
            //    });
            //    locPanelOpen = false;
            //}
            //if ($(tnBorderWrapper)[0] === undefined) {
            //    makethumbnailPicker();
            //    $(tnBorderWrapper).fadeToggle(200);
            //} else {
            //    $(tnBorderWrapper).fadeToggle(200);
            //}
        }

        /**
         * Opens the thumbnail editor and closes any open panels.
         * @method open
         */
        function open() {
            if (!isOpen) {
                closeAllPanels();
                tnBorderWrapper.fadeIn();
                editThumbnailButton.css({
                    'background-color': 'white',
                    'color': 'black'
                });
                rightArrowEditThumb.attr('src', tagPath+'images/icons/RightB.png');
                isOpen = true;
            }
        }

        /**
         * Closes the thumbnail editor.
         * @method close
         */
        function close() {
            if (isOpen) {
                tnBorderWrapper.fadeOut();
                editThumbnailButton.css({
                    'background-color': 'transparent',
                    'color': 'white'
                });
                rightArrowEditThumb.attr('src', tagPath+'images/icons/Right.png');
                isOpen = false;
            }
        }

        /**
         * Saves the current thumbnail selection.
         * @method save
         */
        function save() {
            //progress circle
            var progressCircleCSS = {
                'position': 'absolute',
                'top': '110%',
                'left': '100%',
                'z-index': '50',
                'height': 'auto',
                'width': '40px'
            };
            var progressCircle = TAG.Util.showProgressCircle($('.tnHelp'), progressCircleCSS, '0px', '0px', false);

            var canvas = $("canvas"),
                ctx = canvas[0].getContext("2d"),
                tnBorderCenter = $('.tnBorderCenter'),
                x = tnBorderCenter.offset().left, // get position of thumbnail frame
                y = tnBorderCenter.offset().top,
                width = tnBorderCenter.outerWidth(),
                height = tnBorderCenter.outerHeight(),
                imgdata = ctx.getImageData(x, y, width, height), // gets imagedata from position of thumbnail frame
                tmpCanvas = document.createElement("canvas"),
                tmpCtx,
                dataurl;

            tnSave.attr('disabled', 'true');

            tmpCanvas.width = imgdata.width; // set width of canvas like this (using CSS will stretch contents)
            tmpCanvas.height = imgdata.height;

            tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.putImageData(imgdata, 0, 0);

            dataurl = tmpCanvas.toDataURL(); // gets dataurl from tmpcanvas, ready to send to server!

            TAG.Worktop.Database.uploadImage(dataurl, function (imageURL) {
                TAG.Worktop.Database.changeArtwork(artwork.Identifier, { Thumbnail: imageURL }, thumbnailSuccess, thumbnailUnauth, conflict);
            }, thumbnailUnauth, thumbnailError);

            // success handler for saving
            function thumbnailSuccess() {
                TAG.Util.removeProgressCircle(progressCircle);
                tnSave[0].removeAttribute('disabled');
                close();
            }

            // unauthorized handler
            function thumbnailUnauth() {
                TAG.Util.removeProgressCircle(progressCircle);
                var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  You must log in to save changes.");
                $('body').append(popup);
                $(popup).show();
                tnSave[0].removeAttribute('disabled');
            }

            // general error handler
            function thumbnailError() {
                TAG.Util.removeProgressCircle(progressCircle);
                var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  There was an error contacting the server.");
                $('body').append(popup);
                $(popup).show();
                tnSave[0].removeAttribute('disabled');
            }
        }

        return {
            init: init,
            toggle: toggle,
            close: close,
            open: open,
            save: save
        };
    }

    /**
     * Rich location history API. Location history code can make everything else messy and dense, so we'll cordon it off here.
     * @method RichLocationHistory
     * @return {Object}         an object with "public" location history methods
     */
    function RichLocationHistory() {
        var isOpen = false,
            RLH,
            locationPanelDiv;

        function init() {
            RLH = TAG.Util.RLH({
                artwork: artwork,
                root: root,
                authoring: true
            });
            locationPanelDiv = RLH.init();
        }

        function open() {
            if (!isOpen) {
                closeAllPanels();
                MEDIA_EDITOR.close();
                editLocButton.css({ 'background-color': 'white', 'color': 'black' }).css('border-radius', '3.5px');
                rightArrowEditLoc.attr('src', tagPath+'images/icons/RightB.png');
                sidebarHideButtonContainer.hide();
                locationPanelDiv.show("slide", { direction: 'left' }, 500);
                locationPanelDiv.css({ display: 'inline' });
                
                isOpen = true;
            }
        }

        function close() {
            if (isOpen) {
                editLocButton.css({ 'background-color': 'transparent', 'color': 'white' }).css('border-radius', '3.5px');
                rightArrowEditLoc.attr('src', tagPath+'images/icons/Right.png');
                locationPanelDiv.hide("slide", { direction: 'left' }, 500, function () {
                    if (!METADATA_EDITOR.isOpen()) {
                        sidebarHideButtonContainer.show();
                    }
                });
                
                isOpen = false;
            }
        }

        function toggle() {
            isOpen ? close() : open();
        }

        function returnIsOpen() {
            return isOpen;
        }

        return {
            init: init,
            open: open,
            close: close,
            toggle: toggle,
            isOpen: returnIsOpen
        };
    }

    /**
     * Media editing panel. Contains methods for initializing, opening, and closing the panel, as well as
     * methods for saving and deleting media.
     * @method AssocMediaEditor
     * @return {Object}       an object with "public" associated media editing methods
     */
    function AssocMediaEditor() {
        var isOpen = false,
            editingMedia = false,
            hotspotAnchor,
            layerContainer,
            currSource,
            toggleHotspotButton = $('.toggleHotspot'),
            toggleLayerButton = $('.toggleLayer'),
            activeAssocMedia, // TODO in web app, this should be current assoc media object (of the type created by AnnotatedImage)
            isHotspot = false, // whether the current media is a hotspot
            isLayer = false,
            oldTitle, //title text when the editor is opened
            oldDescription, // description text when the editor is opened
            positionChanged = false; // whether the hotspot is added, moved, or deleted
        toggleHotspotButton.css('border-radius','3.5px');
        toggleLayerButton.css('border-radius','3.5px');
        /**
         * Initialize a reusible hotspot circle div and store it in the variable hotspotAnchor
         * @method makeHotspotAnchor
         */
        function makeHotspotAnchor() {
            var hotspotCircle = $(document.createElement('div')),
                innerCircle = $(document.createElement('div')),
                hotspotHint = $(document.createElement('div')),
                clickableArea = $(document.createElement('div'));

            hotspotAnchor = $(document.createElement('div')).css({ // TODO JADE/STYL
                'position': 'absolute',
                'display': 'none'
            }).addClass('hotspotedit');

            hotspotCircle.css({ // TODO JADE/STYL -- should use same stylus as hotspot circles in kiosk mode
                'position': 'absolute',
                'display': 'block',
                'width': '40px',
                'height': '40px',
                'border': 'solid rgba(255,255,255,1) 5px',
                'border-radius': '50%',
                'top': '-50px',
                'left': '-50px'
            })
            .attr('on', null)
            .appendTo(hotspotAnchor)
            .addClass('hotspotCircle');

            innerCircle.css({ // TODO JADE/STYL
                'display': 'block',
                'width': '30px',
                'height': '30px',
                'background': 'rgba(0,0,0,0.01)',
                'border': 'solid rgba(0,0,0,1) 5px',
                'border-radius': '50%'
            })
            .appendTo(hotspotCircle);

            clickableArea.css({ // TODO JADE/STYL
                'display': 'block',
                'width': '0px',
                'height': '0px',
                'background': 'rgba(0,0,0,0)',
                'border': 'solid rgba(0,0,0,0.1) 15px',
                'border-radius': '50%'
            })
            .appendTo(innerCircle);

            hotspotHint.text('Hotspot (drag to update)').css({ // TODO JADE/STYL
                'position': 'relative',
                'left': '-5px',
                'top': '-5px',
                'width': 'auto',
                'color': 'white',
                'font-weight': 'bold',
                'font-size': 'large',
                'padding': '8px',
                'background-color': 'rgba(0,0,0,.85)'
            }).appendTo(hotspotAnchor);

            TAG.Util.disableDrag(root);

            // detect whether the hotspot is moved
            hotspotCircle.get(0).addEventListener('mouseup', function () {
                //Enable save nutton
                $(".addbutton").prop('disabled', false);
                $(".addbutton").css('opacity', '1');
                positionChanged = true;
            }, false);

            // TODO use makeManipulatable here for web app (and for win8 app... some dragging issues right now, though)
            if (IS_WINDOWS) {
                TAG.Util.makeManipulatableWin(hotspotCircle[0], {
                    onManipulate: function (res) {
                        var t = hotspotAnchor.css('top'),
                            l = hotspotAnchor.css('left');
                        hotspotAnchor.css("top", (parseInt(t, 10) + res.pivot.y - 20) + "px");
                        hotspotAnchor.css("left", (parseInt(l, 10) + res.pivot.x - 20) + "px");
                        annotatedImage.updateOverlay(hotspotAnchor[0], Seadragon.OverlayPlacement.TOP_LEFT);
                    }
                });
            } else {
                TAG.Util.makeManipulatable(hotspotCircle[0], {
                    onManipulate: function (res) {
                        var t = hotspotAnchor.css('top'),
                            l = hotspotAnchor.css('left');
                        hotspotAnchor.css("top", (parseInt(t, 10) + res.pivot.y - 20) + "px");
                        hotspotAnchor.css("left", (parseInt(l, 10) + res.pivot.x - 20) + "px");
                        annotatedImage.updateOverlay(hotspotAnchor[0], Seadragon.OverlayPlacement.TOP_LEFT);
                    }
                });
            }
            

            hotspotAnchor.appendTo(root);
        }

        /**
         * Adds hotspot circle to canvas and pans to circle's location
         * @method toggleToHotspot
         * @param {Seadragon.Point} point       the point at which to add the hotspot circle (defaults to center of canvas)
         */
        function toggleToHotspot(point) {
            point = point || annotatedImage.viewer.viewport.getCenter();

            var pixel = annotatedImage.viewer.viewport.pixelFromPoint(point),
                pixel_adj = new Seadragon.Point(pixel.x + 50, pixel.y + 50),
                point_adj = annotatedImage.viewer.viewport.pointFromPixel(pixel_adj);

            isLayer && toggleFromLayer();

            toggleHotspotButton.text('Remove Hotspot');
            toggleLayerButton.attr('disabled', 'disabled');
            toggleLayerButton.css('opacity', '0.5');

            annotatedImage.addOverlay(hotspotAnchor[0], point_adj, Seadragon.OverlayPlacement.TOP_LEFT); // TODO see new AnnotatedImage; also, do we really want to be adding a new overlay each time? we only have one hotspot circle, so maybe just want to update the existing overlay
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(point.x, point.y), false);
            hotspotAnchor.fadeIn(100);
            isHotspot = true;
        }

        /**
         * Removes hotspot from canvas
         * @method toggleFromHotspot
         */
        function toggleFromHotspot() {
            toggleHotspotButton.text('Set as Hotspot');
            toggleLayerButton.removeAttr('disabled');
            toggleHotspotButton.on("mousedown", function () {
                toggleHotspotButton.css({ "background-color": "white", "color": "black" });
            });
            toggleHotspotButton.on("mouseleave", function () {
                toggleHotspotButton.css({ "background-color": "transparent", "color": "white" });
            });
            toggleLayerButton.css('opacity', '1.0');

            annotatedImage.removeOverlay(hotspotAnchor[0]); // TODO check
            hotspotAnchor.fadeOut(100);
            isHotspot = false;
        }

        /**
         * Returns a Seadragon.Rect bounding the artwork layer on screen
         * @method getLayerRect
         * @return {Seadragon.Rect}         the Seadragon.Rect
         */
        function getLayerRect() {
            var offset = layerContainer.offset(),
                width = layerContainer.width(),
                height = layerContainer.height(),
                topLeft = annotatedImage.viewer.viewport.pointFromPixel(new Seadragon.Point(offset.left, offset.top)),
                bottomRight = annotatedImage.viewer.viewport.pointFromPixel(new Seadragon.Point(offset.left + width, offset.top + height));
            console.log("width" + width);
            console.log("height" + height);
            return new Seadragon.Rect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        }

        /**
         * Initialize a reusable layer container and store it in the variable layerContainer
         * @method makeLayerContainer
         */
        function makeLayerContainer() {
            layerContainer = $(document.createElement('img'))
                                .attr({
                                    src: currSource
                                })
                                .addClass('layerContainer')
                                .appendTo(root);

            // add manipulation handlers
            LADS.Util.makeManipulatable(layerContainer[0], {
                onManipulate: function (res) {
                    var l = layerContainer.offset().left, // TODO might need to update this for web app
                        t = layerContainer.offset().top,
                        tx = res.translation.x,
                        ty = res.translation.y;

                    layerContainer.css({
                        left: (l + tx) + 'px',
                        top: (t + ty) + 'px'
                    });

                    annotatedImage.viewer.drawer.updateOverlay(layerContainer[0], getLayerRect());
                },
                onScroll: function (res, pivot) {
                    var l = layerContainer.offset().left, // TODO might need to update this for web app
                        t = layerContainer.offset().top,
                        w = layerContainer.width(),
                        h = layerContainer.height(),
                        newW = w * res,
                        newH = h * res;

                    annotatedImage.viewer.drawer.removeOverlay(layerContainer[0]); // remove and re-add to ensure correct positioning if we move artwork
                    root.append(layerContainer);

                    layerContainer.css({
                        left: (l + (1 - res) * (pivot.x)) + 'px',
                        top: (t + (1 - res) * (pivot.y)) + 'px',
                        width: newW + 'px',
                        height: newH + 'px',
                        position: 'absolute'
                    });

                    annotatedImage.viewer.drawer.addOverlay(layerContainer[0], getLayerRect());
                }
            }, false, true);

            //layerContainer.on('mousedown', function () {
            //    var l = layerContainer.offset().left, // TODO might need to update this for web app
            //        t = layerContainer.offset().top,
            //        w = layerContainer.width(),
            //        h = layerContainer.height();

            //    annotatedImage.viewer.drawer.removeOverlay(layerContainer[0]); // remove to ensure correct positioning if artwork is in midst of a move
            //    root.append(layerContainer);
            //    layerContainer.css({
            //        left: l + 'px',
            //        top: t + 'px',
            //        width: w + 'px',
            //        height: h + 'px',
            //        position: 'absolute'
            //    });
            //});

           
            /**
            layerContainer.hover(function () {
                console.log("freezing");
                annotatedImage.freezeArtwork();
            }, function () {
                console.log("unfreezing");
                annotatedImage.unfreezeArtwork();
            });
            **/

            //Not sure why this is the combo of handlers that works, probably should refine at some point 
            layerContainer.on("mousedown", function () {
                annotatedImage.freezeArtwork();
            });
            //Mouse up doesn't seem to work...added on click
            layerContainer.on("mouseup", function () {
                positionChanged = true;
                annotatedImage.unfreezeArtwork();
                annotatedImage.viewer.drawer.updateOverlay(layerContainer[0], getLayerRect());
            });
            layerContainer.on("click", function () {
                positionChanged = true;
                annotatedImage.unfreezeArtwork();
                annotatedImage.viewer.drawer.updateOverlay(layerContainer[0], getLayerRect());
            });
        }

        /**
         * Makes layerContainer visible at the specified location
         * @method toggleToLayer
         * @param {Seadragon.Rect} rect      the rect on the artwork on which we'll add the layer container (see Seadragon.Drawer docs)
         */
        function toggleToLayer(rect) {
            var i,
                oldLayerContainers = $('.layerContainer');

            isHotspot && toggleFromHotspot();

            isLayer = true;

            makeLayerContainer();

            toggleLayerButton.text('Remove Layer');
            //toggleHotspotButton.attr('disabled', 'disabled'); TODO REMOVE WHEN LAYERS COME BACK
            //toggleHotspotButton.css('opacity', '0.5');

            if (oldLayerContainers.length > 0) {   // clicking on a thumbnail button really quickly would add a bunch of layerContainers...but
                for (i = 0; i < oldLayerContainers.length; i++) { // a cleaner way to avoid that would be to just disable the thumbnail button when its media is already open
                    annotatedImage.viewer.drawer.removeOverlay(oldLayerContainers[i]);
                    $(oldLayerContainers[i]).remove();
                }
            }

            layerContainer.css({
                'border': '2px solid red',
                'display': 'block',
                'opacity': '0.5',
                'position': 'absolute'
            }).appendTo(root);

            if (!rect) {
                layerContainer.css({
                    'left': '30%',
                    'top': '20%',
                    'width': '40%',
                    'height': 'auto'
                });
                rect = getLayerRect();
            }

            annotatedImage.viewer.drawer.addOverlay(layerContainer[0], rect);
        }

        /**
         * Removes layer image from canvas and updates some button text/attributes
         * @method toggleFromLayer
         */
        function toggleFromLayer() {
            isLayer = false;
            toggleLayerButton.text('Set as Layer');
            toggleHotspotButton.removeAttr('disabled');
            toggleHotspotButton.css('opacity', '1.0');
           
            toggleLayerButton.on("mousedown", function () {
                toggleLayerButton.css({ "background-color": "white", "color": "black" });
            });
            toggleLayerButton.on("mouseleave", function () {
                toggleLayerButton.css({ "background-color": "transparent", "color": "white" });
            });
            if (layerContainer) {
                annotatedImage.viewer.drawer.removeOverlay(layerContainer[0]);
                layerContainer.remove();
                layerContainer.css('display', 'none');
            }
        }

        /** TODO GET RID OF THIS IN WEB APP (just use current assoc media object)
         * Set a metadata value for the active media content.
         * @param key
         * @param val
         */
        function setActiveMediaMetadata(key, val) {
            var $media = $('.rightbar').find('.assocmedia').children();
            ($media.length) ? $media.data(key, val) : textMetadata[key] = val;
        }

        /** TODO GET RID OF THIS IN WEB APP (just use current assoc media object)
         * Get metadata values for the active media content.
         * @param key (optional)   the key to retrieve. If key is not given, retrieve 
         *     the entire values object. 
         */
        function getActiveMediaMetadata(key) {
            var $media = $('.rightbar').find('.assocmedia').children();
            if (!key) {
                return false;
            }
            else {
                return $media.data(key) || textMetadata[key];
            }
        }

        // Fix volume far for video/audio
        function fixVolumeBar(holder) {
            var media = holder[0];
            var lastVolume = media.volume;
            var muted = false;
            media.addEventListener('volumechange', function () {
                if (media.muted) {
                    media.volume = 0;
                    muted = true;
                }
                else {
                    if (muted) {
                        media.volume = lastVolume;
                        muted = false;
                    }
                    lastVolume = media.volume;
                }
            }, false);
        }

        /** 
         * Create a view in the editing pane for the specified media
         * @method createMediaWrapper
         * @param {Object} media    the assoc media object we want to "wrap"
         * @return {jQuery obj}     a jQuery element wrapping a view into the content
         */
        function createMediaWrapper(media) {
            var video,
                audio,
                iframe,
                src = media.doq.Metadata.Source,
                type = media.doq.Metadata.ContentType,
                thumbnail = (media.doq.Metadata.Thumbnail && !media.doq.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(media.doq.Metadata.Thumbnail) : '',
                src_webm,
                src_ogg,
                src_mp4,
                src_mp3,
                errText,
                msgdiv,
                fixedSrc = TAG.Worktop.Database.fixPath(src);

            if (type === 'Image') {
                return $(document.createElement('div'))
                    .css({
                        'width': '100%',
                        'height': '100%',
                        'background-image': 'url(' + fixedSrc + ')',
                        'background-repeat': 'no-repeat',
                        'background-position': 'center center',
                        'background-size': 'contain',
                        'border': '0'
                    });
            } else if (type === 'Video') {
                video = $(document.createElement('video'));
                fixVolumeBar(video);
                video[0].onerror = function (err) { // TODO put this error handler in the Util file -- could be useful elsewhere
                    var msg = "";
                    switch (err.target.error.code) {
                        case err.target.error.MEDIA_ERR_ABORTED:
                            msg = "Video playback aborted. Please see FAQs on the TAG website.";
                            break;
                        case err.target.error.MEDIA_ERR_NETWORK:
                            msg = "Network error during video upload. Please see FAQs on the TAG website.";
                            break;
                        case err.target.error.MEDIA_ERR_DECODE:
                            msg = "Error decoding video. Please see FAQs on the TAG website.";
                            break;
                        case err.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            msg = "Either the video format is not supported or a network or server error occurred. Please see FAQs on the TAG website.";
                            break;
                        default:
                            msg = "Error: please see FAQs on the TAG website.";
                            break;
                    }

                    msgdiv = $(document.createElement('div'));
                    msgdiv.css({
                        'width': '80%',
                        'margin-left': '10%',
                        'margin-top': '50%',
                        'color': 'white',
                        'text-align': 'center'
                    });
                    msgdiv.text(msg);

                    video.hide();
                    video.parent().append(msgdiv);
                    video[0].onerror = function (err) { }; // neglect any further errors
                };
                video.attr({
                    'preload': 'none',
                    'poster': thumbnail,
                    'controls': 'controls'
                });

                src_mp4 = document.createElement('source');
                src_mp4.src = fixedSrc;
                src_mp4.type = "video/mp4";

                src_webm = document.createElement('source');
                src_webm.src = fixedSrc;
                src_webm.type = "video/webm";

                src_ogg = document.createElement('source');
                src_ogg.src = fixedSrc;
                src_ogg.type = "video/ogg";

                video.append(src_mp4);
                video.append(src_webm);
                video.append(src_ogg);
                video[0].innerHTML += "Your browser does not support this video."; // fallback text

                video.css({ // TODO could be done in STYL even though video probably shouldn't be created in JADE
                    color: "white",
                    position: 'relative',
                    width: '100%',
                    height: '100%'
                });
                return video;
            } else if (type === 'Audio') {
                audio = $(document.createElement('audio'));
                fixVolumeBar(audio);
                
                audio.attr({
                    'preload': 'none',
                    'controls': 'controls'
                });

                src_mp3 = document.createElement('source');
                src_mp3.src = fixedSrc;
                src_mp3.type = "audio/mp3";

                src_ogg = document.createElement('source');
                src_ogg.src = fixedSrc;
                src_ogg.type = "audio/ogg";

                audio.append(src_mp3);
                audio.append(src_ogg);

                audio.css({ // TODO see video comment above
                    position: 'absolute',
                    width: '100%',
                    bottom: '0%'
                });
                return audio;
            } else if (type === 'iframe') {
                iframe = $(document.createElement('iframe'));
                iframe.attr({
                    src: src + "?modestbranding=1&showinfo=0&fs=0",
                    frameborder: '0'
                });
                iframe.css({
                    width: '100%',
                    height: '100%'
                });
                return iframe;
            }
        }

         /**
        * Saves the current settings for the opened associate media
        * @method saveAssocMedia
        */
        function saveAssocMedia() {
            var titleTextVal,
                descriptionTextVal,
                assetType;
            $('.assetHolder').css('background-color', '');

            if (getActiveMediaMetadata('ContentType') === 'Video') { // TODO see comments in the delete button's click handler
              //  $('.rightbar').find('video')[0].pause();
            } else if (getActiveMediaMetadata('ContentType') === 'Audio') { // TODO see comments in the delete button's click handler
              //  $('.rightbar').find('audio')[0].pause();
            }

            titleTextVal = $('.title').val() || 'Untitled';
            descriptionTextVal = $('.description').val() || 'Untitled';
            oldTitle = oldTitle || 'Untitled';
            oldDescription = oldDescription || 'Untitled';


            assetType = isHotspot ? 'Hotspot' : (isLayer ? 'Layer' : 'Asset');

            if (titleTextVal != oldTitle || descriptionTextVal != oldDescription || positionChanged) {
                console.log(titleTextVal + " " + oldTitle + " " + descriptionTextVal + " " + oldDescription + " " + positionChanged);
                updateAssocMedia({
                    title: TAG.Util.htmlEntityEncode(titleTextVal),
                    desc: TAG.Util.htmlEntityEncode($('.description').val()),
                    pos: isHotspot ? Seadragon.Utils.getElementPosition(hotspotAnchor.children().first().get(0)) : null, // TODO should store this html elt in a variable (in the function that makes the hotspot anchor) so people don't have to figure out what this means
                    rect: isLayer ? getLayerRect() : null,
                    contentType: activeAssocMedia.doq.Metadata.ContentType,
                    contentUrl: TAG.Worktop.Database.fixPath(activeAssocMedia.doq.Metadata.Source),
                    assetType: assetType,
                    metadata: {
                        assetDoqID: activeAssocMedia.doq.Identifier
                    }
                });
            }
        }

        /**
         * Wrapper around TAG.Worktop.Database.changeHotspot to update assoc media after
         * editing in the right pane.
         * @method updateAssocMedia
         * @param {Object} info        assoc media info to update
         */
        function updateAssocMedia(info) { // TODO use new AnnotatedImage; also, could eliminate need for param here by using 'global' current assoc media object (same with showEditMedia above, actually)
            var title = info.title,
                desc = info.desc,
                contentType = info.contentType,
                contentUrl = info.contentUrl,
                duration = info.duration,
                assetType = info.assetType,
                worktopInfo = info.metadata || {},
                //dzPos = info.pos ? annotatedImage.viewer.viewport.pointFromPixel(info.pos) : { x: 0, y: 0 },
                coords,
                rightbarLoadingSave,
                thumbnailLoadingSave,
                options;

            if (info.pos) {
                coords = annotatedImage.viewer.viewport.pointFromPixel(info.pos);
                coords.width = 0;
                coords.height = 0;
            } else if (info.rect) {
                coords = info.rect
            } else {
                coords = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            }
            
            rightbarLoadingSave = $(document.createElement('div'));
            rightbarLoadingSave.css({
                'width': '20%',
                'height': '100%',
                'position': 'absolute',
                'background-color': 'rgba(0,0,0,.85)',
                'top': $('.topbar').css('height'),
                'right': '0%',
                'z-index': 100
            });
            mainPanel.append(rightbarLoadingSave);


            TAG.Util.showLoading(rightbarLoadingSave, '20%', '40%', '40%');
            rightbarLoadingSave.attr('class', 'rightbarLoadingSave');
            

            // add loading overlay to the thumbnail of the associate media which has been modified
            var top = 
            $(document.getElementById(worktopInfo.assetDoqID)).height();
            thumbnailLoadingSave = $(document.createElement('div'));
            thumbnailLoadingSave.css({
                'width': '100%',
                'height': '100%',
                'position': 'relative',
                'background-color': 'rgba(0,0,0,.85)',
                'top': '-' + top -4 + 'px',
                'z-index': 100
            });
            $('#' + worktopInfo.assetDoqID).append(thumbnailLoadingSave);
        
            TAG.Util.showLoading(thumbnailLoadingSave, '20%', '40%', '40%');
            thumbnailLoadingSave.attr('class', 'thumbnailLoadingSave');

            options = {
                Name: title,
                ContentType: contentType,
                Duration: duration,
                LinqTo: artwork.Identifier,
                X: coords.x,
                Y: coords.y,
                W: coords.width,
                H: coords.height,
                LinqType: assetType,
                Description: desc
            };
            if (contentType !== "iframe") {
                options.Source = contentUrl;
            }

            TAG.Worktop.Database.changeHotspot(worktopInfo.assetDoqID, options, updateSuccess, no_op, conflict, no_op);

            /**
             * Success callback for call to changeHotspot in updateAssocMedia;
             * reloads media list and hides editing pane
             * @method updateSuccess
             */
            function updateSuccess() {
                /*
                close();
                createMediaList();*/
                rightbarLoadingSave.fadeOut();
                
                reloadAssocMedia(worktopInfo.assetDoqID);
                thumbnailLoadingSave.fadeOut();
            }

            function no_op() { // TODO I think TAG.Worktop.Database functions can just accept null callbacks, since they use the safeCall util function. if so, use null

            }
        }

        /**
         * Initializes UI for associated media editor.
         * @method init
         */
        function init() {
            var $rightbar = $(document.createElement('div')) // move all of these to JADE/STYL
                    .addClass("rightbar")
                    .css({
                        'width': '20%',
                        'height': '100%',
                        'position': 'absolute',
                        'background-color': 'rgba(0,0,0,0.85)',
                        'top': $('.topbar').css('height'),
                        'right': '-20%',
                        'float': 'right',
                        'z-index': 100,
                        'color': 'white'
                    }),
                rightbarHeader = $(document.createElement('div'))
                    .css({
                        'margin': '5% 8%',
                        'color': 'white',
                        'font-size': '100%',
                        'float': 'left',
                        'position': 'relative',
                    })
                    .addClass('header')
                    .text('Edit Associated Media')
                    .appendTo($rightbar),
                $assocMediaContainer = $(document.createElement('div'))
                    .css({
                        'position': 'relative',
                        'margin': '10% 8%', 
                        'margin-top': '20%',
                        'border': '2px solid white',
                        'width': '86%',
                        'height': '30%'
                    })
                    .addClass('assocMediaContainer')
                    .appendTo($rightbar),
                $assocMediaContent = $(document.createElement('div'))
                    .addClass('assocmedia')
                    .addClass('contentwrapper')
                    .css({
                        'background-color': 'rgba(0,0,0,.9)',
                        'height': '100%',
                        'width': '100%',
                        'left': '0',
                        'position': 'absolute'
                    })
                    .appendTo($assocMediaContainer),
                $toggleModeContainer = $(document.createElement('div'))
                    .addClass('toggleModeContainer')
                    .css({
                        'width': '87%',
                        'left': '8%',
                        'position': 'relative',
                        'height': 'auto', 
                        'max-height': '10%'
                    })
                    .appendTo($rightbar),
                $toggleHotspot = $(document.createElement('button'))
                    .addClass('toggleHotspot')
                    .css({ // css for this and toggleLayer should be defined as a class rule
                        'width': '100%',
                        'height': 'auto',
                        'max-height': '45%', 
                        'border': '2px solid white',
                        'position': 'relative',
                        'font-size': $('.addRemoveMedia').css('font-size')
                    }).css('border-radius','3.5px')
                    .attr('type', 'button')
                    .appendTo($toggleModeContainer),
                $toggleLayer = $(document.createElement('button'))
                    .addClass('toggleLayer').css('border-radius','3.5px')
                    .css({
                        'width': '100%',
                        'height': 'auto',
                        'max-height': '45%', 
                        'margin-top': '5%', 
                        'border': '2px solid white',
                        'position': 'relative',
                        'font-size': $('.addRemoveMedia').css('font-size')
                    })
                    .attr('type', 'button'),
                    //.appendTo($toggleModeContainer), //TODO Add layer functionality back in for 2.2
                $titleContainer = $(document.createElement('div'))
                    .addClass('textareaContainer')
                    .css({
                        'width': '87%',
                        'left': '8%',
                        'position': 'relative',
                        'height': 'auto', 
                        'max-height': '10%',
                        'margin-top': '5%',
                    })
                    .appendTo($rightbar),
                $titleText = $(document.createElement('input'))
                    .addClass('title')
                    .attr('placeholder', ' Title')
                    .attr('title', 'Title')
                    .css({
                        'width': '100%',
                        '-webkit-box-sizing': 'border-box', /* Safari/Chrome, other WebKit */
                        '-moz-box-sizing': 'border-box',    /* Firefox, other Gecko */
                        'box-sizing': 'border-box',        /* Opera/IE 8+ */
                        'font-size': '0.7em'
                    })
                    .appendTo($titleContainer),
                $descContainer = $(document.createElement('div'))
                    .addClass('textareaContainer')
                    .css({
                        'width': '87%',
                        'left': '8%',
                        'position': 'relative',
                        'height': '16%', 
                        'margin-top': '5%',
                    })
                    .appendTo($rightbar),
                $descArea = $(document.createElement('textarea'))
                    .addClass('description')
                    .attr('placeholder', ' Description')
                    .css({
                        'background-color': 'white',
                        'width': '100%',
                        'min-width': '100%',
                        'height': '90%',
                        '-webkit-box-sizing': 'border-box', /* Safari/Chrome, other WebKit */
                        '-moz-box-sizing': 'border-box',    /* Firefox, other Gecko */
                        'box-sizing': 'border-box',        /* Opera/IE 8+ */
                        'font-size': '0.7em',
                        'padding-right': '8px'
                    })
                    .appendTo($descContainer),
                $assocMediaButtonContainer = $(document.createElement('div'))
                    .addClass('buttoncontainer')
                    .css({
                        'width': '87%',
                        'padding': '5% 8%',
                        'position': 'relative',
                        'height': '5%',
                        'display': 'block'
                    })
                    .appendTo($rightbar),
                $unassociateAssocMediaButton = $(document.createElement('button'))
                    .addClass('asscmediabutton unassociatebutton').css('border-radius','3.5px')
                    .text('Unassociate')
                    .css({
                        'float': 'left',
                        'border': '2px solid white',
                        'max-width': '43%',
                        'width': '43%',
                        'display': 'inline-block',
                        'text-align': 'center',
                        'padding': '4px 4px 4px 4px',
                        'font-size': $('.addRemoveMedia').css('font-size'),
                    })
                    .attr('type', 'button')
                    .appendTo($assocMediaButtonContainer),
                $saveAssocMediaButton = $(document.createElement('button')).css('border-radius', '3.5px')
                    .addClass('asscmediabutton addbutton')
                    .text('Save')
                    .attr('type', 'button')
                    .css({
                        'float': 'right',
                        'border': '2px solid white',
                        'max-width': '43%',
                        'width': '43%',
                        'display': 'inline-block',
                        'text-align': 'center',
                        'padding': '4px 4px 4px 4px',
                        'font-size': $('.addRemoveMedia').css('font-size'),
                    })
                    .appendTo($assocMediaButtonContainer),
                closeButton = $(document.createElement('img')).addClass('closeEditAssocMedia')
                    .attr('src', tagPath + 'images/icons/x.svg')
                    .css({
                        'position': 'absolute',
                        'top': '85%',
                        //'top': ($(window).height() - ($(window).height() * topbarHeight / 100)) * 0.95 - 15 + 'px',
                        'left': '8%',
                        'width': '11%',
                        'height': '5%',//
                    })
                    .appendTo($rightbar);
            /*$descArea.on('keyup', function () {
                var txt = ($descArea && $descArea[0] && $descArea[0].value) ? $descArea[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if ($descArea && $descArea[0] && $descArea[0].value && $descArea[0].value!=txt) {
                    $descArea[0].value = txt;
                }
            });
            $titleText.on('keyup', function () {
                var txt = ($titleText && $titleText[0] && $titleText[0].value) ? $titleText[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if ($titleText && $titleText[0] && $titleText[0].value && $titleText[0].value!=txt) {
                    $titleText[0].value = txt;
                }
            });*/
            $saveAssocMediaButton.on("mousedown", function () {
                $saveAssocMediaButton.css({ "background-color": "white", "color": "black" });

            });
            $unassociateAssocMediaButton.on("mousedown", function () {
                $unassociateAssocMediaButton.css({ "background-color": "white", "color": "black" });

            });
            $saveAssocMediaButton.on("mouseleave", function () {
                $saveAssocMediaButton.css({ "background-color": "transparent", "color": "white" });
            });
            $unassociateAssocMediaButton.on("mouseleave", function () {
                $unassociateAssocMediaButton.css({ "background-color": "transparent", "color": "white" });
            });

            $unassociateAssocMediaButton.on("mouseup", function () {
                $unassociateAssocMediaButton.css({ "background-color": "transparent", "color": "white" });
            });

            //Initially disable the save button
            $saveAssocMediaButton.prop('disabled', true);
            $saveAssocMediaButton.css('opacity', '0.4');

            $titleText.on('keyup', function () {
                $saveAssocMediaButton.prop('disabled', false);
                $saveAssocMediaButton.css('opacity', '1');
            });

            $descArea.on('keyup', function () {
                $saveAssocMediaButton.prop('disabled', false);
                $saveAssocMediaButton.css('opacity', '1');
            });

            $toggleHotspot.on('click', function () {
                $saveAssocMediaButton.prop('disabled', false);
                $saveAssocMediaButton.css('opacity', '1');
            });

            $toggleLayer.on('click', function () {
                $saveAssocMediaButton.prop('disabled', false);
                $saveAssocMediaButton.css('opacity', '1');
            });

            makeHotspotAnchor();
            // makeLayerContainer(); -- called in toggleToLayer now

            $toggleHotspot.on('click', function () {
                positionChanged = true;
                isHotspot ? toggleFromHotspot() : toggleToHotspot();
            });

            $toggleLayer.on('click', function () {
                isLayer ? toggleFromLayer() : toggleToLayer();
            });

            toggleHotspotButton = $toggleHotspot; // get rid of these intermediate variables...
            toggleLayerButton = $toggleLayer;

            $unassociateAssocMediaButton.on('click', function () {
                TAG.Util.removeYoutubeVideo();
                var assetDoqID = getActiveMediaMetadata('assetDoqID'); // TODO see comment below about AnnotatedImage
                $saveAssocMediaButton.attr('disabled', true).css('color', 'rgba(255,255,255,0.5)');
                if (getActiveMediaMetadata('contentType') === 'Video') { // TODO when this file is better integrated with the new AnnotatedImage, should store the current active media in a 'global' variable and just access its contentType rather than going through a helper function
                    $('.rightbar').find('video')[0].pause();
                } else if (getActiveMediaMetadata('contentType') === 'Audio') {
                    $('.rightbar').find('audio')[0].pause();
                }


                var thumbnailLoadingUnassoc;
                var top =
                $(document.getElementById(assetDoqID)).height();
                thumbnailLoadingUnassoc = $(document.createElement('div'));
                thumbnailLoadingUnassoc.css({
                    'width': '100%',
                    'height': '100%',
                    'position': 'relative',
                    'background-color': 'rgba(0,0,0,.85)',
                    'top': '-' + top - 4 + 'px',
                    'z-index': 100
                });
                $('#' + assetDoqID).append(thumbnailLoadingUnassoc);

                TAG.Util.showLoading(thumbnailLoadingUnassoc, '20%', '40%', '40%');
                thumbnailLoadingUnassoc.attr('class', 'thumbnailLoadingUnassoc');


                var rightbarLoadingDelete = $(document.createElement('div'));
                rightbarLoadingDelete.css({ // TODO STYL
                    'width': '20%',
                    'height': '100%',
                    'position': 'absolute',
                    'background-color': 'rgba(0,0,0,.85)',
                    'top': $('.topbar').css('height'),
                    'right': '0%',
                    'z-index': 100
                });
                mainPanel.append(rightbarLoadingDelete);
                TAG.Util.showLoading(rightbarLoadingDelete, '20%', '40%', '40%');
                $unassociateAssocMediaButton.attr('disabled', true).css('color', 'rgba(255,255,255,0.5)');

                // remove the associated media's linq to this artwork
                if (assetDoqID) {
                    TAG.Worktop.Database.changeArtwork(artwork.Identifier, { RemoveIDs: assetDoqID }, function () {
                        close();
                        $('.assetContainer').empty();
                        createMediaList();
                        rightbarLoadingDelete.fadeOut();
                    }, function () {
                        console.log("error 1");
                    }, function () {
                        console.log("error 2");
                    }, function () {
                        console.log("error 3");
                    });
                } else {
                    close();
                    createMediaList();
                    rightbarLoadingDelete.fadeOut();
                }

            });

            $saveAssocMediaButton.on('click', function () {
                var titleTextVal,
                    assetType;

                //$('.assetHolder').css('background-color', '');

                if (getActiveMediaMetadata('ContentType') === 'Video') { // TODO see comments in the delete button's click handler
                    $('.rightbar').find('video')[0].pause();
                } else if (getActiveMediaMetadata('ContentType') === 'Audio') { // TODO see comments in the delete button's click handler
                    $('.rightbar').find('audio')[0].pause();
                }

                titleTextVal = $titleText.val() || 'Untitled';

                assetType = isHotspot ? 'Hotspot' : (isLayer ? 'Layer' : 'Asset');

                updateAssocMedia({
                    title: TAG.Util.htmlEntityEncode(titleTextVal),
                    desc: TAG.Util.htmlEntityEncode($descArea.val()),
                    pos: isHotspot ? Seadragon.Utils.getElementPosition(hotspotAnchor.children().first().get(0)) : null, // TODO should store this html elt in a variable (in the function that makes the hotspot anchor) so people don't have to figure out what this means
                    rect: isLayer ? getLayerRect() : null,
                    contentType: activeAssocMedia.doq.Metadata.ContentType,
                    contentUrl: TAG.Worktop.Database.fixPath(activeAssocMedia.doq.Metadata.Source),
                    assetType: assetType,
                    metadata: {
                        assetDoqID: activeAssocMedia.doq.Identifier
                    }
                });
            });

            closeButton.on('click', function () {
                if (getActiveMediaMetadata('contentType') === 'Video') { // TODO see comments above
                    $('.rightbar').find('video')[0].pause();
                } else if (getActiveMediaMetadata('contentType') === 'Audio') {
                    $('.rightbar').find('audio')[0].pause();
                }
                close();
            });

            mainPanel.append($rightbar);
        }

        /**
         * Opens the media editor with the specified media.
         * @method open
         * @param {Object} asset         the media to edit
         * @param {jQuery obj} content   a dom element suitable for displaying the content (could be the result
         *                                of a call to createMediaWrapper)
         * @param {Function} callback    a callback function to call after the editing pane has opened
         */
        function open(asset, content, callback) {
            //Initially disable the save button
            $(".addbutton").prop('disabled', true);
            $(".addbutton").css('opacity', '0.4');

            /*
            var editingMediamsg;

            if (editingMedia) {
                editingMediamsg = $(TAG.Util.UI.popUpMessage(null, "You are currently making changes. Please save or cancel before opening another media for editing.", "OK", false));
                root.append(editingMediamsg);
                editingMediamsg.show();
                return;
            }
            */
            if (isOpen) {
                //saveAssocMedia();
            }
            $(".asscmediabutton").attr('disabled', false).css('color', 'rgba(255,255,255,1)');
            editingMedia = false;

            TAG.Worktop.Database.getLinq(artwork.Identifier, asset.doq.Identifier, linqCallback, function () { }, function () { });

            /**
             * Helper function for showEditMedia, called when the linq between the
             * media and the artwork has been obtained
             * @method linqCallback
             * @param {linq} linq           a linq object (see github wiki for structure)
             */
            function linqCallback(linq) {
                var x = parseFloat(linq.Offset._x),
                    y = parseFloat(linq.Offset._y),
                    w = parseFloat(linq.Dimensions ? linq.Dimensions._x : 0), // some backwards compatibility checking
                    h = parseFloat(linq.Dimensions ? linq.Dimensions._y : 0),
                    title = TAG.Util.htmlEntityDecode(asset.doq.Name),
                    description = asset.doq.Metadata.Description ? TAG.Util.htmlEntityDecode(asset.doq.Metadata.Description).replace(/<br>/g, '\n') : '',
                    point,
                    enableLayering = asset.doq.Metadata.ContentType === 'Image' && linq.Dimensions,
                    rect,
                    key,
                    rightbar = $('.rightbar'); // TODO get this from JADE, store as a 'global' variable at top of file

                isHotspot = linq.Metadata.Type === "Hotspot";
                isLayer = linq.Metadata.Type === "Layer";

                oldTitle = title;
                oldDescription = description;
                positionChanged = false;

                if (enableLayering) {
                    currSource = LADS.Worktop.Database.fixPath(asset.doq.Metadata.Source);
                }

                $('.assocMediaContainer').show();

                if (isHotspot) {
                    point = new Seadragon.Point(x, y);
                } else if (isLayer) {
                    rect = new Seadragon.Rect(x, y, w, h);
                }

                toggleHotspotButton.text(isHotspot ? 'Remove Hotspot' : 'Create Hotspot');
                toggleLayerButton.text(isLayer ? 'Remove Layer' : 'Create Layer');

                isHotspot ? toggleToHotspot(point) : toggleFromHotspot();
                isLayer ? toggleToLayer(rect) : toggleFromLayer();

                // don't show the toggle layer button if we're dealing with audio/video or an older server
                toggleLayerButton.css({
                    'display': enableLayering ? 'inline-block' : 'none'
                });

                rightbar.find('.assocmedia').html(content);
                rightbar.find('.title').val(title);
                rightbar.find('.description').val(description);

                rightbar.find('.title').on('keyup', function () {
                    editingMedia = true;
                });

                rightbar.find('.description').on('keyup', function () {
                    editingMedia = true;
                });

                if (!isOpen) {
                    rightbar.animate({ 'right': 0 }, 600);
                }

                for (key in asset.doq.Metadata) { // TODO just use 'global' current assoc media object rather than doing this set/getActiveMediaMetadata business
                    if (asset.doq.Metadata.hasOwnProperty(key)) {
                        setActiveMediaMetadata(key, asset.doq.Metadata[key]);
                    }
                }
                setActiveMediaMetadata('assetDoqID', asset.doq.Identifier);

                isOpen = true;
                activeAssocMedia = asset;

                callback && callback();
            }
        }

        /**
         * Closes the media editor.
         * @method close
         */
        function close() {
            TAG.Util.removeYoutubeVideo();
            var rightbar;
            if (isOpen) {
                //saveAssocMedia();
                rightbar = $('.rightbar');
                hotspotAnchor.fadeOut(100);
                if (layerContainer) {
                    annotatedImage.viewer.drawer.removeOverlay(layerContainer[0]);
                    layerContainer.remove();
                }
                annotatedImage.unfreezeArtwork();
                rightbar.animate({ 'right': '-20%' }, 600);
                $('.assetHolder').css('background-color', '');
                editingMedia = false;
                isOpen = false;
            }
        }

        /**
         * Returns whether the editing panel is open
         * @method returnIsOpen
         * @return {Boolean}      true if open
         */
        function returnIsOpen() {
            return isOpen;
        }

        return {
            init: init,
            open: open,
            close: close,
            createMediaWrapper: createMediaWrapper,
            isOpen: returnIsOpen
        };
    }

    /**
    * Save artwork metadata
    * @method save
    */
    var shouldSave = false;
    function saveMetadata() {
        var i,
            additionalFields = $('.additionalField'),
            infoFields = {};        
        //saveMetadataButton.text('Saving...');
        //saveMetadataButton.attr('disabled', 'true');
        titleArea.text("Saving "+artworkMetadata.Title.val() + "...");
        for (i = 0; i < additionalFields.length; i++) {
            var key = $(additionalFields[i]).attr("value");
            if (key === "") {
                key = "Unnamed Field " + i;
            }
            infoFields[key] = $(additionalFields[i]).attr('entry');
        }

        var textName = $(artworkMetadata.Title).val();
        
        if (textName == "") {
            textName= "Untitled Artwork";
        }
        TAG.Worktop.Database.changeArtwork(artwork.Identifier, {
            Name: textName,
            Artist: $(artworkMetadata.Artist).val(),
            Year: $(artworkMetadata.Year).val(),
            Location: JSON.stringify(locationList),
            Description: $(artworkMetadata.Description).val(),
            InfoFields: JSON.stringify(infoFields)
        }, saveSuccess, saveFail,conflict, saveError);

        // success handler for save button
        function saveSuccess() {
            titleArea.text(artworkMetadata.Title.val());
            var authoringHub = new LADS.Authoring.SettingsView("Artworks", null, null, artwork.Identifier);
            TAG.Util.UI.slidePageRight(authoringHub.getRoot());
            //saveMetadataButton.text('Save Changes');
            //saveMetadataButton[0].removeAttribute('disabled');
        }

        // general failure callback for save button
        function saveFail() {
            titleArea.text(artworkMetadata.Title.val());
            var popup = $(TAG.Util.UI.popUpMessage(function () {
                var authoringHub = new LADS.Authoring.SettingsView("Artworks", null, null, artwork.Identifier);
                TAG.Util.UI.slidePageRight(authoringHub.getRoot());
            }, "Changes to " + artwork.Name + " have not been saved.  You must log in to save changes."));
            $('body').append(popup);
            popup.show();
            shouldSave = false;
            //saveMetadataButton.text('Save Changes');
            //saveMetadataButton[0].removeAttribute('disabled');
        }

        // error handler for save button
        function saveError() {
            titleArea.text(artworkMetadata.Title.val());
            var popup;
            popup = $(TAG.Util.UI.popUpMessage(function () {
                var authoringHub = new LADS.Authoring.SettingsView("Artworks", null, null, artwork.Identifier);
                TAG.Util.UI.slidePageRight(authoringHub.getRoot());
            }, "Changes to " + artwork.Name + " have not been saved.  There was an error contacting the server."));
            $('body').append(popup); // TODO ('body' might not be quite right in web app)
            popup.show();
            shouldSave = false;
            //saveMetadataButton.text('Save Changes');
            //saveMetadataButton[0].removeAttribute('disabled');
        }
    }

    /**
     * Artwork metadata editor. Contains methods for initializing the metadata form, saving metadata, adding additional
     * metadata fields, etc...
     * @method MetadataEditor
     * @return {Object}      an object with "public" associated media editing methods
     */
    function MetadataEditor() {
        var isOpen,
            addInfoButton,
            saveMetadataButton,
            textFieldContainer,
            metadataForm;

        /**
         * Create a metadata editing field.
         * @method createMetadataTextArea
         * @param {Object} options
         */
        function createMetadataTextArea(options) {
            var field = options.field,
                entry = options.entry,
                animate = options.animate,
                isTextarea = options.isTextarea,
                isAdditionalField = options.isAdditionalField,
                textareaContainer = $(document.createElement('div')).addClass('textareaContainer'),
                fieldTitle = $(document.createElement(isAdditionalField ? 'input' : 'div')).addClass('fieldTitle'),
                textarea = $(document.createElement(isTextarea ? 'textarea' : 'input')),
                deleteFieldIcon = $(document.createElement('div'));

            textareaContainer.css({ // TODO STYL
                'margin-bottom': '7%',
                'width': '100%',
                'text-align': 'left'
            });

            isAdditionalField && fieldTitle.addClass('additionalField');
            isAdditionalField && field!=="" ? fieldTitle.attr('value', field) : fieldTitle.text(field);

            fieldTitle.css({ // TODO STYL
                'display': 'inline-block',
                'color': isAdditionalField ? 'black' : 'white',
                'margin-right': '12px',
                'width': '18%',
                'text-align': 'right',
                'vertical-align': isAdditionalField ? '' : 'top',
                'padding-top': isAdditionalField ? '0px' : '5px',
                'font-size':'0.8em',
                'overflow': 'hidden',
                'border': "0px solid black"
            });

            if (isTextarea) {
                textarea.attr('rows', 3);
                textarea.css({ // TODO add a class, use textarea.classname vs input.classname in STYL
                    'overflow': 'auto',
                    'background': 'white',
                    'border': "0px solid black"
                });
            }// else {
            /*textarea.on('keyup', function () {
                var txt = (textarea && textarea[0] && textarea[0].value) ? textarea[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if (textarea && textarea[0] && textarea[0].value && textarea[0].value!=txt) {
                    textarea[0].value = txt;
                }
            });
            fieldTitle.on('keyup', function () {
                var txt = (fieldTitle && fieldTitle[0] && fieldTitle[0].value) ? fieldTitle[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
                if (fieldTitle && fieldTitle[0] && fieldTitle[0].value && fieldTitle[0].value!=txt) {
                    fieldTitle[0].value = txt;
                }
            });*/
            textarea.change(function () {
                shouldSave = true;
            })
            fieldTitle.change(function () {
                shouldSave = true;
            })
            //}
            textarea.css({ // TODO STYL
                'width': '70%',
                'font-size': '11pt',
                'display': 'inline-block',
                'border': "0px solid black"
            });
            if (isAdditionalField){
                textarea.attr('placeholder', "Metadata Field")
            }
            if (!isAdditionalField) {
                textarea.attr('placeholder', field);
            }

            if (isAdditionalField) {
                fieldTitle.attr('entry', entry);
                textarea.on('keyup', function () {
                    fieldTitle.attr('entry', textarea.attr('value'));
                });
            }
            artworkMetadata[field] = textarea;
            textarea.val(entry);
            textarea.attr('title', field);

            deleteFieldIcon.css({ 'margin-left': '15px', display: 'inline-block', width: '30px' });
            if (field !== 'Title' && field !== 'Keywords' && field !== 'Artist' && field !== 'Year' && field !== 'Description') {
                fieldTitle.attr('placeholder', "New");
                deleteFieldIcon = $(document.createElement('img'));
                deleteFieldIcon.attr('src', tagPath + 'images/icons/minus.svg');
                deleteFieldIcon.css({
                    'float': 'right',
                    'margin-right': '2%',
                    'width': '30px',
                    'height': '30px',
                    'display': 'inline-block'
                });
                deleteFieldIcon.bind("click", { Param1: field, }, function (event) {
                    shouldSave = true;
                    textareaContainer.remove();
                    if (!shouldDisableAddButton()) {
                        addInfoButton.removeAttr('disabled');
                    }
                });
            }
            animate && textareaContainer.css('display', 'none');

            textareaContainer.append(fieldTitle);
            textareaContainer.append(textarea);
            textareaContainer.append(deleteFieldIcon);
            textFieldContainer.append(textareaContainer);
            if (animate) {
                textareaContainer.slideDown(function () {
                    $("#metadataForm").animate({ scrollTop: $("#metadataForm")[0].scrollHeight }, 1000);
                });
            }
            return textarea;
        }

        /**
         * Creates additional metadata fields
         */
        function createCustomFields() {
            var infoFields = artwork.Metadata.InfoFields;
            infoFields = infoFields || {};
            $.each(infoFields, function (key, val) {
                createMetadataTextArea({ field: key, entry: val, animate: true, isAdditionalField: true });
            });
        }

        /**
         * Returns true if we should disable the "Add Information Field" button. We should if there are more than
         * two additional fields already.
         * @method shouldDisableAddButton
         * @return {Boolean}         whether or not we should disable the button
         */
        function shouldDisableAddButton() {
            return $('.additionalField').length >= 4;
        }

        /**
         * Initialize the metadata editor UI
         * @method init
         */
        function init() {
            var formTitle;

            metadataForm = $(document.createElement('div')) // TODO JADE/STYL
            .attr("id", "metadataForm")
            .css({
                'background': 'rgba(0, 0, 0, 0.85)',
                'border-radius': '0px 10px 10px 0px',
                'left': '20%',
                'width': '45%',
                'position': 'absolute',
                'display': 'none',
                'color': 'white',
                'padding-top': '1%',
                'margin-top': '1%',
                'z-index': 100000,
                'max-height': '70%',
                'overflow-y': 'scroll'
            })
            .appendTo(mainPanel);

            formTitle = $(document.createElement('div')); // TODO JADE/STYL
            formTitle.text("Metadata Editor");
            formTitle.css({
                'width': '100%',
                'text-align': 'center',
                'font-size': '150%',
            });
            metadataForm.append(formTitle);

            textFieldContainer = $(document.createElement('div')); // TODO JADE/STYL
            textFieldContainer.attr("id", "textFieldContainer");
            textFieldContainer.css({
                'position': 'relative',
                'height': '25%',
                'overflow': 'auto',
                'padding': '0px 4% 0px 0px',
                'margin-top': '30px'
            });
            metadataForm.append(textFieldContainer);

            addInfoButton = $(document.createElement('button'));
            addInfoButton.text('Add Metadata Field').css('border-radius', '3.5px'); // TODO JADE/STYL
            addInfoButton.attr('type', 'button');
            addInfoButton.css({
                'left': '10%',
                'width': '80%',
                'margin-top': '2%',
                'margin-bottom': '3%',
                'position': 'relative'
            });
            metadataForm.append(addInfoButton);

            saveMetadataButton = $(document.createElement('button')); // TODO JADE/STYL
            saveMetadataButton.text('Save');
            saveMetadataButton.attr('type', 'button');
            saveMetadataButton.css({
                'left': '10%',
                'width': '80%',
                'margin-top': '2%',
                'margin-bottom': '3%',
                'position': 'relative'
            });
            //metadataForm.append(saveMetadataButton);

            createMetadataTextArea({ field: 'Title', entry: artwork.Name }); // TODO a lot of this can be factored to J/S
            createMetadataTextArea({ field: 'Artist', entry: artwork.Metadata.Artist });
            createMetadataTextArea({ field: 'Year', entry: artwork.Metadata.Year });
            createMetadataTextArea({ field: 'Description', entry: artwork.Metadata.Description, isTextarea: true });
            createCustomFields();

            if (shouldDisableAddButton()) {
                addInfoButton.attr('disabled', 'true');
            }

            addInfoButton.on('click', function () {
                shouldSave = true;
                createMetadataTextArea({ field: "", entry: "", animate: true, isAdditionalField: true });
                if (shouldDisableAddButton()) {
                    addInfoButton.attr('disabled', 'disabled');
                }
            });

            //saveMetadataButton.on('click', save);
        }

        

        /**
         * Open the metadata editor
         * @method open
         */
        function open() {
            if (!isOpen) {
                closeAllPanels();
                metadataForm.toggle();
                metadataButton.css({ 'background-color': 'white', 'color': 'black' }); // TODO could do css toggling using classes and static css
                rightArrow.attr('src', tagPath+'images/icons/RightB.png');
                sidebarHideButtonContainer.hide();
                isOpen = true;
            }
        }

        /**
         * Close the metadata editor
         * @method close
         */
        function close() {
            if (isOpen) {                
                metadataForm.toggle();
                metadataButton.css({ 'background-color': 'transparent', 'color': 'white' });
                rightArrow.attr('src', tagPath+'images/icons/Right.png');
                sidebarHideButtonContainer.show();
                isOpen = false;
            }
        }


        /**
         * Toggle the metadata editor open and closed
         * @method toggle
         */
        function toggle() {
            isOpen ? close() : open();
        }

        /**
         * Returns whether the editing panel is open
         * @method returnIsOpen
         * @return {Boolean}      true if open
         */
        function returnIsOpen() {
            return isOpen;
        }

        return {
            init: init,
            open: open,
            close: close,
            toggle: toggle,
            isOpen: returnIsOpen
        };
    }
};
;
TAG.Util.makeNamespace('TAG.Layout.TourAuthoringNew');

/**
 * Final layout for Tour Authoring
 * All parts of layout are container in separate files/classes
 * Layout file also contains testing instructions / notes / functions
 * @param tourobj           Doq containing tour info
 * @param onLoadCallback    Callback to run once tour has loaded (loadRin runs async)
 */
TAG.Layout.TourAuthoringNew = function (tourobj, onLoadCallback) {
    "use strict";

    var root = $(document.createElement('div')),
        resizableArea = $(document.createElement('div')),
        originalHeightSize = window.innerHeight * 0.3,
        timeManager,
        undoManager,
        viewer,
        timeline,
        componentControls,
        playbackControls,
        $mainScrollHider,
        $trackBody,
        $trackVeil,
        $inkTextControls,
        $inkDrawControls,
        $inkTransControls,
        $inkEditText,
        $inkEditDraw,
        $inkEditTransparency,
        topbar,
        dataHolder = new DataHolder();

    // Background css
    root.css({
        "background-color": "rgb(219,218,199)",
        "height": "100%",
        "width": "100%" 
    });
    root.attr("class", "rootPage");
    TAG.Util.UI.getStack()[0] = null;

    /**
    *Second row on screen, contains ComponentControls and Viewer
    **/
    (function setupResizableArea() {



        resizableArea.css({
            "background-color": "rgb(219,218,199)",
            "height": originalHeightSize + "px",
            "width": "100%",
            "box-shadow": "0px 30px 30px -25px #888"
        });
        resizableArea.attr("id", "resizableArea");
        //mouse down and drag this button, aka three dots...to resize the viewer and component control
        var resizeButtonDocfrag = document.createDocumentFragment();
        var resizeButtonArea = $(document.createElement('div'));
        resizeButtonDocfrag.appendChild(resizeButtonArea[0]);
        resizeButtonArea.addClass('resizeButtonArea');
        resizeButtonArea.css({
            'height': '3%', 'width': '10%', 'position': 'absolute', 'top': (originalHeightSize + window.innerHeight * 0.09) + 'px',
            'left': '45%', 'margin-left': '-1.5%', 'z-index': 0, 'float': 'left'
        });

        var resizeButton = $(document.createElement('img'));
        resizeButton.addClass("resizeButton");
        resizeButton.attr('src', tagPath + 'images/icons/dragTourWindowTwoBars.svg');
        resizeButton.attr('id', 'resizeButton');
        resizeButton.css({
            'cursor': 'pointer', 'height': 'auto', 'width': '30%', 'position': 'absolute', 'top': '20%', 'left': '40%'
        });

        var prevLocationY;
        var currentMouseLocation;
        var dragOverlay;

        resizeButtonArea.draggable({
            axis: "y", containment: [0, window.innerHeight / 5 + window.innerHeight * 0.1, 0, window.innerHeight / 1.5 + window.innerHeight * 0.1],
            scroll: false,
            start: function (evt, ui) {
                if (timeline.getEditInkOn() === true) {
                    return false;
                }

                // bring up the buffering overlay, since artwork doesn't resize as you drag anyway
                $("#bufferingDiv").css({
                    "background": "rgba(0,0,0,.9)"
                });
                $($("#bufferingDiv").parent()).css({
                    "opacity": 0.9,
                    "display": "block"
                });
                prevLocationY = ui.position.top;
                timeManager.stop();
            }, //commented out because broke with svg
            stop: function (evt, ui) {
                // the css of bufferingDiv and its parentbeing reset in timeline.onUpdate
                // if we ever eliminate timeline.onUpdate, reset css here
                timeline.onUpdate();
            },
            drag: function (event, ui) {
                if (timeline.getEditInkOn() === true) {
                    return false;
                }
                ui.position.top = Math.constrain(ui.position.top, window.innerHeight / 5 + window.innerHeight * 0.1, window.innerHeight / 1.5 + window.innerHeight * 0.1);
                //if (event.originalEvent.pageY < window.innerHeight / 5 + window.innerHeight * 0.1) {//minimum size
                //    currentMouseLocation = window.innerHeight / 5 + window.innerHeight * 0.1;
                //}
                //else if (event.originalEvent.pageY > window.innerHeight / 1.5 + window.innerHeight * 0.1) {//maximum size
                //    currentMouseLocation = window.innerHeight / 1.5 + window.innerHeight * 0.1;
                //}
                //else {
                //    currentMouseLocation = event.originalEvent.pageY;
                //}

                if (prevLocationY === null) {
                    prevLocationY = ui.position.top;
                    return;
                }
                var distance = (ui.position.top - prevLocationY);
                resizableArea.css({
                    "height": originalHeightSize + distance + 'px'
                });
                if (!$mainScrollHider) {
                    $mainScrollHider = $('.mainScrollHider');
                }
                $mainScrollHider.css({
                    'height': $mainScrollHider.height() - distance + 'px',
                });
                if (!$trackBody) {
                    $trackBody = $('#trackBody');
                }
                $trackBody.css({
                    'height': $trackBody.height() - distance + 'px',
                });
                
               

                if (!$trackVeil) {
                    $trackVeil = $('#trackScrollVeil');
                }
                $trackVeil.css({
                    'height': $trackVeil.height() - distance + 'px',
                });

               
                $('#verticalSliderPane').css({
                    'height': $trackBody.height() + 'px',
                });

                $('#trackScrollVeil').css({
                    'height': $trackBody.height() + 'px',
                });
                
                //update the height
                originalHeightSize = originalHeightSize + distance;

                var raTop = resizableArea.offset().top;
                var raHeight = resizableArea.height();
                //resize the component control stuff
                if (!$inkTextControls) { $inkTextControls = $('#inkTextControls'); }
                if (!$inkDrawControls) { $inkDrawControls = $('#inkDrawControls'); }
                if (!$inkTransControls) { $inkTransControls = $('#inkTransControls'); }
             //   if (!$inkEditText) { $inkEditText = $('#inkEditText'); }
             //   if (!$inkEditDraw) { $inkEditDraw = $('#inkEditDraw'); }
             //   if (!$inkEditTransparency) { $inkEditTransparency = $('#inkEditTransparency'); }
                if ($('#inkTextControls').length > 0) {
                    $("#inkTextControls").css("height", raTop + raHeight - $("#inkTextControls").offset().top - 10);
                }
                if ($('#inkDrawControls').length > 0) {
                    $("#inkDrawControls").css("height", raTop + raHeight - $("#inkDrawControls").offset().top - 10);
                }
                if ($('#inkTransControls').length > 0) {
                    $("#inkTransControls").css("height", raTop + raHeight - $("#inkTransControls").offset().top - 10);
                }
           //     $("#inkEditText").css("height", raTop + raHeight - $("#inkEditText").offset().top - 10);
           //     $("#inkEditDraw").css("height", raTop + raHeight - $("#inkEditDraw").offset().top - 10);
           //     $("#inkEditTransparency").css("height", raTop + raHeight - $("#inkEditTransparency").offset().top - 10);
                viewer.resize();//resize the viewer.

                prevLocationY = ui.position.top;
            },
            appendTo: 'body'
        });
        resizeButtonArea.append(resizeButton);

        root.append(resizeButtonDocfrag);
       
    })();
 
    /**
    *Creates components and sets up UI
    */
    (function initBackend() {
        // Start by initializing all the parts
        timeManager = TAG.TourAuthoring.TimeManager();
        undoManager = TAG.TourAuthoring.UndoManager();
        viewer = TAG.TourAuthoring.Viewer({
            timeManager: timeManager
        });
        timeline = TAG.TourAuthoring.Timeline({
            timeManager: timeManager,
            undoManager: undoManager,
            dataHolder: dataHolder,
            viewer: viewer,
            root: root
        });
        viewer.setTimeline(timeline);
        playbackControls = TAG.TourAuthoring.PlaybackControl({
            timeManager: timeManager,
            undoManager: undoManager,
            viewer: viewer,
            timeline: timeline,
            root : root
        });
        componentControls = TAG.TourAuthoring.ComponentControls({
            root: root,
            undoManager: undoManager,
            playbackControls: playbackControls,
            timeline: timeline,
            dataHolder: dataHolder,
            viewer: viewer,
            timeManager: timeManager
        });
        topbar = TAG.TourAuthoring.TopMenu({
            viewer: viewer,
            timeline: timeline,
            tourobj: tourobj,
            componentControls: componentControls,
            timeManager: timeManager,
            undoManager: undoManager,
            playbackControls: playbackControls,
            root: root
        });
       
        // Assemble the UI using docfrag
        var uiDocfrag = document.createDocumentFragment();
        uiDocfrag.appendChild(resizableArea[0]);
        topbar.addToDOM(root);
        componentControls.addToDOM(resizableArea);
        viewer.addToDOM(resizableArea);
        componentControls.addCatalogToDOM(uiDocfrag);
        timeline.addToDOM(uiDocfrag);
        playbackControls.addToDOM(uiDocfrag);
        root.append(uiDocfrag);

        // Load tour from the rin object
        var rin = JSON.parse(unescape(tourobj.Metadata.Content));   
        if (jQuery.isEmptyObject(rin)) {
            rin = timeline.toRIN();
        }

        viewer.initializeTour(rin);
        timeline.loadRIN(rin, onLoadCallback);
        timeline.updateVerticalScroller();
        //timeline.setLoaded();
    })();

    this.getRoot = function() {
        return root;
    };
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.TimeManager');

/**
 * Manages all time-related things in TourAuthoring
 * Stores info re: start/end, current time, scale
 * Scale converts between time space (seconds) and pixel space (pixels on timeline)
 * Dispatches events to subscribers on time changes
 * All time values stored as seconds
 * @class 
 * @constructor
 * @param spec      start, end, scale, current parameters, all integers, all in seconds (not required)
 * @param my        not used
 * @return that     object containing public functions
 */
TAG.TourAuthoring.TimeManager = function (spec, my) { //get rid of my- look to make sure never called in other files?
    "use strict";

    spec = spec || {};

    // PRIVATE DOM elements
    var player = null, // Holds interval during playback
        // Initial time settings
        start = spec.start|| 0,
        end = spec.end || 180,
        scale = spec.scale || 20, // Defines px per sec
        current = spec.current || 0,
        // Event handling
        seekSubscribers = [],
        durationSubscribers = [],
        playStartSubscribers = [],
        playSubscribers = [],
        stopSubscribers = [],
        moveSubscribers = [],
        // viewer state
        ready = false,
        getViewerTime = null,

    /////////
    // PUBLIC
        that = {
            setTime : setTime,
            setStart : setStart,
            setEnd : setEnd,
            setScale : setScale,
            seek : seek,
            seekByAmount : seekByAmount,
            seekToPercent : seekToPercent,
            setReady : setReady,
            getReady : getReady,
            registerTime : registerTime,
            getScale : getScale,
            play : play,
            stop : stop,
            timeToPx : timeToPx,
            pxToTime : pxToTime,
            formatTime : formatTime,
            unformatTime : unformatTime,
            getCurrentTime : getCurrentTime,
            getCurrentPx : getCurrentPx,
            getCurrentPercent : getCurrentPercent,
            getDuration : getDuration,
            onSeek : onSeek,
            onSizing : onSizing,
            onPlayStart : onPlayStart,
            onPlay : onPlay,
            onStop : onStop,
            onMove : onMove,
        };
 

    // SETTERS

    

    /**
     * Generally should use setTime once everything has been initialized:
     * All time-dependent text in DOM is updated as well to reflect changes.
     * @method setTime
     * @param {Object} newspec      contains new start, end, and scale properties
     */
    function setTime (newspec) {
        // Duration updates
        var updated = [];
        if (newspec.start) {
            currentPx = null;
            start = newspec.start; //LVK- changed these from spec.start to newspec.start, Not sure if this was ever called cause it seems like it had errors
            updated.push('start');
        }
        if (newspec.end) {
            end = newspec.end;
            updated.push('end');
        }
        if (newspec.scale) {
            currentPx = null;
            scale = newspec.scale;
            updated.push('scale');
        }
        if (newspec.start || newspec.end || newspec.scale) {
            _sendSizing({ start: start, end: end, scale: scale, updated: updated });
        }
        // Seek updates
        if (newspec.current) {
            currentPx = null;
            current = newspec.current;
            _sendSeek({ current: current });
        }
    }

    /**Sets start
     * @method setStart
     * @param {Integer} newStart     in seconds
     */
    function setStart(newStart) {
        currentPx = null;
        start = newStart;
        _sendSizing({ start: start, end: end, scale: scale, updated: ['start'] });
    }

    /**Sets end
     * @method setEnd
     * @param {Integer} newEnd       in seconds
     */
    function setEnd (newEnd) {
        end = newEnd;
        if (current > end) {
            currentPx = null;
            current = end;
        }
        _sendSizing({ start: start, end: end, scale: scale, updated: ['end'] });
    }

    /*Sets scale (pixels per second)
     * @method setScale
     * @param {Integer} newScale      px/sec
     */
    function setScale(newScale) {
        currentPx = null;
        scale = newScale;
        _sendSizing({ start: start, end: end, scale: scale, updated: ['scale'] });
    }

    //SEEKING FUCTIONS

    /**Seek to a specific time
     * @method seek
     * @param {Integer} newTime     in seconds
     */
    function seek(newTime) {
        if (newTime < 0) { //prevent seeking to -1 sec
            newTime = 0;
        } else if (newTime > end) { // prevent seeking past the end of the timeline
            newTime = end;
        }
        currentPx = null;
        current = newTime;
        var pct = ((current - start) / (end - start)); 
        _sendMove({ current: current, percent: pct });
        _sendSeek({ current: current, percent: pct });
        if (current > end) {
            console.log('On timeManager seek: asked to seek past end (normal seek)');
        }
    }
    
    /**Seek by a certain amount past current time 
     * @method seekByAmound
     * @param {Integer} amount        in seconds
     */
    function seekByAmount(amount) {
        currentPx = null;
        //TODO- should probably have check to make sure doesn't pass end
        current += amount;
        var pct = ((current - start) / (end - start));
        _sendMove({ current: current, percent: pct });
        _sendSeek({ current: current, percent: pct });
        if (current > end) {
            console.log('On timeManager seek: asked to seek past end (amount seek)');
        }
    }

    /**Seek to a specific percent of the tour length
     * @method seekToPercent
     * @param {Integer} per         percent (as decimal)
     */
    function seekToPercent(per) {
        currentPx = null;
        current = (end - start) * per;
        _sendMove({ current: current, percent: ((current - start) / (end - start)) });
        _sendSeek({ current: current, percent: per });
    }

    /** Set state of viewer
     * @param {Boolean} isReady       whether the tour can play
     */
    function setReady(isReady) {
        ready = isReady;
    }

    /** Get state from viewer
    * @method getReady
    * @return {Boolean} ready       whether the tour can play
    */
    //LVK- removed parameter from this function cause not neccessary--> check to make sure never called with passed in parameter
    function getReady() {
        return ready;
    }
   

    function registerTime(func) {
        getViewerTime = func;
    }
    //that.registerTime = registerTime;

    function getScale() {
        return scale;
    }
   // that.getScale = getScale;
    /**
     * Drives forward current time to mimic playback
     */
    function play () {
        var interval = 100, last = -10,//?
            useInternalTime = false, lastInternalTime = Date.now(),//?
            pct = ((current - start) / (end - start));

        _sendMove({ current: current, percent: pct });
        _sendPlayStart({ current: current, percent: pct });

        player = window.requestAnimationFrame(function updatePlay(timestamp) {//window?
            player = window.requestAnimationFrame(updatePlay);
            // update program state
            if (ready) {
                if (!useInternalTime) {//internal time?
                    current = getViewerTime();
                    if (current === last) {
                        useInternalTime = true;
                        current += (timestamp - lastInternalTime) / 1000;
                        //if(current > end)
                        //    current = end;
                        //stop();
                    }
                } else {
                    current += (timestamp - lastInternalTime) / 1000;
                }

                if (current >= end) {
                    current = end;
                    stop();
                }

                _sendPlay({ current: current, percent: ((current - start) / (end - start)) });
                
                currentPx = null;
                last = current;
                lastInternalTime = timestamp;
            }
        });
    }
   // that.play = play;

    /**
     * Stops playback if time manager is playing
     */
    function stop () {
        if (player) {
            window.cancelAnimationFrame(player);
            player = null;
            _sendStop();
        }
    }
    //that.stop = stop;
    onSeek(stop); // Automatically stop playback when a seek occurs

    /**
     * Functions for converting btw pixel space and time space
     */
    function timeToPx(t) {
        return (t - start) * scale;
    }
    function pxToTime(px) {
        return (px / scale) + start;
    }
    function formatTime(seconds) {
        var min = parseInt(seconds / 60, 10);
        var sec = Math.floor(seconds % 60);
        if (sec < 10) {
            sec = '0' + sec;
        }
        return min + ':' + sec;
    }
    function unformatTime(string) {
        // Strings are expected in format: MM:SS TODO: include milliseconds?
        var min, sec;
        string.split(':');
        min = parseFloat(min);
        sec = parseFloat(sec);
        return min * 60 + sec;
    }
/*
    that.timeToPx = timeToPx;
    that.pxToTime = pxToTime;
    that.formatTime = formatTime;
    that.unformatTime = unformatTime;
    */
    var currentPx = null;
    /**
     * Grab current time in editor using playhead position
     * @returns     Current time (in time-space)
     */
    function getCurrentTime() {
        return current;
    }
    //that.getCurrentTime = getCurrentTime;

    function getCurrentPx() {
        if (!currentPx) {
            currentPx = timeToPx(current);
        }
        return currentPx;
    }
   // that.getCurrentPx = getCurrentPx;

    /**
     * Grab current time as percent complete of tour
     * @returns     Current time (as percentage)
     */
    function getCurrentPercent() {
        return (current - start) / (end - start);
    }
    //that.getCurrentPercent = getCurrentPercent;

    /**
     * Gets description of current duration
     * @returns     Object w/ start, end, scale parameters
     */
    function getDuration () {
        return { start: start, end: end, scale: scale };
    }
    //that.getDuration = getDuration;

    // Event subscribers

    /**
     * Add an event handler to be called on updating of current time (during playback or seek)
     * @param handler   Event handler to be called whenever current time is updated
     */
    function onSeek (handler) {
        seekSubscribers.push(handler);//?
    }
    //that.onSeek = onSeek;

    /**
     * Dispatches events to subscribers on seek update (private)
     * Context is set as time object
     * @param ev    The event: current, percent parameters
     */
    function _sendSeek (ev) {
        var i;
        for (i = 0; i < seekSubscribers.length; i++) {
            seekSubscribers[i].call(that, ev);
        }
    }

    /**
     * Add an event handler to be called on updating of duration
     * @param handler   Event handler to be called whenever start, end, or scale is updated
     */
    function onSizing (handler) {
        durationSubscribers.push(handler);
    }
   // that.onSizing = onSizing;

    /**
     * Dispatches events to subscribers on duration update (private)
     * Context is set as time object
     * @param {Object} ev    The event: start, end, scale, updated parameters
     */
    function _sendSizing (ev) {
        var i;
        for (i = 0; i < durationSubscribers.length; i++) {
            durationSubscribers[i].call(that, ev);
        }
    }

    /**
     * Add an event handler to be called on play() / when it is called
     * Will only be called once
     * @param handler       Event handler
     */
    function onPlayStart(handler) {
        playStartSubscribers.push(handler);
    }
    //that.onPlayStart = onPlayStart;

    /**
     * Dispatches events to subscribers on play (private)
     * @param ev    The event: current, percent parameters
     */
    function _sendPlayStart(ev) {
        var i;
        for (i = 0; i < playStartSubscribers.length; i++) {
            playStartSubscribers[i].call(that, ev);
        }
    }

    /**
     * Add an event handler to be called during player interval updates
     * @param handler       Event handler
     */
    function onPlay (handler) {
        playSubscribers.push(handler);
    }
    //?when/how is handler accessed?
    //that.onPlay = onPlay;

    /**
     * Dispatches events to subscribers on play updates (private)
     * Context is set as time object
     * @param ev    The event: current, percent parameters
     */
    function _sendPlay(ev) {
        var i;
        for (i = 0; i < playSubscribers.length; i++) {
            playSubscribers[i].call(that, ev);
        }
    }

    /**
     * Add an event handler to be called on stop
     * @param handler       Event Handler to be called whenever stop() is called
     */
    function onStop(handler) {
        stopSubscribers.push(handler);
    }
   // that.onStop = onStop;

    /**
     * Dispatches events to subscribers on play (private)
     * Context is set as time object
     * @param ev    The event: no use at the moment
     */
    function _sendStop (ev) {
        var i;
        for (i = 0; i < stopSubscribers.length; i++) {
            stopSubscribers[i].call(that, ev);
        }
    }

    /**
     * Add an event handler to be called on move (either play or seek)
     * Executes before other actions in play or seek, allowing safe updates
     * @param handler       Event handler to be called whenever play() or seek() is called
     */
    function onMove(handler) {
        moveSubscribers.push(handler);
    }
    //that.onMove = onMove;

    /**
     * Dispatches events to subscribers on move (private)
     * Context is set as time object
     * @param ev    The event: current, percent parameters
     */
    function _sendMove(ev) {
        var i;
        for (i = 0; i < moveSubscribers.length; i++) {
            moveSubscribers[i].call(that, ev);
        }
    }
    /**
    var that = {
        setTime : setTime,
        setStart : setStart,
        setEnd : setEnd,
        setScale : setScale,
        seek : seek,
        seekByAmount : seekByAmount,
        seekToPercent : seekToPercent,
        setReady : setReady,
        getReady : getReady,
        registerTime : registerTime,
        getScale : getScale,
        play : play,
        stop : stop,
        timeToPx : timeToPx,
        pxToTime : pxToTime,
        formatTime : formatTime,
        unformatTime : unformatTime,
        getCurrentTime : getCurrentTime,
        getCurrentPx : getCurrentPx,
        getCurrentPercent : getCurrentPercent,
        getDuration : getDuration,
        onSeek : onSeek,
        onSizing : onSizing,
        onPlayStart : onPlayStart,
        onPlay : onPlay,
        onStop : onStop,
        onMove : onMove,
    },
        **/
    
    return that;
};


;
TAG.Util.makeNamespace('TAG.TourAuthoring.UndoManager');

/**
 * Keeps track of commands and changes issued by program and order of issuing
 * Can unexecute or execute (undo / redo) these commands
 * @param spec  not used
 * @param my    not used
 */
TAG.TourAuthoring.UndoManager = function (spec, my) {
    "use strict";

    // Private
    var that = {},
        undoStack = [],
        redoStack = [],
        initialized = false, //used to prevent undoStack from updating when timeline is opening
        undoStackSizeOriginal = 0,
        stackSize = 75;

    // Public methods

    /**
     * Log a command that has just been executed, ie. add it to the undo stack
     * @param command       TAG.TourAuthoring.Command that was just run
     */
    function logCommand(command) {
        if (initialized === true) {
            if (command.savedState === undefined)
                command.savedState = false;
            if (redoStack.length > 0) {
                redoStack = []; // when should do this?
                $('.redoButton').css({ 'opacity': '0.4' });
                console.log("clear redoStack?");
            }
            undoStack.push(command);
            $('.undoButton').css({ 'opacity': '1.0' });
            if (undoStack.length > stackSize) {
                var diff = undoStack.length - stackSize;
                undoStack.splice(0, diff);
            }

            //  console.log("SAVED STATE //TOP//FROM log command// ===" + undoStack[undoStack.length - 1].savedState);
        }

        //Check to see if there have been any changes and update save button accordingly
        if (undoStack.length) {
            $('#tourSaveButton').css('opacity', '1');
            $('#tourSaveButton').prop('disabled', false);
        }
    }
    that.logCommand = logCommand;

    /**
    * function returns the savedState of the element in the top of the stack, which determines if timeline is dirty or not
    */
    function dirtyStateGetter() {
        if (undoStack.length > 0) {
            console.log("SAVED STATE //TOP//FROM DSG// ===" + undoStack[undoStack.length - 1].savedState);
            return undoStack[undoStack.length - 1].savedState;
        }
        return true;
    }
    that.dirtyStateGetter = dirtyStateGetter;


    //returns undoStack size
    function undoStackSize() {
        return undoStack.length;
    }
    that.undoStackSize = undoStackSize;


    //sets the savedState of the top element in undoStack to true, and the rest to false 
    function setPrevFalse() {
        if (undoStack.length > 0) {
            undoStack[undoStack.length - 1].savedState = true;

            for (var i = 0; i < undoStack.length - 1; i++) {
                undoStack[i].savedState = false;
                // console.log("SAVED STATE===" + undoStack[i].savedState);
            }
            // console.log("SAVED STATE //TOP// ===" + undoStack[undoStack.length - 1].savedState);
        }
    }
    that.setPrevFalse = setPrevFalse;
    //called by loadRIN method in timeline class
    function setInitialized(boolVal) {
        initialized = boolVal;
    }
    that.setInitialized = setInitialized;


    function getInitialized() {
        return initialized;
    }
    that.getInitialized = getInitialized;

    /**
     * Undo
     */
    function undo() {
        if (undoStack.length > 0) {
            var toUndo = undoStack.pop();
            toUndo.unexecute();
            redoStack.push(toUndo);
            $('.redoButton').css({ 'opacity': '1.0' });
            if (undoStack.length === 0)
                $('.undoButton').css({ 'opacity': '0.4' });
        }
        else {
            $('#tourSaveButton').prop('disabled', true);
            $('#tourSaveButton').css('opacity', '0.4');
            $('.undoButton').css({ 'opacity': '0.4' });
        }

        //Check to see if there have been any changes and update save button accordingly
        if (!undoStack.length) {
            $('#tourSaveButton').prop('disabled', true);
            $('#tourSaveButton').css('opacity', '0.4');
            $('.undoButton').css({ 'opacity': '0.4' });
        }
            
    }
    that.undo = undo;

    /**
     * Redo
     */
    function redo() {
        if (redoStack.length > 0) {
            var toRedo = redoStack.pop();
            toRedo.execute();
            undoStack.push(toRedo);
            $('.undoButton').css({ 'opacity': '1.0' });
            if (redoStack.length === 0)
                $('.redoButton').css({ 'opacity': '0.4' });
        }
        else $('.redoButton').css({ 'opacity': '0.4' });

        //Check to see if there have been any changes and update save button accordingly
        if (undoStack.length) {
            $('#tourSaveButton').css('opacity', '1');
            $('#tourSaveButton').prop('disabled', false);
        }
    }
    that.redo = redo;

    /**
     * Clears undo / redo stack
     * Called on save or after loading
     */
    function clear() {
        undoStack = [];
        redoStack = [];
    }
    that.clear = clear;

    // greyed out the undo/redo buttons when there is no possible action
    function greyOutBtn() {
        $('.undoButton').css({ 'opacity': '1.0' });
        $('.redoButton').css({ 'opacity': '1.0' });
        if (undoStack.length < 1) {
            $('.undoButton').css({ 'opacity': '0.4' });
        }
        if (redoStack.length < 1) {
            $('.redoButton').css({ 'opacity': '0.4' });
        }
    }
    that.greyOutBtn = greyOutBtn;

    /**
     * Utility for combining together multiple commands
     * (Originally used for tying auto-creation of displays together with track creation)
     * @param n     Number of commands to tie together
     */
    function combineLast(n) {
        var command, i;
        n = n || 2;
        command = {
            execute: function () {
                for (i = 0; i < n; i++) {
                    redo();
                }
            },
            unexecute: function () {
                for (i = 0; i < n; i++) {
                    undo();
                }
            }
        };
        logCommand(command);
    }
    that.combineLast = combineLast;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.ArtworkTrack');

/**
 * Creates an Artwork track
 * @param spec              Specifications (see Track class for details);
 * @param spec.thumbnail
 * @param my     After superclass is called, will contain displays and keyframes arrays
 *              Don't pass in unless you are subclassing this
 */
TAG.TourAuthoring.ArtworkTrack = function (spec, my) {
    "use strict";

    // Call super-constructor
    spec.type = TAG.TourAuthoring.TrackType.artwork;
    my = my || {};
    var that = TAG.TourAuthoring.Track(spec, my);

    my.track.addClass('artwork');
    //my.svg.classed('artwork', true);

    // Artwork-specific functions

    // Keyframes

    // Export to RIN format

    // Associated Inks
    //TAG.TourAuthoring.InkablePart(that, my);

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.AudioTrack');

/**
 * Creates an Audio track
 * @param spec  Specifications (see Track class for details);
 * @param my    After superclass is called, will contain displays and keyframes arrays
 *              Don't pass in unless you are subclassing this
 */
TAG.TourAuthoring.AudioTrack = function (spec, my) {
    "use strict";

    // Call super-constructor
    spec.type = TAG.TourAuthoring.TrackType.audio;
    my = my || {};
    var that = TAG.TourAuthoring.Track(spec, my);

    my.track.addClass('audio');
    //my.svg.classed('audio', true);

    // Audio-specific functions

    // Keyframes

    // Export to RIN format

    return that;

};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.Viewer');

/**
 * Previews current tour while user edits
 * @param spec  timeManager attr, url (url of tour if loading existing tour for editing)
 * @param my    not used
 */
TAG.TourAuthoring.Viewer = function (spec, my) {
    "use strict";

    var player, timeline,
        that = {},
        artworkPanel = $(document.createElement('div')),
        rinContainer = $(document.createElement('div')),
        timeManager = spec.timeManager,
        url = spec.url,

        // viewer state
        playing = false,
        buffering = false,
        reloading = false,
        needRefresh = false, ctime = null,

        // capturing keyframes?
        capturingOn = false,
        currentCapture = '',
        keyframingDisabled = false,
            
        // is the tour reloading?
        isReloading = false,
        rinPath = IS_WINDOWS ? tagPath + 'js/WIN8_RIN/web' : tagPath + 'js/RIN/web';
    // Instantiate RIN player
    (function _startRIN() {
        // HTML containers
        artworkPanel.attr('id', 'viewer');
        artworkPanel.css({
            "background-color": "rgb(0,0,0)", "height": "100%", "width": "80%",
            "position": "relative", "left": "20%"
        });

        // let's assume 16:9 ratio for now
        rinContainer.attr('id', 'rinContainer');
        rinContainer.css({
            'border-style': 'solid', 'border-width': TAG.TourAuthoring.Constants.rinBorder+'px', 'border-color': 'white',
            'height': '95%', 'width': '30%', 'top': '0%', 'left': '30%', 'position': 'absolute', 'z-index': 0
        });
        artworkPanel.append(rinContainer);

        var playerElement = $(document.createElement('div'));
        playerElement.attr('id', 'rinplayer');
        playerElement.css({
            'z-index': -100, 'overflow': 'hidden',
            'height': '100%', 'width': '100%',
            'position': 'absolute'
        });
        rinContainer.append(playerElement);

        // creates actual RIN player
        rin.processAll(null, rinPath).then(function () {
            var options = 'systemRootUrl=' + rinPath + '/&hideAllControllers=true&playerMode=authorerEditor';;
            player = rin.createPlayerControl(playerElement[0], options);
            //player.interactionModeStarted.subscribe(_onInteraction);
            player.orchestrator.playerESEvent.subscribe(_onPlayerESEvent, 'id');
            player.orchestrator.isPlayerReadyChangedEvent.subscribe(_onPlayerStateEvent);
            
            timeManager.registerTime(getCurrentTime);
        });

        if (url) {
            loadTour(url, function () { console.log('Viewer: initial loading complete'); });
        }
    })();

    //function _onInteraction(eventArgs) {
    //    timeManager.stop();
    //    capturingOn = true;
    //    currentCapture = eventArgs.interactionES._esData.experienceId;
    //    if (!reloading && timeManager.getReady()) {
    //        _sendKeyframe(eventArgs.interactionES);
    //    }
    //}

    /**
     * When RIN is interacted with, captures new keyframe data and sends it to timeline
     * @param eventArgs     sender, eventId, ? (RIN)
     */
    function _onPlayerESEvent(eventArgs) {
        console.log(eventArgs.eventId);
        if (timeline) {
            switch (eventArgs.eventId) {
                case rin.contracts.esEventIds.interactionActivatedEventId:
                    timeManager.stop(); // on interaction start capturing
                    capturingOn = true;
                    currentCapture = eventArgs.sender._esData.experienceId;
                    if (capturingOn && !reloading && !keyframingDisabled && timeManager.getReady()) {
                        _sendKeyframe(eventArgs.sender);
                    }
                    break;
                case rin.contracts.esEventIds.stateTransitionEventId:
                    // filter out non-interaction transitions
                    if (capturingOn && !reloading && !keyframingDisabled && timeManager.getReady()) {
                        _sendKeyframe(eventArgs.sender);
                    }
                    break;
            }
        }
    }

    function _sendKeyframe(sender) {
        var trackName, capture = '';
        if (sender.captureKeyframe && capturingOn) {
            capture = sender.captureKeyframe();
            if (capture === '') { // continue capturing until successful
                //setTimeout(function () { _sendKeyframe(sender); }, 10);
				console.log('No keyframe captured!?');
                return;
            }
            trackName = sender._esData.experienceId;

            timeline.receiveKeyframe(trackName, capture,
                true);
            timeline.allDeselected();
        }
    }

    /**
     * Turn capturing off on update
     */
    function capturingOff() {
        capturingOn = false;
        currentCapture = '';
    }
    that.capturingOff = capturingOff;

    /**
     * Get state of keyframe disable switch.
     */
    function isKeyframingDisabled() {
        return keyframingDisabled;
    }
    that.isKeyframingDisabled = isKeyframingDisabled;

    function setKeyframingDisabled(state) {
        keyframingDisabled = state;
    }
    that.setKeyframingDisabled = setKeyframingDisabled;

    // add event listener for playerReady event to re-enable keyframe capture.
    $('body')[0].addEventListener('playerReady', function () {
        keyframingDisabled = false;
    });

    $('body')[0].addEventListener('playerReloading', function () {
        keyframingDisabled = true;
        setTimeout(function () {
            keyframingDisabled = false;
        }, 150);
    });

    /**
     * Syncs time manager with buffering state of RIN
     * @param isReady        true if RIN is ready to play
     */
    function _onPlayerStateEvent(isReady) {
        buffering = !isReady;
        timeManager.setReady(isReady);
        reloading = false;
        if (isReady) {
            if (needRefresh && ctime) {
                needRefresh = false;
                seek(timeManager.getCurrentTime());
                ctime = null;
            }
            needRefresh = false;
            setTimeout(function () {
                var readyEvent = document.createEvent('Event');
                readyEvent.initEvent('playerReady', true, true);
                $('body')[0].dispatchEvent(readyEvent);
            }, 500);
        }
    }

    // Turn off capture on player events
    function _stopCapture() {
        capturingOn = false;
    }
    timeManager.onMove(_stopCapture);
    timeManager.onStop(_stopCapture);

    // Public stuff

    /**
     * @returns     current keyframe state data
     */
    function captureKeyframe(artname) {
        if (player) {
            return player.captureKeyframe(artname); //grab artwork container? BREAKPOINT HERE
        }
    }
    that.captureKeyframe = captureKeyframe;

    /**
     * Passed to TimeManager on player load
     * @returns     current time in player
     */
    function getCurrentTime() {
        return player.orchestrator.getCurrentLogicalTimeOffset();
    }
    that.getCurrentTime = getCurrentTime;
    

    function addToDOM (container) {
        container.append(artworkPanel);
    }
    that.addToDOM = addToDOM;

    /**
     * Get JQuery object containing rin player
     */
    function getContainer() {
        return rinContainer;
    }
    that.getContainer = getContainer;

    /**
     * Updates size of viewer area on resize
     */
    function resize() {
        var h = artworkPanel.height() - 2 * TAG.TourAuthoring.Constants.rinBorder,
            w = artworkPanel.width() - 2 * TAG.TourAuthoring.Constants.rinBorder,
            idealW = h * 16 / 9, idealH, // ideal W given h, vice-versa
            xoffset, yoffset;
        if (idealW <= w) {
            xoffset = (w - idealW) / 2;
            rinContainer.css({
                width: idealW + 'px',
                height: h + 'px',
                top: '0px',
                left: xoffset + 'px'
            });
        } else { // no room to support, use ideal H
            idealH = w * 9 / 16;
            yoffset = (h - idealH) / 2; // equal spacing on top and bottom
            rinContainer.css({
                width: w + 'px',
                height: idealH + 'px',
                top: yoffset + 'px',
                left: '0px'
            });
        }
    }
    that.resize = resize;

    // PLAYER INTERACTIONS
    /**
     * Play viewer (should only be called from timeManager)
     */
    function play(time) {
        if (!playing) {
            player.play(time);
            playing = true;
        }
    }
    that.play = play;
    timeManager.onPlayStart(function (ev) { play(ev.current); });

    /**
     * Stop viewer (should only be called from timeManager)
     */
    function stop() {
        if (playing && !buffering) {
            player.pause();
            playing = false;
        }
    }
    that.stop = stop;
    timeManager.onStop(stop);

    /**
     * Seek viewer (should only be called from timeManager)
     * @param time  location to seek to in units of seconds
     */
    function seek(time) {
        if (player.orchestrator._isNarrativeLoaded) {
            if (needRefresh) {
                ctime = timeManager.timeToPx(time);
            }

            else if (player && !playing) {
                stop();
                playing = false;
                player.pause(time);
            }
        }
    }
    that.seek = seek;
    timeManager.onSeek(function (ev) { seek(ev.current); });

    /**
     * Set volume
     * @param v     volume, between 0 and 1
     */
    function volume(v) {
        player.volume(v);
    }
    that.volume = volume;

    /**
     * Set reference to Timeline for keyframe passing
     */
    function setTimeline(t) {
        timeline = t;
    }
    that.setTimeline = setTimeline;

    /**
     * Load tour from url
     * @param url       URL of json tour
     */
    function loadTour(url, callback) {
        if (player) {
            player.load(url, callback);
        } else {
            setTimeout(function () {
                loadTour(url, callback);
            }, 50);
        }
    }
    that.loadTour = loadTour;

    /**
     * Load / reload tour into viewer
     * @param data      Segment portion of RIN tour
     */
    function reloadTour(data, doNotUpdateReloading) {
        if (!doNotUpdateReloading) {
            isReloading = true;
        }
        //console.log("####################################################: "+isReloading);
        // console.log("player: "+player);
        for (var key in data.resources) {
            if (data.resources.hasOwnProperty(key)) {
                if (typeof data.resources[key].uriReference === 'string') {
                    data.resources[key].uriReference = TAG.Worktop.Database.fixPath(data.resources[key].uriReference);
                }               
            }
        }
        if (player) {
            reloading = true;
            needRefresh = true;
            player.orchestrator._isPlayerReady = false;
            ctime = timeManager.getCurrentTime();
            player.unload();
            player.loadData(data, function () {
                // if needRefresh is false we seeked too early?
                if (!needRefresh) {
                    seek(timeManager.getCurrentTime());
                    setTimeout(function () {
                        var readyEvent = document.createEvent('Event');
                        readyEvent.initEvent('playerReady', true, true);
                        $('body')[0].dispatchEvent(readyEvent);
                    }, 500);
                }
                //setTimeout(function () { seek(ctime); reloading = false; }, 25);
                if (!doNotUpdateReloading) {
                    isReloading = false;

                }
                //console.log("##############################################: "+isReloading);
            });
        } else {
            setTimeout(function () { reloadTour(data, true); }, 50);
        }
    }
    that.reloadTour = reloadTour;

    function getIsReloading() {
        return isReloading;
    }
    that.getIsReloading = getIsReloading;

    function setIsReloading(bool) {
        isReloading = bool;
    }
    that.setIsReloading = setIsReloading;

    function initializeTour(data) {
        var ctime;
        isReloading = true;
        console.log("isReloading: true, in initializeTour");
        // console.log("player: "+player);
        if (player) {
            ctime = timeManager.getCurrentTime();
            player.unload();
            player.loadData(data, function () {
                setTimeout(function () {
                    seek(ctime);
                    isReloading = false;
                    console.log("isReloading: false, in initializeTour");
                }, 50);
            });
        } else if (timeline.getTrackslength() === 0) {
            ctime = timeManager.getCurrentTime();
            setTimeout(function () {
                //seek(ctime);
                isReloading = false;
                console.log("isReloading: false, in initializeTour");
            }, 50);
        } else {
            setTimeout(function () { reloadTour(data, true); }, 50);
        }
    }
    that.initializeTour = initializeTour;

    /**
     * Unloads RIN player
     * call when exiting Authoring
     */
    function unload() {
        player.unload();
    }
    that.unload = unload;

    function getPlayer() {
        return player;
    }
    that.getPlayer = getPlayer;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.Command');

/**
 * Interface representing an action taken by the user
 * Stored in the undo/redo stack, used for multi-level undo/redo
 * @param spec      An object with the following keys:
 *                      execute: Function to execute the command
 *                      unexecute: Function to undo the command
 */
TAG.TourAuthoring.Command = function (spec, my) {
    "use strict";

    var that = {};

    that.execute = spec.execute;
    that.unexecute = spec.unexecute;
    that.savedState = false;
    return that;
};
;
/// <reference path="TAG.TourAuthoring.InkTrack.js" />
TAG.Util.makeNamespace('TAG.TourAuthoring.ComponentControls');



/**
 * Controls for adding Components, editing properties of them, and undo/redo buttons
 * @param spec  root, timeline, timeManager attr
 * @param my    not used
 */
TAG.TourAuthoring.ComponentControls = function (spec, my) {
    "use strict";

    var functionsPanel = $(document.createElement('div')),
        functionsPanelDocfrag = document.createDocumentFragment(),
        catalogPicker = $(document.createElement('div')),
        associatedMediaPicker = $(document.createElement('div')),
        that = {},
        root = spec.root,
        playbackControls = spec.playbackControls,
        timeManager = spec.timeManager,
        timeline = spec.timeline,
        viewer = spec.viewer,
        tourobj = spec.tourobj,
        undoManager = spec.undoManager,
        inkAuthoring,
        inkTransparencyControls, inkTextControls, inkDrawControls, inkEditTransparency, inkEditText, inkEditDraw,
        addCompButtonHeight,
        myPicker, resizableHeight,
        artQueue = TAG.Util.createQueue(),
        mediaQueue = TAG.Util.createQueue(),
        PICKER_SEARCH_TEXT = 'Search by Name, Artist, or Year...',
        IGNORE_IN_SEARCH = ['visible', 'exhibits', 'selected'],
        rinContainer = viewer.getContainer(),
        isUploading = false,
        allArtworks,
        pickerloaded = false;
    functionsPanelDocfrag.appendChild(functionsPanel[0]);
    timeline.setCompControl(that);
    var catalogPickerOverlay = TAG.Util.UI.blockInteractionOverlay();
    $(catalogPickerOverlay).addClass('catalogPickerOverlay');
    $(catalogPickerOverlay).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);

    var associatedMediaPickerOverlay = TAG.Util.UI.blockInteractionOverlay();
    $(associatedMediaPickerOverlay).addClass('associatedMediaPickerOverlay');
    $(associatedMediaPickerOverlay).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);    
    
    /**
     * Display warning message if ink cannot be loaded
     * @param displayString     String describing error (to be displayed)
     */
    function creationError(displayString) {
        var messageBox = TAG.Util.UI.popUpMessage(null, displayString, null);
        $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
        $('body').append(messageBox);
        $(messageBox).fadeIn(500);

        timeline.onUpdate(true);
    }

    (function _createHTML() {

        function ctrlZHandler(evt) {
            if (evt.keyCode === 90 && evt.ctrlKey) { // keyCode 90 is 'z'
                if (!onCtrlZCalled) {
                    onCtrlZCalled = true;
                    root.on('keyup.z', function (evt) {
                        onCtrlZCalled = false;
                        root.off('keyup.z');
                        if (timeline.getEditInkOn()) {//in ink authoring mode
                            if (evt.shiftKey) {
                                inkAuthoring.getInkUndoManager().redo();
                            }
                            
                            else {
                                inkAuthoring.getInkUndoManager().undo();
                            }

                        }
                        else {
                            if (evt.shiftKey) {
                                undoManager.redo();
                            }
                            else {
                                undoManager.undo();
                            }
                        }
                    });
                }
            }

            else if (evt.keyCode === 89 && evt.ctrlKey) {   // keyCode 89 is 'y'
                root.on('keyup.y', function (evt) {
                    root.off('keyup.y');

                    if ((inkAuthoring !== null) && (inkAuthoring.getInkUndoManager())) {//in ink authoring mode
                        inkAuthoring.getInkUndoManager().redo();
                    }
                    else {
                        undoManager.redo();

                    }
                });
            }
        }
        //code to handle undo-redo using ctrl-z
        var onCtrlZCalled = false;
        root.on('keydown', ctrlZHandler);

        var maxFontSize = 48;
        var currentFontSize;
        /**
         * Method called when "Edit Ink" is clicked on a draw-type ink track.
         * Creates a new InkController and loads in the datastring of the track.
         * Shows the edit draw controls.
         * If the ink is linked, need to position it correctly using keyframes and size of artwork.
         * @param track        the ink track in question
         * @param datastring   the track's ink datastring (see InkController.js for format)
         */
        var myEditDrawPicker = null;
        function showEditDraw(track, datastring) {
            playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
            var cw, ch, initKeyframe, artname, proxy,
                linked = track.getInkEnabled(),
                linkedTrack = track.getInkLink();

            // gotta do this up here to do creation check
            if (linked) {
                artname = linkedTrack.getTitle();

                var proxy_div = $("[data-proxy='" + escape(artname) + "']");
                proxy = {
                    x: proxy_div.data("x"),
                    y: proxy_div.data("y"),
                    w: proxy_div.data("w"),
                    h: proxy_div.data("h")
                };

                var keyframe = viewer.captureKeyframe(artname);
                if (!keyframe) {
                    track.setIsVisible(true);
                    creationError("The track this annotation is attached to must be fully on screen in order to edit this annotation. Please seek to a location where the track is visible.");
                    return false;
                }
                var kfvx, kfvy, kfvw, kfvh,
                    linkType = linkedTrack.getType();
                if (linkType === TAG.TourAuthoring.TrackType.artwork) {
                    kfvx = keyframe.state.viewport.region.center.x;
                    kfvy = keyframe.state.viewport.region.center.y;
                    kfvw = keyframe.state.viewport.region.span.x;
                    kfvh = keyframe.state.viewport.region.span.y;
                }
                else if (linkType === TAG.TourAuthoring.TrackType.image) {
                    kfvw = 1.0 / keyframe.state.viewport.region.span.x;
                    var rw = keyframe.state.viewport.region.span.x * $("#rinplayer").width();
                    kfvh = keyframe.state.viewport.region.span.y; // not used
                    kfvx = -keyframe.state.viewport.region.center.x * kfvw;
                    kfvy = -($("#rinplayer").height() / rw) * keyframe.state.viewport.region.center.y;
                }
            }
            //hide any open component controls, show inkEditDraw
            hideInkControls();
            //var newHeight = functionsPanel.parent().height() - addComponentLabel.offset().top - 10;
            inkEditDraw.css({ 'display': 'block' });

            //make sure the initial size of the panel is the full height of the resizable area
            var raTop = $("#resizableArea").offset().top;
            var raHeight = $("#resizableArea").height();
            inkEditDraw.css("height", raTop + raHeight - inkEditDraw.offset().top - 10);

            drawEditLabel.css({ 'color': 'black' });
            eraseEditLabel.css({ 'color': 'gray' });
            drawEditMode = 'draw';
            drawEditModeLabel1.text("Draw");
            brushEditLabel.text("Width: ");
            brushEditLabel1.text("7px");
            brushEditLabel.append(brushEditLabel1);
            brushEditSliderPoint.css("left", "0px");
            //eraserEditLabel.text("Eraser: ");
            //eraserEditLabel1.text("7px");
            //eraserEditLabel.append(eraserEditLabel1);
            //eraserEditSliderPoint.css("left", "0px");
            opacityEditLabel.text("Opacity: ");
            opacityEditLabel1.text("100%");
            opacityEditLabel.append(opacityEditLabel1);
            opacityEditSliderPoint.css("left", (0.87 * opacityEditSlider.width()) + "px");

            //reset click and save handlers to deal with current datastring
            cancelEditDrawButton.off('click');
            cancelEditDrawButton.on('click', function () {
                track.setIsVisible(true);
                timeline.setEditInkOn(false);
                timeline.onUpdate(true);
                timeline.setModifyingInk(false);
                timeline.hideEditorOverlay();

                brushEditSliderPoint.attr('value', 7.0);
                currentInkController.updatePenWidth("brushEditSlider");
                currentInkController.remove_all();
                removeInkCanv();
                inkEditDraw.hide();
                
                playbackControls.undoButton.off('click'); //reset undo/redo buttons to global undo/redo functionality
                playbackControls.redoButton.off('click');
                playbackControls.undoButton.on('click', function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on('click', function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');
            });

            saveDrawButton.off('click');
            saveDrawButton.on('click', function () {
                saveDraw();
                timeline.hideEditorOverlay();
                timeline.setEditInkOn(false);
                timeline.setModifyingInk(false);
            });

            function saveDraw() {
                //first, check if the ink is empty
                if (currentInkController.isDatastringEmpty(currentInkController.update_datastring())) {
                    var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                        //delete track
                        track.setIsVisible(true);

                        var command = TAG.TourAuthoring.Command({
                            execute: function () {
                                timeline.removeTrack(track);
                            },
                            unexecute: function () {
                                track.reloadTrack();
                            }
                        });
                        undoManager.logCommand(command);
                        command.execute();
                        //hide ink controls and removeinkcanv
                        inkEditDraw.hide();
                        removeInkCanv();
                        //change the undomanager back fron ink only
                        playbackControls.undoButton.off('click'); //reset undo/redo buttons to global undo/redo functionality
                        playbackControls.redoButton.off('click');
                        playbackControls.undoButton.on('click', function () {
                            undoManager.undo();
                        });
                        playbackControls.redoButton.on('click', function () {
                            undoManager.redo();
                        });
                        playbackControls.undoRedoInkOnly.css('display', 'none');

                    }, "You have created an empty annotation. Would you like to delete annotation track or go back to editing?", "Delete Track", true);
                    root.append(confirmationBox);
                    $(confirmationBox).show();
                    return;
                }
                //reset the initial keyframe and relative artwork positioning in the track data
                if (linked) {
                    var currcanv = $('#inkCanv');

                    var new_proxy_div = $("[data-proxy='" + escape(artname) + "']"); //proxy for the artwork -- keeps track of dimensions
                    var new_proxy = {
                        x: new_proxy_div.data("x"),
                        y: new_proxy_div.data("y"),
                        w: new_proxy_div.data("w"),
                        h: new_proxy_div.data("h")
                    };

                    var new_keyframe = viewer.captureKeyframe(artname);

                    if (!new_keyframe) {
                        creationError("The track this annotation is attached to must be fully on screen in order to save this annotation. Please seek to a location where the track is visible.");
                        return false;
                    }
                    var new_kfvx, new_kfvy, new_kfvw, new_kfvh,
                        linkType = linkedTrack.getType();
                    if (linkType === TAG.TourAuthoring.TrackType.artwork) {
                        new_kfvx = new_keyframe.state.viewport.region.center.x;
                        new_kfvy = new_keyframe.state.viewport.region.center.y;
                        new_kfvw = new_keyframe.state.viewport.region.span.x;
                        new_kfvh = new_keyframe.state.viewport.region.span.y;
                    }
                    else if (linkType === TAG.TourAuthoring.TrackType.image) {
                        new_kfvw = 1.0 / new_keyframe.state.viewport.region.span.x;
                        var rw = new_keyframe.state.viewport.region.span.x * currcanv.width();
                        new_kfvh = new_keyframe.state.viewport.region.span.y; // not used
                        new_kfvx = -new_keyframe.state.viewport.region.center.x * new_kfvw;
                        new_kfvy = -(currcanv.height() / rw) * new_keyframe.state.viewport.region.center.y;
                    }
                    track.setInkInitKeyframe({ "x": new_kfvx, "y": new_kfvy, "w": new_kfvw, "h": new_kfvh });
                    track.setInkRelativeArtPos(currentInkController.getArtRelativePos(new_proxy, currcanv.width(), currcanv.height()));
                }
                var datastr = currentInkController.update_datastring();
                var oldDataStr = track.getInkPath();

                var command = TAG.TourAuthoring.Command({
                    execute: function () {
                        track.setInkPath(datastr);
                        timeline.onUpdate(true);
                    },
                    unexecute: function () {
                        track.setInkPath(oldDataStr);
                        timeline.onUpdate(true);
                    },
                });

                currentInkController.remove_all();
                removeInkCanv();
                inkEditDraw.hide();

                track.setIsVisible(true);

                undoManager.logCommand(command);
                command.execute();

                //timeline.onUpdate(true);

                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");

                playbackControls.undoButton.on('click', function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on('click', function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');


                if (inkAuthoring) {
                    inkAuthoring.getInkUndoManager().clear();
                    undoManager.greyOutBtn();
                }
            }
            that.saveDraw = saveDraw;
            hideAll(drawEditArray);

            //create a div on which we'll draw inks

            var inkdiv = createInkCanv();
            var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
            $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
            inkAuthoring = p1;
            p1.set_editable();
            p1.set_mode(TAG.TourAuthoring.InkMode.draw);
            //p1.updatePenWidth("brushSlider"); // reset to defaults
            //p1.updatePenOpacity("opacitySlider");

            if (linked) {
                //if the ink is linked, need to figure out where to place it beyond loading in the original datastring
                initKeyframe = track.getInkInitKeyframe();
                p1.setInitKeyframeData(initKeyframe);
                p1.setArtName(artname);
                p1.retrieveOrigDims();
                p1.setEID(track.getTitle());
            }

            p1.loadInk(datastring); //load in the ink to be edited

            if (linked) {
                //now adjust viewbox so art is at the proper coordinates
                p1.update_datastring();
                p1.setOldOpac(1);
                p1.adjustViewBoxDiv({ x: proxy.x, y: proxy.y, width: proxy.w, height: proxy.h });
                p1.drawPaths();
                p1.drawBezierPath();
            }

            currentInkController = p1;


            //call onUpdate to remove the existing ink before reloading it in edit mode
            timeline.onUpdate(true);
            timeline.showEditorOverlay();
            timeline.setEditInkOn(true);
        }
        that.showEditDraw = showEditDraw;

        /**
         * Method called when "Edit Ink" is clicked on a block/isolate-type ink track.
         * See comments for showEditDraw.
         * @param track        the ink track in question
         * @param datastring   the track's ink datastring
         * @param trans_type   'isolate' or 'block'
         */
        function getInkUndoManager() {
            if (inkAuthoring)
                return inkAuthoring.getInkUndoManager();
        }
        that.getInkUndoManager = getInkUndoManager;

        function showEditTransparency(track, datastring, trans_type) {
            playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
            var cw, ch, initKeyframe, artname, proxy, proxy_h, proxy_w,
                kfvx, kfvy, kfvw, kfvh,
                linked = track.getInkEnabled(),
                linkedTrack = track.getInkLink();

            if (linked) {
                initKeyframe = track.getInkInitKeyframe();
                artname = linkedTrack.getTitle();
                var proxy_div = $("[data-proxy='" + escape(artname) + "']");
                proxy = {
                    x: proxy_div.data("x"),
                    y: proxy_div.data("y"),
                    w: proxy_div.data("w"),
                    h: proxy_div.data("h")
                };

                var keyframe = viewer.captureKeyframe(artname);

                if (!keyframe) {
                    track.setIsVisible(true);
                    creationError("The track this annotation is attached to must be fully on screen in order to edit this annotation. Please seek to a location where the track is visible.");
                    return false;
                }

                if (track.getInkLink().getType() === TAG.TourAuthoring.TrackType.artwork) {
                    kfvx = keyframe.state.viewport.region.center.x;
                    kfvy = keyframe.state.viewport.region.center.y;
                    kfvw = keyframe.state.viewport.region.span.x;
                    kfvh = keyframe.state.viewport.region.span.y;
                }
                else if (track.getInkLink().getType() === TAG.TourAuthoring.TrackType.image) {
                    kfvw = 1.0 / keyframe.state.viewport.region.span.x;
                    var rw = keyframe.state.viewport.region.span.x * $("#rinplayer").width();
                    kfvh = keyframe.state.viewport.region.span.y; // not used
                    kfvx = -keyframe.state.viewport.region.center.x * kfvw;
                    kfvy = -($("#rinplayer").height() / rw) * keyframe.state.viewport.region.center.y;
                }
            }
            

            inkTransparencyControls.css({ 'display': 'none' });
            inkTextControls.css({ 'display': 'none' });
            inkDrawControls.css({ 'display': 'none' });
            inkEditDraw.css('display', 'none');
            inkEditText.css('display', 'none');
            inkEditTransparency.show();

            //var newHeight = functionsPanel.parent().height() - addComponentLabel.offset().top - 10;
            var raTop = $("#resizableArea").offset().top;
            var raHeight = $("#resizableArea").height();
            inkEditTransparency.css({
                "height": raTop + raHeight - inkEditTransparency.offset().top - 10
            });
            

            opacityEditTransparencyLabel.text("Opacity: ");
            opacityEditTransparencyLabel1.text("80%");
            opacityEditTransparencyLabel.append(opacityEditTransparencyLabel1);    
            opacityEditTransparencySliderPoint.css("left", 0.8 * (opacityEditTransparencySlider.offset().left + opacityEditTransparencySlider.width()) / 1.28 + 'px');

            cancelEditTransButton.off('click');
            cancelEditTransButton.on('click', function () {
                track.setIsVisible(true);
                timeline.onUpdate(true);
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
                timeline.hideEditorOverlay();

                currentInkController.remove_all();
                removeInkCanv();
                inkEditTransparency.hide();

                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");

                playbackControls.undoButton.on('click', function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on('click', function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');
            });

            saveTransButton.off("click");
            saveTransButton.on('click', function () {
                saveTrans();
                timeline.hideEditorOverlay();
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
            });

            function saveTrans() {
                var datastr;

                //first, check if the ink is empty
                if (currentInkController.isDatastringEmpty(currentInkController.update_datastring())) {
                    var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                        //delete track
                        track.setIsVisible(true);

                        var command = TAG.TourAuthoring.Command({
                            execute: function () {
                                timeline.removeTrack(track);
                            },
                            unexecute: function () {
                                track.reloadTrack();
                            }
                        });
                        undoManager.logCommand(command);
                        command.execute();
                        //hide ink controls and removeinkcanv
                        inkEditTransparency.hide();
                        removeInkCanv();
                        //change the undomanager back fron ink only
                        playbackControls.undoButton.off('click'); //reset undo/redo buttons to global undo/redo functionality
                        playbackControls.redoButton.off('click');
                        playbackControls.undoButton.on('click', function () {
                            undoManager.undo();
                        });
                        playbackControls.redoButton.on('click', function () {
                            undoManager.redo();
                        });
                        playbackControls.undoRedoInkOnly.css('display', 'none');

                    }, "You have created an empty annotation. Would you like to delete annotation track or go back to editing?", "Delete Track", true);
                    root.append(confirmationBox);
                    $(confirmationBox).show();
                    return;
                }
                if (linked) {
                    var currcanv = $('#inkCanv');

                    var new_proxy_div = $("[data-proxy='" + escape(artname) + "']"); //proxy for the artwork -- keeps track of dimensions
                    var new_proxy = {
                        x: new_proxy_div.data("x"),
                        y: new_proxy_div.data("y"),
                        w: new_proxy_div.data("w"),
                        h: new_proxy_div.data("h")
                    };

                    var new_keyframe = viewer.captureKeyframe(artname);

                    if (!new_keyframe) {
                        creationError("The track this annotation is attached to must be fully on screen in order to save this annotation. Please seek to a location where the track is visible.");
                        return false;
                    }
                    var new_kfvx, new_kfvy, new_kfvw, new_kfvh,
                        linkType = linkedTrack.getType();
                    if (linkType === TAG.TourAuthoring.TrackType.artwork) {
                        new_kfvx = new_keyframe.state.viewport.region.center.x;
                        new_kfvy = new_keyframe.state.viewport.region.center.y;
                        new_kfvw = new_keyframe.state.viewport.region.span.x;
                        new_kfvh = new_keyframe.state.viewport.region.span.y;
                    }
                    else if (linkType === TAG.TourAuthoring.TrackType.image) {
                        new_kfvw = 1.0 / new_keyframe.state.viewport.region.span.x;
                        var rw = new_keyframe.state.viewport.region.span.x * currcanv.width();
                        new_kfvh = new_keyframe.state.viewport.region.span.y; // not used
                        new_kfvx = -new_keyframe.state.viewport.region.center.x * new_kfvw;
                        new_kfvy = -(currcanv.height() / rw) * new_keyframe.state.viewport.region.center.y;
                    }
                    track.setInkInitKeyframe({ "x": new_kfvx, "y": new_kfvy, "w": new_kfvw, "h": new_kfvh });
                    track.setInkRelativeArtPos(currentInkController.getArtRelativePos(new_proxy, currcanv.width(), currcanv.height()));
                }

                //need to convert rectangles/ellipses to paths before updating datastring
                currentInkController.get_trans_shape_data();
                datastr = currentInkController.update_datastring();
                datastr += currentInkController.getBoundingShapes(); //save the rect/ellipse data in case we need to edit again

                var oldDataStr = track.getInkPath();

                var command = TAG.TourAuthoring.Command({
                    execute: function () {
                        track.setInkPath(datastr);
                        timeline.onUpdate(true);
                    },
                    unexecute: function () {
                        track.setInkPath(oldDataStr);
                        timeline.onUpdate(true);
                    },
                });

                track.setIsVisible(true);

                undoManager.logCommand(command);
                command.execute();

                currentInkController.remove_all();
                removeInkCanv();
                inkEditTransparency.hide();

                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");
                playbackControls.undoButton.on("click", function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on("click", function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');

                if (inkAuthoring){
                    inkAuthoring.getInkUndoManager().clear();
                    undoManager.greyOutBtn();
                }
            }
            that.saveTrans = saveTrans;

            hideAll(transEditArray);

            var inkdiv = createInkCanv();
            var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
            $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
            inkAuthoring = p1;
            p1.set_mode(TAG.TourAuthoring.InkMode.shapes); //shape manipulation mode
            p1.set_editable();
            p1.setMarqueeFillOpacity(p1.get_attr(datastring, 'opac', 'f'));
            if (linked) {
                //get the inkController set to load ink in the correct position
                p1.setInitKeyframeData(initKeyframe);
                p1.setArtName(artname);
                cw = $("#inkCanv").width();
                ch = $("#inkCanv").height();
                p1.retrieveOrigDims();
                p1.setEID(track.getTitle());
            }
            var currentMode =datastring.split("mode")[1].split("[")[0].replace("]", "");
            p1.setTransMode(trans_type);
            p1.load_transparency_bounding_shapes(datastring);
            if (currentMode === 'isolate') {
                isolateEditLabel.css({ 'color': 'black' });
                blockEditLabel.css({ 'color': 'gray' });
                transparencyEditMode = 'isolate';
                transEditModeLabel1.text("Isolate");
                p1.setTransMode("isolate");
            }
            if (currentMode === 'block') {
                isolateEditLabel.css({ 'color': 'gray' });
                blockEditLabel.css({ 'color': 'black' });
                transparencyEditMode = 'block';
                transEditModeLabel1.text("Block");
                p1.setTransMode("block");
            }
            if (linked) {
                //now adjust viewbox so art is at the proper coordinates
                var real_kfw = p1.origPaperW / kfvw;
                var real_kfh = real_kfw * proxy_h / proxy_w;
                var real_kfx = -kfvx * real_kfw;
                var real_kfy = -kfvy * real_kfw;
                p1.update_datastring();
                p1.setOldOpac(1);
                p1.adjustViewBoxDiv({ x: proxy.x, y: proxy.y, width: proxy.w, height: proxy.h });
            }
            currentInkController = p1;
            var currOpacity = currentInkController.getMarqueeFillOpacity();
            opacityEditTransparencyLabel1.text(Math.round(100 * currOpacity) + "%");
            opacityEditTransparencyLabel.append(opacityEditTransparencyLabel1);
            opacityEditTransparencySliderPoint.css("left", currOpacity * (opacityEditTransparencySlider.offset().left + opacityEditTransparencySlider.width()) / 1.28 + 'px');

            //call onUpdate to remove the existing ink before reloading it in edit mode
            timeline.onUpdate(true);
            timeline.showEditorOverlay();
        }
        that.showEditTransparency = showEditTransparency;

        /**
         * Method called when "Edit Ink" is clicked on a text-type ink track.
         * See comments for showEditDraw.
         * @param track        the ink track in question
         * @param datastring   the track's ink datastring
         */
        var myEditTextPicker = null;
        function showEditText(track, datastring, dims) {
            playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
            var cw, ch, initKeyframe, rap, artname, proxy,
                linked = track.getInkEnabled(),
                linkedTrack = track.getInkLink();

            if (linked) {
                initKeyframe = track.getInkInitKeyframe();
                artname = linkedTrack.getTitle();

                var proxy_div = $("[data-proxy='" + escape(artname) + "']");
                proxy = {
                    x: proxy_div.data("x"),
                    y: proxy_div.data("y"),
                    w: proxy_div.data("w"),
                    h: proxy_div.data("h")
                };

                var keyframe = viewer.captureKeyframe(artname);
                if (!keyframe) {
                    track.setIsVisible(true);
                    creationError("The track this annotation is attached to must be fully on screen in order to edit this annotation. Please seek to a location where the track is visible.");
                    return false;
                }

                var kfvx, kfvy, kfvw, kfvh,
                    linkType = linkedTrack.getType();
                if (linkType === TAG.TourAuthoring.TrackType.artwork) {
                    kfvx = keyframe.state.viewport.region.center.x;
                    kfvy = keyframe.state.viewport.region.center.y;
                    kfvw = keyframe.state.viewport.region.span.x;
                    kfvh = keyframe.state.viewport.region.span.y;
                }
                else if (linkType === TAG.TourAuthoring.TrackType.image) {
                    kfvw = 1.0 / keyframe.state.viewport.region.span.x;
                    var rw = keyframe.state.viewport.region.span.x * $("#rinplayer").width();
                    kfvh = keyframe.state.viewport.region.span.y; // not used
                    kfvx = -keyframe.state.viewport.region.center.x * kfvw;
                    kfvy = -($("#rinplayer").height() / rw) * keyframe.state.viewport.region.center.y;
                }
            }
            
            hideInkControls();
            inkEditText.show();

            //var newHeight = functionsPanel.parent().height() - addComponentLabel.offset().top - 10;
            var raTop = $("#resizableArea").offset().top;
            var raHeight = $("#resizableArea").height();
            inkEditText.css({
                "height": raTop + raHeight - inkEditText.offset().top - 10
            });
            

            fontEditLabel.text("Font: ");
            fontEditLabel1.text("Times New Roman");
            fontEditLabel.append(fontEditLabel1);
            textEditSliderPoint.css("left", "0px");
            textEditSizeLabel.text("Text Size: ");
            hideAll(textEditArray);

            cancelEditTextButton.off("click");
            cancelEditTextButton.on("click", function () {
                track.setIsVisible(true);
                timeline.onUpdate(true);
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
                timeline.hideEditorOverlay();
                currentInkController.resetText();
                currentInkController.remove_all();
                removeInkCanv();
                inkEditText.hide();

                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");

                playbackControls.undoButton.on("click", function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on("click", function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');
            });

            saveTextButton.off("click");
            saveTextButton.on("click", function () {
                saveText();
                textEditArea.val("");
                textEditBodyLabel1.text("");
                timeline.hideEditorOverlay();
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
            });

            function saveText() {
                //first, check if the ink is empty
                if (currentInkController.isTextboxEmpty()) {
                    var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                        //delete track
                        track.setIsVisible(true);
                        var command = TAG.TourAuthoring.Command({
                            execute: function () {
                                timeline.removeTrack(track);
                            },
                            unexecute: function () {
                                track.reloadTrack();
                            }
                        });
                        undoManager.logCommand(command);
                        command.execute();

                        //hide ink controls and removeinkcanv
                        inkEditText.hide();
                        removeInkCanv();

                        //change the undomanager back fron ink only
                        playbackControls.undoButton.off('click'); //reset undo/redo buttons to global undo/redo functionality
                        playbackControls.redoButton.off('click');
                        playbackControls.undoButton.on('click', function () {
                            undoManager.undo();
                        });
                        playbackControls.redoButton.on('click', function () {
                            undoManager.redo();
                        });
                        playbackControls.undoRedoInkOnly.css('display', 'none');

                    }, "You have created an empty annotation. Would you like to delete annotation track or go back to editing?", "Delete Track", true);
                    root.append(confirmationBox);
                    $(confirmationBox).show();
                    return;
                }
                if (linked) {
                    var currcanv = $('#inkCanv');

                    var new_proxy_div = $("[data-proxy='" + escape(artname) + "']"); //proxy for the artwork -- keeps track of dimensions
                    var new_proxy = {
                        x: new_proxy_div.data("x"),
                        y: new_proxy_div.data("y"),
                        w: new_proxy_div.data("w"),
                        h: new_proxy_div.data("h")
                    };

                    var new_keyframe = viewer.captureKeyframe(artname);

                    if (!new_keyframe) {
                        creationError("The track this annotation is attached to must be fully on screen in order to save this annotation. Please seek to a location where the track is visible.");
                        return false;
                    }
                    var new_kfvx, new_kfvy, new_kfvw, new_kfvh,
                        linkType = linkedTrack.getType();
                    if (linkType === TAG.TourAuthoring.TrackType.artwork) {
                        new_kfvx = new_keyframe.state.viewport.region.center.x;
                        new_kfvy = new_keyframe.state.viewport.region.center.y;
                        new_kfvw = new_keyframe.state.viewport.region.span.x;
                        new_kfvh = new_keyframe.state.viewport.region.span.y;
                    }
                    else if (linkType === TAG.TourAuthoring.TrackType.image) {
                        new_kfvw = 1.0 / new_keyframe.state.viewport.region.span.x;
                        var rw = new_keyframe.state.viewport.region.span.x * currcanv.width();
                        new_kfvh = new_keyframe.state.viewport.region.span.y; // not used
                        new_kfvx = -new_keyframe.state.viewport.region.center.x * new_kfvw;
                        new_kfvy = -(currcanv.height() / rw) * new_keyframe.state.viewport.region.center.y;
                    }
                    track.setInkInitKeyframe({ "x": new_kfvx, "y": new_kfvy, "w": new_kfvw, "h": new_kfvh });
                    track.setInkRelativeArtPos(currentInkController.getArtRelativePos(new_proxy, currcanv.width(), currcanv.height()));
                }

                track.setInkPath(currentInkController.update_datastring()); //======== can call currentInkController.update_datastring here to get the most recent ink path (getDatastring assumes it's already been called)
                removeInkCanv();
                inkEditText.hide();

                track.setIsVisible(true);

                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");

                playbackControls.undoButton.on("click", function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on("click", function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');

                colorTextLabel1.text("#FFFFFF");
                $('#textColorToggle').attr('value', "FFFFFF");

                if (inkAuthoring) {
                    inkAuthoring.getInkUndoManager().clear();
                    undoManager.greyOutBtn();
                }
                timeline.onUpdate();
            }
            that.saveText = saveText;

            var inkdiv = createInkCanv();
            var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
            $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
            inkAuthoring = p1;
            cw = $("#inkCanv").width();
            ch = $("#inkCanv").height();
            p1.set_mode(TAG.TourAuthoring.InkMode.text);
            p1.set_editable();

            var fontsize, line_breaks, num_lines;
            fontsize = p1.get_attr(datastring, "fontsize", 'f') * ch;
            p1.setFontSize(fontsize);
            maxFontSize = Math.max(48, fontsize);
            var str = p1.get_attr(datastring, 'str', 's');
            textEditArea.val(str);
            textEditBodyLabel1.text(str);
            
            var scaleFactor = dims.fontsize / fontsize;

            var w, h;
            try {
                w = p1.get_attr(datastring, 'w', 'f');
                w = linked ? w * scaleFactor : w;
                h = p1.get_attr(datastring, 'h', 'f');
                h = linked ? h * scaleFactor : h;
            } catch (err) {
                w = null;
                h = null;
            }

            if (linked) {
                p1.setInitKeyframeData(initKeyframe);
                p1.setArtName(artname);
                p1.retrieveOrigDims();
                p1.setEID(track.getTitle());
                p1.loadInk(datastring);
                p1.adjustViewBoxDiv({ x: proxy.x, y: proxy.y, width: proxy.w, height: proxy.h });
            }
            var textX = p1.getPannedPos().x || p1.get_attr(datastring, "x", "f") * cw;
            var textY = p1.getPannedPos().y || p1.get_attr(datastring, "y", "f") * ch;
            p1.setFontFamily(p1.get_attr(datastring, "font", 's'));
            p1.setFontColor(p1.get_attr(datastring, "color", 's'));
            p1.add_text_box(textX, textY, w, h, str); // 5px seems to be standard textarea padding
            var svgText = p1.getSVGText();
            
            currentFontSize = fontsize;
            textEditSizeLabel1.text(Math.round(fontsize) + "px");
            textEditSizeLabel.append(textEditSizeLabel1);
            var pointvalue = (fontsize - 8) / (maxFontSize - 8);
            textEditSizeSlider.attr("value", Math.round(fontsize) + "px");
            //console.log(pointleft);
            var currentcolor = p1.get_attr(datastring, "color", 's'); //update the current color
            colorEditTextLabel1.text(currentcolor);
            
            //myPicker = new jscolor.color(itemEditText, {});
            myEditTextPicker.fromString(currentcolor);
            currentInkController = p1;
            firstUpdate();
            updateToggle(textEditArray, textEditArea);

            timeline.onUpdate(true);
            timeline.showEditorOverlay();

        }
        that.showEditText = showEditText;

        functionsPanel.attr('id', 'component-controls');
        functionsPanel.css({
            "background-color": "rgb(219,218,199)",
            "height": "48px",
            "width": "20%",
            'top': '15px',
            'left': '0%',
            'position': 'relative',
            'float': 'left'
        }); // Had to do tops and heights as CSS to prevent overlap on small screens

        /** Drop Down icon
         *  Modified By: Hak
         */
        var addDropDownIconComponent = $(document.createElement('img'));
        addDropDownIconComponent.attr('id', 'addDropDownIconComponent');
        addDropDownIconComponent.attr('src', tagPath + 'images/icons/Down.png');
        addDropDownIconComponent.css({
            'width': '10%',
            'height': '10%',
            'display': 'inline-block',
            'float': 'right',
            'margin-top': '3%',
            'margin-right': '3%'
        });

        /**
         * Add parts of function panel
         */
        // Add Component menu - main button
        var menuOffsetL = '13%';
        var addComponentLabel = $(document.createElement('label'));
        addComponentLabel.text("Add Track");
        addComponentLabel.attr('id', 'addComponentLabel');
        addComponentLabel.css({
            "left": menuOffsetL, "top": "5%", "position": "relative",
            //"font-size": TAG.Util.getFontSize(70),
            "font-size": '70%',
            "color": "rgb(256, 256, 256)",
            //Using the current background color value multiplied by the ( 1- alpha value )
            'background-color': "rgb(63, 55, 53)",
            'padding': '3% 1% 4% 3%',
            'width': '70%',
            'float': 'left',
        });
        addComponentLabel.append(addDropDownIconComponent);
        functionsPanel.append(addComponentLabel);

        //fade overlay appears when AddComponent is opened -- allows addComponent to be closed when clicking away
        var fade = $(document.createElement('div'));
        fade.css({
            width: "100%",
            height: "100%",
            position: "fixed",
            top: '0px',
            left: '0px',
            //'background-color': 'rgba(0,0,0,.5)',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 18
        });
        fade.attr("class", "fade");
        functionsPanel.append(fade);
        fade.hide();

        //fades "Add Component" menus away when click happens outside the menus
        fade.on('mousedown', function (evt) {
            fade.hide();
            componentDropDown = false;
            addDropDownIconComponent.css({ 'transform': 'scaleY(1)', 'margin-bottom': '2%' });
            dropInk.hide();
            dropFile.hide();
            dropMain.hide();
        });

        // Dropdown menus:
        // Main section
        var dropMain = $(document.createElement('div'));
        dropMain.css({
            "left": menuOffsetL,
            "position": "relative",
            "color": "rgb(256, 256, 256)",
            'width': '74%',
            'background-color': 'rgba(0,0,0,0.95)',
            'float': 'left',
            'clear': 'left',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 19
        });
        functionsPanel.append(dropMain);
        dropMain.hide();

        // create the buttons to add various components
        var artButton = _createAddComponentButton("Artwork", dropMain);
        var assetButton = _createAddComponentButton("Associated Media", dropMain);
        var fileButton = _createAddComponentButton("From File", dropMain);
        var inkButton = _createAddComponentButton("Annotate", dropMain);

        //File uploading subsection -Xiaoyi
        var dropFile = $(document.createElement('div'));
        dropFile.css({
            "left": '87%',
            'margin-top': '-33%',
            "position": "relative",
            "color": "rgb(256, 256, 256)",
            'width': '74%',
            'background-color': 'rgba(0,0,0,0.95)',
            'float': 'left',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 19
        }); 
        functionsPanel.append(dropFile);
        dropFile.hide();

        var audioButton = _createAddComponentButton("Audio (MP3)", dropFile);
        var videoButton = _createAddComponentButton("Video (MP4, WEBM, OGV)", dropFile);
        var imageButton = _createAddComponentButton("Image", dropFile);

        function exitInk() {
            removeInkCanv();
            hideInkControls();
            // set undo/redo buttons back to global undo/redo functionality
            playbackControls.undoButton.off("click");
            playbackControls.redoButton.off("click");
            playbackControls.undoButton.on("click", function () {
                undoManager.undo();
            });
            playbackControls.redoButton.on("click", function () {
                undoManager.redo();
            });
            playbackControls.undoRedoInkOnly.css({ 'display': 'none' });
        }

        /**
         * Opens the correct file picker based on the file type
         */
        function pickFile() {
            var type, names = [],
                title = $(this).text(),
                //toConvertDecisions = [],
                initLoc = timeManager.getCurrentPx(),
                mediaLengths = [], i, upldr,
                mediaFiles;

            isUploading = true;
            // Get music properties
            function getMusicPropertiesHelper(files, i, callback) {
                var file = files[i];
                try {
                    file.properties.getMusicPropertiesAsync().done(function (musicProperties) {
                        mediaLengths.push(musicProperties.duration / 1000); // get duration in seconds
                        if (i < files.length - 1) {
                            getMusicPropertiesHelper(files, i + 1, callback);
                        } else {
                            callback && callback();
                        }
                    }, function (error) {
                        console.log(error);
                    });
                } catch (err) {
                    console.log(err.message);
                    mediaLengths.push(TAG.TourAuthoring.Constants.maxTourLength);
                    if (i < files.length - 1) {
                        getMusicPropertiesHelper(files, i + 1, callback);
                    } else {
                        callback && callback();
                    }
                }
            }

            if (title === "Audio (MP3)") {
                upldr = TAG.Authoring.FileUploader(root, TAG.Authoring.FileUploadTypes.Standard,
                function (files) {
                    var file;
                    for (i = 0; i < files.length; i++) {
                        file = files[i];
                        names.push(file.displayName);
                        //if (file.fileType === '.mp3') {
                        //    type = TAG.TourAuthoring.TrackType.audio;
                        //    getMusicPropertiesHelper(file);
                        //}
                    }
                    type = TAG.TourAuthoring.TrackType.audio;
                    mediaFiles = files;
                },
                function (urls) {
                    getMusicPropertiesHelper(mediaFiles, 0, urlsCallback);
                    function urlsCallback() {
                        var url, name, mediaLength;
                        for (i = 0; i < urls.length; i++) {
                            url = urls[i];
                            name = names[i];
                            mediaLength = mediaLengths[i];
                            var track = timeline.addAudioTrack(url, name, null, mediaLength);

                            var positionX = initLoc;
                            var displayLength = mediaLength;
                            //track.addDisplay(positionX, displayLength);
                            if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                            }
                            var diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                            var newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                 track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                 track.addDisplay(positionX, Math.min(diff, displayLength));

                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                        }
                        undoManager.combineLast(2 * urls.length);
                        isUploading = false;
                        timeline.getDataHolder().mapTracks(function (container, i) {
                            container.track.updatePos(i);
                        });
                    }
                },
                ['.mp3'],
                false,
                function () {
                    root.append(TAG.Util.UI.popUpMessage(null, "There was an error uploading the file. Please try again later."));
                },
                true);
                upldr.setMaxDuration(TAG.TourAuthoring.Constants.maxTourLength);
                upldr.setMinDuration(TAG.TourAuthoring.Constants.minMediaLength);
            }

            function getVideoPropertiesHelper(files, i, callback) {
                var file = files[i];
                try {
                    file.properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        mediaLengths.push(VideoProperties.duration / 1000); // get duration in seconds
                        if (i < files.length - 1) {
                            getVideoPropertiesHelper(files, i + 1, callback);
                        } else {
                            callback && callback();
                        }
                    },
                    function (error) {
                        console.log(error);
                    });
                } catch (err) {
                    mediaLengths.push(TAG.TourAuthoring.Constants.maxTourLength);
                    if (i < files.length - 1) {
                        getVideoPropertiesHelper(files, i + 1, callback);
                    } else {
                        callback && callback();
                    }
                }
            }

            if (title === "Video (MP4, WEBM, OGV)") {
                upldr = TAG.Authoring.FileUploader(root, TAG.Authoring.FileUploadTypes.Standard,
                function (files, localURLs, confirmCallback, cancelCallback) {
                    var file,
                        total = files.length,
                        decided = 0,
                        decisions = [];
                    for (i = 0; i < files.length; i++) {
                        file = files[i];
                        names.push(file.displayName);
                        //var toUpload = true;
                        //if (file.fileType !== '.mp4') {
                        //var confirmBox = TAG.Util.UI.PopUpConfirmation(function () {
                        //    decisions.push(true);
                        //    if (++decided >= total) {
                        //        confirmCallback && confirmCallback();
                        //    }
                        //}, "This video is not in a compatible format. Would you like us to convert " + file.displayName + " for you?", "Yes", true, (function (curfile) {
                        //    return function () {
                        //        decisions.push(false);
                        //        if (++decided >= total) {
                        //            confirmCallback && confirmCallback();
                        //        }
                        //    };
                        //})(file));
                        //root.append(confirmBox);
                        //$(confirmBox).show();
                        //} else {//file is Mp4, ask users if they still want to convert it. Regardless, upload the video
                        //var confirmBox = TAG.Util.UI.PopUpConfirmation((function (index) {
                        //    return function () {
                        //        decisions.push(true);
                        //        if (++decided >= total) {
                        //            confirmCallback && confirmCallback();
                        //        }
                        //    };
                        //})(i), "Video " + file.displayName + " is already MP4. Would you like us to convert it to other formats for different browsers for you?", "Yes", true, function () {
                        //    if (++decided >= total) {
                        //        decisions.push(false);
                        //        confirmCallback && confirmCallback();
                        //    }
                        //});
                        //root.append(confirmBox);
                        //$(confirmBox).show();
                    }
                    //return toUpload;
                    //}
                    //if (decided >= total) {
                    //    confirmCallback && confirmCallback();
                    //}
                    confirmCallback && confirmCallback();
                    type = TAG.TourAuthoring.TrackType.video;
                    mediaFiles = files;
                    //toConvertDecisions = decisions;
                    return 'uploading test!';
                },
                function (urls) {
                    getVideoPropertiesHelper(mediaFiles, 0, urlsCallback);
                    function urlsCallback() {
                        var url,
                            name,
                            mediaLength,
                            track,
                            positionX,
                            displayLength,
                            diff,
                            newDisplay;
                        for (i = 0; i < urls.length; i++) {
                            url = urls[i];
                            name = names[i];
                            mediaLength = mediaLengths[i];
                            //if (toConvertDecisions[i] === true) {
                            var newFileName = urls[i].slice(8, urls[i].length);
                            var index = newFileName.lastIndexOf(".");
                            var fileExtension = newFileName.slice(index);
                            var baseFileName = newFileName.slice(0, index);
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, newFileName, fileExtension, baseFileName, null, "True");
                            //}
                            var track = timeline.addVideoTrack(url, name, null, mediaLength, true, false,true);
                            var positionX = initLoc;
                            var displayLength = mediaLength;
                            if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                            }
                            var diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                            if (displayLength !== 0 && mediaFiles[i].fileType === '.mp4') {//check if the video is mp4 and we currently can get the length of the video
                                var newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                 track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                 track.addDisplay(positionX, Math.min(diff, displayLength));
                            } else {//else we don't add a display and also gray out the track
                                //videos2Convert.push(track);
                                track.changeTrackColor("gray");
                            }
                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                            //check if the video is not mp4 and the medialength is 0, remove display. gray out the track
                        }
                        undoManager.combineLast(2 * urls.length);
                        isUploading = false;
                        timeline.getDataHolder().mapTracks(function (container, i) {
                            container.track.updatePos(i);
                        });
                    }
                },
            ['.mp4', '.webm', '.ogv','.avi','.mov','.wma'],//'.avi','.mov','.wma'
                false,
                function () {
                    root.append(TAG.Util.UI.popUpMessage(null, "There was an error uploading the file.  Please try again later."));
                },
                true);
                upldr.setMaxDuration(TAG.TourAuthoring.Constants.maxTourLength);
                upldr.setMinDuration(TAG.TourAuthoring.Constants.minMediaLength);
            }
            if (title === "Image") {
                TAG.Authoring.FileUploader(root, TAG.Authoring.FileUploadTypes.Standard,
                function (files) {
                    for (i = 0; i < files.length; i++) {
                        names.push(files[i].displayName);
                    }
                },
                function (urls) {
                    for (i = 0; i < urls.length; i++) {
                        var track = timeline.addImageTrack(urls[i], names[i].replace(/\'/, '').replace(/\"/, ''));
                        var dispLen = Math.min(5, timeManager.getDuration().end - timeManager.pxToTime(initLoc));
                        var newDisplay = (dispLen < TAG.TourAuthoring.Constants.displayEpsilon) ? track.addDisplay(timeManager.timeToPx(timeManager.getDuration().end - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) : track.addDisplay(initLoc, dispLen);
                        if (dispLen < 1.5 && dispLen >= TAG.TourAuthoring.Constants.displayEpsilon) {
                            newDisplay.setIn(0);
                            newDisplay.setOut(0);
                            newDisplay.setMain(dispLen);
                        }
                        
                        if (timeline.getTracks().length > 0) { // reload tour?
                            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                        }
                    }
                    undoManager.combineLast(2 * urls.length);
                    isUploading = false;
                    timeline.getDataHolder().mapTracks(function (container, i) {
                        container.track.updatePos(i);
                    });
                },
                ['.jpg', '.png', '.gif', '.tif', '.tiff'],
                false,
                function () {
                    root.append(TAG.Util.UI.popUpMessage(null, "There was an error uploading the file.  Please try again later."));
                },
                true);
            }

        }

        // Ink subsection
        var dropInk = $(document.createElement('div'));
        dropInk.css({
            "left": '87%',
            'margin-top': '-16.5%',
            "position": "relative",
            "color": "rgb(256, 256, 256)",
            'width': '74%',
            'background-color': 'rgba(0,0,0,0.95)',
            'float': 'left',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 19
        });
        functionsPanel.append(dropInk);
        dropInk.hide();

        // create ink buttons
        _createAddComponentButton("Write", dropInk);
        _createAddComponentButton("Draw", dropInk);
        _createAddComponentButton("Highlight", dropInk);

        /**
         * Creates component menu buttons
         * @param title         Name of button
         * @param component     DOM element to add button to
         *@return addComponentButton     the button created.
         */
        function _createAddComponentButton(title, component) {
            var addComponentButton = $(document.createElement('label'));
            if (title === "From File")
                addComponentButton.addClass('clickable ' + 'files');
            else
                addComponentButton.addClass('clickable ' + title);
            addComponentButton.text(title);
            addComponentButton.css({
                "left": "0%",
                "position": "relative",
                "font-size": '80%',
                "color": "rgb(256, 256, 256)",
                "display": "block",
                'padding': '2% 0 2% 0',
                'text-indent': '4%',
                'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 19
            });

            addComponentButton.on('mouseenter', function () {
                var self = $(this);
                self.css({ 'background-color': 'white', 'color': 'black' });

                switch (self.text()) {
                    case "Artwork":
                    case "Associated Media":
                        dropInk.hide();
                        dropFile.hide();
                        break;
                    case "From File":
                        dropFile.show();
                        dropInk.hide();
                        break;
                    case "Audio (MP3)":
                    case "Video (MP4, WEBM, OGV)":
                    case "Image":
                        isInFileSubMenu = true;
                        break;
                    case "Annotate":
                        if (allowInk) {
                            dropInk.show();
                            dropFile.hide();
                            //$(assetButton).data('selected', false);
                        }
                        else {
                            self.css({
                                'background-color': 'transparent',
                                'color': 'gray'
                            });
                        }
                        break;
                    case "Write":
                    case "Draw":
                    case "Highlight":
                        isInInkSubMenu = true;
                        break;
                }
            });

            addComponentButton.on('mouseleave', function () {
                var self = $(this);

                self.css({ 'background-color': 'transparent', 'color': 'white' });

                if (self.text() === "Annotate" && !allowInk) {
                    self.css({ 'background-color': 'transparent', 'color': 'gray' });
                }

                if (fileClick || inkClick || isInFileSubMenu || isInInkSubMenu) {
                    return;
                }

                dropFile.hide();
                dropInk.hide();
            });

            addComponentButton.on('mousedown', function (evt) {
                evt.stopImmediatePropagation();
            });

            addComponentButton.on('click', function (evt) {
                if (timeline.getEditInkOn() === true) {
                    var messageBox = TAG.Util.UI.popUpMessage(null, "An annotation is already being edited.", null);
                    $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 2000000);
                    $("#resizableArea").parent().parent().append(messageBox);
                    closeComponentMenu();
                    $(messageBox).fadeIn(500);
                    return;
                }

                evt.stopImmediatePropagation();

                var self = $(this);
                // reset css of any previously selected menu items
                for (var i = 0; i < prevSelected.length; i++) {
                    if (self !== $(prevSelected[i])) {
                        ($(prevSelected[i])).css({ 'background-color': 'transparent', 'color': 'white' });
                    }
                }
                prevSelected[prevSelected.length] = this;

                //for being able to close addComponent by clicking away (only the following two have submenus)
                switch (self.text()) {
                    case "Artwork": // change these to not check by title of the button! changing the button title will break this
                        exitInk();
                        self.css({
                            'background-color': 'white',
                            'color': 'black'
                        });
                        hideInkControls();
                        removeInkCanv();
                        closeComponentMenu();
                        _catalogPick();
                    break;

                    case "Associated Media":
                        exitInk();
                        self.css({
                            'background-color': 'white',
                            'color': 'black'
                        });
                        inkButton.data('selected', false);
                        hideInkControls();
                        removeInkCanv();
                        closeComponentMenu();
                        _associatedMediaPick();
                        break;

                    case "From File":
                        self.css({
                            'background-color': 'white',
                            'color': 'black'
                        });
                        dropFile.show();
                        dropInk.hide();
                        assetButton.data('selected', false);
                        fileClick = true;
                        break;

                    case "Audio (MP3)":
                    case "Video (MP4, WEBM, OGV)":
                    case "Image":
                        closeComponentMenu();
                        exitInk();
                        hideInkControls();
                        removeInkCanv();
                        isInFileSubMenu = true;
                        // use call b/c this needs to be set in pickFile
                        pickFile.call(addComponentButton);
                        break;

                    case "Annotate":
                        if (allowInk) {
                            self.css({
                                'background-color': 'white',
                                'color': 'black'
                            });
                            dropInk.show();
                            dropFile.hide();
                            $(assetButton).data('selected', false);
                            inkClick = true;
                        }
                        break;

                    case "Write":
                        $('.undoButton').css({ 'opacity': '0.4' });
                        $('.redoButton').css({ 'opacity': '0.4' });
                        self.css({
                            'background-color': 'white',
                            'color': 'black'
                        });
                        inkButton.data('selected', false);
                        playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
                        closeComponentMenu();
                        hideInkControls();
                        inkTextControls.show();
                        var newHeight = $("#resizableArea").offset().top + $("#resizableArea").height() - inkTextControls.offset().top - 10;
                        inkTextControls.css({ 'height': newHeight});
                        initText();

                        //create an ink canvas and inkController
                        var inkdiv = createInkCanv();
                        var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
                        $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
                        inkAuthoring = p1;
                        p1.resetText();
                        p1.add_text_box();
                        p1.setFontColor("FFFFFF");
                        p1.setFontFamily("Times New Roman, serif");
                        p1.setFontSize("12");
                        p1.set_mode(TAG.TourAuthoring.InkMode.text);
                        p1.set_editable(); //in this case, we're just making sure that the artwork can't be manipulated
                        currentInkController = p1;
                        textArea.val("");
                        textBodyLabel1.text("");
                        colorTextLabel1.text("#FFFFFF");
                        $('#textColorToggle').attr('value', "FFFFFF");
                        myPicker.fromString("FFFFFF");
                        $('.changeColor')[0].innerHTML = "#" + $("#textColorToggle").attr('value');
                        updateToggle(textArray, textArea);
                        timeline.setEditInkOn(true);
                        break;

                    case "Draw":
                        $('.undoButton').css({ 'opacity': '0.4' });
                        $('.redoButton').css({ 'opacity': '0.4' });
                        self.css({ 'background-color': 'white', 'color': 'black' });
                        playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
                        inkButton.data('selected', false);
                        closeComponentMenu();
                        hideInkControls();
                        inkDrawControls.css({ 'display': 'block' });

                        // here, we set the initial height of the ink draw controls, so they can be resized appropriately
                        var raTop = $("#resizableArea").offset().top;
                        var raHeight = $("#resizableArea").height();
                        inkDrawControls.css("height", raTop + raHeight - inkDrawControls.offset().top - 10);

                        initDraw();
                        colorLabel1.text("#000000");
                        myPicker.fromString("000000"); //jscolor picker

                        //create ink canvas and inkController
                        var inkdiv = createInkCanv();
                        var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
                        $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
                        inkAuthoring = p1;
                        p1.set_mode(TAG.TourAuthoring.InkMode.draw);
                        p1.set_editable(); // give the canvas pointer events
                        p1.updatePenWidth("brushSlider");
                        p1.updatePenColor("brushColorToggle");
                        p1.updatePenOpacity("opacitySlider");
                        currentInkController = p1;
                        timeline.setEditInkOn(true);

                        break;

                    case "Highlight":
                        $('.undoButton').css({ 'opacity': '0.4' });
                        $('.redoButton').css({ 'opacity': '0.4' });
                        self.css({ 'background-color': 'white', 'color': 'black' });
                        playbackControls.undoRedoInkOnly.css({ 'display': 'block' });
                        inkButton.data('selected', false);
                        closeComponentMenu();
                        hideInkControls();
                        inkTransparencyControls.show();
                        var newHeight = $("#resizableArea").offset().top + $("#resizableArea").height() - inkTransparencyControls.offset().top - 10;
                        inkTransparencyControls.css({ 'height': newHeight });
                        initTrans();

                        //create an ink canvas and inkController
                        var inkdiv = createInkCanv();
                        var p1 = new TAG.TourAuthoring.InkAuthoring("inkCanv", null, "componentControls", spec);
                        $('#inkCanv').css("background", "rgba(0,0,0,0.01)");
                        inkAuthoring = p1;
                        p1.set_mode(TAG.TourAuthoring.InkMode.shapes);
                        p1.set_editable(); //in this case, we're just making sure that the artwork can't be manipulated
                        currentInkController = p1;
                        timeline.setEditInkOn(true);
                        break;
                }

                // if this is already selected, unselect it -- this 'selected' stuff might be unnecessary
                var selected = self.data('selected');
                if (selected) {
                    self.css({ 'background-color': 'transparent', 'color': 'white' });
                }
                self.data('selected', !selected);
                if (!allowInk) {
                    inkButton.css({ 'background-color': 'transparent', 'color': 'gray' });
                }
            });

            component.append(addComponentButton);
            return addComponentButton;
        }

        var prevSelected = [];
        var allowInk = false;
        var componentDropDown = false;
        var currentInkController;
        /**
         * Called when all artworks
         are deleted; disables ink functionality by graying out "Ink" button
         */
        function disableInk() {
            allowInk = false;
            inkButton.css({ 'background-color': 'transparent', 'color': 'gray' });
            dropInk.hide();
            inkTransparencyControls.css({ 'display': 'none' });
            inkTextControls.css({ 'display': 'none' });
            inkDrawControls.css({ 'display': 'none' });
            inkEditDraw.css({ 'display': 'none', });
            inkEditTransparency.css('display', 'none');
            inkEditText.css('display', 'none');
            timeline.setEditInkOn(false);
            timeline.setModifyingInk(false);
            //if ink is currently being edited but is unattached, remove it if there are no artworks left
            removeInkCanv();
        }
        that.disableInk = disableInk;

        function closeComponentMenu() {
            // set componentDropDown state to true
            // to force close
            componentDropDown = true;
            addComponentLabel.click();
        }

        addComponentLabel.on('mousedown', function (evt) {
            evt.stopImmediatePropagation();
        });

        /**
         * "Add Component" button click handler.
         * Allows user to drop menus and exit out of menus by clicking elsewhere.
         */
        addComponentLabel.click(function (evt) {
            if (timeline.getEditInkOn() === true) {
                return;
            }
            var i, prev,
                closeFunc = timeline.getCloseMenu();
            if (closeFunc && closeFunc !== closeComponentMenu) {
                closeFunc();
            }

            //console.log('addcomponent click');

            evt.stopImmediatePropagation();

            // flip state
            componentDropDown = !componentDropDown;

            // hide submenus
            dropInk.hide();
            dropFile.hide();

            // close --> open
            if (componentDropDown) {
                dropMain.show();

                root.on('mousedown.componentMenu', closeComponentMenu);

                timeline.setisMenuOpen(true);
                timeline.setCloseMenu(closeComponentMenu);

                timeManager.stop();

                addDropDownIconComponent.css({
                    'transform': 'scaleY(-1)',
                    'margin-bottom': '2%'
                });

                //reseting all menu items to normal font thickness
                $(".thicknessLabel").css({ 'font-weight': 'normal' });

                // Reset any selected menu items to regular CSS
                // and unselected state
                for (i = 0; i < prevSelected.length; i++) {
                    prev = $(prevSelected[i]);
                    prev.css({
                        'background-color': 'transparent',
                        'color': 'white'
                    });
                    prev.data('selected', false);
                }

                // check to see if ink can be added
                // (only allow ink if there are artworks or images)
                if (!timeline.checkForArtworks(0)) {
                    allowInk = false;
                    inkButton.css({
                        'background-color': 'transparent',
                        'color': 'gray'
                    });
                }
                else {
                    allowInk = true;
                    inkButton.css({
                        'background-color': 'transparent',
                        'color': 'white'
                    });
                }
            }

            // open --> close
            else {
                dropMain.hide();

                root.off('mousedown.componentMenu');
                timeline.setCloseMenu(null);
                timeline.setisMenuOpen(false);

                addDropDownIconComponent.css({
                    'transform': 'scaleY(1)',
                    'margin-bottom': '0%'
                });
            }
        });

        /**
         * Hover colors for "Add Component" menu items
         */
        var isInFileSubMenu = false;
        var isInInkSubMenu = false;
        var fileClick = true;
        var inkClick = true;

        /**
         * Creates catalog picker for associated media related to the artwork already imported into the tour (Jessica Fu)
         */
        // picker
        associatedMediaPicker.addClass("associatedMediaPicker");
        associatedMediaPicker.css({
            position: 'absolute',
            width: '49%',
            height: '49%',
            padding: '1%',
            'background-color': 'black',
            'border': '3px double white',
            top: '25%',
            left: '25%',
        });
        $(associatedMediaPickerOverlay).append(associatedMediaPicker);

        // heading
        var associatedMediaPickerHeader = document.createElement('div');
        $(associatedMediaPickerHeader).addClass('associatedMediaPickerInfo');
        $(associatedMediaPickerHeader).text("Select media to import");
        $(associatedMediaPickerHeader).css({
            'font-size': '100%',
        });
        var associatedsearchbar = $(document.createElement('input'));
        associatedsearchbar.attr('type', 'text');
        $(associatedsearchbar).css({
            'float': 'right',
            'margin-right': '3%',
            'margin-top': '0.75%',
            'width': '38%',
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size': 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position': '8px center'
        });
        $(associatedsearchbar).on('focus', function () {
            $(associatedsearchbar).css({
                'background-image': ''
            });
        });
        $(associatedsearchbar).on('focusout blur', function () {
            if (!associatedsearchbar.val()) {
                $(associatedsearchbar).css({
                    'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")'
                });
            }
        });

        $(associatedsearchbar).on('keyup', function (event) {
            if (!pickerloaded)
                return;
            event.stopPropagation();
        });
        //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
        associatedsearchbar.val("");
        //TAG.Util.defaultVal(PICKER_SEARCH_TEXT, associatedsearchbar, true, IGNORE_IN_SEARCH);
        associatedsearchbar.keyup(function () {
            if (!pickerloaded)
                return; 
            TAG.Util.searchData(associatedsearchbar.val(), '.mediaHolder', IGNORE_IN_SEARCH);
        });

        $(associatedMediaPickerHeader).append(associatedsearchbar);

        associatedMediaPicker.append(associatedMediaPickerHeader);

        // list of artworks in tour that have associated media
        var associatedMediaPickerArtwork = document.createElement('div');
        $(associatedMediaPickerArtwork).addClass('associatedMediaPickerArtwork');
        $(associatedMediaPickerArtwork).css({
            position: 'absolute',
            'border-right': '1px solid white',
            top: '15%',
            padding: '1%',
            height: '72%',
            width: '28%',
            overflow: 'auto',
        });
        associatedMediaPicker.append(associatedMediaPickerArtwork);

        // list of associated media
        var associatedMediaPickerMedia = document.createElement('div');
        $(associatedMediaPickerMedia).addClass('associatedMediaPickerMedia');
        $(associatedMediaPickerMedia).css({
            position: 'absolute',
            left: '33%',
            top: '15%',
            padding: '1%',
            height: '72%',
            width: '62%',
            overflow: 'auto',
        });
        associatedMediaPicker.append(associatedMediaPickerMedia);

        /**
         * Get associated media for all artworks in the tour from the server.
         * Creates the media picker dom elements.
         */
        var selectedArtworks = [];
        var artworkIndicesViaURL = [];
        var selectedArtworksUrls = {};
        function _associatedMediaPick() {
            selectedArtworks = [];
            artworkIndicesViaURL = [];
            selectedArtworksUrls = {};
            isUploading = true;
            $(associatedMediaPickerOverlay).fadeIn();
            mediaQueue.clear();

            //create a loading circle(to be displayed while artworks are loading)
            var loading = $(document.createElement('div'));
            loading.css({
                'display': 'inline-block',
                'position': 'absolute',
                'left': '3%',
                'bottom': '2%',
            });
            loading.text('Loading...');
            loading.attr('id', 'associatedLoadingLabel');

            var circle = $(document.createElement('img'));
            circle.attr('src', tagPath + 'images/icons/progress-circle.gif');
            circle.css({
                'height': '12px',
                'width': 'auto',
                'margin-left': '20px',
                'float': 'right',
            });
            loading.append(circle);

            associatedMediaPicker.append(loading);


            var myArtwork = timeline.getRelatedArtworks();


            // draw "All Associated Media" Label
            var allAssociatedMediaHolder = document.createElement('div');
            $(allAssociatedMediaHolder).addClass('allAssociatedMediaHolder');
            $(allAssociatedMediaHolder).css({
                width: '100%',
                height: '9%',
                margin: '1px 0px 1px 0px',
                background: '#999',
                'padding-left': '3%',
                'padding-top': '3%',
                'font-size': '70%'
            });
            $(allAssociatedMediaHolder).text('All Associated Media');
            $(associatedMediaPickerArtwork).append(allAssociatedMediaHolder);

            var mediaCache = {};

            // draw artwork name labels
            var myFilteredArtwork = [];
            var unique;
            for (var i = 0; i < myArtwork.length ; i++) {
                unique = true;
                for (var j = 0; j < i; j++) {
                    if (myArtwork[j] === myArtwork[i]) {
                        unique = false;
                        break;
                    }
                }
                //unique ? myFilteredArtwork.push(myArtwork[i]) : {};
                if (unique) {
                    myFilteredArtwork.push(myArtwork[i]);
                }
            }
            for (var k = 0; k < myFilteredArtwork.length; k++) {
                getArt(k);
            }

            loading.hide(); //hides the loading circle once art is recieved

            //single clicking on associated media selects it, to be imported
            function mediasingleClick(e, mediaHolder) {
                if (mediaHolder) {
                    var index;
                    //$(".mediaHolder").css('background', '#222');
                    if (mediaHolder.data("selected")) {
                        mediaHolder.data("selected", false);
                        mediaHolder.css('background', '#222');
                        index = artworkIndicesViaURL.indexOf(mediaHolder.data('url'));
                        selectedArtworks.splice(index, 1);
                        artworkIndicesViaURL.splice(index, 1);
                        selectedArtworksUrls[mediaHolder.data('url')] = false;
                        associatedMediaPickerImport.disabled = selectedArtworks.length ? false : true;
                    }
                    else {
                        mediaHolder.data({
                            "selected": true
                        });
                        mediaHolder.css('background', '#999');
                        selectedArtworks.push({ 'url': mediaHolder.data('url'), 'name': mediaHolder.data('name'), 'id': mediaHolder.attr('id'), 'type': mediaHolder.data('type'), 'duration': mediaHolder.data('duration') });
                        artworkIndicesViaURL.push(mediaHolder.data('url'));
                        selectedArtworksUrls[mediaHolder.data('url')] = true;
                        associatedMediaPickerImport.disabled = false;
                    }
                }
            }

            //double clicking on associated media will import all selected media
            function mediadoubleClick(e,mediaHolder) {
                if (mediaHolder) {
                    var i, selectedArt, track, positionX, displayLength, newDisplay, diff;
                    mediaHolder.css('background', '#999');
                    
                    if (mediaHolder.data('selected') !== true) {
                        selectedArtworks.push({ 'url': mediaHolder.data('url'), 'name': mediaHolder.data('name'), 'id': mediaHolder.attr('id'), 'type': mediaHolder.data('type'), 'duration': mediaHolder.data('duration') });
                        mediaHolder.data({
                        "selected": true
                    });}
                    _clearAssMedia(); // interesting name....
                    $(associatedMediaPickerOverlay).fadeOut();
                    //console.log(selectedArt.type);
                    associatedMediaPickerImport.disabled = true;
                    //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                    if (selectedArtworks && selectedArtworks.length) {
                        for (i = 0; i < selectedArtworks.length; i++) {
                            selectedArt = selectedArtworks[i];
                            if (selectedArt.type === "Video") {
                                track = timeline.addVideoTrack(selectedArt.url, selectedArt.name, null, selectedArt.duration);
                                positionX = timeManager.getCurrentPx();
                                displayLength = parseFloat(selectedArt.duration);
                                // track.addDisplay(positionX, displayLength);
                                if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                    timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                                }
                                diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                                newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                     track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                     track.addDisplay(positionX, Math.min(diff, displayLength));
                                if (timeline.getTracks().length > 0) {
                                    timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                                }
                            } else if (selectedArt.type === "Image") {
                                track = timeline.addImageTrack(selectedArt.url, selectedArt.name);
                                positionX = timeManager.getCurrentPx();
                                displayLength = 5;
                                var dispLen = Math.min(displayLength, timeManager.getDuration().end - timeManager.pxToTime(positionX));
                                newDisplay = (dispLen < TAG.TourAuthoring.Constants.displayEpsilon) ? track.addDisplay(timeManager.timeToPx(timeManager.getDuration().end - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) : track.addDisplay(positionX, dispLen);
                                if (dispLen < 1.5 && dispLen >= TAG.TourAuthoring.Constants.displayEpsilon) {
                                    newDisplay.setIn(0);
                                    newDisplay.setOut(0);
                                    newDisplay.setMain(dispLen);
                                }
                                if (timeline.getTracks().length > 0) {
                                    timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                                }
                            } else if (selectedArt.type === "Audio") {
                                track = timeline.addAudioTrack(selectedArt.url, selectedArt.name, null, selectedArt.duration);
                                positionX = timeManager.getCurrentPx();
                                displayLength = parseFloat(selectedArt.duration);
                                //if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                //    timeManager.setEnd(displayLength + timeManager.pxToTime(positionX));
                                //}
                                //track.addDisplay(positionX, displayLength);
                                if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                    timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                                }
                                diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                                newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                     track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                     track.addDisplay(positionX, Math.min(diff, displayLength));
                                if (timeline.getTracks().length > 0) {
                                    timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                                }
                            } else {
                                console.log('Unrecognized file type imported!!!???');
                            }
                        }
                        undoManager.combineLast(2 * selectedArtworks.length);
                    }
                }
                //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                associatedsearchbar.val("");
                isUploading = false;
                timeline.getDataHolder().mapTracks(function (container, i) {
                    container.track.updatePos(i);
                });
            }

            //this handles discriminating between the double and single clicks for importing media
            //cleans up bugs where both click events were firing and media would import twice
            function assMediasingleDoubleclick(mediaHolder) {
                mediaHolder.click(function (e) {
                    var that = this;
                    setTimeout(function () {
                        var dblclick = parseInt($(that).data('double'), 10);
                        if (dblclick > 0) {
                            $(that).data('double', dblclick - 1);
                        } else {
                            mediasingleClick.call(that, e, mediaHolder);
                        }
                    }, 300);
                }).dblclick(function (e) {
                    $(this).data('double', 2);
                    mediadoubleClick.call(this, e, mediaHolder);
                });
            }
            
            function getArt(i) {
                // get associated media and cache them in array associated with the guid of each artwork
                TAG.Worktop.Database.getAssocMediaTo(myFilteredArtwork[i], function (doqs) {
                    doqs.sort(function (a, b) {
                        return a.Name.toLowerCase() < b.Name.toLowerCase() ? -1 : 1;
                    });
                    var mediaArray = [];
                    if (doqs) {
                        var k = 0;
                        var doq;
                        for (var j = 0; j < doqs.length; j++) {
                            //var hotspotDoqID = linqs[j].Targets.BubbleRef[1].BubbleContentID;
                            k++;
                            doq = doqs[j];
                            var c1 = (doq.Metadata.ContentType === 'Video' || doq.Metadata.ContentType === 'Audio');
                            var c2 = (doq.Metadata.Duration <= TAG.TourAuthoring.Constants.maxTourLength && doq.Metadata.Duration >= TAG.TourAuthoring.Constants.minMediaLength);
                            var c3 = (c2 || doq.Metadata.Duration === undefined);
                            if ((c1 && c3) || doq.Metadata.ContentType === 'Image') {//make sure no text associated media for now
                                mediaArray.push(doq);
                            }
                            if (k === doqs.length) { // just put this outside loop
                                mediaCache[myFilteredArtwork[i]] = mediaArray;
                                if (mediaArray.length > 0) { //only shows artworks with at least one associated media
                                    var mediaHolderDocfrag = document.createDocumentFragment();
                                    drawAssociatedMedia(mediaCache[myFilteredArtwork[i]], assMediasingleDoubleclick, mediaHolderDocfrag);// create dom elements for this artwork's associated media
                                    // retrieve titles of artworks that have at least one associated media, create divs for them in the artwork list
                                    TAG.Worktop.Database.getDoq(myFilteredArtwork[i], function (nextArt) {
                                        var name;
   
                                        if (nextArt.Name.length > 15) {
                                            var hasSpace = false;
                                            var scanLength = Math.min(nextArt.Name.length, 25);
                                            for (var j = 14; j < scanLength ; j++) {
                                                if (nextArt.Name[j] === " " && !hasSpace) {
                                                    name = nextArt.Name.substr(0, j) + "...";
                                                    hasSpace = true;
                                                } else if (nextArt.Name[j] === "-" && j !== (scanLength - 1) && !hasSpace) {
                                                    if (nextArt.Name[j + 1] === " ") {
                                                        name = nextArt.Name.substr(0, j) + "...";
                                                        hasSpace = true;
                                                    }
                                                }
                                            }
                                            if (!hasSpace) {
                                                name = nextArt.Name.substr(0, 25) + "...";
                                            }
                                        } else {
                                            name = nextArt.Name;
                                        }

                                        var artworkHolder = document.createElement('div');
                                        $(artworkHolder).addClass('artworkHolder');
                                        $(artworkHolder).attr('id', nextArt.Identifier);
                                        $(artworkHolder).css({
                                            width: '100%',
                                            height: '9%',   
                                            margin: '1px 0px 1px 0px',
                                            'font-size': '70%',
                                            'padding-left': '3%',
                                            'padding-top': '3%',
                                        });
                                        $(artworkHolder).text(name);
                                        $(associatedMediaPickerArtwork).append(artworkHolder);
                                        artworkHolderClick($(artworkHolder));
                                    });
                                }
                            }
                        }
                    }
                });
            }

            // "All Associated Media" button click handler
            $(allAssociatedMediaHolder).click(function () {
                $(".artworkHolder").css('background', 'black');
                $(allAssociatedMediaHolder).css('background', '#999');
                $(".mediaHolder").detach();
                for (var i = 0; i < myArtwork.length; i++) {
                    var allAMDocfrag = document.createDocumentFragment();
                    drawAssociatedMedia(mediaCache[myFilteredArtwork[i]], assMediasingleDoubleclick, allAMDocfrag);
                }
                associatedMediaPickerImport.disabled = selectedArtworks.length ? false : true;
                TAG.Util.searchData(associatedsearchbar.val(), '.mediaHolder', IGNORE_IN_SEARCH);
            });

            // click handlers for all artwork name buttons
            function artworkHolderClick(artworkHolder) {
                
                artworkHolder.off('click');
                artworkHolder.on('click', function () {
                    mediaQueue.clear();
                    $(".allAssociatedMediaHolder").css('background', 'black');
                    $(".artworkHolder").css('background', 'black');
                    artworkHolder.css('background', '#999');
                    var selected = artworkHolder.attr('id');
                    $(".mediaHolder").detach();
                    var artworkAMDocfrag = document.createDocumentFragment();
                    drawAssociatedMedia(mediaCache[selected], assMediasingleDoubleclick, artworkAMDocfrag);
                    associatedMediaPickerImport.disabled = selectedArtworks.length ? false : true;
                    TAG.Util.searchData(associatedsearchbar.val(), '.mediaHolder', IGNORE_IN_SEARCH);
                });
            }

            // create import button
            var associatedMediaPickerImport = document.createElement('button');
            associatedMediaPickerImport.disabled = true;
            $(associatedMediaPickerImport).text("Import");
            $(associatedMediaPickerImport).css({
                position: 'absolute',
                bottom: '1%',
                right: '22%',
            }).css('border-radius', '3.5px');

            // click handler for import button -- perform the import using selectedArtworks.*
            $(associatedMediaPickerImport).click(function () {
                var selectedArt, i, track, positionX, newDisplay, dispLen, displayLength, diff;
                _clearAssMedia(); // interesting name....
                $(associatedMediaPickerOverlay).fadeOut();
                //console.log(selectedArt.type);
                associatedMediaPickerImport.disabled = true;
                //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                if (selectedArtworks && selectedArtworks.length) {
                    for (i = 0; i < selectedArtworks.length; i++) {
                        selectedArt = selectedArtworks[i];
                        if (selectedArt.type === "Video") {
                            track = timeline.addVideoTrack(selectedArt.url, selectedArt.name,null,selectedArt.duration);
                            positionX = timeManager.getCurrentPx();
                            displayLength = parseFloat(selectedArt.duration);
                            //if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                            //    timeManager.setEnd(displayLength + timeManager.pxToTime(positionX));
                            //}
                            //track.addDisplay(positionX, displayLength);
                            //track.addDisplay(positionX, displayLength);
                            if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                            }
                            diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                            newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                 track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                 track.addDisplay(positionX, Math.min(diff, displayLength));
                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                        } else if (selectedArt.type === "Image") {
                            track = timeline.addImageTrack(selectedArt.url, selectedArt.name);
                            positionX = timeManager.getCurrentPx();
                            displayLength = 5;
                            dispLen = Math.min(displayLength, timeManager.getDuration().end - timeManager.pxToTime(positionX));
                            newDisplay = (dispLen < TAG.TourAuthoring.Constants.displayEpsilon) ? track.addDisplay(timeManager.timeToPx(timeManager.getDuration().end - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) : track.addDisplay(positionX, dispLen);
                            if (dispLen < 1.5 && dispLen >= TAG.TourAuthoring.Constants.displayEpsilon) {
                                newDisplay.setIn(0);
                                newDisplay.setOut(0);
                                newDisplay.setMain(dispLen);
                            }
                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                        } else if (selectedArt.type === "Audio") {
                            track = timeline.addAudioTrack(selectedArt.url, selectedArt.name,null,selectedArt.duration);
                            positionX = timeManager.getCurrentPx();
                            displayLength = parseFloat(selectedArt.duration);
                            //if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                            //    timeManager.setEnd(displayLength + timeManager.pxToTime(positionX));
                            //}
                            //track.addDisplay(positionX, displayLength);
                            //track.addDisplay(positionX, displayLength);
                            if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                                timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                            }
                            diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                            newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                                 track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                                 track.addDisplay(positionX, Math.min(diff, displayLength));
                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                        } else {
                            console.log('Unrecognized file type imported!!!???');
                        }
                    }
                    undoManager.combineLast(2 * selectedArtworks.length);
                }
                //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                associatedsearchbar.val("");
                isUploading = false;
                timeline.getDataHolder().mapTracks(function (container, i) {
                    container.track.updatePos(i);
                });
            });
            associatedMediaPicker.append(associatedMediaPickerImport);


            // cancel button
            var associatedMediaPickerCancel = document.createElement('button');
            $(associatedMediaPickerCancel).text("Cancel");
            $(associatedMediaPickerCancel).css({
                position: 'absolute',
                bottom: '1%',
                right: '5%'//$('button').width() + 15,
            }).css('border-radius', '3.5px');

            // cancel button click handler
            $(associatedMediaPickerCancel).click(function () {
                _clearAssMedia();
                $(associatedMediaPickerOverlay).fadeOut();
                associatedMediaPickerImport.disabled = true;
                //associatedsearchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                associatedsearchbar.val("");
                return undefined;
            });
            associatedMediaPicker.append(associatedMediaPickerCancel);

            // detach picker elements
            function _clearAssMedia() {
                $(".mediaHolder").detach();
                $(".artworkHolder").detach();
                $(".allAssociatedMediaHolder").detach();
                $('#associatedLoadingLabel').detach();
            }
        }

        /** 
         * Creates the media panel for the media associated to a given artwork. Each is given a .mediaHolder-class container.
         * @param mediaArray   the list of media to appear in the panel
         */
        function drawAssociatedMedia(mediaArray, applyClick, docfrag) {
            //mediaQueue.clear();
            if (mediaArray) {
                for (var i = 0; i < mediaArray.length; i++) {
                    mediaQueue.add(createMediaHolder(mediaArray[i], applyClick));
                }
            }
            //$(associatedMediaPickerMedia).append(docfrag);
        }

        function createMediaHolder(media, applyClick) {
            return function () {
                var mediaHolder = $(document.createElement('div'));
                mediaHolder.addClass("mediaHolder");
                mediaHolder.attr('id', media.Identifier); // unique identifier for this media
                mediaHolder.data('type', media.Metadata.ContentType);
                mediaHolder.data('url', media.Metadata.Source); // store url as data
                mediaHolder.data('name', media.Name);
                mediaHolder.data('duration', media.Metadata.Duration);
                mediaHolder.data('description', media.Metadata.Description);
                var isSelected = selectedArtworksUrls[media.Metadata.Source] ? true : false;
                mediaHolder.data('selected', isSelected);
                mediaHolder.css({
                    float: 'left',
                    background: isSelected ? '#999' : '#222',
                    width: '48%',
                    height: '25%',
                    padding: '2px',
                    margin: '1px',
                });
                $(associatedMediaPickerMedia).append(mediaHolder);
                //docfrag.appendChild(mediaHolder);
                //create holder for thumbnails
                var mediaHolderImageHolder = $(document.createElement('div'));
                mediaHolderImageHolder.addClass('mediaHolderImageHolder');
                mediaHolderImageHolder.css({
                    float: 'left',
                    width: '40%',
                    margin: '3.5%',
                    height: '80%',
                    'overflow': 'hidden'
                });
                mediaHolder.append(mediaHolderImageHolder);


                // create the thumbnail to show in the media holder
                var mediaHolderImage = $(document.createElement('img'));
                mediaHolderImage.addClass('mediaHolderImage');
                if (media.Metadata.ContentType === 'Audio') {
                    mediaHolderImage.attr('src', tagPath + 'images/audio_icon.svg');
                }
                else if (media.Metadata.ContentType === 'Video') {
                    mediaHolderImage.attr('src', (media.Metadata.Thumbnail && !media.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(media.Metadata.Thumbnail) : tagPath + 'images/video_icon.svg');
                }
                else if (media.Metadata.ContentType === 'Image') {
                    mediaHolderImage.attr('src', media.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(media.Metadata.Thumbnail) : tagPath + 'images/image_icon.svg');
                }
                else {//text associated media without any media...
                    mediaHolderImage.attr('src', tagPath + 'images/text_icon.svg');
                }
                mediaHolderImage.css({
                    float: 'left',
                    'height': '100%',
                    'max-height': '100%',
                    'text-align': 'center'
                });
                mediaHolderImage.removeAttr('width');
                mediaHolderImageHolder.append(mediaHolderImage);

                // create the text to show in the media holder
                var mediaHolderText = $(document.createElement('div'));
                mediaHolderText.addClass('mediaHolderText');
                //trims off long names
                var name;

                var name = media.Name;
                if (name.length > 15) {
                    var hasSpace = false;
                    var scanLength = Math.min(name.length, 24);
                    for (var i = 14; i < scanLength ; i++) {
                        if (name[i] === " " && !hasSpace) {
                            name = name.substr(0, i) + "...";
                            hasSpace = true;
                        } else if (name[i] === "-" && i !== (scanLength - 1) && !hasSpace) {
                            if (name[i + 1] === " ") {
                                name = name.substr(0, i) + "...";
                                hasSpace = true;
                            }
                        }
                    }
                    if (!hasSpace) {
                        name = name.substr(0, 16) + "...";
                    }
                }
                mediaHolderText.text(name);
                mediaHolderText.css({
                    floar: 'left',
                    'padding-left': '3%',
                    'padding-right': '4.5%',
                    'font-size': '70%',
                    'margin': '5% 0 5% 2%',
                    'overflow': 'hidden',
                    'word-wrap': 'break-word',
                });
                mediaHolder.append(mediaHolderText);
                applyClick(mediaHolder);
            }
        }

        // creates catalogPicker for artwork import
        catalogPicker.addClass("catalogPicker");
        catalogPicker.css({
            position: 'absolute',
            width: '49%',
            height: '49%',
            padding: '1%',
            'background-color': 'black',
            'border': '3px double white',
            top: '25%',
            left: '25%',
        });
        $(catalogPickerOverlay).append(catalogPicker);


        // creates the header for the artwork catalog picker
        var catalogPickerHeader = document.createElement('div');
        $(catalogPickerHeader).addClass('catalogPickerInfo');
        $(catalogPickerHeader).text("Select artwork to import");
        $(catalogPickerHeader).css({
            'font-size': '100%%',
            'float': 'left',
        });
        catalogPicker.append(catalogPickerHeader);

        var searchbar = $(document.createElement('input'));
        searchbar.attr('type', 'text');
        $(searchbar).css({
            'float': 'right',
            'margin-right': '3%',
            'margin-top': '0.75%',
            'width': '38%',
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size': 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position': '8px center'
        });
        $(searchbar).on('focus', function () {
            $(searchbar).css({
                'background-image': ''
            });
        });
        $(searchbar).on('focusout blur', function () {
            if (!searchbar.val()) {
                $(searchbar).css({
                    'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")'
                });
            }
        });


        $(searchbar).on('keyup', function (event) {
            event.stopPropagation();
        });

        //searchbar.attr('placeholder', PICKER_SEARCH_TEXT);
        //TAG.Util.defaultVal(PICKER_SEARCH_TEXT, searchbar, true, IGNORE_IN_SEARCH);
        searchbar.keyup(function () {
            if (!pickerloaded)
                return;
            TAG.Util.searchData(searchbar.val(), '.artButton', IGNORE_IN_SEARCH);
        });
        searchbar.change(function () {
            if (!pickerloaded)
                return;
            TAG.Util.searchData(searchbar.val(), '.artButton', IGNORE_IN_SEARCH);
        });
        catalogPicker.append(searchbar);

        // creates the exhibitions panel in the artwork catalog picker
        var catalogPickerExhibitions = document.createElement('div');
        $(catalogPickerExhibitions).addClass('catalogPickerExhibitions');
        $(catalogPickerExhibitions).css({
            position: 'absolute',
            'border-right': '1px solid white',
            top: '13%',
            padding: '1%',
            height: '73%',
            width: '28%',
            overflow: 'auto',
        });
        catalogPicker.append(catalogPickerExhibitions);

        // creates the artwork panel in the artwork catalog picker
        var catalogPickerArtworks = document.createElement('div');
        $(catalogPickerArtworks).addClass('catalogPickerArtworks');
        $(catalogPickerArtworks).css({
            position: 'absolute',
            left: '33%',
            top: '13%',
            padding: '1%',
            height: '73%',
            width: '62%',
            overflow: 'auto',
        });
        catalogPicker.append(catalogPickerArtworks);

        /**
         * Gets artwork from server, displays catalogPicker
         * @return artwork id
         */
        function _catalogPick() {
            selectedArtworks = [];
            selectedArtworksUrls = {};
            artworkIndicesViaURL = [];
            isUploading = true;
            var selectedExhib;
            artQueue.clear();
            //var artworks = [];//TAG.Worktop.Database.getAllArtworks(); // there is a try/catch in Worktop.Database.js to help with xml errors
            //var exhibitions = [];//TAG.Worktop.Database.getExhibitions(); // check Worktop.Database.js if any server response problems come up

            // draw "All Artworks" exhibition container
            var allArtworksHolder = document.createElement('div');
            $(allArtworksHolder).addClass('allArtworksHolder');
            $(allArtworksHolder).css({
                width: '100%',
                height: '9%',
                margin: '1px 0px 1px 0px',
                background: '#999',
                'padding-left': '3%',
                'padding-top': '3%',
                'font-size': '70%'
            });
            $(allArtworksHolder).text('All Artworks');
            $(catalogPickerExhibitions).append(allArtworksHolder);

            var loading = $(document.createElement('div'));
            loading.css({
                'display': 'inline-block',
                'position': 'absolute',
                'left': '3%',
                'bottom': '2%',
            });
            loading.text('Loading...');
            loading.attr('id', 'loadingLabel');

            var circle = $(document.createElement('img'));
            circle.attr('src', tagPath + 'images/icons/progress-circle.gif');
            circle.css({
                'height': '12px',
                'width': 'auto',
                'margin-left': '20px',
                'float': 'right',
            });
            loading.append(circle);

            TAG.Worktop.Database.getExhibitions(function (exhibitions) {
                // draw exhibition holders for each exhibition
                for (var i = 0; i < exhibitions.length; i++) {
                    
                    var origName = exhibitions[i].Name;
                    var name;

                    if (origName.length > 15) {
                        var hasSpace = false;
                        var scanLength = Math.min(origName.length, 25);
                        for (var j = 14; j < scanLength ; j++) {
                            if (origName[j] === " " && !hasSpace) {
                                name = origName.substr(0, j) + "...";
                                hasSpace = true;
                            } else if (origName[j] === "-" && j !== (scanLength - 1) && !hasSpace) {
                                if (origName[j + 1] === " ") {
                                    name = origName.substr(0, j) + "...";
                                    hasSpace = true;
                                }
                            }
                        }
                        if (!hasSpace) {
                            name = origName.substr(0, 25) + "...";
                        }
                    } else {
                        name = exhibitions[i].Name;
                    }



                    var exhibHolder = $(document.createElement('div'));
                    exhibHolder.addClass('exhibHolder');
                    exhibHolder.attr('id', exhibitions[i].Identifier);
                    exhibHolder.css({
                        width: '100%',
                        height: '9%',
                        'text-overflow': 'ellipsis',
                        margin: '1px 0px 1px 0px',
                        'font-size': '70%',
                        'padding-left': '3%',
                        'padding-top': '3%',
                    });
                    exhibHolder.text(name);
                    $(catalogPickerExhibitions).append(exhibHolder);
                    // click handler for general exhibition button
                    makeExhibClickable(exhibHolder);
                }

                function makeExhibClickable(exhibHolder) {
                    exhibHolder.click(function () {
                        if (!pickerloaded)
                            return;
                        $(".allArtworksHolder").css('background', 'black');
                        $(".exhibHolder").css('background', 'black');
                        exhibHolder.css('background', '#999');
                        var selected = exhibHolder.attr('id');
                        selectedExhib = selected;
                        $('.catalogPickerArtworks').empty();
                        catalogPickerImport.disabled = selectedArtworks.length ? false : true;
                        $('.artButton').hide().data('visible', false);
                        $('.' + selected).show().data('visible', true);
                        TAG.Util.searchData(searchbar.val(), '.artButton', IGNORE_IN_SEARCH);
                        TAG.Worktop.Database.getArtworksIn(exhibHolder.attr('id'),loadInArtworks, function () {
                            console.log("error");
                        }, function () {
                            console.log("error2");
                        });


                    });
                }

                TAG.Worktop.Database.getArtworks(loadInArtworks, function () {
                    console.log("error");
                }, function () {
                    console.log("error2");
                });
            });


            function loadInArtworks(artworks) {
                pickerloaded = false;
                var i;
                for (i = 0; i < artworks.length; i++) {
                    if (artworks[i].Type === 'Empty') {
                        artworks.splice(i, 1);
                        i--;
                    }
                }
                //allArtworks = artworks;
                // sort all artworks alphabetically
                artworks.sort(function (a, b) {
                    return a.Name.toLowerCase() < b.Name.toLowerCase() ? -1 : 1;
                });

                // using docfrag
                //var artworkListDocfrag = document.createDocumentFragment();
                // create holders for all artworks (since we start in the "all artworks" exhibition)
                $.each(artworks, function (i, artwork) {
                    artQueue.add(function () {
                        var artHolder = document.createElement('div');
                        var exhibits = [];
                        var ids = "";
                        if (selectedExhib)
                            $(artHolder).hide().data('visible', false);
                        for (var j = 0; j < artwork._Folders.FolderData.length; j++) {
                            exhibits.push(artwork._Folders.FolderData[j]);
                            if (selectedExhib === artwork._Folders.FolderData[j].FolderId)
                                $(artHolder).show().data('visible', true);
                            ids += artwork._Folders.FolderData[j].FolderId + " ";
                        }
                        $(artHolder).attr('class', 'artButton ' + ids);
                        $(artHolder).data({
                            name: artwork.Name,
                            artist: artwork.Metadata.Artist,
                            year: artwork.Metadata.Year,
                        });
                        $(artHolder).data('exhibits', exhibits);
                        $(artHolder).addClass("artHolder");
                        $(artHolder).attr('id', artwork.Identifier); // unique artwork identifier
                        //$(artHolder).data('url', artwork.Metadata.DeepZoom); // store url as data
                        $(artHolder).data('name', artwork.Name);
                        $(artHolder).data('type', artwork.Metadata.Type);
                        $(artHolder).data('description', artwork.Metadata.Description);
                        if (artwork.Metadata.InfoFields) {
                            $.each(artwork.Metadata.InfoFields, function (field, fieldText) {           //Adding custom metadata fields: both keys and values
                                $(artHolder).data(field, fieldText);
                            });
                        }

                        if (artwork.Metadata.Duration) { //for videos
                            $(artHolder).data('duration', artwork.Metadata.Duration);
                            $(artHolder).data('url', artwork.Metadata.Source);
                        } else {
                            $(artHolder).data('url', artwork.Metadata.DeepZoom);
                        }
                        $(artHolder).css({
                            float: 'left',
                            background: '#222',
                            width: '48%',
                            height: '25%',
                            padding: '2px',
                            margin: '1px',
                        });
                        $(catalogPickerArtworks).append(artHolder);
                        //artworkListDocfrag.appendChild(artHolder);
                        TAG.Util.searchData(searchbar.val(), '.artButton', IGNORE_IN_SEARCH);

                        //create holder for image
                        var artHolderImageHolder = document.createElement('div');
                        $(artHolderImageHolder).addClass('artHolderImageHolder');
                        $(artHolderImageHolder).css({
                            float: 'left',
                            position: 'relative',
                            width: '40%',
                            margin: '3.5%',
                            height: '80%',
                            'overflow': 'hidden',
                        });
                        $(artHolder).append(artHolderImageHolder);

                        // create image for artwork holder
                        var artHolderImage = document.createElement('img');
                        $(artHolderImage).addClass('artHolderImage');
                        $(artHolderImage).attr('src', TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail));
                        $(artHolderImage).css({
                            'max-height': '100%',
                            'position': 'absolute',
                            'left': '0',
                            'right': '0',
                            'top': '0',
                            'bottom': '0',
                            'margin': 'auto',
                            'display': 'block',
                            'max-width': '100%',
                            width: 'auto',
                        });
                        $(artHolderImageHolder).append(artHolderImage);
                            
                        // create text for artwork holder
                        var artHolderText = document.createElement('div');
                        $(artHolderText).addClass('artHolderText');
                        /*
                        var maxlength = 33; // trim off long names
                        var name;
                        if (artwork.Name.length > maxlength) {
                            name = artwork.Name.slice(0, maxlength) + "...";
                        } else {
                            name = artwork.Name;
                        }
                        */
                        // intelligent truncate + ellipses insertion (bleveque: use text-overflow:ellipsis instead... TODO)
                        var name = artwork.Name;
                        if (name.length > 23) {
                            var hasSpace = false;
                            var scanLength = Math.min(name.length, 35);
                            for (var i = 20; i < scanLength ; i++) {
                                if (name[i] === " " && !hasSpace) {
                                    name = name.substr(0, i) + "...";
                                    hasSpace = true;
                                } else if (name[i] === "-" && i !== (scanLength - 1) && !hasSpace) {
                                    if (name[i + 1] === " ") {
                                        name = name.substr(0, i) + "...";
                                        hasSpace = true;
                                    }
                                }
                            }
                            if (!hasSpace) {
                                name = name.substr(0, 24) + "...";
                            }
                        }
                             
                        $(artHolderText).text(name);
                        $(artHolderText).css({
                            floar: 'left',
                            'padding-left': '3%',
                            'padding-right': '4.5%',
                            'font-size': '70%',
                            'margin': '5% 0 5% 2%',
                            'overflow': 'hidden',
                            'word-wrap': 'break-word',
                        });
                        $(artHolder).append(artHolderText);
                        singleDoubleclick($(artHolder));
                    });
                });
                artQueue.add(function () {
                    loading.hide();
                    pickerloaded = true;
                });
                // append docfrag at end
                //artQueue.add(function () { $(catalogPickerArtworks).append(artworkListDocfrag); });
            }

            //single clicking selects/deselects artworks to be imported
            function singleClick(e,artHolder) {
                var index, urlindex;
                if (artHolder.data('selected')) {
                    artHolder.css('background', '#222');
                    artHolder.data('selected', false);
                    urlindex = artworkIndicesViaURL.indexOf(artHolder.data('url'));
                    //index = selectedArtworks.indexOf(artHolder.data('url'));
                    selectedArtworks.splice(urlindex, 1);
                    artworkIndicesViaURL.splice(urlindex, 1);
                    selectedArtworksUrls[artHolder.data('url')] = false;
                    catalogPickerImport.disabled = selectedArtworks.length ? false : true;
                    //console.log(selectedArtworks.length);
                }
                else {
                    artHolder.css('background', '#999');
                    artHolder.data({
                        'selected': true
                    }); // else, artHolder.removeClass('selected')
                    if (artworkIndicesViaURL.indexOf(artHolder.data('url')) === -1) {
                        selectedArtworks.push({ 'url': artHolder.data('url'), 'name': artHolder.data('name'), 'id': artHolder.attr('id'), 'type': artHolder.data('type'), 'duration': artHolder.data('duration') });
                        artworkIndicesViaURL.push(artHolder.data('url'));
                        selectedArtworksUrls[artHolder.data('url')] = true;
                    }
                    catalogPickerImport.disabled = false;
                }
            }

            //double clicking will import all selected artworks
            function doubleClick(e,artHolder) {
                var i, selectedArt;
                // get artwork selected
                catalogPickerImport.disabled = false;
                //$(".artHolder .unSelected").css('background', '#222'); /// noooooo
                artHolder.css('background', '#999');
                if (!selectedArtworksUrls[artHolder.data('url')] && artHolder.data('selected') !== true) {
                    selectedArtworks.push({ 'url': artHolder.data('url'), 'name': artHolder.data('name'), 'id': artHolder.attr('id'),'type': artHolder.data('type'), 'duration': artHolder.data('duration') });
                    selectedArtworksUrls[artHolder.data('url')] = true;
                    artHolder.data({
                        'selected': true
                    });
                }
                $(catalogPickerOverlay).fadeOut();
                _clearCatalog();
                //searchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                searchbar.val("");
                // add the artwork track to the timeline
                for (i = 0; i < selectedArtworks.length; i++) {
                    selectedArt = selectedArtworks[i];
                    var track;
                    if (selectedArt.type === "VideoArtwork") {
                        track = timeline.addVideoTrack(selectedArt.url, selectedArt.name,null,selectedArt.duration);
                        var positionX = timeManager.getCurrentPx();
                        var displayLength = parseFloat(selectedArt.duration);
                        //if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                        //    timeManager.setEnd(displayLength + timeManager.pxToTime(positionX));
                        //}
                        //track.addDisplay(positionX, displayLength);
                        //track.addDisplay(positionX, displayLength);
                        if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                            timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                        }
                        var diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                        var newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                             track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                             track.addDisplay(positionX, Math.min(diff, displayLength));
                        if (timeline.getTracks().length > 0) {
                            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                        }
                     } else {
                            track = timeline.addArtworkTrack(selectedArt.url, selectedArt.name, selectedArt.id, selectedArt.type);
                                       
                            var positionX = timeManager.getCurrentPx();
                            var displayLength = 5;
                            var dispLen = Math.min(displayLength, timeManager.getDuration().end - timeManager.pxToTime(positionX));
                            var newDisplay = (dispLen < TAG.TourAuthoring.Constants.displayEpsilon) ? track.addDisplay(timeManager.timeToPx(timeManager.getDuration().end - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) : track.addDisplay(positionX, dispLen);
                            if (dispLen < 1.5 && dispLen >= TAG.TourAuthoring.Constants.displayEpsilon) {
                                newDisplay.setIn(0);
                                newDisplay.setOut(0);
                                newDisplay.setMain(dispLen);
                            }

                            // forcing a tour reload? probably easiest to use timeline.onUpdate()
                            if (timeline.getTracks().length > 0) {
                                timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                            }
                        }
                }
                undoManager.combineLast(2 * selectedArtworks.length); // allow undo/redo to perform both actions (addTrack, addDisplay) at once
                isUploading = false;
                timeline.getDataHolder().mapTracks(function (container, i) {
                    container.track.updatePos(i);
                });
                
            }

            //this handles discriminating between the double and single clicks for importing artworks
            //cleans up bugs where both click events were firing and artworks would import twice
            function singleDoubleclick(artHolder) {
                artHolder.click(function (e) {
                    var that = this;
                    setTimeout(function () {
                        var dblclick = parseInt($(that).data('double'), 10);
                        if (dblclick > 0) {
                            $(that).data('double', dblclick - 1);
                        } else {
                            singleClick.call(that, e,artHolder);
                        }
                    }, 300);
                }).dblclick(function (e) {
                    $(this).data('double', 2);
                    doubleClick.call(this, e, artHolder);
                });
            }


            // click handler for the "all artworks" button
            $(allArtworksHolder).on('click', function () {
                $(".exhibHolder").css('background', 'black');
                $(this).css('background', '#999');
                catalogPickerImport.disabled = selectedArtworks.length ? false : true;
                $('.catalogPickerArtworks').empty();
                $('.artButton').show().data('visible', true);
                TAG.Util.searchData(searchbar.val(), '.artButton', IGNORE_IN_SEARCH);
                selectedExhib = null;
                if (allArtworks) {
                    loadInArtworks(allArtworks);
                } else {
                    TAG.Worktop.Database.getArtworks(loadInArtworks, function () {
                        console.log("error");
                    }, function () {
                        console.log("error2");
                    });
                }
            });



            $(catalogPickerOverlay).fadeIn();

            catalogPicker.append(loading);

            // create artwork import button
            var catalogPickerImport = document.createElement('button');
            catalogPickerImport.disabled = true;
            $(catalogPickerImport).text("Import");
            $(catalogPickerImport).css({
                position: 'absolute',
                bottom: '2%',
                right: '22%',
            }).css('border-radius', '3.5px');

            // in here, deal with multiple selected artworks
            // artwork import button click handler
            $(catalogPickerImport).click(function () {
                var i;
                // if an artwork is selected, add an artwork track and a display (and combine these commands in undo manager)
                catalogPickerImport.disabled = true;
                $(catalogPickerImport).css({ 'color': 'rgba(255,255,255,0.5)' });
                $(catalogPickerCancel).css({ 'color': 'rgba(255,255,255,0.5)' }).attr('disabled', true);
                function importHelper(j) {
                    var selectedArt = selectedArtworks[j];
                    //artQueue.add(function () {
                    var track;
                    var positionX = timeManager.getCurrentPx();
                    var displayLength;
                    if (selectedArt.type === "VideoArtwork") {
                        track = timeline.addVideoTrack(selectedArt.url, selectedArt.name, null, selectedArt.duration);
                        displayLength = parseFloat(selectedArt.duration);
                        if (timeManager.getDuration().end < displayLength + timeManager.pxToTime(positionX)) {
                            timeManager.setEnd(Math.min(TAG.TourAuthoring.Constants.maxTourLength, displayLength + timeManager.pxToTime(positionX)));
                        }
                        var diff = TAG.TourAuthoring.Constants.maxTourLength - timeManager.pxToTime(positionX);
                        var newDisplay = (diff < TAG.TourAuthoring.Constants.displayEpsilon) ?
                                             track.addDisplay(timeManager.timeToPx(TAG.TourAuthoring.Constants.maxTourLength - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) :
                                             track.addDisplay(positionX, Math.min(diff, displayLength));
                        if (timeline.getTracks().length > 0) {
                            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                        }
                    } else {
                        track = timeline.addArtworkTrack(selectedArt.url, selectedArt.name, selectedArt.id);
                        displayLength = 5;
                        var dispLen = Math.min(displayLength, timeManager.getDuration().end - timeManager.pxToTime(positionX));
                        var newDisplay = (dispLen < TAG.TourAuthoring.Constants.displayEpsilon) ? track.addDisplay(timeManager.timeToPx(timeManager.getDuration().end - TAG.TourAuthoring.Constants.displayEpsilon), TAG.TourAuthoring.Constants.displayEpsilon) : track.addDisplay(positionX, dispLen);
                        if (dispLen < 1.5 && dispLen >= TAG.TourAuthoring.Constants.displayEpsilon) {
                            newDisplay.setIn(0);
                            newDisplay.setOut(0);
                            newDisplay.setMain(dispLen);
                        }
                        // force a tour reload? easiest to use timeline.onUpdate()
                        if (timeline.getTracks().length > 0) {
                            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
                        }
                    }
                }
                if (selectedArtworks && selectedArtworks.length) {
                    artQueue.clear();
                    loading.text('Importing...');
                    loading.show();
                    $(catalogPickerImport).hide();
                    $(catalogPickerCancel).hide();
                    for (i = 0; i < selectedArtworks.length; i++) {
                        importHelper(i);
                    }
                    undoManager.combineLast(2 * selectedArtworks.length);
                    //artQueue.add(function () {
                        //allow ink annotations
                    $(inkButton).css({ 'background-color': 'transparent', 'color': 'white' });
                    allowInk = true;
                    _clearCatalog();
                    $(catalogPickerOverlay).fadeOut();
                    //});
                } else {
                    _clearCatalog();
                    $(catalogPickerOverlay).fadeOut();
                }
                //searchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                searchbar.val("");
                isUploading = false;
                timeline.getDataHolder().mapTracks(function (container, i) {
                    container.track.updatePos(i);
                });
            });
            catalogPicker.append(catalogPickerImport);

            // cancel button
            var catalogPickerCancel = document.createElement('button');
            $(catalogPickerCancel).text("Cancel");
            $(catalogPickerCancel).css({
                position: 'absolute',
                bottom: '2%',
                right: '5%',
            }).css('border-radius', '3.5px');

            // cancel button click handler
            $(catalogPickerCancel).click(function () {
                $(catalogPickerOverlay).fadeOut();
                _clearCatalog();
                catalogPickerImport.disabled = true;
                $(catalogPickerImport).css({ 'color': 'rgba(255,255,255,0.5)' });
                $(catalogPickerCancel).css({ 'color': 'rgba(255,255,255,0.5)' }).attr('disabled', true);
                //searchbar.attr('placeholder', PICKER_SEARCH_TEXT);
                searchbar.val("");
                return undefined;
            });
            catalogPicker.append(catalogPickerCancel);
        }

        // Checks if a string 'val' contains 'str
        // If 'val' is the default search text it will always return true
        // Case insensitive
        function searchString(str, val) { // could use regex instead...
            if (val === PICKER_SEARCH_TEXT) val = '';
            return str.toLowerCase().indexOf(val.toLowerCase()) !== -1;
        }

        /**
         * Detach catalog dom elements
         */
        function _clearCatalog() {
            $(".artHolder").detach();
            $(".exhibHolder").detach();
            $(".allArtworksHolder").detach();
            $('#loadingLabel').detach();
            artQueue.clear();
        }

        
        /**
         * Below are the ink UI controls. They are separated into draw, text, and transparency controls.
         */

        var numInkTracks = 0;
        
        /**
         * Ink text UI controls (initial text creation, not edit mode)
         */

        // text UI control panel
        var inkTextDocfrag = document.createDocumentFragment();
        inkTextControls = $(document.createElement('div'));
        inkTextControls.css({
            'height': '425%',
            'width': '100%',
            top: '130%',
            position: 'absolute',
            'z-index': 0,
            'overflow-x': 'none',
            'overflow-y': 'auto',
            'margin-top': '8%',
            "display": "none"
        });
        inkTextControls.attr('id', 'inkTextControls');
        inkTextDocfrag.appendChild(inkTextControls[0]);
        inkTextControls.css({ "display": "none" });

        // cancel text button
        var cancelTextButton = $(document.createElement('button'));
        cancelTextButton.css({
            'font-size': '70%',
            'color': 'black',
            'margin-left': '8%',
            'margin-bottom': '10px',
            'font-weight': 'bold',
            'float': 'left',
            'width': '80%',
            //'height': '14%'
            'padding-left':'4px','padding-right':'4px'
        }).css('border-radius', '3.5px');
        cancelTextButton.get(0).innerHTML = "Cancel";
        cancelTextButton.click(function () {
            removeInkCanv();
            inkTextControls.hide();
            timeline.setModifyingInk(false);
            timeline.setEditInkOn(false);

            inkAuthoring.getInkUndoManager().clear();
            undoManager.greyOutBtn();
            // set undo/redo buttons back to global undo/redo functionality
            playbackControls.undoButton.off("click");
            playbackControls.redoButton.off("click");
            playbackControls.undoButton.on("click", function () {
                undoManager.undo();
            });
            playbackControls.redoButton.on("click", function () {
                undoManager.redo();
            });
            playbackControls.undoRedoInkOnly.css({ 'display': 'none' });
        });
        inkTextControls.append(cancelTextButton);

        // CREATING NEW TEXT INK
        var textArray = []; // array of text UI controls
        
        var textBodyLabel = $(document.createElement('div'));
        textBodyLabel.addClass('thicknessLabel');
        var textBodyLabel1 = $(document.createElement('div'));
        textBodyLabel.text("Text:");
        textBodyLabel.append(textBodyLabel1);
        inkTextControls.append(textBodyLabel);
        textBodyLabel1.css({
            'position': 'relative',
            'top': '2px',
            'width': '65%',
            'color': 'green',
            'display': 'inline-block',
            'margin-left': '2%',
            'text-overflow': 'ellipsis',
            'overflow': 'hidden',
            'white-space': 'nowrap',
            'margin-bottom': '0',
        });
        textBodyLabel.css({
            'font-size': '0.8em',
            'color': 'black',
            'margin-left': '8%',
            'font-weight': 'normal',
            'margin-top': '3%',
            'margin-right': '12%',
            'margin-bottom': '1%',
            'display': 'inline-block',
            'border-bottom-width': ' 2px',
            'border-bottom-style': 'solid',
            'border-bottom-color': 'white',
            'width': '80%',
        });

        var textArea = $(document.createElement('textarea'));
        textArea.css({
            'width': "72%",
            'min-width': '0px',
            'margin-left': '8%',
            'margin-top': '2%',
            'overflow-x': 'hidden',
            'position': 'relative',
        });
        textArray.push(textArea);
        textArea.attr('id', 'writeAnnotation');
        /*textArea.on('keyup', function () {
            var txt = (textArea && textArea[0] && textArea[0].value) ? textArea[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (textArea && textArea[0] && textArea[0].value && textArea[0].value != txt) {
                textArea[0].value = txt;
            }
        });*/
        $('#writeAnnotation').autoSize({
            onResize: function () {
                $(this).css({ 'opacity': '0.8' });
            },
            animateCallback: function () {
                $(this).css({ 'opacity': '1' });
            },
            animateDuration: 300,
            extraSpace: 40
        });
        //textArea.autoSize();
        inkTextControls.append(textArea);

        function updateAreaText() {
            var text = currentInkController.getSVGText();
            textBodyLabel1.text(textArea.val()); // or .text()
            text.attr('text', textArea.val());
            text.data('str', textArea.val());
        }

        var lastText = "";
        textArea.on("keyup", function (evt) { //use onpropertychange

            var code = evt.keyCode;
            if (code === 32) {
            evt.stopPropagation();
            }
          
            var undoRedo = $.debounce(500, false, undoRedoText(evt));
            if (code !== 37 && code !== 38 && code !== 39 && code !== 40 && evt.keyCode !== 90 && !evt.ctrlKey && evt.keyCode !== 89) { // exclude arrow/ctrl/etc keys
                undoRedo();
            }
            updateAreaText();
        });

        function undoRedoText(evt) {
            return function () {
                var currText = textArea.val();
                var oldText = lastText;
                if (currText === lastText || evt.which === 17) {
                    return;
                }
                var undoMgr = currentInkController.getInkUndoManager();
                var command = TAG.TourAuthoring.Command({
                    execute: function () {
                        textArea.val(currText);
                        updateAreaText();
                    },
                    unexecute: function () {
                        textArea.val(oldText);
                        updateAreaText();
                    }
                });
                undoMgr.logCommand(command);
                lastText = textArea.val();
            };
        }

        textBodyLabel.click(function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            textBodyLabel.css({ 'font-weight': 'bold' });
            updateToggle(textArray, textArea);
        });

        // show current font label
        var fontLabel = $(document.createElement('div'));
        fontLabel.addClass('thicknessLabel');
        var fontLabel1 = $(document.createElement('div'));
        fontLabel.text("Font:");
        fontLabel1.text("Times New Roman");
        fontLabel.append(fontLabel1);
        inkTextControls.append(fontLabel);

        fontLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        fontLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // dropdown font selector
        var fontSelector = $(document.createElement("select"));
        fontSelector.addClass('fontSelector');
        fontSelector.css({
            color: "white",
            'float': 'left',
            'clear': 'both',
            'display': 'none',
            "border": "solid 3px rgba(255,255,255,1)",
            width: "72%",
            'margin-left': '8%',
            'margin-top': '2%',
            "background-color": 'rgba(0,0,0,0.5)'
        });
        textArray.push(fontSelector);
        inkTextControls.append(fontSelector);

        
        // create font options for the selector -- on click, set the font family of the current ink and reset fontLabel1.text
        var timesOption = $(document.createElement("option"));
        timesOption.text("Times New Roman").css({
            color: "white",
            "border-color": "rgba(0,0,0,0.5)",
            overflow: "hidden",
            background: "no-repeat scroll",
            "background-color": 'rgba(0,0,0,0.5)'
        });
        timesOption.on('click', function () {
            currentInkController.setFontFamily("Times New Roman, serif");
            fontLabel1.text("Times New Roman");
        });
        var georgiaOption = $(document.createElement("option"));
        georgiaOption.text("Georgia").css({
            color: "white",
            "border-color": "rgba(0,0,0,0.5)",
            overflow: "hidden",
            background: "no-repeat scroll",
            "background-color": 'rgba(0,0,0,0.5)'
        });
        georgiaOption.on('click', function () {
            currentInkController.setFontFamily("Georgia, serif");
            fontLabel1.text("Georgia");
        });
        var verdanaOption = $(document.createElement("option"));
        verdanaOption.text("Verdana").css({
            color: "white",
            "border-color": "rgba(0,0,0,0.5)",
            overflow: "hidden",
            background: "no-repeat scroll",
            "background-color": 'rgba(0,0,0,0.5)'
        });
        verdanaOption.on('click', function () {
            currentInkController.setFontFamily("Verdana, Geneva, sans-serif");
            fontLabel1.text("Verdana");
        });
        var courierOption = $(document.createElement("option"));
        courierOption.text("Courier").css({
            color: "white",
            "border-color": "rgba(0,0,0,0.5)",
            overflow: "hidden",
            background: "no-repeat scroll",
            "background-color": 'rgba(0,0,0,0.5)'
        });
        courierOption.on('click', function () {
            currentInkController.setFontFamily("'Courier New', Courier, monospace");
            fontLabel1.text("Courier");
        });

        fontSelector.append(timesOption);
        fontSelector.append(georgiaOption);
        fontSelector.append(verdanaOption);
        fontSelector.append(courierOption);

        // font label click handler (needs to be after the font selector is created)
        fontLabel.click(function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            fontLabel.css({ 'font-weight': 'bold' });
            updateToggle(textArray, fontSelector);
        });

        // show current font color label
        var colorTextLabel = $(document.createElement('div'));
        colorTextLabel.addClass('thicknessLabel');
        var colorTextLabel1 = $(document.createElement('div'));
        colorTextLabel1.addClass('changeColor');
        colorTextLabel.text("Color: ");
        colorTextLabel1.text("#FFFFFF");
        colorTextLabel.append(colorTextLabel1);
        inkTextControls.append(colorTextLabel);

        colorTextLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        colorTextLabel1.css({ 'font-size': '0.8em', 'color': 'green', 'display': 'inline', 'padding-left': '2%' });

        // create div containing the color picker
        var colorTextDiv = $(document.createElement('div'));
        colorTextDiv.attr("id", "colorTextDiv");
        colorTextDiv.css('display', 'none');
        inkTextControls.append(colorTextDiv);
        textArray.push(colorTextDiv);

        //click handler to open the color picker when we click on the color label
        colorTextLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            colorTextLabel.css({ 'font-weight': 'bold' });
            updateToggle(textArray, colorTextDiv);

        });

        // create input box for color picker
        var itemText = document.createElement('input');
        $(itemText).attr('id', 'textColorToggle');
        $(itemText).attr('readonly', 'readonly');
        $(itemText).css({ 'margin-left': '8%', 'margin-top': '3%', 'clear': 'left', 'width': '40%' });
        $(itemText).on('keyup', function (event) {
            event.stopPropagation();
        });

        if (itemText.addEventListener) {
            itemText.addEventListener('DOMNodeInserted', function () {
                // initialize colorpicker object on current element
                myPicker = new jscolor.color(itemText, {});
                myPicker.fromString("FFFFFF");
                myPicker.onImmediateChange = function () {
                    currentInkController.setFontColor("#"+$("#textColorToggle").attr('value'));
                    $('.changeColor')[0].innerHTML = "#"+$("#textColorToggle").attr('value');
                };
            }, false);
        }
        colorTextDiv.append(itemText);

        // show font size label 
        var textSizeLabel = $(document.createElement('div'));
        textSizeLabel.addClass('thicknessLabel');
        var textSizeLabel1 = $(document.createElement('div'));
        textSizeLabel.text("Text Size: ");
        textSizeLabel1.text("12px");
        textSizeLabel.append(textSizeLabel1);
        inkTextControls.append(textSizeLabel);
        textSizeLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        textSizeLabel.css({
            'font-size': '70%',
            'color': 'black',
            'margin-left': '8%',
            'font-weight': 'normal',
            'margin-top': '3%',
            'margin-right': '12%',
            'margin-bottom': '1%',
            'float': 'left',
            'clear': 'both',
            'display': 'inline',
            'border-bottom-width': ' 2px',
            'border-bottom-style': 'solid',
            'border-bottom-color': 'white',
            'width': '80%',
        });

        // create slider for font size
        var textSizeSlider = $(document.createElement('div'));
        textSizeSlider.css({
            'clear': 'both',
            'background-color': 'rgb(136, 134, 134)',
            'border-radius': '25px',
            "-ms-touch-action": "none",
            'border': '1px solid gray',
            'width': '70%',
            'height':'12%',// '21px',
            'margin-top': '3%',
            'margin-left': '8%',
            'display': 'none',
            'position': 'relative',
            'float': 'left'
        });
        var textSliderPoint = $(document.createElement('div'));
        textSliderPoint.css({
            'background-color': 'white',
            'height': '115%',
            'width': '9.25%',
            'position': 'relative',
            'border': '1px',
            'border-style': 'solid',
            'border-color': 'gray',
            "border-radius": "50%",
            "top": "-5%",
            "margin-top": "-0.57%",
            "left": "50px"
        });

        textSizeSlider.append(textSliderPoint);
        textSizeSlider.attr("value", "12px");
        inkTextControls.append(textSizeSlider);
        
        // drag functionality for font size slider point
        textSliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                textSliderPoint.value = textSliderPoint.css("left").replace('px', '') / (textSizeSlider.offset().left + textSizeSlider.width()) * 1.28;
                //console.log(textSliderPoint.value);
                textSizeSlider.attr("value", (textSliderPoint.value * 39 + 8) + "px");
                var val = Math.round(textSliderPoint.value * 39) + 8;
                textSizeLabel1.text( val + "px");
                currentInkController.setFontSize(textSizeSlider.attr("value"));
            },
            appendTo: 'body'
        });

        textArray.push(textSizeSlider);

        // click handler for text size label -- opens slider
        textSizeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            textSizeLabel.css({ 'font-weight': 'bold' });
            updateToggle(textArray, textSizeSlider);
        });

        // attach buttons for text
        var linkTextDiv = getAttachDiv(inkTextControls, "Write");
        inkTextControls.append(linkTextDiv);
        functionsPanel.append(inkTextDocfrag);

        /**
         * Edit ink text UI controls -- we can probably compress some of this by reusing the inkTextControls
         */

        // edit text control panel
        var textEditDocfrag = document.createDocumentFragment();
        inkEditText = $(document.createElement('div'));
        inkEditText.attr("id", "inkEditText");
        inkEditText.css({ 'height': '425%', 'width': '100%', top: '130%', position: 'absolute', 'z-index': 0, 'overflow-y': 'auto', 'margin-top': '8%' });
        //functionsPanel.append(inkEditText);
        textEditDocfrag.appendChild(inkEditText[0]);
        inkEditText.css({ "display": "none" });

        var cancelEditTextButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelEditTextButton.css({ 'padding-left':'4px','padding-right':'4px', 'font-size': '70%', 'color': 'black', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', /*'width': '25%'*/ 'width':'80%' });
        cancelEditTextButton.get(0).innerHTML = "Cancel";
        inkEditText.append(cancelEditTextButton);

        // EDITING OLD TEXT INK
        var textEditArray = []; // array of edit text controls
        
        var textEditBodyLabel = $(document.createElement('div'));
        textEditBodyLabel.addClass('thicknessLabel');
        var textEditBodyLabel1 = $(document.createElement('div'));
        textEditBodyLabel.text("Text:");
        textEditBodyLabel.append(textEditBodyLabel1);
        inkEditText.append(textEditBodyLabel);
        textEditBodyLabel1.css({
            'position': 'relative',
            'top': '2px',
            'width': '65%',
            'color': 'green',
            'display': 'inline-block',
            'margin-left': '2%',
            'text-overflow': 'ellipsis',
            'overflow': 'hidden',
            'white-space': 'nowrap',
            'margin-bottom': '0',
        });
        textEditBodyLabel.css({
            'font-size': '0.8em',
            'color': 'black',
            'margin-left': '8%',
            'font-weight': 'normal',
            'margin-top': '3%',
            'margin-right': '12%',
            'margin-bottom': '1%',
            'display': 'inline-block',
            'border-bottom-width': ' 2px',
            'border-bottom-style': 'solid',
            'border-bottom-color': 'white',
            'width': '80%',
        });

        var textEditArea = $(document.createElement('textarea'));
        textEditArea.css({
            'width': "72%",
            'min-width': '0px',
            'margin-left': '8%',
            'margin-top': '2%',
            'overflow-x': 'hidden',
            'position': 'relative',
        }).attr("id","textEditArea");
        textEditArray.push(textEditArea);
        $("#textEditArea").autoSize({
            onResize: function () {
                $(this).css({ 'opacity': '0.8' });
            },
            animateCallback: function () {
                $(this).css({ 'opacity': '1' });
            },
            animateDuration: 300,
            extraSpace: 40
        });
        inkEditText.append(textEditArea);

        var textA;
        function updateEditAreaText() {
            textA = currentInkController.getSVGText();
            textEditBodyLabel1.text(textEditArea.val()); // or .text()
            currentInkController.remove_all();
            currentInkController.add_text_box(textA.attrs.x, textA.attrs.y, -1, -1, textEditArea.val(), true);
            textA = currentInkController.getSVGText();
            textA.data('str', textEditArea.val());
        }
        var lastEditText;
        function firstUpdate() {
            textA = currentInkController.getSVGText();
            textEditBodyLabel1.text(textEditArea.val()); // or .text()
            currentInkController.remove_all();
            lastEditText = textEditArea.val();
            switch (textA.attr('font-family')) {
                case "'Courier New', Courier, monospace":
                    courierEditOption.prop('selected', true);
                    currentInkController.setFontFamily("'Courier New', Courier, monospace");
                    fontEditLabel1.text("Courier");
                    break;
                case "Verdana, Geneva, sans-serif":
                    verdanaEditOption.prop('selected', true);
                    currentInkController.setFontFamily("Verdana, Geneva, sans-serif");
                    fontEditLabel1.text("Verdana");
                    break;
                case "Georgia, serif":
                    georgiaEditOption.prop('selected', true);
                    currentInkController.setFontFamily("Georgia, serif");
                    fontEditLabel1.text("Georgia");
                    break;
                case "Times New Roman, serif":
                    timesEditOption.prop('selected', true);
                    currentInkController.setFontFamily("Times New Roman, serif");
                    fontEditLabel1.text("Times New Roman");
                    break;
                default:
                    break;
            
            }
            currentInkController.add_text_box(textA.attrs.x, textA.attrs.y, -1, -1, textEditArea.val(), true);
            textA = currentInkController.getSVGText();
            textA.data('str', textEditArea.val());
        }

        
        textEditArea.on("keyup", function (evt) { //use onpropertychange

            var code = evt.keyCode;

            if (code == 32) {
            evt.stopPropagation();
            }
            var undoRedoEdit = $.debounce(500, false, undoRedoEditText(evt));
            if (code !== 37 && code !== 38 && code !== 39 && code !== 40 && !evt.ctrlKey) { // exclude arrow keys
                undoRedoEdit();
            }
            updateEditAreaText();
        });

       
        function undoRedoEditText(evt) {
            return function () {
                var currEditText = textEditArea.val();
                var oldEditText = lastEditText;
                if (currEditText === lastEditText || evt.which === 17) {
                    return;
                }
                var undoMgr = currentInkController.getInkUndoManager();
                var command = TAG.TourAuthoring.Command({
                    execute: function () {
                        textEditArea.val(currEditText);
                        updateEditAreaText();
                    },
                    unexecute: function () {
                        textEditArea.val(oldEditText);
                        updateEditAreaText();
                    }
                });
                undoMgr.logCommand(command);
                lastEditText = currEditText;
            };
        }

        textEditBodyLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            textEditBodyLabel.css({ 'font-weight': 'bold' });
            updateToggle(textEditArray, textEditArea);
        });

        // show font family label
        var fontEditLabel = $(document.createElement('div'));
        fontEditLabel.addClass('thicknessLabel');
        var fontEditLabel1 = $(document.createElement('div'));
        fontEditLabel.text("Font:");
        fontEditLabel1.text("Times New Roman");
        fontEditLabel.append(fontEditLabel1);
        inkEditText.append(fontEditLabel);

        fontEditLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        fontEditLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // font selection dropdown
        var fontEditSelector = $(document.createElement("select"));
        fontEditSelector.addClass('fontSelector');
        fontEditSelector.css({ color: "white", 'float': 'left', 'clear': 'both', 'display': 'none', "border": "solid 3px rgba(255,255,255,1)", width: "72%",  'margin-left': '8%', 'margin-top': '2%', "background-color": 'rgba(0,0,0,0.5)' });
        textEditArray.push(fontEditSelector);
        inkEditText.append(fontEditSelector);

        // font options in dropdown
        var timesEditOption = $(document.createElement("option"));
        timesEditOption.text("Times New Roman").css({ color: "white", "border-color": "rgba(0,0,0,0.5)", overflow: "hidden", background: "no-repeat scroll", "background-color": 'rgba(0,0,0,0.5)' });
        timesEditOption.click(function () {
            currentInkController.setFontFamily("Times New Roman, serif");
            fontEditLabel1.text("Times New Roman");
        });
        var georgiaEditOption = $(document.createElement("option"));
        georgiaEditOption.text("Georgia").css({ color: "white", "border-color": "rgba(0,0,0,0.5)", overflow: "hidden", background: "no-repeat scroll", "background-color": 'rgba(0,0,0,0.5)' });
        georgiaEditOption.click(function () {
            currentInkController.setFontFamily("Georgia, serif");
            fontEditLabel1.text("Georgia");
        });
        var verdanaEditOption = $(document.createElement("option"));
        verdanaEditOption.text("Verdana").css({ color: "white", "border-color": "rgba(0,0,0,0.5)", overflow: "hidden", background: "no-repeat scroll", "background-color": 'rgba(0,0,0,0.5)' });
        verdanaEditOption.click(function () {
            currentInkController.setFontFamily("Verdana, Geneva, sans-serif");
            fontEditLabel1.text("Verdana");
        });
        var courierEditOption = $(document.createElement("option"));
        courierEditOption.text("Courier").css({ color: "white", "border-color": "rgba(0,0,0,0.5)", overflow: "hidden", background: "no-repeat scroll", "background-color": 'rgba(0,0,0,0.5)' });
        courierEditOption.click(function () {
            currentInkController.setFontFamily("'Courier New', Courier, monospace");
            fontEditLabel1.text("Courier");
        });

        fontEditSelector.append(timesEditOption);
        fontEditSelector.append(georgiaEditOption);
        fontEditSelector.append(verdanaEditOption);
        fontEditSelector.append(courierEditOption);

        // font label click handler -- opens dropdown
        fontEditLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            fontEditLabel.css({ 'font-weight': 'bold' });
            updateToggle(textEditArray, fontEditSelector);
        });

        // font color label for editing ink text
        var colorEditTextLabel = $(document.createElement('div'));
        colorEditTextLabel.addClass('thicknessLabel');
        var colorEditTextLabel1 = $(document.createElement('div'));
        colorEditTextLabel1.addClass('changeColorEdit');
        colorEditTextLabel.text("Color: ");
        colorEditTextLabel1.text("#FFFFFF");
        colorEditTextLabel.append(colorEditTextLabel1);
        inkEditText.append(colorEditTextLabel);
        colorEditTextLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        colorEditTextLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });

        // div to contain color picker
        var colorEditTextDiv = $(document.createElement('div'));
        colorEditTextDiv.css('display', 'none');
        inkEditText.append(colorEditTextDiv);
        textEditArray.push(colorEditTextDiv);

        // click handler to open color picker
        colorEditTextLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            colorEditTextLabel.css({ 'font-weight': 'bold' });
            updateToggle(textEditArray, colorEditTextDiv);

        });

        // color picker input box for editing ink Text
        var itemEditText = document.createElement('input');
        $(itemEditText).attr('id', 'textEditColorToggle');
        $(itemEditText).attr('readonly', 'readonly');
        $(itemEditText).css({ 'margin-left': '8%', 'margin-top': '3%', 'clear': 'left', 'width': '40%' });
        $(itemEditText).on('keyup', function (event) {
            event.stopPropagation();
        });

        if (itemEditText.addEventListener) {
            itemEditText.addEventListener('DOMNodeInserted', function () {
                // initialize colorpicker object on current element
                myEditTextPicker = new jscolor.color(itemEditText, {});
                myEditTextPicker.fromString("FFFFFF");
                myEditTextPicker.onImmediateChange = function () {
                    currentInkController.setFontColor("#" + $("#textEditColorToggle").attr('value'));
                    $('.changeColorEdit')[0].innerHTML = "#" + $("#textEditColorToggle").attr('value');
                };
            }, false);
        }
        colorEditTextDiv.append(itemEditText);

        // font size label for editing
        var textEditSizeLabel = $(document.createElement('div'));
        textEditSizeLabel.addClass('thicknessLabel');
        var textEditSizeLabel1 = $(document.createElement('div'));
        textEditSizeLabel.text("Text Size: ");
        textEditSizeLabel1.text("8px");
        textEditSizeLabel.append(textEditSizeLabel1);
        inkEditText.append(textEditSizeLabel);
        textEditSizeLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        textEditSizeLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // font size slider for editing
        var textEditSizeSlider = $(document.createElement('div'));
        textEditSizeSlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        });
        inkEditText.append(textEditSizeSlider);
        var textEditSliderPoint = $(document.createElement('div'));
        textEditSliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%", "margin-top": "-0.57%"
        });
        textEditSizeSlider.append(textEditSliderPoint);
        textEditSizeSlider.attr("value", "8px");
        
        // drag handler for font size slider point
        textEditSliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event, ui) {
                //console.log(ui.position.left);
                textEditSliderPoint.value = ui.position.left / (textEditSizeSlider.width() - textEditSliderPoint.width());
                //console.log(textEditSliderPoint.value);
                textEditSizeSlider.attr("value", (textEditSliderPoint.value * (maxFontSize - 8) + 8) + "px"); // font size goes from 12-43 (maybe the slider point goes past 1.0?)
                var val = Math.round(textEditSliderPoint.value * (maxFontSize - 8)) + 8;
                currentFontSize = val;
                textEditSizeLabel1.text(val + "px");
                currentInkController.setFontSize(textEditSizeSlider.attr("value"));
            },
            appendTo: 'body'
        });
        textEditArray.push(textEditSizeSlider);

        // click handler for font size label -- opens size slider
        textEditSizeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            textEditSizeLabel.css({ 'font-weight': 'bold' });
            updateToggle(textEditArray, textEditSizeSlider);
            var pointvalue = (currentFontSize - 8) / (maxFontSize - 8);
            var pointleft = pointvalue * (textEditSizeSlider.width() - textEditSliderPoint.width());
            textEditSliderPoint.css("left", pointleft + "px");
        });

        // save edited ink button
        var saveTextButton = $(document.createElement('button')).css('border-radius', '3.5px');
        saveTextButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-top': '3%', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', 'width': '80%' });
        saveTextButton.get(0).innerHTML = "Save";
        inkEditText.append(saveTextButton);

        functionsPanel.append(textEditDocfrag);


        /**
         * Ink draw UI controls (for initial draw authoring, not editing mode)
         */

        // draw control panel
        var inkDrawDocfrag = document.createDocumentFragment();
        inkDrawControls = $(document.createElement('div'));
        inkDrawControls.attr("id", "inkDrawControls");
        inkDrawControls.css({ 'height': '425%', 'width': '100%', top: '130%', position: 'absolute', 'z-index': 0, 'overflow-y': 'auto', 'margin-top': '8%' });
        inkDrawDocfrag.appendChild(inkDrawControls[0]);
        inkDrawControls.css({ "display": "none" });

        // draw cancel button
        var cancelDrawButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelDrawButton.css({
            'font-size': '70%',
            'color': 'black',
            'margin-left': '8%',
            'margin-bottom': '10px',
            'font-weight': 'bold',
            'float': 'left', /*'width': '25%'*/
            'width': '80%',
            //'height': '14%'
            'padding-left': '4px', 'padding-right': '4px',
        });
        cancelDrawButton.get(0).innerHTML = "Cancel";
        cancelDrawButton.click(function () {
            brushSliderPoint.attr('value', 7.0);
            currentInkController.updatePenWidth("brushSlider");
            removeInkCanv();
            inkDrawControls.hide();
            timeline.setModifyingInk(false);
            timeline.setEditInkOn(false);

            inkAuthoring.getInkUndoManager().clear();
            undoManager.greyOutBtn();
            // reset undo/redo buttons to global undo/redo functionality
            playbackControls.undoButton.off("click");
            playbackControls.redoButton.off("click");

            playbackControls.undoButton.on('click', function () {
                undoManager.undo();
            });
            playbackControls.redoButton.on('click', function () {
                undoManager.redo();
            });
            playbackControls.undoRedoInkOnly.css({ 'display': 'none' });
        });
        inkDrawControls.append(cancelDrawButton);

        var drawArray = []; // array of draw controls

        /////////////////////////////////////

        // draw mode div (contains draw and eraser labels)
        var drawModeDiv = $(document.createElement('div'));
        drawModeDiv.css({ "height": '10%', 'width': '80%', 'clear': 'both', 'margin-left': '8%', 'margin-top': '3%', 'display': 'none' });

        // draw mode label
        var drawModeLabel = $(document.createElement('div'));
        drawModeLabel.addClass('thicknessLabel');
        var drawModeLabel1 = $(document.createElement('div'));
        drawModeLabel.text("Mode: ");
        drawModeLabel1.text("Draw");
        drawModeLabel.append(drawModeLabel1);
        drawModeLabel1.css({'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        drawModeLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        inkDrawControls.append(drawModeLabel);
        inkDrawControls.append(drawModeDiv);
        drawArray.push(drawModeDiv);

        // draw mode label click handler
        drawModeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            drawModeLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawArray, drawModeDiv);
        });

        // draw label
        var drawMode = 'draw';
        var drawLabel = $(document.createElement('label'));
        drawLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'bold', 'float': 'left' });
        drawLabel.text("Draw");
        drawModeDiv.append(drawLabel);

        //defaults to min
        var saveDrawThickness = 7;
        var saveEraseThickness = 7;
        var drawThicknessCircleCSSLeft = 0;
        var eraseThicknessCircleCSSLeft = 0;

        // draw label click handler
        drawLabel.on('click', function () {
            if (drawMode === 'erase') {
                drawLabel.css({ 'color': 'black' });
                eraseLabel.css({ 'color': 'gray' });
                drawMode = 'draw';
                drawModeLabel1.text("Draw");
                //save the erase thickness
                    saveEraseThickness = parseFloat(brushSliderPoint.val());
                    eraseThicknessCircleCSSLeft = parseFloat(brushSliderPoint.css('left'));
                //update thickness to saveDrawThickness
                    $('#brushSlider').attr('value', saveDrawThickness);
                    $('#brushSlider').css({
                        'left': drawThicknessCircleCSSLeft + 'px'
                    });
                    currentInkController.updatePenWidth("brushSlider");
                    currentInkController.setEraserWidth($('#brushSlider').attr('value'));
                    $('.brushLabel1').text(Math.round($('#brushSlider').attr('value')) + "px");
                //
                //console.log('setting draw thickness to '+ saveDrawThickness);
                currentInkController.set_mode(1); // draw mode
            }
        });

        // erase label
        var eraseLabel = $(document.createElement('label'));
        eraseLabel.css({ 'font-size': '0.8em', 'color': 'gray', 'margin-right': '9%', 'font-weight': 'bold', 'float': 'right' });
        eraseLabel.text("Erase");
        drawModeDiv.append(eraseLabel);

        // block label click handler
        eraseLabel.on('click', function () {
            if (drawMode === 'draw') {
                drawLabel.css({ 'color': 'gray' });
                eraseLabel.css({ 'color': 'black' });
                drawMode = 'erase';
                drawModeLabel1.text("Erase");
                //save the draw thickness
                    saveDrawThickness = parseFloat(brushSliderPoint.val());
                    drawThicknessCircleCSSLeft = parseFloat(brushSliderPoint.css('left'));
                //update thickness to saveEraseThickness
                    $('#brushSlider').attr('value', saveEraseThickness);
                    $('#brushSlider').css({
                        'left': eraseThicknessCircleCSSLeft + 'px'
                    });
                    currentInkController.updatePenWidth("brushSlider");
                    currentInkController.setEraserWidth($('#brushSlider').attr('value'));
                    $('.brushLabel1').text(Math.round($('#brushSlider').attr('value')) + "px");
                //
                //console.log('setting erase thickness to ' + saveEraseThickness);
                currentInkController.set_mode(2); // erase mode
            }
        });

        /////////////////////////////////////



        // brush width label
        var brushLabel = $(document.createElement('div'));
        brushLabel.addClass('thicknessLabel');
        var brushLabel1 = $(document.createElement('div')).addClass('brushLabel1');
        brushLabel.text("Width: ");
        brushLabel1.text("7px");
        brushLabel.append(brushLabel1);
        inkDrawControls.append(brushLabel);
        brushLabel1.css({ 'color': 'green', /*'float': 'right',*/ 'display': 'inline', 'padding-left': '2%' });
        brushLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // brush width slider
        var brushSlider = $(document.createElement('div')).addClass('brushSliderDiv');
        brushSlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        });
        inkDrawControls.append(brushSlider);
        drawArray.push(brushSlider);
        var brushSliderPoint = $(document.createElement('div'));
        brushSliderPoint.attr('id', 'brushSlider');
        brushSliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': "relative",
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%"
        });
        brushSliderPoint.attr('value', 7.0);
        brushSlider.append(brushSliderPoint);

        // brush width label click handler -- opens brush width slider
        brushLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            brushLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawArray, brushSlider);
            //currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
        });
        
        // brush width slider drag handler
        brushSliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                brushSliderPoint.attr('value', (brushSliderPoint.css("left").replace('px', '') / (brushSlider.offset().left + brushSlider.width()) * 60 + 1) + 6); // get values in the right range
                if (brushSliderPoint.value < 7) {
                    brushSliderPoint.attr('value', 7.0);
                }
                currentInkController.updatePenWidth("brushSlider");
                currentInkController.setEraserWidth(brushSliderPoint.attr('value'));
                //currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
                brushLabel1.text(Math.round(brushSliderPoint.attr('value')) + "px");
            },
            appendTo: 'body'
        });
        
        // brush color label
        var colorLabel = $(document.createElement('div'));
        colorLabel.addClass('thicknessLabel');
        var colorLabel1 = $(document.createElement('div'));
        colorLabel1.addClass('changeColor1');
        colorLabel.text("Color: ");
        colorLabel1.text("#000000");
        colorLabel.append(colorLabel1);
        inkDrawControls.append(colorLabel);
        colorLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        colorLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });

        // div to contain color picker
        var colorDiv = $(document.createElement('div'));
        colorDiv.css('display', 'none');
        inkDrawControls.append(colorDiv);
        drawArray.push(colorDiv);

        // color label click handler
        colorLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            colorLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawArray, colorDiv);
            currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
            drawLabel.css({ 'color': 'black' });
            eraseLabel.css({ 'color': 'gray' });
            drawMode = 'draw';
            drawModeLabel1.text("Draw");
        });

        // input element for color picker
        var item = document.createElement('input');
        $(item).attr('id', 'brushColorToggle');
        $(item).attr('readonly', 'readonly');
        $(item).css({ 'margin-left': '8%', 'float': 'left', 'margin-top': '3%', 'clear': 'left', 'width': '40%'});
        item.onfocus = function () {
            currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
        };
        $(item).on('keyup', function (event) {
            event.stopPropagation();
        });
        if (item.addEventListener) {
            item.addEventListener('DOMNodeInserted', function () {
                //initialize colorpicker object on current element
                myPicker = new jscolor.color(item, {});
                myPicker.fromString("000000");
                myPicker.onImmediateChange = function () {
                    currentInkController.updatePenColor("brushColorToggle");
                    currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
                    $('.changeColor1')[0].innerHTML = "#"+$("#brushColorToggle").attr("value");
                };
            }, false);
        }
        colorDiv.append(item);

        //// eraser width label
        //var eraserLabel = $(document.createElement('div'));
        //eraserLabel.addClass('thicknessLabel');
        //var eraserLabel1 = $(document.createElement('div'));
        //eraserLabel.text("Eraser: ");
        //eraserLabel1.text("7px");
        //eraserLabel.append(eraserLabel1);
        //inkDrawControls.append(eraserLabel);
        //eraserLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        //eraserLabel.css({ 'font-size': '130%', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        //// eraser width slider
        //var eraserSlider = $(document.createElement('div'));
        //eraserSlider.css({
        //    'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
        //    'width': '70%', 'height': '21px', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        //});
        //inkDrawControls.append(eraserSlider);
        //drawArray.push(eraserSlider);

        //// eraser label click handler
        //eraserLabel.on('click', function () {
        //    $(".thicknessLabel").css({ 'font-weight': 'normal' });
        //    eraserLabel.css({ 'font-weight': 'bold' });
        //    updateToggle(drawArray, eraserSlider);
        //    currentInkController.set_mode(TAG.TourAuthoring.InkMode.erase);
        //});
        //var eraserSliderPoint = $(document.createElement('div'));
        //eraserSliderPoint.attr('id', 'eraserSlider');
        //eraserSliderPoint.css({
        //    'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
        //    'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%"
        //});
        //eraserSliderPoint.attr('value', 7.0);
        //eraserSlider.append(eraserSliderPoint);

        //// eraser width slider drag handler
        //eraserSliderPoint.draggable({
        //    axis: "x", containment: "parent",
        //    scroll: false,
        //    drag: function (event) {
        //        eraserSliderPoint.attr('value', (parseFloat(eraserSliderPoint.css("left").replace('px', '')) / parseFloat(eraserSlider.offset().left + eraserSlider.width()) * 60 + 1) + 6);// * 24.33 + 1;
        //        if (eraserSliderPoint.value < 7) {
        //            eraserSliderPoint.attr('value', 7.0);
        //        }
        //        currentInkController.setEraserWidth(eraserSliderPoint.attr('value'));
        //        eraserLabel1.text(Math.round(eraserSliderPoint.attr('value')) + "px");
        //    },
        //    appendTo: 'body'
        //});

        // draw opacity label
        var opacityLabel = $(document.createElement('div'));
        opacityLabel.addClass('thicknessLabel');
        var opacityLabel1 = $(document.createElement('div'));
        opacityLabel.text("Opacity: ");
        opacityLabel1.text("100%");
        opacityLabel.append(opacityLabel1);
        inkDrawControls.append(opacityLabel);
        opacityLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        opacityLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // draw opacity slider
        var opacitySlider = $(document.createElement('div'));
        opacitySlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        });
        inkDrawControls.append(opacitySlider);
        drawArray.push(opacitySlider);
        var opacitySliderPoint = $(document.createElement('div'));
        opacitySliderPoint.attr('id', 'opacitySlider');
        opacitySliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%", "margin-top": "-0.57%"
        });
        opacitySliderPoint.attr("value", 1.0);
        opacitySlider.append(opacitySliderPoint);

        // opacity label click handler
        opacityLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            opacityLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawArray, opacitySlider);
            currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
            drawLabel.css({ 'color': 'black' });
            eraseLabel.css({ 'color': 'gray' });
            drawMode = 'draw';
            drawModeLabel1.text("Draw");
        });

        // opacity slider drag handler
        opacitySliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                opacitySliderPoint.attr('value', (parseFloat(opacitySliderPoint.css("left").replace('px', '')) / (parseFloat(opacitySlider.offset().left) + parseFloat(opacitySlider.width())) * 1.28));
                if (opacitySliderPoint[0].value > 0.99) {
                    opacitySliderPoint.attr('value', 1.0);
                }
                else if (opacitySliderPoint[0].value < 0) {
                    opacitySliderPoint.attr('value', 0.0);
                }
                currentInkController.updatePenOpacity("opacitySlider");
                opacityLabel1.text(Math.round(100 * opacitySliderPoint.attr("value")) + "%");
            },
            appendTo: 'body'
        });
        
        // draw attach buttons
        var linkDrawDiv = getAttachDiv(inkDrawControls);
        inkDrawControls.append(linkDrawDiv);
        functionsPanel.append(inkDrawDocfrag);

        /**
         * Edit draw controls (edit mode)
         */

        // edit draw control panel
        var editDrawDocfrag = document.createDocumentFragment();
        inkEditDraw = $(document.createElement('div'));
        inkEditDraw.attr("id", "inkEditDraw");
        inkEditDraw.css({ 'height': '425%', 'width': '100%', top: '130%', position: 'absolute', 'z-index': 0, 'overflow-y': 'auto', 'margin-top': '8%', });
        editDrawDocfrag.appendChild(inkEditDraw[0]);
        inkEditDraw.css('display', 'none');

        // cancel edit draw button
        var cancelEditDrawButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelEditDrawButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', 'width': '80%' });
        cancelEditDrawButton.get(0).innerHTML = "Cancel";
        inkEditDraw.append(cancelEditDrawButton);

        var drawEditArray = []; // array of draw controls

        /////////////////////////////////////

        // draw mode div (contains draw and eraser labels)
        var drawEditModeDiv = $(document.createElement('div'));
        drawEditModeDiv.css({ "height": '10%', 'width': '80%', 'clear': 'both', 'margin-left': '8%', 'margin-top': '3%', 'display': 'none' });

        // draw mode label
        var drawEditModeLabel = $(document.createElement('div'));
        drawEditModeLabel.addClass('thicknessLabel');
        var drawEditModeLabel1 = $(document.createElement('div'));
        drawEditModeLabel.text("Mode: ");
        drawEditModeLabel1.text("Draw");
        drawEditModeLabel.append(drawEditModeLabel1);
        drawEditModeLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        drawEditModeLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        inkEditDraw.append(drawEditModeLabel);
        inkEditDraw.append(drawEditModeDiv);
        drawEditArray.push(drawEditModeDiv);

        // draw mode label click handler
        drawEditModeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            drawEditModeLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawEditArray, drawEditModeDiv);
        });

        // draw label
        var drawEditMode = 'draw';
        var drawEditLabel = $(document.createElement('label'));
        drawEditLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'bold', 'float': 'left' });
        drawEditLabel.text("Draw");
        drawEditModeDiv.append(drawEditLabel);

        // draw label click handler
        drawEditLabel.on('click', function () {
            if (drawEditMode === 'erase') {
                drawEditLabel.css({ 'color': 'black' });
                eraseEditLabel.css({ 'color': 'gray' });
                drawEditMode = 'draw';
                drawEditModeLabel1.text("Draw");
                currentInkController.set_mode(1); // draw mode
            }
        });

        // erase label
        var eraseEditLabel = $(document.createElement('label'));
        eraseEditLabel.css({ 'font-size': '0.8em', 'color': 'gray', 'margin-right': '9%', 'font-weight': 'bold', 'float': 'right' });
        eraseEditLabel.text("Erase");
        drawEditModeDiv.append(eraseEditLabel);

        // block label click handler
        eraseEditLabel.on('click', function () {
            if (drawEditMode === 'draw') {
                drawEditLabel.css({ 'color': 'gray' });
                eraseEditLabel.css({ 'color': 'black' });
                drawEditMode = 'erase';
                drawEditModeLabel1.text("Erase");
                currentInkController.set_mode(2); // erase mode
            }
        });

        /////////////////////////////////////

        // brush width label
        var brushEditLabel = $(document.createElement('div'));
        brushEditLabel.addClass('thicknessLabel');
        var brushEditLabel1 = $(document.createElement('div'));
        brushEditLabel.text("Width: ");
        brushEditLabel1.text("7px");
        brushEditLabel.append(brushEditLabel1);
        inkEditDraw.append(brushEditLabel);
        brushEditLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        brushEditLabel.css({ '-ms-touch-action': 'none', 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // brush width slider
        var brushEditSlider = $(document.createElement('div'));
        brushEditSlider.addClass("brushEditSlider");
        brushEditSlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative', 'float': 'left'
        });
        inkEditDraw.append(brushEditSlider);
        drawEditArray.push(brushEditSlider);
        var brushEditSliderPoint = $(document.createElement('div'));
        brushEditSliderPoint.attr('id', 'brushEditSlider');
        brushEditSliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': "relative",
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%"
        });
        brushEditSliderPoint.attr('value', 7.0);
        brushEditSlider.append(brushEditSliderPoint);

        // brush width label click handler
        brushEditLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            brushEditLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawEditArray, brushEditSlider);
            //currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
        });

        // brush width slider drag handler
        brushEditSliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                brushEditSliderPoint.attr('value', (brushEditSliderPoint.css("left").replace('px', '') / (brushEditSlider.offset().left + brushEditSlider.width()) * 60 + 1) + 6);// * 24.33 + 1;
                if (brushEditSliderPoint.value < 7) {
                    brushEditSliderPoint.attr('value', 7.0);
                }
                currentInkController.updatePenWidth("brushEditSlider");
                //currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
                brushEditLabel1.text(Math.round(brushEditSliderPoint.attr('value')) + "px");
            },
            appendTo: 'body'
        });

        // brush color label
        var colorEditLabel = $(document.createElement('div'));
        colorEditLabel.addClass('thicknessLabel');
        var colorEditLabel1 = $(document.createElement('div'));
        colorEditLabel1.addClass('changeColor1Edit');
        colorEditLabel.text("Color: ");
        colorEditLabel1.text("#000000");
        colorEditLabel.append(colorEditLabel1);
        inkEditDraw.append(colorEditLabel);
        colorEditLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        colorEditLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });

        // div containing color picker
        var colorEditDiv = $(document.createElement('div'));
        colorEditDiv.css('display', 'none');
        inkEditDraw.append(colorEditDiv);
        drawEditArray.push(colorEditDiv);

        // color label click handler
        colorEditLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            colorEditLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawEditArray, colorEditDiv);
            currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
            drawEditLabel.css({ 'color': 'black' });
            eraseEditLabel.css({ 'color': 'gray' });
            drawEditMode = 'draw';
            drawEditModeLabel1.text("Draw");
        });

        // input element for color picker
        var itemEdit = document.createElement('input');
        $(itemEdit).attr('id', 'brushEditColorToggle');
        $(itemEdit).attr('readonly', 'readonly');
        $(itemEdit).css({ 'margin-left': '8%', 'float': 'left', 'margin-top': '3%', 'clear': 'left', 'width': '40%' });
        itemEdit.onfocus = function () {
            currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
            drawEditLabel.css({ 'color': 'black' });
            eraseEditLabel.css({ 'color': 'gray' });
            drawEditMode = 'draw';
            drawEditModeLabel1.text("Draw");
        };
        $(itemEdit).on('keyup', function (event) {
            event.stopPropagation();
        });
        if (itemEdit.addEventListener) {
            itemEdit.addEventListener('DOMNodeInserted', function () {
                //initialize colorpicker object on current element
                myEditDrawPicker = new jscolor.color(itemEdit, {});
                myEditDrawPicker.fromString("000000");
                myEditDrawPicker.onImmediateChange = function () {
                    currentInkController.updatePenColor("brushEditColorToggle");
                    currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
                    drawEditLabel.css({ 'color': 'black' });
                    eraseEditLabel.css({ 'color': 'gray' });
                    drawEditMode = 'draw';
                    drawEditModeLabel1.text("Draw");
                    $('.changeColor1Edit')[0].innerHTML = currentInkController.getPenColor();
                };
            }, false);
        }
        colorEditDiv.append(itemEdit);
        
        //// eraser width label
        //var eraserEditLabel = $(document.createElement('div'));
        //eraserEditLabel.addClass('thicknessLabel');
        //var eraserEditLabel1 = $(document.createElement('div'));
        //eraserEditLabel.text("eraser: ");
        //eraserEditLabel1.text("7px");
        //eraserEditLabel.append(eraserEditLabel1);
        //inkEditDraw.append(eraserEditLabel);
        //eraserEditLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        //eraserEditLabel.css({ 'font-size': '130%', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        //// eraser width slider
        //var eraserEditSlider = $(document.createElement('div'));
        //eraserEditSlider.css({
        //    'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
        //    'width': '70%', 'height': '21px', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        //});
        //inkEditDraw.append(eraserEditSlider);
        //drawEditArray.push(eraserEditSlider);

        //// eraser width label click handler
        //eraserEditLabel.on('click', function () {
        //    $(".thicknessLabel").css({ 'font-weight': 'normal' });
        //    eraserEditLabel.css({ 'font-weight': 'bold' });
        //    updateToggle(drawEditArray, eraserEditSlider);
        //    currentInkController.set_mode(TAG.TourAuthoring.InkMode.erase);
        //});
        //var eraserEditSliderPoint = $(document.createElement('div'));
        //eraserEditSliderPoint.attr('id', 'eraserEditSlider');
        //eraserEditSliderPoint.css({
        //    'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
        //    'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%"
        //});
        //eraserEditSliderPoint.attr('value', 7.0);
        //eraserEditSlider.append(eraserEditSliderPoint);

        //// eraser width slider drag handler
        //eraserEditSliderPoint.draggable({
        //    axis: "x", containment: "parent",
        //    scroll: false,
        //    drag: function (event) {
        //        eraserEditSliderPoint.attr('value', (eraserEditSliderPoint.css("left").replace('px', '') / (eraserEditSlider.offset().left + eraserEditSlider.width()) * 60 + 1) + 6);// * 24.33 + 1;
        //        if (eraserEditSliderPoint.value < 7) {
        //            eraserEditSliderPoint.attr('value', 7.0);
        //        }
        //        currentInkController.updateEraserWidth("eraserEditSlider");
        //        eraserEditLabel1.text(Math.round(eraserEditSliderPoint.attr('value')) + "px");
        //    },
        //    appendTo: 'body'
        //});

        // draw opacity label
        var opacityEditLabel = $(document.createElement('div'));
        opacityEditLabel.addClass('thicknessLabel');
        var opacityEditLabel1 = $(document.createElement('div'));
        opacityEditLabel.text("opacity: ");
        opacityEditLabel1.text("100%");
        opacityEditLabel.append(opacityEditLabel1);
        inkEditDraw.append(opacityEditLabel);
        opacityEditLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        opacityEditLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // draw opacity slider
        var opacityEditSlider = $(document.createElement('div'));
        opacityEditSlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'
        });
        inkEditDraw.append(opacityEditSlider);
        drawEditArray.push(opacityEditSlider);
        var opacityEditSliderPoint = $(document.createElement('div'));
        opacityEditSliderPoint.attr('id', 'opacityEditSlider');
        opacityEditSliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%", 'left': '87%', "margin-top": "-0.57%"
        });
        opacityEditSliderPoint.attr("value", 1.0);
        opacityEditSlider.append(opacityEditSliderPoint);

        // draw opacity label click handler
        opacityEditLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            opacityEditLabel.css({ 'font-weight': 'bold' });
            updateToggle(drawEditArray, opacityEditSlider);
            currentInkController.set_mode(1);
            drawEditLabel.css({ 'color': 'black' });
            eraseEditLabel.css({ 'color': 'gray' });
            drawEditMode = 'draw';
            drawEditModeLabel1.text("Draw");
        });

        // draw opacity slider drag handler
        opacityEditSliderPoint.draggable({
             axis: "x", containment: "parent",
             scroll: false,
             drag: function (event) {
                 opacityEditSliderPoint.attr('value', (parseFloat(opacityEditSliderPoint.css("left").replace('px', '')) / (parseFloat(opacityEditSlider.offset().left) + parseFloat(opacityEditSlider.width())) * 1.28));
                 if (opacityEditSliderPoint[0].value > 0.99) {
                     opacityEditSliderPoint.attr('value', 1.0);
                 }
                 else if (opacityEditSliderPoint[0].value < 0) {
                     opacityEditSliderPoint.attr('value', 0.0);
                 }
                 currentInkController.updatePenOpacity("opacityEditSlider");
                 opacityEditLabel1.text(Math.round(100 * opacityEditSliderPoint.attr("value")) + "%");
             },
             appendTo: 'body'
         });
        

        // edit draw save button
        var saveDrawButton = $(document.createElement('button')).css('border-radius', '3.5px');
        saveDrawButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-top': '3%', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', 'width': '80%' });
        saveDrawButton.get(0).innerHTML = "Save";
        inkEditDraw.append(saveDrawButton);

        functionsPanel.append(editDrawDocfrag);

        /**
         * Ink transparency controls (initial authoring, not editing mode)
         */

        // transparency control panel
        var inkTransparencyDocfrag = document.createDocumentFragment();
        inkTransparencyControls = $(document.createElement('div'));
        inkTransparencyControls.attr("id","inkTransControls");
        inkTransparencyControls.css({ 'height': '425%', 'width': '100%', top: '130%', position: 'absolute', 'z-index': 0, 'overflow-y': 'auto', 'margin-top': '8%' });
        inkTransparencyDocfrag.appendChild(inkTransparencyControls[0]);
        inkTransparencyControls.css({ "display": "none" });

        // trans cancel button
        var cancelTransButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelTransButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', /*'width': '25%'*/ 'width': '80%', });
        cancelTransButton.get(0).innerHTML = "Cancel";
        cancelTransButton.on('click', function () {
            removeInkCanv();
            inkTransparencyControls.hide();
            timeline.setModifyingInk(false);
            timeline.setEditInkOn(false);

            inkAuthoring.getInkUndoManager().clear();
            undoManager.greyOutBtn();
            // revert undo/redo buttons to global undo/redo functionality
            playbackControls.undoButton.off("click");
            playbackControls.redoButton.off("click");
            playbackControls.undoButton.on('click', function () {
                undoManager.undo();
            });
            playbackControls.redoButton.on('click', function () {
                undoManager.redo();
            });
            //console.log("reseting undo-redo buttons to global");
            playbackControls.undoRedoInkOnly.css({ 'display': 'none' });
        });
        inkTransparencyControls.append(cancelTransButton);

        var transArray = []; // array of transparency controls
        
        // add ellipse bounding shape button
        var addEllipseButton = $(document.createElement('button')).css('border-radius', '3.5px');
        addEllipseButton.css({'color': 'black', 'width': '35%', 'float': 'left', 'margin-left': '8%', 'margin-top': '3%', 'clear': 'left' });
        addEllipseButton.get(0).innerHTML = "Add Ellipse";
        addEllipseButton.on('click', function () {
            currentInkController.add_ellipse();
        });
        inkTransparencyControls.append(addEllipseButton);

        // add rectangle bounding shape button
        var addRectButton = $(document.createElement('button')).css('border-radius', '3.5px');
        addRectButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'color': 'black', 'width': '35%', 'float': 'left', 'margin-left': '8%', 'margin-top': '3%' });
        addRectButton.get(0).innerHTML = "Add Rectangle";
        addRectButton.on('click', function () {
            currentInkController.add_rectangle();
        });
        inkTransparencyControls.append(addRectButton);

        // trans mode div (contains isolate and block labels)
        var transModeDiv = $(document.createElement('div'));
        transModeDiv.css({ "height": '10%', 'width': '80%', 'clear': 'both', 'margin-left': '8%', 'margin-top': '3%', 'display': 'none' });

        // trans mode label
        var transModeLabel = $(document.createElement('div'));
        transModeLabel.addClass('thicknessLabel');
        var transModeLabel1 = $(document.createElement('div'));
        transModeLabel.text("Mode: ");
        transModeLabel1.text("Isolate");
        transModeLabel.append(transModeLabel1);
        transModeLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        transModeLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        inkTransparencyControls.append(transModeLabel);
        inkTransparencyControls.append(transModeDiv);
        transArray.push(transModeDiv);

        // trans mode label click handler
        transModeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            transModeLabel.css({ 'font-weight': 'bold' });
            updateToggle(transArray, transModeDiv);
        });

        // isolate label
        var transparencyMode = 'isolate';
        var isolateLabel = $(document.createElement('label'));
        isolateLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'bold', 'float': 'left' });
        isolateLabel.text("Isolate");
        transModeDiv.append(isolateLabel);

        // isolate label click handler
        isolateLabel.on('click', function () {
            if (transparencyMode === 'block') {
                isolateLabel.css({ 'color': 'black' });
                blockLabel.css({ 'color': 'gray' });
                transparencyMode = 'isolate';
                transModeLabel1.text("Isolate");
                currentInkController.setTransMode("isolate");         
            }
        });

        // block label
        var blockLabel = $(document.createElement('label'));
        blockLabel.css({ 'font-size': '0.8em', 'color': 'gray', 'margin-right': '9%', 'font-weight': 'bold', 'float': 'right' });
        blockLabel.text("Block");
        transModeDiv.append(blockLabel);

        // block label click handler
        blockLabel.on('click', function () {
            if (transparencyMode === 'isolate') {
                isolateLabel.css({ 'color': 'gray' });
                blockLabel.css({ 'color': 'black' });
                transparencyMode = 'block';
                transModeLabel1.text("Block");
                currentInkController.setTransMode("block");
            }
        });

        // trans opacity label
        var opacityTransparencyLabel = $(document.createElement('div'));
        opacityTransparencyLabel.addClass('thicknessLabel');
        var opacityTransparencyLabel1 = $(document.createElement('div'));
        opacityTransparencyLabel.text("Opacity: ");
        opacityTransparencyLabel1.text("80%");
        opacityTransparencyLabel.append(opacityTransparencyLabel1);
        inkTransparencyControls.append(opacityTransparencyLabel);
        opacityTransparencyLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        opacityTransparencyLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // trans opacity slider
        var opacityTransparencySlider = $(document.createElement('div'));
        opacityTransparencySlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'/*, 'float': 'left'*/

        });
        var opacityTransparencySliderPoint = $(document.createElement('div'));
        opacityTransparencySliderPoint.attr("id", "opacityTransparencySliderPoint");
        opacityTransparencySliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': 'relative',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%", "margin-top": "-0.57%"
        });
        opacityTransparencySlider.append(opacityTransparencySliderPoint);
        inkTransparencyControls.append(opacityTransparencySlider);

        // trans opacity label click handler
        opacityTransparencyLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            opacityTransparencyLabel.css({ 'font-weight': 'bold' });
            updateToggle(transArray, opacityTransparencySlider);
        });

        // trans opacity slider drag handler
        opacityTransparencySliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                opacityTransparencySliderPoint.attr('value', (parseFloat(opacityTransparencySliderPoint.css("left").replace('px', '')) / (parseFloat(opacityTransparencySlider.offset().left) + parseFloat(opacityTransparencySlider.width())) * 1.28));
                if (opacityTransparencySliderPoint[0].value > 0.99) {
                    opacityTransparencySliderPoint.attr('value', 1.0);
                }
                else if (opacityTransparencySliderPoint[0].value < 0) {
                    opacityTransparencySliderPoint.attr('value', 0.0);
                }
                currentInkController.setMarqueeFillOpacity(parseFloat(opacityTransparencySliderPoint.attr("value")));
                opacityTransparencyLabel1.text(Math.round(100 * opacityTransparencySliderPoint.attr("value")) + "%");
            },
            appendTo: 'body'
        });
        transArray.push(opacityTransparencySlider);

        // trans attach buttons
        var linkTransDiv = getAttachDiv(inkTransparencyControls, 0, "trans");
        inkTransparencyControls.append(linkTransDiv);
        functionsPanel.append(inkTransparencyDocfrag);

        /**
         * Edit transparency controls (edit mode)
         */

        // edit trans control panel
        var editTransparencyDocfrag = document.createDocumentFragment();
        inkEditTransparency = $(document.createElement('div'));
        inkEditTransparency.attr("id", "inkEditTransparency");
        inkEditTransparency.css({ 'height': '425%', 'width': '100%', top: '130%', position: 'absolute', 'z-index': 0, 'overflow-y': 'auto', 'margin-top': '8%' });
        editTransparencyDocfrag.appendChild(inkEditTransparency[0]);
        inkEditTransparency.css({ "display": "none" });

        // trans cancel button
        var cancelEditTransButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelEditTransButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', /*'width': '25%'*/ 'width': '80%' });
        cancelEditTransButton.get(0).innerHTML = "Cancel";
        inkEditTransparency.append(cancelEditTransButton);

        var transEditArray = []; // array of edit transparency controls

        // add ellipse bounding shape button
        var addEditEllipseButton = $(document.createElement('button')).css('border-radius', '3.5px');
        addEditEllipseButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'color': 'black', 'width': '35%', 'float': 'left', 'margin-left': '8%', 'margin-top': '3%', 'clear': 'left' });
        addEditEllipseButton.get(0).innerHTML = "Add Ellipse";
        addEditEllipseButton.on('click', function () {
            currentInkController.add_ellipse();
        });
        inkEditTransparency.append(addEditEllipseButton);

        // add rectangle bounding shape button
        var addEditRectButton = $(document.createElement('button')).css('border-radius', '3.5px');
        addEditRectButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'color': 'black', 'width': '35%', 'float': 'left', 'margin-left': '8%', 'margin-top': '3%' });
        addEditRectButton.get(0).innerHTML = "Add Rectangle";
        addEditRectButton.on('click', function () {
            currentInkController.add_rectangle();
        });
        inkEditTransparency.append(addEditRectButton);

        // div containing transparency mode options
        var transEditModeDiv = $(document.createElement('div'));
        transEditModeDiv.css({ "height": '10%', 'width': '80%', 'clear': 'both', 'margin-left': '8%', 'margin-top': '3%', 'display': 'none' });

        // trans mode label
        var transEditModeLabel = $(document.createElement('div'));
        transEditModeLabel.addClass('thicknessLabel');
        var transEditModeLabel1 = $(document.createElement('div'));
        transEditModeLabel.text("Mode: ");
        transEditModeLabel1.text("Isolate");
        transModeLabel.attr("id", "transModeLabel");
        transEditModeLabel.append(transEditModeLabel1);
        transEditModeLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        transEditModeLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });
        inkEditTransparency.append(transEditModeLabel);
        inkEditTransparency.append(transEditModeDiv);
        transEditArray.push(transEditModeDiv);

        //trans mode click handler
        transEditModeLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            transEditModeLabel.css({ 'font-weight': 'bold' });
            updateToggle(transEditArray, transEditModeDiv);
        });

        var transparencyEditMode = 'isolate';

        // isolate label
        var isolateEditLabel = $(document.createElement('label'));
        isolateEditLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'bold', 'float': 'left' });
        isolateEditLabel.text("Isolate");
        transEditModeDiv.append(isolateEditLabel);

        // isolate label click handler
        isolateEditLabel.on('click', function () {
            if (transparencyEditMode === 'block') {
                isolateEditLabel.css({ 'color': 'black' });
                blockEditLabel.css({ 'color': 'gray' });
                transparencyEditMode = 'isolate';
                transEditModeLabel1.text("Isolate");
                currentInkController.setTransMode("isolate");
            }
        });

        // block label
        var blockEditLabel = $(document.createElement('label'));
        blockEditLabel.css({ 'font-size': '0.8em', 'color': 'gray', 'margin-right': '9%', 'font-weight': 'bold', 'float': 'right' });
        blockEditLabel.text("Block");
        transEditModeDiv.append(blockEditLabel);

        // block label click handler
        blockEditLabel.on('click', function () {
            if (transparencyEditMode === 'isolate') {
                isolateEditLabel.css({ 'color': 'gray' });
                blockEditLabel.css({ 'color': 'black' });
                transparencyEditMode = 'block';
                transEditModeLabel1.text("Block");
                currentInkController.setTransMode("block");
            }
        });

        // trans opacity label
        var opacityEditTransparencyLabel = $(document.createElement('div'));
        opacityEditTransparencyLabel.addClass('thicknessLabel');
        var opacityEditTransparencyLabel1 = $(document.createElement('div'));
        opacityEditTransparencyLabel.text("Opacity: ");
        opacityEditTransparencyLabel1.text("80%");
        opacityEditTransparencyLabel.append(opacityEditTransparencyLabel1);
        inkEditTransparency.append(opacityEditTransparencyLabel);
        opacityEditTransparencyLabel1.css({ 'color': 'green', 'display': 'inline', 'padding-left': '2%' });
        opacityEditTransparencyLabel.css({ 'font-size': '0.8em', 'color': 'black', 'margin-left': '8%', 'font-weight': 'normal', 'margin-top': '3%', 'margin-right': '12%', 'margin-bottom': '1%', 'float': 'left', 'clear': 'both', 'display': 'inline', 'border-bottom-width': ' 2px', 'border-bottom-style': 'solid', 'border-bottom-color': 'white', 'width': '80%', });

        // trans opacity slider
        var opacityEditTransparencySlider = $(document.createElement('div'));
        opacityEditTransparencySlider.attr("id", "opacityEditTransparencySlider");
        opacityEditTransparencySlider.css({
            'clear': 'both', 'background-color': 'rgb(136, 134, 134)', "border-radius": "25px", "-ms-touch-action": "none", 'border': '1px solid gray',
            'width': '70%', 'height': '12%', 'margin-top': '3%', 'margin-left': '8%', 'display': 'none', 'position': 'relative'/*, 'float': 'left'*/
        });
        var opacityEditTransparencySliderPoint = $(document.createElement('div'));
        opacityEditTransparencySliderPoint.attr("id", "opacityEditTransparencySliderPoint");
        opacityEditTransparencySliderPoint.css({
            'background-color': 'white', 'height': '115%', 'width': '9.25%', 'position': "relative",
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%", "top": "-5%", "margin-top": "-0.57%"
        });
        opacityEditTransparencySlider.append(opacityEditTransparencySliderPoint);
        inkEditTransparency.append(opacityEditTransparencySlider);

        // trans opacity label click handler
        opacityEditTransparencyLabel.on('click', function () {
            $(".thicknessLabel").css({ 'font-weight': 'normal' });
            opacityEditTransparencyLabel.css({ 'font-weight': 'bold' });
            updateToggle(transEditArray, opacityEditTransparencySlider);
        });

        // trans opacity slider drag handler
        opacityEditTransparencySliderPoint.draggable({
            axis: "x", containment: "parent",
            scroll: false,
            drag: function (event) {
                opacityEditTransparencySliderPoint.attr('value', (parseFloat(opacityEditTransparencySliderPoint.css("left").replace('px', '')) / (parseFloat(opacityEditTransparencySlider.offset().left) + parseFloat(opacityEditTransparencySlider.width())) * 1.28));
                if (opacityEditTransparencySliderPoint[0].value > 0.99) {
                    opacityEditTransparencySliderPoint.attr('value', 1.0);
                }
                else if (opacityEditTransparencySliderPoint[0].value < 0) {
                    opacityEditTransparencySliderPoint.attr('value', 0.0);
                }
                currentInkController.setMarqueeFillOpacity(parseFloat(opacityEditTransparencySliderPoint.attr("value")));
                opacityEditTransparencyLabel1.text(Math.round(100 * opacityEditTransparencySliderPoint.attr("value")) + "%");
            },
            appendTo: 'body'
        });
        transEditArray.push(opacityEditTransparencySlider);

        // edit trans save button
        var saveTransButton = $(document.createElement('button')).css('border-radius', '3.5px');
        saveTransButton.css({ 'padding-left': '4px', 'padding-right': '4px', 'font-size': '70%', 'color': 'black', 'margin-top': '3%', 'margin-left': '8%', 'margin-bottom': '10px', 'font-weight': 'bold', 'float': 'left', 'width': '80%' });
        saveTransButton.get(0).innerHTML = "Save";
        inkEditTransparency.append(saveTransButton);
        functionsPanel.append(editTransparencyDocfrag);

        /**
         * Below are some helper function for the creation of ink controls above
         */

        /**
         * Allows you to click to close ink, edit ink controls (e.g. opacity sliders by clicking on labels).
         * Clicking on a label will collapse all other controls and show the selected control if it was hidden, hide it if it was shown.
         * @param array   the array of controls containing the control we are clicking on
         * @param show    the control we are clicking on -- we toggle it to be shown or hidden
         */
        function updateToggle(array, show) {
            if (array === textArray || array === drawArray || array === transArray || array === textEditArray || array === drawEditArray || array === transEditArray) {
                $.each(array, function () {
                    if (this === show && $(show).css("display") === "block") {
                        $(".thicknessLabel").css({ 'font-weight': 'normal' });
                        this.css("display", "none");
                    }
                    else {
                        if (this === show) { this.css("display", "block"); }
                        else { this.css("display", "none"); }
                    }
                });
            }
            else {
                $.each(array, function () {
                    if (this === show)
                        this.css("display", "block");
                    else
                        this.css("display", "none");
                });
            }
        }

        /**
         * Collapses all controls in a given panel
         * @param array   this is the array of controls to collapse (e.g. drawArray)
         */
        function hideAll(array) {
            $.each(array, function () {
                    this.css("display", "none");
            });
        }

        /**
         * Initialize the text controls with default values
         */
        function initText() {
            fontLabel.text("Font: ");
            fontLabel1.text("Times New Roman");
            fontLabel.append(fontLabel1);
            textSliderPoint.css("left", "10%");
            timesOption.attr("selected", "selected");
            textSizeLabel.text("Text Size: ");
            textSizeLabel1.text("12px");
            textSizeLabel.append(textSizeLabel1);
            hideAll(textArray);
        }

        /**
         * Initialize the transparency controls with default values
         */
        function initTrans() {
            opacityTransparencyLabel.text("Opacity: ");
            opacityTransparencyLabel1.text("80%");
            opacityTransparencyLabel.append(opacityTransparencyLabel1);
            opacityTransparencySliderPoint.css("left", (0.8 * (opacityTransparencySlider.offset().left + opacityTransparencySlider.width()) / 1.28) + 'px');
            isolateLabel.css({ 'color': 'black' });
            blockLabel.css({ 'color': 'gray' });
            transparencyMode = 'isolate';
            transModeLabel1.text("Isolate");
            hideAll(transArray);
        }

        /**
         * Initialize the draw controls with default values
         */
        function initDraw() {
            brushLabel.text("Width: ");
            brushLabel1.text("7px");
            brushLabel.append(brushLabel1);
            brushSliderPoint.css("left", "0px");
            drawLabel.css({ 'color': 'black' });
            eraseLabel.css({ 'color': 'gray' });
            drawMode = 'draw';
            drawModeLabel1.text("Draw");
            //eraserLabel.text("Eraser: ");
            //eraserLabel1.text("7px");
            //eraserLabel.append(eraserLabel1);
            //eraserSliderPoint.css("left", "0px");
            opacityLabel.text("Opacity: ");
            opacityLabel1.text("100%");
            opacityLabel.append(opacityLabel1);
            opacitySliderPoint.css("left", (0.87 * opacitySlider.width()) + "px");
            hideAll(drawArray);
        }

        function closeAllMenus() {
            dropInk.hide();
            dropFile.hide();
            dropMain.hide();
            fade.hide();
            componentDropDown = false;
        }
        /**
         * Create attach and create as unlinked buttons for ink creation
         */
        function getAttachDiv(controls, text, trans) {
            // slightly different controls for text and transparency, since we can't call currentInkController.link directly
            var text_mode = false;
            var trans_mode = false;
            if (text && text !== 0)
                text_mode = true;
            if (trans)
                trans_mode = true;

            // div to contain buttons
            var newDiv = $(document.createElement('div'));
            newDiv.css("display", "block");
            newDiv.css('margin-top', '2%');

            // attach button
            var linkButton = $(document.createElement('button')).addClass("linkButton").css('border-radius', '3.5px');
            linkButton.css({
                'padding-left': '4px',
                'padding-right': '4px',
                'color': 'black',
                'width': '35%',
                'float': 'left',
                'margin-left': '8%',
                'margin-top': '5%',
                'clear': 'left'
            });
            linkButton.get(0).innerHTML = "Attach to Selected";

            // attach button click handler -- reset to default values, call link, link_text, or link_trans or their unattached equivalents
            linkButton.on('click', function () {
                brushSliderPoint.attr('value', 7.0);
                currentInkController.updatePenWidth("brushSlider");
                colorLabel1.text("#000000");
                myPicker = new jscolor.color(item, {});
                myPicker.fromString("000000");
                myPicker.onImmediateChange = function () {
                    currentInkController.updatePenColor("brushColorToggle");
                    currentInkController.set_mode(TAG.TourAuthoring.InkMode.draw);
                    $('.changeColor1')[0].innerHTML = "#" + $("#brushColorToggle").attr("value");
                };
                var check = true; // if check becomes false, then a warning message appeared, do not proceed after trying to attach
                text_mode = false; // hacky temporary workaround
                if (text_mode)
                    check = currentInkController.link_text();
                else if (trans_mode)
                    check = currentInkController.link_trans();
                else // draw
                    check = currentInkController.link();
                if (!check)
                    return;

                controls.hide();
                // reset undo/redo buttons to global undo/redo functionality
                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");

                playbackControls.undoButton.on('click', function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on('click', function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');


                if (inkAuthoring) {
                    inkAuthoring.getInkUndoManager().clear();
                    undoManager.greyOutBtn();
                }
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
            });
            newDiv.append(linkButton);

            // create as unattached ink button
            var freeInkButton = $(document.createElement('button')).addClass("freeInkButton").css('border-radius', '3.5px');
            freeInkButton.css({
                'padding-left': '4px',
                'padding-right': '4px',
                'color': 'black',
                'width': '35%',
                'float': 'left',
                'margin-left': '8%',
                'margin-top': '5%'
            });
            freeInkButton.get(0).innerHTML = "Create as Unattached";

            // unattached button click handler
            freeInkButton.on('click', function () {
                brushSliderPoint.attr('value', 7.0);
                currentInkController.updatePenWidth("brushSlider");
                var check=true;
                if (text_mode)
                    check=currentInkController.link_text_unattached();
                else if (trans_mode)
                    check=currentInkController.link_trans_unattached();
                else
                    check=currentInkController.linkUnattached();
                if (!check) {
                    return;
                }
                controls.hide();
                // restore global undo/redo functionality
                playbackControls.undoButton.off("click");
                playbackControls.redoButton.off("click");
                playbackControls.undoButton.on('click', function () {
                    undoManager.undo();
                });
                playbackControls.redoButton.on('click', function () {
                    undoManager.redo();
                });
                playbackControls.undoRedoInkOnly.css('display', 'none');

                if (inkAuthoring) {
                    inkAuthoring.getInkUndoManager().clear();
                    undoManager.greyOutBtn();
                }
                timeline.setModifyingInk(false);
                timeline.setEditInkOn(false);
            });
            newDiv.append(freeInkButton);
            return newDiv;
        }

        /**
         * Sets display:none for each of the ink control panels
         */
        function hideInkControls() {
            inkTransparencyControls.css({ 'display': 'none' });
            inkTextControls.css({ 'display': 'none' });
            inkDrawControls.css({ 'display': 'none' });
            inkEditDraw.css({ 'display': 'none', });
            inkEditTransparency.css('display', 'none');
            inkEditText.css('display', 'none');
        }
        that.hideInkControls = hideInkControls;

        /**
         * Removes the current ink canvas if there is one
         */
        function removeInkCanv() {
            if ($("#inkCanv").length)
                $("#inkCanv").remove();

            $("#rinplayer").css({
                
            });
        }
        that.removeInkCanv = removeInkCanv;

        /**
         * Creates an ink canvas
         * @return   a div on which we'll create a Raphael paper
         */
        function createInkCanv() {
            // remove any existing ink canvases
            removeInkCanv();

            // create a div on which we'll create a Raphael paper
            var inkdiv = document.createElement("div");
            inkdiv.setAttribute("id", "inkCanv");
            inkdiv.setAttribute("class", "inkCanv");
            //set rinplayer's position to absolute so our canvas isn't pushed down
            $("#rinplayer").css({
                "position": "absolute",
            });

            // set css of inkdiv, making sure that its z-index is greater than those of all images and artworks (artwork in track i has z-index 20000+i)
            var num_tracks = timeline.getTrackslength();
            inkdiv.setAttribute("style", "overflow:hidden; position:absolute; width:100%; height:100%; background:transparent; pointer-events: all; z-index:" + (20100 + num_tracks) + ";");
            var view_elt = $("#rinContainer"); // change to #rinplayer if we can figure out how to keep it around during tour reloads (if in #rinplayer, we can capture inks in thumbnails)
            //view_elt.append(inkdiv);
            $("#rinplayer").before(inkdiv);
            return inkdiv;
        }

    })();


    /**
     * Appends the functions panel to the inputted container element
     * @param container   element to which we'll append the functions panel
     */
    function addToDOM(container) {
        container.append(functionsPanelDocfrag);
    }
    that.addToDOM = addToDOM;

    /**
     * Adds the catalog overlays (for artwork and associated media import) to the inputted container element
     * Used in TourAuthoringNew
     * @param container   element to which we'll append the functions panel
     */
    function addCatalogToDOM(container) {
        container.appendChild(catalogPickerOverlay);
        container.appendChild(associatedMediaPickerOverlay);
    }
    that.addCatalogToDOM = addCatalogToDOM;

    function getIsUploading() {
        return isUploading;
    }
    that.getIsUploading = getIsUploading;

    return that;
};
;
TAG.Util.makeNamespace("TAG.TourAuthoring.Display");
TAG.Util.makeNamespace("TAG.TourAuthoring.DisplayParts");

TAG.TourAuthoring.DisplayParts = {
    main: 1,
    'fade-in': 2,
    'fade-out': 3
};

/**
 * Makes a display
 * Represents region of time where media is playing
 * Maps to Keyframe Sequence in RIN
 * Contains and manages keyframes added to sequence
 * @param spec  Params: start, length, fadeIn, fadeOut (all time values in seconds), id
 * @param my    Update currentDisplay for touch handling, contains timeManager, undoManager, svg, update
 */
TAG.TourAuthoring.Display = function (spec, my) {
    "use strict";
    if (my.type === TAG.TourAuthoring.TrackType.audio) {
        console.log('audio');
    }
    var that = {}, //values of display
        storageContainer, parentDisplay, // parentDisplay used only by ink
        inStart = spec.start || 0, // start of fade-in, start of entire display
        totalLength = spec.length || 5, // total length
        canKeyframe = spec.canKeyframe,
        canFade = spec.canFade,
        fadeIn = (canFade && totalLength >= 1.5) ? (spec.fadeIn || 0.5) : 0, // length of fade-in
        fadeOut = (canFade && totalLength >= 1.5) ? (spec.fadeOut || 0.5) : 0, // length of fade-out
        main = (totalLength - (fadeIn + fadeOut)),
        mainStart = (inStart + fadeIn), // start of main region
        outStart = (mainStart + main), // start of fade-out
        id,
        mainRect,
        trackPos,
        dataHolder = spec.dataHolder,
        //keyframes = [],
        currkeyframes,
        childDisplays = [], // used only by artworks to be aware of their inks
        menu = TAG.TourAuthoring.EditorMenu({
            type: TAG.TourAuthoring.MenuType.display,
            parent: that
        }, my);
 
    //use these for edit ink primarily -- we could also use getters so we don't have to use 'that.' all over the place -bleveque
    that.inStart = inStart;
    that.fadeIn = fadeIn;
    that.fadeOut = fadeOut;
    that.oldStart = outStart;
    //that.id = id || 0;
    that.clamped_new = {};
    that.clamped_init = {};
    that.has_been_clamped = false;

    // Add to SVG
    // Note: there is no "add" function, due to how SVG and d3 operates.
    var gv, // svg group containing display elements
        gkey, // svg group containing keyframe elements
        finD, // fade-in display box
        finHandle, // handle for resizing
        mainD, // main display box
        fioD, // fade-out display box
        fioHandle, // handle for resizing
        // last two used for mouse/touch handling
        loc, // region of display mouse/finger is clicked over
        offset, // offset of mouse/finger from beginning of region specified in loc
        hidden = false; // bool flag for whether circles are hidden, i.e. track is minimized

    var snapTimesDLL = new DoublyLinkedList(); //global snappable times list
    var dispNode;

    var T2P = my.timeManager.timeToPx,
        P2T = my.timeManager.pxToTime;

    function setKeyframeTree(kft) {
        currkeyframes = kft;
    }
    that.setKeyframeTree = setKeyframeTree;
    
    function getChildDisplays() {
        return childDisplays;
    }
    that.getChildDisplays = getChildDisplays;

    function addChildDisplay(newdisp) {
        childDisplays.push(newdisp);
    }
    that.addChildDisplay = addChildDisplay;

    function removeChildDisplay(toRemove) {
        childDisplays.splice(childDisplays.indexOf(toRemove), 1);
    }
    that.removeChildDisplay = removeChildDisplay;

    function initVisuals() {
        var displayDivs = TAG.Util.UI.createDisplay({
            x: T2P(inStart),
            fadeIn: T2P(fadeIn),
            fadeOut: T2P(fadeOut),
            mainLength: T2P(main),
            mainColor: canKeyframe ? (my.type === TAG.TourAuthoring.TrackType.audio ? 'rgba(129, 173, 98, 0.8)' : TAG.TourAuthoring.Constants.displayColor) : TAG.TourAuthoring.Constants.inkDisplayColor,
            fadeColor: null, // FIX THIS TODO
            height: null,
            container: my.track
        }); 

        mainD = displayDivs.mainRect;
        finD = displayDivs.inRect,
        fioD = displayDivs.outRect,
        finHandle = displayDivs.inHandle,
        fioHandle = displayDivs.outHandle;

        finD.on('mousedown', function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-in']);
        });
        mainD.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['main']);
        });
        fioD.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-out']);
        });
        finHandle.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-in']);
        });
        fioHandle.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-out']);
        });
    }
    that.initVisuals = initVisuals;
    initVisuals();

    function restoreHandlers() {
        finD.off('mousedown');
        fioD.off('mousedown');
        mainD.off('mousedown');
        finHandle.off('mousedown');
        fioHandle.off('mousedown');
        finD.on('mousedown', function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-in']);
        });
        mainD.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['main']);
        });
        fioD.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-out']);
        });
        finHandle.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-in']);
        });
        fioHandle.on("mousedown", function (e) {
            var offsetX = e.offsetX;
            _displayMousedown(offsetX, TAG.TourAuthoring.DisplayParts['fade-out']);
        });
    }
    that.restoreHandlers = restoreHandlers;

    /**
         * Bound to mousedown on display parts
         * Sets currentDisplay for use by displayClick
         * Resets currentDisplay on mouseup
         * @param mouseoffset   offset of mouse on element clicked for accurate dragging (offset from start of the timeline)
         * @param mouseloc      TAG.TourAuthoring.DisplayParts enum type specifying which part of display was clicked
         */
    function _displayMousedown(mouseoffset, mouseloc) {
        var oldin = inStart, // state before move
            oldmainstart = mainStart,
            oldmain = main,
            oldout = outStart,
            oldtotal = totalLength; // saves old values

        initSnap(); //initialize snapping at mouse down on display

        // Stop playback on click
        my.timeManager.stop();

        // Set move related instance variables
        offset = mouseoffset;
        loc = mouseloc;
        if (loc === TAG.TourAuthoring.DisplayParts['fade-in'] || loc === TAG.TourAuthoring.DisplayParts['fade-out']) {
            if (my.that.getMinimizedState()) {
                return;
            }
        }

        if (my.that.getMinimizedState()) {
            finHandle.hide();
            fioHandle.hide();
        }
        my.currentDisplay = that;
        my.timeline.newDataArray();
        for (var i = 0; i < my.timeline.getMultiSelectionArray().length; i++) {
            my.timeline.getMultiSelectionArray()[i].setLoc(loc);
        }
        // On mouseup reset all instance vars and log state
        $('body').on('mouseup.display', function () {
            //  var command, newin, newmainstart, newmain, newout, newtotal; // state after move
            if (my.that.getMinimizedState()) {
                finHandle.hide();
                fioHandle.hide();
            }

            var command, redo, undo, multiDisplays;
            var prevDisp = dataHolder.findPreviousDisplay(my.that.getPos(), that);
            var nextDisp = dataHolder.findNextDisplay(my.that.getPos(), that);
            redo = 0;
            undo = 0;
            var oldOff = offset;
            var oldLoc = loc;
            my.currentDisplay = null;
            offset = null;
            loc = null;
            $('body').off('mouseup.display');
            function logHelper(disp, cinit, cnew) {
                var clamp_command = {
                    execute: function () { disp.setTimes(cnew); },
                    unexecute: function () {
                        disp.setTimes(cinit);
                    },
                };
                my.undoManager.logCommand(clamp_command);
            }


            if (my.timeline.getMultiSelectionArray().length !== 0) {
                var multiDisplaysOrig = my.timeline.getMultiSelectionArray();
                multiDisplays = [];
                multiDisplaysOrig.map(function (d) {
                    multiDisplays.push(d);
                });
            }

            // If movement has occured, update and log command

            if (oldin !== inStart || oldmainstart !== mainStart || oldmain !== main || oldout !== outStart) {
                my.timeline.updateOldData();
                my.update();
                switch (oldLoc) {
                    case TAG.TourAuthoring.DisplayParts['fade-in']:
                        redo = inStart;//save new value
                        undo = oldin;//save old value
                        break;
                    case TAG.TourAuthoring.DisplayParts['fade-out']:
                        redo = outStart;
                        undo = oldout;
                        break;
                    case TAG.TourAuthoring.DisplayParts['main']:
                        redo = mainStart;
                        undo = oldmainstart;
                        break;
                }
                // my.update();
                var left = 0;
                var right = Infinity;
                if (prevDisp) {
                    left = prevDisp.display.getEnd();
                }
                if (nextDisp) {
                    right = nextDisp.display.getStart();
                }
                //stores these two functions with each command that is logged
                var olddata = my.timeline.getOldData();
                var msdata = my.timeline.getDisplayData();

                command = {
                    execute: function () {
                        var res = {
                            pivot: {
                                x: my.timeManager.timeToPx(redo) + oldOff
                            }
                        };
                        my.currentDisplay = that;
                        loc = oldLoc;
                        offset = oldOff;
                        //if these are defined, then get the logged positions and move the selected displays
                        if (olddata && multiDisplays) {
                            for (var i = 0; i < multiDisplays.length; i++) {
                                var currdisplay = multiDisplays[i];
                                var newredo;
                                switch (oldLoc) {
                                    case TAG.TourAuthoring.DisplayParts['fade-in']:
                                        newredo = olddata[i][0]; //inStart;//save new value
                                        break;
                                    case TAG.TourAuthoring.DisplayParts['fade-out']:
                                        newredo = olddata[i][2];//outStart;
                                        break;
                                    case TAG.TourAuthoring.DisplayParts['main']:
                                        newredo = olddata[i][1];
                                        break;
                                }
                                var newres = {
                                    pivot: {
                                        x: my.timeManager.timeToPx(newredo) + oldOff
                                    }
                                };
                                //need to update the location, currentdisplay, offset for move 
                                currdisplay.setLoc(oldLoc);
                                currdisplay.setcurrentDisplay(currdisplay);
                                currdisplay.setOffset(offset);
                                var newleft = left + currdisplay.getStart() - that.getStart();
                                var newright = right + currdisplay.getEnd() - that.getEnd();
                                currdisplay.move(newres, olddata[i][3], olddata[i][4], -1, -1, true);
                                currdisplay.setcurrentDisplay(null);
                            }
                        }
                        else {
                            move(res, left, right, -1, -1, true);
                        }
                        // reset state
                        my.currentDisplay = null;
                        loc = null;
                        offset = null;
                        my.update();
                    },
                    unexecute: function () {
                        var res = {
                            pivot: {
                                x: my.timeManager.timeToPx(undo) + oldOff
                            }
                        };
                        my.currentDisplay = that;
                        loc = oldLoc;
                        offset = oldOff;
                        //if there is data logged, then you can undo the positions of the selected displays to the saved msdata's positions
                        if (msdata && multiDisplays) {
                            for (var i = 0; i < multiDisplays.length; i++) {
                                var currdisplay = multiDisplays[i];
                                var newundo;
                                switch (oldLoc) {
                                    case TAG.TourAuthoring.DisplayParts['fade-in']:
                                        newundo = msdata[i][0];//oldin;//save old value
                                        break;
                                    case TAG.TourAuthoring.DisplayParts['fade-out']:
                                        newundo = msdata[i][2];
                                        break;
                                    case TAG.TourAuthoring.DisplayParts['main']:
                                        newundo = msdata[i][1];
                                        break;
                                }
                                var newres = {
                                    pivot: {
                                        x: my.timeManager.timeToPx(newundo) + oldOff
                                    }
                                };
                                //need to update these for the move function
                                currdisplay.setLoc(oldLoc);
                                currdisplay.setcurrentDisplay(currdisplay);
                                currdisplay.setOffset(offset);
                                currdisplay.move(newres, msdata[i][3], msdata[i][4], -1, -1, true);
                                currdisplay.setcurrentDisplay(null);
                            }
                        }
                        else {
                            move(res, left, right, -1, -1, true);
                        }

                        // reset state
                        my.currentDisplay = null;
                        loc = null;
                        offset = null;
                        my.update();
                    }
                };
                my.undoManager.logCommand(command);

                var num_clamped = my.timeline.clamped_displays.length;
                for (var i = 0; i < num_clamped; i++) {
                    var disp = my.timeline.clamped_displays[i];
                    logHelper(disp, disp.clamped_init, disp.clamped_new);
                    disp.has_been_clamped = false;
                }
                if (num_clamped > 0) {
                    my.undoManager.combineLast(num_clamped + 1);
                    my.timeline.clamped_displays.length = 0;
                }

            }
        });
    }


    function initSVG() {
        gv = my.svgDisplays.append('g')
                .classed('display', true)
                //.attr('id', id + '');

        //if (canFade) {
        finD = gv.append('rect').classed('fade-in', true)
            .attr('x', my.timeManager.timeToPx(inStart))
            .attr('y', 0)
            .attr('width', my.timeManager.timeToPx(fadeIn))
            .attr('height', my.svg.attr('height'))
            .style('fill', 'url(#fade-in)')
            .style('stroke-width', 1)
            .style('stroke', 'rgb(0,0,0)');
            //.on('mousedown', function (d, i) {
            //    _displayMousedown(d3.mouse(finD[0][0])[0] - parseInt(this.getAttribute('x'), 10),
            //        TAG.TourAuthoring.DisplayParts['fade-in']);
            //});

        $(finD[0][0]).on("mousedown", function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            _displayMousedown(offsetX - parseInt(finD.attr('x'), 10), TAG.TourAuthoring.DisplayParts['fade-in']);
        });

        if (!canKeyframe) {
            finD.style('fill', 'url(#fade-in-ink)');
        }
        //}
        mainD = gv.append('rect').classed('main-display', true)
            .attr('x', my.timeManager.timeToPx(mainStart))
            .attr('y', 0)
            .attr('width', my.timeManager.timeToPx(main))
            .attr('height', my.svg.attr('height'))
            .style('fill', TAG.TourAuthoring.Constants.displayColor);
            //.on('mousedown', function (d, i) {
            //    _displayMousedown(d3.mouse(finD[0][0])[0] - parseInt(this.getAttribute('x'), 10),
            //        TAG.TourAuthoring.DisplayParts['main']);
            //});

        $(mainD[0][0]).on("mousedown", function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            _displayMousedown(offsetX - parseInt(mainD.attr('x'), 10), TAG.TourAuthoring.DisplayParts['main']);
        });

        if (!canKeyframe) {
            mainD.style('fill', TAG.TourAuthoring.Constants.inkDisplayColor);
        }
        //if (canFade) {
        fioD = gv.append('rect').classed('fade-out', true)
            .attr('x', my.timeManager.timeToPx(outStart))
            .attr('y', 0)
            .attr('width', my.timeManager.timeToPx(fadeOut))
            .attr('height', my.svg.attr('height'))
            .style('fill', 'url(#fade-out)')
            .style('stroke-width', 1)
            .style('stroke', 'rgb(0,0,0)');
            //.on('mousedown', function (d, i) {
            //    _displayMousedown(d3.mouse(fioD[0][0])[0] - parseInt(this.getAttribute('x'), 10),
            //        TAG.TourAuthoring.DisplayParts['fade-out']);
            //});

        $(fioD[0][0]).on("mousedown", function (e) {
            
            console.log("using new events");
            var offsetX = e.offsetX;
            _displayMousedown(offsetX - parseFloat(fioD.attr('x')), TAG.TourAuthoring.DisplayParts['fade-out']);
        });

        if (!canKeyframe) {
            fioD.style('fill', 'url(#fade-out-ink)');
        }
        //}

        // put keyframes below handles so hatch lines don't overlap handles
        gkey = my.svg.append('g').classed('keyframes', true);

        // handles
        finHandle = gv.append('circle').classed('fade-in-handle', true)
            .attr('cx', my.timeManager.timeToPx(inStart))
            .attr('cy', '50%')
            .attr('r', TAG.TourAuthoring.Constants.fadeBtnSize)
            .attr('style', 'stroke:black; stroke-width:' + TAG.TourAuthoring.Constants.keyframeStrokeW + '; fill:' + TAG.TourAuthoring.Constants.handleColor);
        //    .on('mousedown', function (d, i) {
        //        _displayMousedown(d3.mouse(finHandle[0][0])[0] - parseInt(finD.attr('x'), 10),
        //            TAG.TourAuthoring.DisplayParts['fade-in']);
        //});

        $(finHandle[0][0]).on("mousedown", function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            _displayMousedown(offsetX - parseInt(finD.attr('x'), 10), TAG.TourAuthoring.DisplayParts['fade-in']);
        });

        fioHandle = gv.append('circle').classed('fade-out-handle', true)
            .attr('cx', my.timeManager.timeToPx(outStart + fadeOut))
            .attr('cy', '50%') // negative for the transform trick
            .attr('r', TAG.TourAuthoring.Constants.fadeBtnSize)
            .attr('style', 'stroke:black; stroke-width:' + TAG.TourAuthoring.Constants.keyframeStrokeW + '; fill:' + TAG.TourAuthoring.Constants.handleColor);
            //.on('mousedown', function (d, i) {
            //    _displayMousedown(d3.mouse(fioHandle[0][0])[0] - parseInt(fioD.attr('x'), 10),
            //        TAG.TourAuthoring.DisplayParts['fade-out']);
            //});

        $(fioHandle[0][0]).on("mousedown", function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            _displayMousedown(offsetX - parseInt(fioD.attr('x'), 10), TAG.TourAuthoring.DisplayParts['fade-out']);
        });
        

        /**
         * Bound to mousedown on display parts
         * Sets currentDisplay for use by displayClick
         * Resets currentDisplay on mouseup
         * @param mouseoffset   offset of mouse on element clicked for accurate dragging (offset from start of the timeline)
         * @param mouseloc      TAG.TourAuthoring.DisplayParts enum type specifying which part of display was clicked
         */
        function _displayMousedown(mouseoffset, mouseloc) {
            var oldin = inStart, // state before move
                oldmainstart = mainStart,
                oldmain = main,
                oldout = outStart,
                oldtotal = totalLength; // saves old values

            initSnap(); //initialize snapping at mouse down on display


            // Stop playback on click
            my.timeManager.stop();

            // Set move related instance variables
            offset = mouseoffset;
            loc = mouseloc;
            if (loc === TAG.TourAuthoring.DisplayParts['fade-in'] || loc === TAG.TourAuthoring.DisplayParts['fade-out']) {
                if (my.that.getMinimizedState()) {
                    return;
                }
            }
            my.currentDisplay = that;
            my.timeline.newDataArray();
            for (var i = 0; i < my.timeline.getMultiSelectionArray().length; i++) {
                my.timeline.getMultiSelectionArray()[i].setLoc(loc);
            }
            // On mouseup reset all instance vars and log state
            $('body').on('mouseup.display', function () {
                //  var command, newin, newmainstart, newmain, newout, newtotal; // state after move
                var command, redo, undo, multiDisplays;
                var prevDisp = dataHolder.findPreviousDisplay(my.that.getPos(), that);
                var nextDisp = dataHolder.findNextDisplay(my.that.getPos(), that);
                redo = 0;
                undo = 0;
                var oldOff = offset;
                var oldLoc = loc;
                my.currentDisplay = null;
                offset = null;
                loc = null;
                $('body').off('mouseup.display');
                function logHelper(disp, cinit, cnew) {
                    var clamp_command = {
                        execute: function () { disp.setTimes(cnew); },
                        unexecute: function () {
                            console.log("init: " + cinit.inStart + ", new: " + cnew.inStart);
                            disp.setTimes(cinit);
                        },
                    };
                    my.undoManager.logCommand(clamp_command);
                }
                
                
                if (my.timeline.getMultiSelectionArray().length !== 0) {
                    var multiDisplaysOrig = my.timeline.getMultiSelectionArray();
                    multiDisplays = [];
                    multiDisplaysOrig.map(function (d) {
                        multiDisplays.push(d);
                    });
                }
                
                // If movement has occured, update and log command
                
                if (oldin !== inStart || oldmainstart !== mainStart || oldmain !== main || oldout !== outStart) {
                    my.timeline.updateOldData();
                    my.update();
                    switch (oldLoc) {
                        case TAG.TourAuthoring.DisplayParts['fade-in']:
                            redo = inStart;//save new value
                            undo = oldin;//save old value
                            break;
                        case TAG.TourAuthoring.DisplayParts['fade-out']:
                            redo = outStart;
                            undo = oldout;
                            break;
                        case TAG.TourAuthoring.DisplayParts['main']:
                            redo = mainStart;
                            undo = oldmainstart;
                            break;
                    }
                    // my.update();
                    var left = 0;
                    var right = Infinity;
                    if (prevDisp) {
                        left = prevDisp.display.getEnd();
                    }
                    if (nextDisp) {
                        right = nextDisp.display.getStart();
                    }
                    //stores these two functions with each command that is logged
                    var olddata = my.timeline.getOldData();
                    var msdata = my.timeline.getDisplayData();
                    
                    command = {
                        execute: function () {
                            var res = {
                                pivot: {
                                    x: my.timeManager.timeToPx(redo) + oldOff
                                }
                            };
                            my.currentDisplay = that;
                            loc = oldLoc;
                            offset = oldOff;
                            //if these are defined, then get the logged positions and move the selected displays
                            if (olddata && multiDisplays) {
                                for (var i = 0; i < multiDisplays.length; i++) {
                                    var currdisplay = multiDisplays[i];
                                    var newredo;
                                    switch (oldLoc) {
                                        case TAG.TourAuthoring.DisplayParts['fade-in']:
                                            newredo = olddata[i][0]; //inStart;//save new value
                                            break;
                                        case TAG.TourAuthoring.DisplayParts['fade-out']:
                                            newredo = olddata[i][2];//outStart;
                                            break;
                                        case TAG.TourAuthoring.DisplayParts['main']:
                                            newredo = olddata[i][1];
                                            break;
                                    }
                                    var newres = {
                                        pivot: {
                                            x: my.timeManager.timeToPx(newredo) + oldOff
                                        }
                                    };
                                    //need to update the location, currentdisplay, offset for move 
                                    currdisplay.setLoc(oldLoc);
                                    currdisplay.setcurrentDisplay(currdisplay);
                                    currdisplay.setOffset(offset);
                                    var newleft = left + currdisplay.getStart() - that.getStart();
                                    var newright = right + currdisplay.getEnd() - that.getEnd();
                                    currdisplay.move(newres, olddata[i][3], olddata[i][4], -1, -1, true);
                                    currdisplay.setcurrentDisplay(null);
                                }
                            }
                            else {
                                move(res, left, right, -1, -1,  true);
                            }
                            // reset state
                            my.currentDisplay = null;
                            loc = null;
                            offset = null;
                            my.update();
                        },
                        unexecute: function () {
                            var res = {
                                pivot: {
                                    x: my.timeManager.timeToPx(undo) + oldOff
                                }
                            };
                            my.currentDisplay = that;
                            loc = oldLoc;
                            offset = oldOff;
                            //if there is data logged, then you can undo the positions of the selected displays to the saved msdata's positions
                            if (msdata && multiDisplays) {
                                for (var i = 0; i < multiDisplays.length; i++) {
                                    var currdisplay = multiDisplays[i];
                                    var newundo;
                                    switch (oldLoc) {
                                        case TAG.TourAuthoring.DisplayParts['fade-in']:
                                            newundo = msdata[i][0];//oldin;//save old value
                                            break;
                                        case TAG.TourAuthoring.DisplayParts['fade-out']:
                                            newundo = msdata[i][2];
                                            break;
                                        case TAG.TourAuthoring.DisplayParts['main']:
                                            newundo = msdata[i][1];
                                            break;
                                    }
                                    var newres = {
                                        pivot: {
                                            x: my.timeManager.timeToPx(newundo) + oldOff
                                        }
                                    };
                                    //need to update these for the move function
                                    currdisplay.setLoc(oldLoc);
                                    currdisplay.setcurrentDisplay(currdisplay);
                                    currdisplay.setOffset(offset);
                                    currdisplay.move(newres, msdata[i][3], msdata[i][4], -1, -1, true);
                                    currdisplay.setcurrentDisplay(null);
                                }
                            }
                            else {
                                move(res, left, right, -1, -1, true);
                            }

                            // reset state
                            my.currentDisplay = null;
                            loc = null;
                            offset = null;
                            my.update();
                        }
                    };
                    my.undoManager.logCommand(command);

                    var num_clamped = my.timeline.clamped_displays.length;
                    for (var i = 0; i < num_clamped; i++) {
                        var disp = my.timeline.clamped_displays[i];
                        logHelper(disp, disp.clamped_init, disp.clamped_new);
                        disp.has_been_clamped = false;
                    }
                    if (num_clamped > 0) {
                        my.undoManager.combineLast(num_clamped + 1);
                        my.timeline.clamped_displays.length = 0;
                    }   
                    
                }
            });
        }
    }
    //initSVG();

    function toggleCircles() {
        hidden = !hidden;
        if (hidden) {
            finHandle.css('display', 'none');
            fioHandle.css('display', 'none');
            finHandle.css('visibility', 'hidden');
            fioHandle.css('visibility', 'hidden');
        } else {
            finHandle.css('display', 'block');
            fioHandle.css('display', 'block');
            finHandle.css('visibility', 'visible');
            fioHandle.css('visibility', 'visible');
        }
        currkeyframes.map(function (j) {
            j.toggleCircle();
        });
    }
    that.toggleCircles = toggleCircles;

    /**
     * Sets up menu with correct inputs and buttons
     */
    (function initMenu() {
        menu.addInput('Start', TAG.TourAuthoring.MenuInputFormats.minSec,
            getStart, setStartFromMenu);
        menu.addInput('Main Length', TAG.TourAuthoring.MenuInputFormats.minSec,
            getMain, setMainFromMenu);
        if (canFade) {
            menu.addInput('Fade-In', TAG.TourAuthoring.MenuInputFormats.sec,
                getFadeIn, setFadeInFromMenu);
            menu.addInput('Fade-Out', TAG.TourAuthoring.MenuInputFormats.sec,
                getFadeOut, setFadeOutFromMenu);
        }
        menu.addButton('Delete', 'left', removeHelper);
        menu.addButton('Close', 'right', menu.forceClose);
    })();

    function getLimits() {
        var duration = my.timeManager.getDuration(),
            left = duration.start,
            right = duration.end;

        var leftDisp = dataHolder.findPreviousDisplay(my.that.getPos(), that);
        var rightDisp = dataHolder.findNextDisplay(my.that.getPos(), that);

        left = (leftDisp) ? leftDisp.display.getEnd() : left;
        right = (rightDisp) ? rightDisp.display.getStart() : right;

        if (my.mediaLength) {
            left = Math.max(left, getEnd() - parseFloat(my.mediaLength));
            right = Math.min(right, parseFloat(my.mediaLength) + getStart());
        }
        return { left: left, right: right };
    }

    function setStartFromMenu(newstart) {
        var translation,
            attachedDisplays,
            bounds = getLimits(),
            oldStart = inStart;

        var totalDispLength = 0;
        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            var surrDisp = getParentDisplay();
            bounds.left = Math.max(bounds.left, surrDisp.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
            bounds.right = Math.min(bounds.right, surrDisp.getEnd());
        }
        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
            attachedDisplays = getChildDisplays();
            totalDispLength = getLongestSubgroup(attachedDisplays);
        }

        inStart = Math.constrain(newstart, // note this is defined in TAG.Util
                            bounds.left, // min
                            bounds.right - fadeIn - fadeOut - main);
        
        translateTo(inStart);
        _moveAllKeyframes(inStart - oldStart);

        //var num_commands = 0;
        if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            for (var i = 0; i < attachedDisplays.length; i++) {
                clampDisplay(attachedDisplays[i]);
                //num_commands++;
            }
        }
        //my.undoManager.combineLast(num_commands);
    }

    function setMainFromMenu(newmain) {
        var bounds = getLimits(),
            attachedDisplays,
            keyframeBound = !currkeyframes.isEmpty() ?
                currkeyframes.max().getTime() + TAG.TourAuthoring.Constants.epsilon - mainStart
                : -Infinity;
        var totalDispLength = 0;
        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            var surrDisp = getParentDisplay();
            bounds.left = Math.max(bounds.left, surrDisp.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
            bounds.right = Math.min(bounds.right, surrDisp.getEnd());
        }
        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
            attachedDisplays = getChildDisplays();
            totalDispLength = getLongestSubgroup(attachedDisplays);
        }
        main = Math.constrain(Math.max(0.1,newmain),
                            keyframeBound,
                            bounds.right - inStart - fadeOut - fadeIn);
        if (fadeIn===0 && fadeOut===0 && main === 0)
            main = 1;

        setMain((main + fadeIn + fadeOut >= totalDispLength) ? main : totalDispLength - fadeIn - fadeOut);

        //var num_commands = 0;
        if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            for (var i = 0; i < attachedDisplays.length; i++) {
                clampDisplay(attachedDisplays[i]);
                //num_commands++;
            }
        }
        //my.undoManager.combineLast(num_commands);
    }

    function setFadeInFromMenu(newfadein) {
        //FEATURE DECIDED UPON: stop down-sizing the fadeIn if it hits a keyframe
        var bounds = getLimits(),
            i, currKeyframe, attachedDisplays, keyTime;

        var totalDispLength = 0;
        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            var surrDisp = getParentDisplay();
            bounds.left = Math.max(bounds.left, surrDisp.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
            bounds.right = Math.min(bounds.right, surrDisp.getEnd());
        }
        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
            attachedDisplays = getChildDisplays();
            totalDispLength = getLongestSubgroup(attachedDisplays);
        }

        fadeIn = Math.constrain(newfadein,
                            0,
                            mainStart - bounds.left);
        var newInStart = mainStart - fadeIn;
        if (!currkeyframes.isEmpty() && newInStart > currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize)) {
            inStart = currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize);
            fadeIn = mainStart - inStart;
        }
        else {
            inStart = newInStart;
        }
        // push back any keyframes inside of fade
            //for (i = 0; i < keyframes.length; i++) {
            //    currKeyframe = keyframes[i];
            //    keyTime = currKeyframe.getTime();
            //    if (keyTime < inStart) {
            //        keyframes[i].translate(inStart - keyTime
            //            + TAG.TourAuthoring.Constants.epsilon * (i + 1));
            //    }
            //}
        //translateTo(inStart);
        var newFin;
        if (main + fadeIn + fadeOut >= totalDispLength) {
            newFin = fadeIn;
        } else {
            newFin = totalDispLength - main - fadeOut;
        }
        setIn(newFin);

        //var num_commands = 0;
        if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            for (i = 0; i < attachedDisplays.length; i++) {
                clampDisplay(attachedDisplays[i]);
                //num_commands++;
            }
        }
       // my.undoManager.combineLast(num_commands);
    }
    that.setFadeInFromMenu = setFadeInFromMenu;

    function setFadeOutFromMenu(newfadeout) {
        //FEATURE DECIDED UPON: stop down-sizing the fadeOut if it hits a keyframe
        var bounds = getLimits(),
            i, currKeyframe, attachedDisplays, keyTime, newend;

        var totalDispLength = 0;
        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            var surrDisp = getParentDisplay();
            bounds.left = Math.max(bounds.left, surrDisp.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
            bounds.right = Math.min(bounds.right, surrDisp.getEnd());
        }
        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
            attachedDisplays = getChildDisplays();
            totalDispLength = getLongestSubgroup(attachedDisplays);
        }

        fadeOut = Math.constrain(newfadeout,
                            0,
                            bounds.right - outStart);
        newend = outStart + fadeOut;
        if (!currkeyframes.isEmpty() && newend < currkeyframes.max().getTime() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize)) {
            fadeOut = currkeyframes.max().getTime() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize) - outStart;
        }
        // push back any keyframes inside of fade
        //for (i = keyframes.length - 1; i >= 0; i--) {
        //    currKeyframe = keyframes[i];
        //    keyTime = currKeyframe.getTime();
        //    if (keyTime > outStart + fadeOut) {
        //        keyframes[i].translate(newend - keyTime
        //            - TAG.TourAuthoring.Constants.epsilon * (i + 1));
        //    }
        //}
        setOut((main + fadeIn + fadeOut >= totalDispLength) ? fadeOut : totalDispLength - main - fadeIn);

       // var num_commands = 0;
        if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image) {
            for (i = 0; i < attachedDisplays.length; i++) {
                clampDisplay(attachedDisplays[i]);
                //num_commands++;
            }
        }
       // my.undoManager.combineLast(num_commands);
    }
    that.setFadeOutFromMenu = setFadeOutFromMenu;

    
    // handles long press on the display
    function rightTapped(evt) {
        menu.open(evt);
    }
    that.rightTapped = rightTapped;

    //closes menu
    function closeMenu() {
        menu.close();
    }
    that.closeMenu = closeMenu;

    function setMenuCloseable(state) {
        menu.menuCloseable = state;
    }

    //Xiaoyi Libby
    function setLoc(dloc) {
        loc = dloc;
    }
    that.setLoc = setLoc;

    function getOffset() {
        return offset;
    }
    that.getOffset = getOffset;

    function setOffset(doffset) {
        offset = doffset;
    }
    that.setOffset = setOffset;

    function setcurrentDisplay(display) {
        my.currentDisplay = display;
    }
    that.setcurrentDisplay = setcurrentDisplay;

    //handles removal of all internal items of display/ wrapper to call remove display
    function removeHelper() {
        // if last display is deleted on a track and track has attached inks, remind user that inks will not function and offer undo option
        var len;
        if (that.getStorageContainer().displayTree.isSolo() && my.attachedInks.length > 0) {
            menu.forceClose();
            my.timeline.confirmDeleteDisableInk(my.title, that, my);
            // for distributed warnings onto ink tracks (alternative option that can be implemented later)
            //var i;
            //for (i = 0; i < my.attachedInks.length; i++) {
            //    console.log('append warning here');
            //}
        } else {
            len = removeAttachedInkDisplays();
            removeDisplay(true);
            if (len > 0) {
                my.undoManager.combineLast(len + 1);
            }
        }
    }
    that.removeHelper = removeHelper;


    // remove all attached ink displays when an artwork display is removed
    function removeAttachedInkDisplays() {
        var attachedDisplays = getChildDisplays();
        var i, len = attachedDisplays.length;
        for (i = 0; i < len; i++) {
            attachedDisplays[i].removeDisplay(true);
        }
        return len; // tells us whether we should combineLast after removing display
    }
    that.removeAttachedInkDisplays = removeAttachedInkDisplays;

    /**
     * Removes the display.
     * @param acted     whether the user directly removed the display / if a command should be logged.
     */
    var dispRemoved = false;
    function removeDisplay(acted) {
        menu.forceClose(true);

        //var oldKeyframes=[];
        var oldkfTree = currkeyframes.clone();
        if (parentDisplay) {
            var oldParentDisplay = parentDisplay;
        }
        var command = TAG.TourAuthoring.Command({
            execute: function () {
                dispRemoved = true;
                dataHolder.removeDisplay(my.that.getPos(), that);
                currkeyframes.clear(function (keyframe) {
                    keyframe._value.removeHelper();
                });
                mainD.remove();
                fioD.remove();
                finD.remove();
                fioHandle.remove();
                finHandle.remove();
                my.update();
           },
            unexecute: function () {
                dispRemoved = false;
                initVisuals();
                var newDisplay = dataHolder.addDisplay(my.that.getPos(), that);
                dataHolder.replaceKeyframes(newDisplay.display, oldkfTree);
                var kfs = dataHolder.getKeyframes(newDisplay);
                kfs._root && kfs._root.traverse(REACTIVATE);
                //if (oldParentDisplay) {
                //    oldParentDisplay.addChildDisplay(that);
                //}
                my.update();
                

                //var newDisplay=TAG.TourAuthoring.Display({start:inStart, length:totalLength, fadeIn: fadeIn, fadeOut:fadeOut, id:id,} ,my);
                //my.displays.insert(that, my.that.displayComp);
                //setID(index);
                //for (i = index + 1; i < my.displays.length; i++) {
                //    my.displays[i].setID(i);
                //}
                
                
                
            }
        });
        command.execute();
        if (acted) {
            my.undoManager.logCommand(command);
            console.log('logging');
        }
    }
    that.removeDisplay = removeDisplay;

    function REACTIVATE(kf) {
        kf._value.reactivateKeyframe();
    }

    function getRemoved() {
        return dispRemoved;
    }
    that.getRemoved = getRemoved;

    //reloads the display when removed
    function reloadDisplay(){
        //initSVG();
        dataHolder.addDisplay(my.that.getPos(), that);
        resetVisuals();
        my.update();
    }
    that.reloadDisplay = reloadDisplay;

    // not using right now b/c broken
    var releasedCounter = 0;
    function released() {
        releasedCounter++;
        if (my.that.getEventsPaused()) {
            return;
        }
        if (releasedCounter > 1) {
            releasedCounter = 0;
            if (!menuCloseable) {
                menuCloseable = true;
                setTimeout(my.timeline.getCloseMenu(), 0);
            }
        }
    }
    that.released = released;

    //////////
    // Getters + Setters

    /**
     * @returns     Start of display block in sec
     */
    function getStart() {
        return inStart;
    }
    that.getStart = getStart;

    /**
     * @returns     End of display block in sec
     */
    function getEnd() {
        return outStart + fadeOut;
    }
    that.getEnd = getEnd;

    function getMainStart() {
        return mainStart;
    }
    that.getMainStart = getMainStart;

    function getMain() {
        return main;
    }
    that.getMain = getMain;

    function getOutStart() {
        return outStart;
    }
    that.getOutStart = getOutStart;

    function getFadeIn() {
        return fadeIn;
    }
    that.getFadeIn = getFadeIn;

    function getFadeOut() {
        return fadeOut;
    }
    that.getFadeOut = getFadeOut;

    function getTotalLength() {
        return totalLength;
    }
    that.getTotalLength = getTotalLength;

    function setTimes(obj) {
        setInStart(obj.inStart);
        setOutStart(obj.outStart);
        setMainStart(obj.inStart + obj.fadeIn);//main = obj.main;
        setMain(obj.main);
        setIn(obj.fadeIn);
        setOut(obj.fadeOut);
    }
    that.setTimes = setTimes;

    function basicSetTimes(input) {
        inStart = input.inStart;
        outStart = input.outStart;
        mainStart = input.inStart+input.fadeIn;
        main = input.main;
        fadeIn = input.fadeIn;
        fadeOut = input.fadeOut;
        resetVisuals();
    }
    that.basicSetTimes = basicSetTimes;

    function getTimes() {
        return {
            inStart: inStart,
            outStart: outStart,
            fadeIn: fadeIn,
            main: main,
            mainStart: mainStart,
            fadeOut: fadeOut
        };
    }
    that.getTimes = getTimes;


 /***JessF adfjlasdjfkljasdflkadlsfj fuckckck***/
    function updateDispTimes(offset) {
        mainStart += offset;
        inStart += offset;
        outStart += offset;
        resetVisuals();
        _moveAllKeyframes(offset);
    }
    that.updateDispTimes = updateDispTimes;

    function resetVisuals() {
        finD.css('left', T2P(inStart)+"px");
        mainD.css('left', T2P(mainStart) + "px");
        fioD.css('left', T2P(outStart) + "px");
        finHandle.css('left', T2P(inStart) - 20 + "px");
        fioHandle.css('left', T2P(outStart + fadeOut) - 20 + "px");

        // need to re-add all elements - figure out where they're originally added to
        my.track.append(mainD).append(finD).append(fioD).append(finHandle).append(fioHandle);
        finD.show();
        mainD.show();
        fioD.show();
        finHandle.show();
        fioHandle.show();
    }
    that.resetVisuals = resetVisuals;

    /*
    *set the main part of display to a new time
    * @param newmainStart   new time for mainStart
    * @trans trans    translation display has been dragged
    */
    function setMainStart(newmainStart,trans) {
        mainStart = newmainStart;
        inStart = mainStart - fadeIn;
        outStart = mainStart + main;
        resetVisuals();
        _moveAllKeyframes(trans);
    }
    that.setMainStart = setMainStart;
    
    function setStart(time) {
        inStart = time;
    }
    function setEnd(time) {
        outStart = time;
    }


    /**xiaoyi & libby
    *these are helper methods for msMove to reset the graphic info.
    *called when you are changing the fadein
    */
    function setInStart(newinStart) {
        inStart = newinStart;
        mainStart = inStart + fadeIn;
        main = outStart - mainStart;
        totalLength = outStart + fadeOut - newinStart;
        finD.css('left', T2P(newinStart) + "px");
        finHandle.css('left', T2P(newinStart) - 20 + "px"); // DON'T HARDCODE TODO
        mainD.css({
            'left': T2P(mainStart) + "px",
            'width': T2P(main) + "px"
        });
    }
    that.setInStart = setInStart;
    /*called when you are changing the fadeout
    */
    function setOutStart(newoutStart) {
        main = newoutStart - mainStart;
        outStart = newoutStart;
        totalLength = newoutStart + fadeOut - inStart;
        fioD.css('left', T2P(newoutStart) + "px");
        fioHandle.css('left', T2P(newoutStart + fadeOut) - 20 + "px");
        mainD.css('width', T2P(main) + "px");
    }
    that.setOutStart = setOutStart;
    /*called when you are changing the main
    */
    function setMain(newm) {
        main = newm;
        outStart = mainStart + main;
        totalLength = outStart + fadeOut - inStart;
        fioD.css('left', T2P(outStart) + "px");
        fioHandle.css('left', T2P(outStart + fadeOut) - 20 + "px");
        mainD.css('width', T2P(main) + "px");
    }
    that.setMain = setMain;

    function setIn(newin) {
        if (canFade) {
            fadeIn = newin;
            mainStart = inStart + fadeIn;
            //outStart = mainStart + main;
            totalLength = outStart + fadeOut - inStart;
            finD.css('left', T2P(inStart) + "px");
            finD.css('width', T2P(fadeIn) + "px");
            finHandle.css('left', T2P(inStart) - 20 + "px");
            mainD.css({
                'left': T2P(mainStart) + "px",
                'width': T2P(main) + "px"
            });
        }
        else { // just change total length
            setMain(main + newin);
        }
    }
    that.setIn = setIn;

    function setOut(newout) {
        if (canFade) {
            fadeOut = newout;
            totalLength = outStart + fadeOut - inStart;
            fioD.css('width', T2P(fadeOut) + "px");
            fioHandle.css('left', T2P(outStart + fadeOut) - 20 + "px");
        }
        else { // just change total length
            setMain(main + newout);
        }
    }
    that.setOut = setOut;

    /**
     * Special setter that sets new start but preserves lengths
     */
    function translateTo(newstart) {
        inStart = newstart;
        mainStart = inStart + fadeIn;
        outStart = main + mainStart;
        finD.css('left', T2P(inStart) + "px");
        finHandle.css('left', T2P(inStart) - 20 + "px");
        mainD.css('left', T2P(mainStart) + "px")
            .css('width', T2P(main) + "px");
        fioD.css('left', T2P(outStart) + "px");
        fioHandle.css('left', T2P(outStart + fadeOut) - 20 + "px");
    }
    that.translateTo = translateTo;

    /**
     * @returns     Numerical ID of display
     */
    function getID() {
        return id;
    }
    that.getID = getID;

    //New ID for display
    function setID(newid) {
        id = newid;
    }
    that.setID = setID;

    function getStorageContainer() {
        return storageContainer;
    }
    that.getStorageContainer = getStorageContainer;

    function setStorageContainer(container) {
        storageContainer = container;
    }
    that.setStorageContainer = setStorageContainer;

    /**
     * @returns Track that the display is in
     */
    function getTrack() {
        return my.that;
    }
    that.getTrack = getTrack;
    function getMediaLength() {
        return parseFloat(my.mediaLength);
    }
    that.getMediaLength = getMediaLength;
    function getMouseup() {
        return mouseisup;
    }
    that.getMouseup = getMouseup;

    function getType() {
        return my.type;
    }
    that.getType = getType;

    function getMainD() {
        return mainD;
    }
    that.getMainD = getMainD;

    function getFioHandle() {
        return fioHandle;
    }
    that.getFioHandle = getFioHandle;

    function getFinHandle() {
        return finHandle;
    }
    that.getFinHandle = getFinHandle;

    function getLoc() {
        return loc;
    }
    that.getLoc = getLoc;

    function suppressHandles() {
        if (my.that.getMinimizedState()) {
            finHandle.hide();
            fioHandle.hide();
            finHandle.css('visibility', 'hidden');
            fioHandle.css('visibility', 'hidden');
        }
    }
    that.suppressHandles = suppressHandles;

    ////////
    // Logic

    /**
     * Logic for manipulation + dragging of displays
     * Moves display to an absolute position given in res
     * currentDisplay, offset, loc should be set, see _initSVG / _displayMousedown for details
     * Currently three different types of move, determined by loc variable
     * 1. loc === 'main': translates the entire display, preserves length
     * 2. loc === 'fade-in' or 'fade-out': drags only fade-in / fade-out region, start of other fade and lengths of fades remaines fixed, length of main area changes
     * @param res           event from makeManipulable, onManipulate
     * @param leftbound     leftmost position display can move to in seconds (not required)
     * @param rightbound    rightmost position display can move to in seconds (not required)
     * @param displayIn     the position of a nearby display in the previous trac
     * @param displayOut    the position of a nearby display in the next track
     */
    var translation;
    
    function move(res, leftbound, rightbound, displayIn, displayOut, inUndoRedo) {
        // If no bounds are set, display can be anywhere (except negative times)
        var duration = my.timeManager.getDuration();
        var attachedDisplays, i, maxTotalDispLength, parentArtDisplay, diff;
        var totalDispLength = 0;
        leftbound = leftbound || duration.start;
        rightbound = rightbound || duration.end;

        // no display in or out, set to -1
        displayIn = displayIn || -1;
        displayOut = displayOut || -1;

        // error checking
        if (!loc || (offset !== 0 && !offset) || !my.currentDisplay) { // need that extra offset = 0 check since 0 and null are equal, arg
            console.log('Move display called when no display is selected!');
        }
            // Actual editing
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-in']) { // Drag fade-in section to adjust length
            if (displayIn !== -1) {
                inStart = displayIn;
            }
            else {
                if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled)) { // constrain ink movement
                    parentArtDisplay = getParentDisplay();
                    leftbound = Math.max(leftbound, parentArtDisplay.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
                }
                else if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                    // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                    attachedDisplays = getChildDisplays();
                    totalDispLength = getLongestSubgroup(attachedDisplays);
                }
                else if (my.type === TAG.TourAuthoring.TrackType.video || my.type === TAG.TourAuthoring.TrackType.audio) {
                    if (my.mediaLength) {
                        maxTotalDispLength = parseFloat(my.mediaLength);
                        var leftLimit = outStart + fadeOut - maxTotalDispLength;
                        leftbound = Math.max(leftbound, leftLimit);
                    }
                }
                diff = my.timeManager.pxToTime(res.pivot.x - offset); // note this is defined in TAG.Util
                if (getEnd() - diff >= totalDispLength) {
                    if (fadeIn === 0 && fadeOut === 0) {
                        inStart = Math.constrain(diff,
                                        leftbound, // min
                                        Math.min(my.timeManager.pxToTime(parseFloat(fioHandle.css('left')) + 20 - 2 * TAG.TourAuthoring.Constants.fadeBtnSize), // max is one of two values
                                            ((!currkeyframes.isEmpty() && (currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || Infinity)));
                    }
                    else {
                        inStart = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offset), // note this is defined in TAG.Util
                                            leftbound, // min
                                            Math.min(outStart - fadeIn-0.1, //make sure the fadein and fadeout handlers are overlapping
                                                ((!currkeyframes.isEmpty() && (currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || Infinity)));
                    }
                    if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                        //var num_commands = 0;
                        for (i = 0; i < attachedDisplays.length; i++) {
                            clampDisplay(attachedDisplays[i]);
                            //num_commands++;
                        }
                       // my.undoManager.combineLast(num_commands);
                    }
                }
            }
            setInStart(inStart);
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-out']) { // Drag fade-out section to adjust length
            if (displayOut !== -1) {
                outStart = displayOut;
            }
            else {
                if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled)) { // constrain ink movement
                    parentArtDisplay = getParentDisplay();
                    rightbound = Math.min(rightbound, parentArtDisplay.getOutStart() + parentArtDisplay.getFadeOut());
                }
                else if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                    // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                    attachedDisplays = getChildDisplays();
                    totalDispLength = getLongestSubgroup(attachedDisplays);
                }
                else if (my.type === TAG.TourAuthoring.TrackType.video || my.type === TAG.TourAuthoring.TrackType.audio) {
                    if (my.mediaLength) {
                        maxTotalDispLength = parseFloat(my.mediaLength);
                        var rightLimit = inStart + maxTotalDispLength;
                        rightbound = Math.min(rightbound, rightLimit);
                    }
                }
                diff = my.timeManager.pxToTime(res.pivot.x - offset); // note this is defined in TAG.Util
                if (diff + fadeOut - getStart() >= totalDispLength) {
                    if (fadeIn === 0 && fadeOut === 0) {
                        outStart = Math.constrain(diff,
                                        Math.max(my.timeManager.pxToTime(parseFloat(finHandle.css('left')) + 20) + my.timeManager.pxToTime(2 * TAG.TourAuthoring.Constants.fadeBtnSize),
                                            ((!currkeyframes.isEmpty() && (currkeyframes.max().getTime() - fadeOut + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || -Infinity)),
                                        rightbound - fadeOut); // max
                    } else {
                        outStart = Math.constrain(diff,
                                        Math.max(inStart + fadeIn + 0.1,
                                            ((!currkeyframes.isEmpty() && (currkeyframes.max().getTime() - fadeOut + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || -Infinity)),
                                        rightbound - fadeOut); // max
                    }
                    if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                        for (i = 0; i < attachedDisplays.length; i++) {
                            clampDisplay(attachedDisplays[i]);
                        }
                    }
                }
            }//first term is current position, second is either the end of the fadeIn or the point when the end circle collides with the last keyframe, last term is the end of the tour. First term is constrained between the second two
            setOutStart(outStart);
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['main']) { // Drag whole display, preserve length
            // in here, we want to take care of constraining attached ink display dragging to its artwork display (leftbound = max(leftbound, left bound of attached artwork display), rightbound = .... )
            // also, take care of moving ink displays with artwork displays if need be 
            var currDisp = null;
            if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled)) { // constrain ink movement
                parentArtDisplay = getParentDisplay();
                rightbound = Math.min(rightbound, parentArtDisplay.getOutStart() + parentArtDisplay.getFadeOut());
                leftbound = Math.max(leftbound, parentArtDisplay.getStart() + TAG.TourAuthoring.Constants.inkTrackOffset);
            }
            else if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                attachedDisplays = getChildDisplays();
            }

            
            var newmainStart = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offset),
                                        leftbound + fadeIn,
                                        rightbound - fadeOut - main),
                translation = newmainStart - mainStart;
            setMainStart(newmainStart, translation);
            /*********************display snapping stuff***********************/
            //jjfu

            var excludeRight = null; //parent display's (if it exists) end time
            var excludeLeft = null; //parent display's (if it exists) start time

            if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) { //if display is an ink
                excludeRight = getParentDisplay().getEnd(); //get parent display's end time
                excludeLeft = getParentDisplay().getStart(); //get parent display's start time
            }

            //display movement should already be set above so mouseLoc should only be used to determine dragging to the right or to the left
            var mouseLoc = my.timeManager.pxToTime(res.pivot.x - offset); // where the start of the display would be based on mouse position alone

            var startTime = getStart(); //start time of display
            var endTime = getEnd(); //end time of display

            // +/- 0.001 to startTime to offset the startTime since it is being set above
            if (mouseLoc > startTime - 0.001) { 
                frontSnap(excludeRight);
            } else if (mouseLoc < startTime + 0.001) {
                backSnap(excludeLeft);
            }

            /********************************************/

            if (!inUndoRedo && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) {
                //var num_commands = 0;
                for (i = 0; i < attachedDisplays.length; i++) {
                    clampDisplay(attachedDisplays[i]);
                    //num_commands++;
                }
                // my.undoManager.combineLast(num_commands);
            }
        }
        else {
            console.log('currentDisplay.loc should be one of: \'fade-in\', \'fade-out\', or \'main\'');
        }
        that.outStart = outStart; //bleveque -- added for edit ink
        that.inStart = inStart;

        my.that.drawLines();
    }
    that.move = move;

    // accessor/mutator pair for parent display, used only by ink tracks
    function setParentDisplay(display) {
        parentDisplay = display;
    }
    that.setParentDisplay = setParentDisplay;

    function getParentDisplay() {
        return parentDisplay;
    }
    that.getParentDisplay = getParentDisplay;

    /**
     * Returns the length of the longest total collection of subdisplays
     */
    function getLongestSubgroup(gp) {
        var lens = {};
        var currmax = 0;
        for (var i = 0; i < gp.length; i++) {
            var title = gp[i].getTrack().getTitle();
            lens[title] = (typeof lens[title] === 'number' ? lens[title] : 0) + (gp[i].getRemoved() ? 0 : gp[i].getEnd() - gp[i].getStart());
            if(lens[title] > currmax)
                currmax = lens[title];
        }
        return currmax + TAG.TourAuthoring.Constants.inkTrackOffset; //add for offset
    }
    that.getLongestSubgroup = getLongestSubgroup;

    /**
     * Gets the attached ink displays residing within the bounds of the current display
     */
    function getAllChildDisplays() {
        var attachedDisplays = [];
        var i;
        // first get the attached inks
        var attached = [];
        var tracks = dataHolder.getTracks();
        for (i = 0; i < tracks.length ; i++) {
            if (tracks[i].track.getType() === TAG.TourAuthoring.TrackType.ink && tracks[i].track.getInkEnabled() && tracks[i].track.getInkLink().getTitle() === my.title)
                attached.push(tracks[i]);
        }
        for (i = 0; i < attached.length; i++) {
            // for each attached ink track, we want to see if we should move it with the new movement
            var attachedInk = attached[i],
                attachedInkDisps = attachedInk.displays.getContents();
            for (var j = 0; j < attachedInkDisps.length; j++) {
                var currDisp = attachedInkDisps[j].display;
                if ((currDisp.getOutStart() <= outStart + fadeOut) && (currDisp.getOutStart() >= inStart)) { // test if ink display is inside our display
                    attachedDisplays.push(currDisp);
                }
            }
        }

        return attachedDisplays;
    }
    that.getAllChildDisplays = getAllChildDisplays;

    /////////////////////////////////display snapping stuuffzzz?/////////////////////////////////
    //jjfu

    var nextDisplay, // furthest current display can go before it coincides with the next display to the right
        prevDisplay; // '' '' but for the previous display

    /*initSnap
    Takes current track and builds an AVLTree -> Doubly Linked List to 
    hold times to which the current display can snap */
    function initSnap() {
        var hostPos = that.getStorageContainer().hostTrack.getPos();

        var excludables = null; //hashtable with all times of attached ink to exclude from the snappable times list
        if (!(my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled)) { //if current display is not an ink
            excludables = buildExcludables(hostPos); 
        }

        //build snappable times list
        var snapTree = buildSnapTree(hostPos, excludables);
        snapTimesDLL = buildSnapDLL(snapTree);

        //find bounds of adjacent displays
        nextDisplay = dataHolder.findNextDisplay(hostPos, that);
        prevDisplay = dataHolder.findPreviousDisplay(hostPos, that);
    }

    /*buildExcludables
    Loop through all attached displays and insert start and end times into the excludables HashTable. Then return the table*/
    var buildExcludables = function () {
        var attachedDisplays = getAllChildDisplays();
        var excludables = new HashTable();

        for (var i = 0; i < attachedDisplays.length ; i++){
            excludables.insert(attachedDisplays[i].getStart(), 1);
            excludables.insert(attachedDisplays[i].getEnd(), 1);
        }

        //if nothing is being added to the excludables table, return null
        if (excludables.getLength() === 0) {
            return null;
        }
        return excludables;
    }


    // Local AVLTree comparator + valuation
    var comparator = function (a, b) {
        if (a.key < b.key) {
            return -1;
        } else if (a.key > b.key) {
            return 1;
        } else {
            return 0;
        }
    };

    var valuation = function (value, compareToNode) {
        if (!compareToNode) {
            return null;
        } else if (value < compareToNode.key) {
            return -1;
        } else if (value > compareToNode.key) {
            return 1;
        } else {
            return 0;
        }
    }

    /*addTimeNode
    For each display in the track, add the start and end time into the list if it is not in excludables HashTable*/
    function addTimeNode(displays, localTree, excludables) {
        if (excludables) { // only checks with excludables if it exists
            for (var i = 0; i < displays.length ; i++) {
                if (!excludables.lookup(displays[i].display.getStart())) {
                    localTree.add({ key: displays[i].display.getStart() });
                }
                if (!excludables.lookup(displays[i].display.getEnd())) {
                    localTree.add({ key: displays[i].display.getEnd() });
                }
            }
        } else {
            for (var i = 0; i < displays.length ; i++) {
                localTree.add({ key: displays[i].display.getStart() });
                localTree.add({ key: displays[i].display.getEnd() });
            }
        }
    }

    /*buildSnapTree
    Takes the track above and below the current display's track and builds the AVLTree (sorted) for the times*/
    function buildSnapTree(hostPos, excludables) {
        var p1 = (hostPos - 1 >= 0) ? (hostPos - 1) : null,
            n1 = (hostPos + 1 < dataHolder.numTracks()) ? (hostPos + 1) : null;
        
        var localTree = new AVLTree(comparator, valuation);
        var tracks = dataHolder.getTracks();
        
        if (p1 != null) {
            addTimeNode(tracks[p1].displays.getContents(), localTree, excludables);
        }
        if (n1 != null) {
            addTimeNode(tracks[n1].displays.getContents(), localTree, excludables);
        }

        return localTree;
    }

    /*buildSnapDLL
    Converts the AVLTree of snappable times to a doubly linked list*/
    function buildSnapDLL(snapTree) {
        var treeTimes = snapTree.getContents();
        var snapTimes = new DoublyLinkedList();

        for (var i = 0; i < treeTimes.length ; i++) {
            snapTimes.append(treeTimes[i].key);
        }

        return snapTimes;
    }

    /*withinSnapRange
    Returns if the time difference is within snappable range
    Using pixels*/
    function withinSnapRange(diff) {
        var pxDiff = my.timeManager.timeToPx(diff);
        if (pxDiff < $(window).width() * 0.01 && pxDiff > 0) {
            return true;
        }
        return false;
    }

    /*frontSnap
    Completes display snapping to the right
    Passes in excludeRight which is the start time of the next display (if it exists) of the current display*/
    function frontSnap(excludeRight) {

        var startTime = getStart();
        var endTime = getEnd();

        // the next time that the current display could possibly snap to relative to the startTime of the current display
        var startNextNode = snapTimesDLL.findNext(startTime);
        // the next time that the current display could possibly snap to relative to the endTime of the current display
        var endNextNode = snapTimesDLL.findNext(endTime);

        var snapped = false; //keeps track of if the end of the current display has snapped to the next snappable time

        if (excludeRight && endNextNode && endNextNode.data === excludeRight) {
           //does not snap if it's its own display so therefore do nothing lolols
        }else {
            if (endNextNode !== null) {
                var endRightDiff = endNextNode.data - (inStart + that.getTotalLength());

                if (!withinSnapRange(endRightDiff) || (excludeRight && (endTime + endRightDiff) > excludeRight)) {
                    //do nothing if it's not suppose to snap
                }else {
                    if (nextDisplay && (nextDisplay.display.getStart() - endTime) >= endRightDiff) {
                        updateDispTimes(endRightDiff);
                        snapped = true;
                    } else if (!nextDisplay) {
                        updateDispTimes(endRightDiff); 
                        snapped = true;
                    }
                }
            }
        }

        if (excludeRight && startNextNode && startNextNode.data === excludeRight) {
            return; //does not snap if snaps to it's own display
        }else {
            if (startNextNode != null) {
                var startRightDiff = startNextNode.data - startTime

                if (!withinSnapRange(startRightDiff) || (excludeRight && (endTime + startRightDiff) > excludeRight) || (endTime + startRightDiff > my.timeManager.getDuration().end)) {
                    //do nothing if it's not suppose to snap
                }else {
                    if (snapped === false) {
                        if (nextDisplay && (nextDisplay.display.getStart() - endTime) >= startRightDiff) {
                            updateDispTimes(startRightDiff);
                        } else if (!nextDisplay) {
                            updateDispTimes(startRightDiff);
                        }
                    }
                }
            }
        }

    }

    function backSnap(excludeLeft) {

        var startTime = getStart();
        var endTime = getEnd();

        var startLeftNode = snapTimesDLL.findPrev(startTime);
        var endLeftNode = snapTimesDLL.findPrev(endTime);
        var snapped = false;

        if (excludeLeft && startLeftNode && startLeftNode.data === excludeLeft) {
            //does not snap if it's its own display so therefore do nothing lolols
        } else {
            if (startLeftNode != null) {
                var startLeftDiff = startTime - startLeftNode.data

                if (!withinSnapRange(startLeftDiff) || (excludeLeft && (startTime - startLeftDiff) < excludeLeft)) {
                    //do nothing lolss
                }else {
                    if (prevDisplay && (prevDisplay.display.getEnd() - startTime) >= startLeftDiff) {
                        updateDispTimes((-1) * startLeftDiff);
                        snapped = true;
                    } else if (!prevDisplay) {
                        updateDispTimes((-1) * startLeftDiff);
                        snapped = true;
                    }
                }
            }
        }

        if (excludeLeft && endLeftNode && endLeftNode.data === excludeLeft) {
            //does not snap if it's its own display so therefore do nothing lolols
        } else {
            if (endLeftNode != null) {
                var endLeftDiff = (inStart + that.getTotalLength()) - endLeftNode.data;

                if (!withinSnapRange(endLeftDiff) || (excludeLeft && (startTime - endLeftDiff) < excludeLeft) || (startTime - endLeftDiff < 0)) {
                    //do nothing lolss
                } else {
                    if (snapped === false) {
                        if (prevDisplay && (prevDisplay.display.getEnd() - startTime) >= endLeftDiff) {
                            updateDispTimes((-1) * endLeftDiff);
                        } else if (!prevDisplay) {
                            updateDispTimes((-1) * endLeftDiff);
                        }
                    }
                }
            }
        }

    }
    ////////////////////////////////////////end of displaySnapping/////////////////////////////////////////////////////







    /**
     * Gets the art display enclosing an attached ink track display.
     */
    function getParentArtDisplay() {
        //DEPRECATED now use getParentDisplay()
        var parentArtTrack = my.experienceId,
            parentDisplays = parentArtTrack.getStorageContainer().displays, //returns the tree that holds all of the displays
            parentArtDisplay,
            currDisp,
            i;
        //for (i = 0; i < parentDisplays.length; i++) {
        //    currDisp = parentDisplays[i];
        //    if ((currDisp.getStart() <= outStart) && (outStart <= currDisp.getOutStart() + currDisp.getFadeOut())) { // use outStart to test if display is in the art display
        //        parentArtDisplay = currDisp;
        //        break;
        //    }
        //}
        var neighbors = parentDisplays.nearestNeighbors(getStart(), 1);

        return neighbors[0];
    }
    that.getParentArtDisplay = getParentArtDisplay;

    /**
     * Accepts a display that should be clamped to the current display (i.e. if it sticks out, move it in)
     * @param disp     the display to clamp
     */
    function clampDisplay(disp) {
        // in here, we should check first the start, move in, then end, move in, then clamp
        // we also need to check to make sure that 
        var dInStart = disp.getStart(),
            dOutEnd = disp.getEnd(),
            dMain = disp.getMain(),
            dFadeIn = disp.getFadeIn(),
            dFadeOut = disp.getFadeOut(),
            coDisplays = disp.getStorageContainer().displayTree, //.getContents().sort(function (a, b) { a.display.getStart() - b.display.getStart() }),//disp.getTrack().getDisplays().sort(function(a,b){a.getStart() - b.getStart()}),
            //index = coDisplays.indexOf(disp),
            newStart = dInStart, newEnd = dOutEnd, newMain = dMain, delta, dirty = false;
        
        if (dInStart < inStart + TAG.TourAuthoring.Constants.inkTrackOffset) { // first check if the ink display starts too early
            slideDisplay(disp, coDisplays, 'right', inStart + TAG.TourAuthoring.Constants.inkTrackOffset);
        }
        if (newEnd > outStart + fadeOut) { // next check if the ink display finishes too late
            slideDisplay(disp, coDisplays, 'left', outStart + fadeOut);
        }
        
        //var newInStart = disp.getStart();
        //var newOutStart = disp.getEnd() - disp.getFadeOut();
        //var newMainLength = disp.getMain();

        //var command = TAG.TourAuthoring.Command({
        //    execute: function () {
        //        disp.setTimes({
        //            inStart: newInStart,
        //            outStart: newOutStart,
        //            main: newMainLength,
        //            fadeIn: dFadeIn,
        //            fadeOut: dFadeOut,
        //        });
        //    },
        //    unexecute: function () {
        //        disp.setTimes({
        //            inStart: dInStart,
        //            outStart: dOutEnd - dFadeOut,
        //            main: dMain,
        //            fadeIn: dFadeIn,
        //            fadeOut: dFadeOut,
        //        });
        //    }
        //});
        //my.undoManager.logCommand(command);
    }
    that.clampDisplay = clampDisplay;

    function slideDisplay(disp, displayTree, direction, bound) {
        // we can always move in, since we check beforehand that there's enough room
        var newStart, newEnd, newMain;
        var oldStart = disp.getStart(), oldEnd = disp.getEnd(), oldMain = disp.getMain();
        var fout = disp.getFadeOut(), fin = disp.getFadeIn();
        var diff;
        if (!disp.has_been_clamped) {
            disp.clamped_init = {
                inStart: oldStart,
                outStart: oldEnd - fout,
                main: oldMain,
                fadeIn: fin,
                fadeOut: fout,
            };
            disp.has_been_clamped = true; //this will be reset to false in the mouseup handler
            my.timeline.clamped_displays.push(disp);
        }
        if (direction === 'right') {
            diff = bound - oldStart;
            newStart = bound;
            newEnd = oldEnd + diff;
            newMain = oldMain;
            //newEnd = Math.min(newStart + dFadeIn + dMain + dFadeOut, coDisplays[index+1] ? coDisplays[index+1].getStart() : Infinity);
            //newMain = newEnd - newStart - dFadeIn - dFadeOut;
            disp.setInStart(newStart);
            disp.setOutStart(newEnd - fout);
            disp.setMain(newMain);
            disp.clamped_new = {
                inStart: newStart,
                outStart: newEnd - fout,
                main: newMain,
                fadeIn: fin,
                fadeOut: fout,
            };
            //console.log("init start: " + disp.clamped_init.inStart + ", new start: " + disp.clamped_new.inStart);
            var nextDisp = displayTree.findNext(disp.getStorageContainer());
            //if (dispArray.length > index+1 && dispArray[index + 1].display.getStart() < newEnd) {
            if (nextDisp && nextDisp.display.getStart() < newEnd) {
                slideDisplay(nextDisp.display, displayTree, 'right', newEnd);
            }
        }
        else {
            diff = oldEnd - bound;
            newEnd = bound;
            newStart = oldStart - diff;
            newMain = oldMain;
            disp.setInStart(newStart);
            disp.setOutStart(newEnd - fout);
            disp.setMain(newMain);
            disp.clamped_new = {
                inStart: newStart,
                outStart: newEnd - fout,
                main: newMain,
                fadeIn: fin,
                fadeOut: fout,
            };
            var prevDisp = displayTree.findPrevious(disp.getStorageContainer());
            if (prevDisp && prevDisp.display.getEnd() > newStart) {
                slideDisplay(prevDisp.display, displayTree, 'left', newStart);
            }
        }
    }
    that.slideDisplay = slideDisplay;

    /**************************Xiaoyi/Libby**************************/
    /*
     * get the translation of the clicked display when manipulated. constrained by the bounds
     * @params res              mouse movement, the rest are the bounds 
     * @return translation
    */
    function getTranslation(res, leftbound, rightbound, fadeinrightbound, fadeoutleftbound) {
        var translation;
        if (!loc || (offset !== 0 && !offset) || !my.currentDisplay) { // need that extra offset = 0 check since 0 and null are equal, arg
            console.log('Move display called when no display is selected!');
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-in']) {
          var newinStart = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offset), // note this is defined in TAG.Util
                                    leftbound, // min
                                    inStart + fadeinrightbound);
          translation = newinStart - inStart;
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-out']) { // Drag fade-out section to adjust length
            var newoutStart = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offset),
                              getEnd()-fadeoutleftbound-fadeOut,
                                rightbound - fadeOut); // max
            translation = newoutStart - outStart;
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['main']) {
            var newmainStart = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offset),
                                        leftbound + fadeIn,
                                        rightbound - fadeOut - main);
            translation = newmainStart - mainStart;
        }
        return translation;
    }
    that.getTranslation = getTranslation;


    /*
    *special move function for multi select mode!~ YoLo~!!!. 
    */
    function msMove(selectDisplays, translation, displayIn, displayOut) { // deal with ink track sliding in here if necessary
        // no display in or out, set to -1
        displayIn = displayIn || -1;
        displayOut = displayOut || -1;
        var attachedDisplays, i, j, disp;
        var totalDispLength = 0;

        // error checking
        if (!loc || (offset !== 0 && !offset)) { // need that extra offset = 0 check since 0 and null are equal, arg
            console.log('Move display called when no display is selected!');
        }
        // Actual editing
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-in']) { // Drag fade-in section to adjust length
            for (i = 0; i < selectDisplays.length; i++) {
                disp = selectDisplays[i];
                if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                    // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                    attachedDisplays = disp.getChildDisplays();
                    totalDispLength = disp.getLongestSubgroup(attachedDisplays);
                }
                if (disp.getEnd() - translation >= totalDispLength) {
                    var msinStart = disp.getStart();
                    if (displayIn !== -1) {
                        msinStart = displayIn;
                    }
                    else {
                        msinStart = msinStart + translation;
                    }
                    disp.setInStart(msinStart);
                    if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                        //var num_commands = 0;
                        for (j = 0; j < attachedDisplays.length; j++) {
                            if (selectDisplays.indexOf(attachedDisplays[j]) === -1) {
                                disp.clampDisplay(attachedDisplays[j]);
                                //num_commands++;
                            }
                        }
                        //my.undoManager.combineLast(num_commands);
                    }
                }
            }
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-out']) { // Drag fade-out section to adjust length
            for (i = 0; i < selectDisplays.length; i++) {
                disp = selectDisplays[i];
                if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                    // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                    attachedDisplays = disp.getChildDisplays();
                    totalDispLength = disp.getLongestSubgroup(attachedDisplays);
                }
                if (disp.getEnd() - translation >= totalDispLength) {
                    var msOutStart = disp.getOutStart();
                    if (displayOut !== -1) {
                        outStart = displayOut;
                    }
                    else {
                        msOutStart = msOutStart + translation;
                    }
                    disp.setOutStart(msOutStart);
                    if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                        //var num_commands = 0;
                        for (j = 0; j < attachedDisplays.length; j++) {
                            if (selectDisplays.indexOf(attachedDisplays[j]) === -1) {
                                disp.clampDisplay(attachedDisplays[j]);
                                //num_commands++;
                            }
                        }
                        //my.undoManager.combineLast(num_commands);
                    }
                }
            }
        }
        else if (loc === TAG.TourAuthoring.DisplayParts['main']) { // Drag whole display, preserve length
            for (i = 0; i < selectDisplays.length; i++) {
                disp = selectDisplays[i];
                if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                    // in here, construct array of attached ink displays that are inside of the current display (can factor this out eventually to make more efficient -- here now to push)
                    attachedDisplays = disp.getChildDisplays();
                    totalDispLength = disp.getLongestSubgroup(attachedDisplays);
                }
                var msmainStart = disp.getMainStart();
                var newmainStart = translation + msmainStart;
                disp.setMainStart(newmainStart, translation);
                if (disp.getType() === TAG.TourAuthoring.TrackType.artwork || disp.getType() === TAG.TourAuthoring.TrackType.image) {
                    //var num_commands = 0;
                    for (j = 0; j < attachedDisplays.length; j++) {
                        if (selectDisplays.indexOf(attachedDisplays[j]) === -1) {
                            disp.clampDisplay(attachedDisplays[j]);
                            //num_commands++;
                        }
                    }
                    //my.undoManager.combineLast(num_commands);
                }
                disp.getTrackFromDisplay().drawLines();
            }
            
        }
        else {
            console.log('currentDisplay.loc should be one of: \'fade-in\', \'fade-out\', or \'main\'');
        }
        that.outStart = outStart; //bleveque -- added for edit ink
        that.inStart = inStart;
        my.that.drawLines();
    }
    that.msMove = msMove;
  
    function getTrackFromDisplay() {
        return my.that;
    }
    that.getTrackFromDisplay = getTrackFromDisplay;
    /**
     * Used to debug move from command line
     * Flips internal state to simulate clicks
     * Resets state when finished
     * Use only in test code or functions inside display
     */
    function internalMove(dx, left, right, dloc, doffset) {
        var res = {
            pivot: {
                x: dx
            }};
        my.currentDisplay = that;
        loc = dloc;
        offset = doffset;
        
        move(res, left, right,-1,-1);

        // reset state
        my.currentDisplay = null;
        loc = null;
        offset = null;
    }
    that.internalMove = internalMove;

    /**
     * Helper function for moving all keyframes when whole display is dragged
     * @param translate     Amount (in time) to move keyframes by
     */
    function _moveAllKeyframes(translate) {
        //var i;
        //for (i = 0; i < keyframes.length; i++) {
        //    keyframes[i].translate(translate);
        //}
        currkeyframes.map(function (i) {
            i.translate(translate);
        });
    }

    /**
     * Resets positioning and size of display
     * Called after zoom or scaling
     */
    function scale() {
        if (T2P(inStart) < 1884 && T2P(inStart) > 1883)
            console.log('');
        outStart = inStart + fadeIn + main;
        finD.css('left', T2P(inStart) + "px")
            .css('width', T2P(fadeIn) + "px");
        mainD.css('left', T2P(mainStart) + "px")
            .css('width', T2P(main) + "px");
        fioD.css('left', T2P(outStart) + "px")
            .css('width', T2P(fadeOut) + "px");
        finHandle.css('left', T2P(inStart) - 20 + "px");
        fioHandle.css('left', T2P(outStart + fadeOut) - 20 + "px");
        //var i;
        //for (i = 0; i < keyframes.length; i++) {
        //    keyframes[i].scale();
        //}
        currkeyframes.map(function (i) {
            i.scale();
        });
    }
    that.scale = scale;
    //my.timeManager.onSizing(scale); // TODO: should I just call scale() from track? It'd be fewer fn's for timemanager to handle


    /**
     * Adds a keyframe to the display / sequence
     * @param x         x location in px
     * @param y         y location in px
     * @param capture   whether the keyframe should immediately capture the state of the player
     * @returns     keyframe%A
     */
    function addKeyframe(x, y, customSpec) {
        if (canKeyframe) {
            var data = my.timeline.captureKeyframe(my.title),
                keyframe, command, i;

            var keyspec = {
                    loc: {
                        x: Math.twoDecPlaces(my.timeManager.pxToTime(x)),
                        y: (my.type === TAG.TourAuthoring.TrackType.audio) ? y : 48
                    },
                    gkey: gkey,
                    display: that,
                    data: data,
                    displayDiv: mainD
                };

            // check that you are not making a keyframe right on top of another
            var neighbors = currkeyframes.nearestNeighbors(keyspec.loc.x, 1);
            if ((neighbors[0] && Math.abs(neighbors[0].getTime() - keyspec.loc.x) < 0.05) || 
                  (neighbors[1] && Math.abs(neighbors[1].getTime() - keyspec.loc.x) < 0.05)) {
                    return null;
            }
            //for (i = 0; i < keyframes.length; i++) {
            //    if (keyframes[i].getTime() === keyspec.loc.x) {
            //        return null; // no keyframe for u
            //    }
            //}
            //var isUnique = currkeyframes.map(function (i) {
            //    if (Math.twoDecPlaces(i.getTime()) === keyspec.loc.x) {
            //        return null;
            //    }
            //});

            keyframe = TAG.TourAuthoring.Keyframe(keyspec, my),
            command = TAG.TourAuthoring.Command({ // NOTE: don't execute command or call update! might screw up user editing
                execute: function () {
                    //keyframes.push(keyframe);
                    //sortKeyframes();
                    currkeyframes.add(keyframe);
                    keyframe.reactivateKeyframe();
                    keyframe.restoreHandlers();
                    my.that.addKeyframeToLines(keyframe);
                    my.update();
                },
                unexecute: function () {
                    // keyframe.remove() // TODO: add svg removal
                    keyframe.remove(false, true);
                    keyframe.setDeselected();
                    //keyframes.remove(keyframe);
                    my.update();
                }
            });
            my.undoManager.logCommand(command);
            console.log('logging');

            //keyframes.push(keyframe);
            //sortKeyframes();
            currkeyframes.add(keyframe);

            if (my.that.getMinimizedState()) {
                keyframe.toggleCircle();
            }

            var reloadingEvent = document.createEvent('Event');
            reloadingEvent.initEvent('playerReloading', true, true);
            $('body')[0].dispatchEvent(reloadingEvent);

            return keyframe;
        } else {
            return null;
        }
    }
    that.addKeyframe = addKeyframe;

    /**
    * Function to remove keyframe from keyframe array
    */
    function removeKeyframe(keyframe) {
        //keyframes.remove(keyframe);
        //don't need to update position anymore
        //for (var i = 0; i < keyframes.length; i++) {
        //    keyframes[i].updatePosition(i);
        //}
        //return i;
        currkeyframes.remove(keyframe);
    }
    that.removeKeyframe = removeKeyframe;

    //Function to add keyframe to keyframe array
    function insertKeyframe(keyframe){
        currkeyframes.add(keyframe);
    }
    that.insertKeyframe = insertKeyframe;

    /**
     * Sorts the keyframe array
     * Must be called after a keyframe is moved, as keyframes can change order
     */
    //no longer being used
    function sortKeyframes() {
        var i;
        keyframes.sort(_keyframesort);
        for (i = 0; i < keyframes.length; i++) {
            keyframes[i].updatePosition(i);
        }
    }
    that.sortKeyframes = sortKeyframes;

    /**
     * Used for passing last state of display on to next display
     */
    function getLastKeyframe() {
        return currkeyframes.max();
    }
    that.getLastKeyframe = getLastKeyframe;

    /**
     * Get keyframes belonging to display
     * Used for finding bounds of keyframe movement
     */
    function getKeyframes() {
        return currkeyframes;
    }
    that.getKeyframes = getKeyframes;

    /**
     * Helper function for keeping keyframes sorted
     * Sorted in ascending order by x position (in time)
     */
    //no longer being used
    function _keyframesort(a, b) {
        if (a.getTime() < b.getTime()) {
            return -1;
        } else if (a.getTime() === b.getTime) {
            return 0;
        } else {
            return 1;
        }
    }
    //no longer being used
    function _keyframecomp(a, b) {
        return a.getTime() < b.getTime();
    }

    //////
    // RIN

    /**
     * Converts Display to Experience Stream
     * @param data          new ES is inserted into this object
     * @param type          type header identifying the type of ES / media
     * @param passthrough   whether this ES (layer) can be manipulated
     * @param prevState     final keyframe from previous display, defines start state for this display
     */
    function toES(data, passthrough, prevState, id) {
        var keySeq = {},
            esTitle = my.title + '-' + id;

        data.experienceStreams[esTitle] = {
            duration: main,
            data: {
                zIndex: my.timeline.getNumTracks() - my.that.getPos(),
                'layerProperties': {
                    'passthrough': passthrough
                }
            }
        };
        if (canFade) {
            data.experienceStreams[esTitle].data.transition = {
                providerId: "FadeInOutTransitionService",
                inDuration: fadeIn,
                outDuration: fadeOut
            };
        }

        // type specific edits
        switch (my.type) {
            case TAG.TourAuthoring.TrackType.artwork:
                data.experienceStreams[esTitle].data.ContentType = '<SingleDeepZoomImage/>';
                data.experienceStreams[esTitle].header = {};
                data.experienceStreams[esTitle].header.defaultKeyframeSequence = esTitle;
                data.experienceStreams[esTitle].keyframes = _getKeyframesRIN(prevState);
                break;

            case TAG.TourAuthoring.TrackType.image:
                data.experienceStreams[esTitle].header = {};
                data.experienceStreams[esTitle].header.defaultKeyframeSequence = esTitle;
                data.experienceStreams[esTitle].keyframes = _getKeyframesRIN(prevState);
                break;

            case TAG.TourAuthoring.TrackType.audio:
                data.experienceStreams[esTitle].header = {};
                data.experienceStreams[esTitle].header.defaultKeyframeSequence = esTitle;
                data.experienceStreams[esTitle].keyframes = _getKeyframesRIN(prevState);
                break;

            case TAG.TourAuthoring.TrackType.video:
                data.experienceStreams[esTitle].data.markers = {
                    'beginAt': 0,
                    'endAt': main
                };
                break;

            case TAG.TourAuthoring.TrackType.ink:
                break;

            default:
                console.log('RIN track type not yet implemented');
        }
    }
    that.toES = toES;

    /**
     * Helper function for collecting RIN data of associated keyframes
     */
    function _getKeyframesRIN(prevState) {
        var i, rin = [],
            first;
        var dispkfs = dataHolder.getKeyframes(that.getStorageContainer());
        var kfarray = dispkfs.getContents();
        if (kfarray.length > 0) {
            if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.audio || my.type === TAG.TourAuthoring.TrackType.image) {
                // Copy first keyframe that appears in display and place copy at start
                // This means display will begin w/ state defined by first keyframe instead of jumping to it
                first = dispkfs.min().toRIN();
                first.offset = 0;
                first.init = true;
                rin.push(first);
            }
                
            //for (i = 0; i < keyframes.length; i++) {
            //    rin.push(keyframes[i].toRIN());
            //}
            dispkfs.map(function (i) {
                rin.push(i.toRIN());
            });

        } else if (prevState) { // If there are no keyframes but are in prev display
            first = prevState.toRIN();
            first.offset = 0;
            first.init = true;
            rin.push(first);
        } else if (my.type === TAG.TourAuthoring.TrackType.audio) {
            first = {
                offset: 0,
                init: true,
                holdDuration: 0,
                state: { // Need to determine where keyframe info is getting stored, also why does it need a media source?
                    'sound': {
                        'volume': TAG.TourAuthoring.Constants.defaultVolume
                    }
                }
            };
            rin.push(first);

        } else if (kfarray.length == 0) {
            //var data = my.timeline.captureKeyframe(my.title);
            console.log("capturing blank kf for reset");
            first = my.timeline.captureKeyframe(my.title);
            if (!first) {
                first = {
                    state: {
                        viewport: {
                            region: {
                                center: {
                                    x: 0,
                                    y: 0,
                                },
                                span: {
                                    x: 1,
                                    y: 1,
                                }
                            },
                        },
                    },
                };
            }
            //first.holdDuration = 0;
            first.offset = 0;
            first.init = true;
            rin.push(first);
        }
        return rin;
    }

    /**
     * Constructs Screenplay entry from display
     * Returns object with begin, xml params so entries can be sorted
     */
    function toScreenPlayEntry(i) {
        var spe = {},
            esTitle = my.title + '-' + i;

        spe.experienceId = my.title;
        spe.experienceStreamId = esTitle;
        spe.begin = inStart;
        spe.duration = (fadeIn + main);
        spe.layer = 'foreground';
        spe.zIndex = dataHolder.numTracks() - my.that.getPos();
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            spe.dominantMedia = 'audio';
            spe.volume = 1;
        } else {
            spe.dominantMedia = 'visual';
            spe.volume = 1;
        }
        
        return spe;
    }
    that.toScreenPlayEntry = toScreenPlayEntry;

    function loadRIN(rin) {
        
    }
    that.loadRIN = loadRIN;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.MenuInputFormats');
TAG.Util.makeNamespace('TAG.TourAuthoring.EditorMenu');

TAG.TourAuthoring.MenuInputFormats = {
    minSec: 1, // 00:00.00 (min:sec.centisecs)
    sec: 2, // 00 (sec)
    percent: 3 // 0 - 100 (%)
};

TAG.TourAuthoring.MenuType = {
    display: 1,
    keyframe: 2,
    track: 3
};

/**
 * Menu for track, display and keyframe editing
 * @param spec.type     value from MenuType enum specifying menu layout
 * @param my            track's shared my object
 */
TAG.TourAuthoring.EditorMenu = function (spec, my) {
    "use strict";
    var that = {},
        menu = $(document.createElement('div')),
        arrow = $(document.createElement('img')),
        menuType = spec.type,
        parent = spec.parent,
        trackBody = my.timeline.getTrackBody(),
        OPACITY = 0.95,
        
        /**
         * Contains one object for every input in the menu
         * Input objects have parameters:
         * @param input             The actual HTML input element
         * @param format            Format of input, value from MenuInputFormats enum
         * @param accessCallback    Function for obtaining current value of linked variable
         * @param updateCallback    Function for updating value of linked variable
         */
        inputObjects = [];

    that.menuCloseable = true;
    menu.addClass("displayMenu");


    /**
     * Initializes menu html
     */
    (function createHTML() {
        var width, arrowSrc;

        // set particular parts of style according to menu type
        switch (menuType) {
            case TAG.TourAuthoring.MenuType.display:
                width = '22%';
                break;
            case TAG.TourAuthoring.MenuType.keyframe:
                width = '18%';
                break;
            case TAG.TourAuthoring.MenuType.track:
                width = '15%';
                break;
        }

        menu.css({
            "position": "fixed",
            "color": "rgb(256, 256, 256)",
            'width': width,
            'background-color': 'rgba(0,0,0,'+OPACITY+')',
            'padding-top': '3px',
            'padding-left': '2px',
            'padding-right': '2px',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 7,
            'border-radius': '15px'
        });

        // more particular fixes
        switch (menuType) {
            case TAG.TourAuthoring.MenuType.display:
                break;
            case TAG.TourAuthoring.MenuType.keyframe:
                break;
            case TAG.TourAuthoring.MenuType.track:
                menu.css({
                    'left': '18%',
                    'padding': '.5%',
                    'margin-top': '1%',
                    'float': 'left',
                    'clear': 'left',
                    'border-radius': '5%'
                });
                break;
        }

        my.track.append(menu);
        menu.hide();
        my.timeline.isMenuOpen = false;

        // general event bindings
        menu.on('MSPointerDown', function (ev) {
            inputObjects.map(updateInput);
            ev.stopImmediatePropagation();
        });
        menu.on('mousedown', function (event) {
            inputObjects.map(updateInput);
            event.stopImmediatePropagation();
        });
        menu.on('click', function (event) {
            inputObjects.map(updateInput);
            event.stopImmediatePropagation();
        });

        // more particular fixes
        switch (menuType) {
            case TAG.TourAuthoring.MenuType.display:
            case TAG.TourAuthoring.MenuType.keyframe:
                arrowSrc = tagPath + "images/icons/KeyframeInfo-Opaque.png";
                break;

            case TAG.TourAuthoring.MenuType.track:
                arrowSrc = tagPath + "images/icons/LeftPoint-Opaque.png";
                break;
        }

        arrow.attr("src", arrowSrc);
        arrow.css({
            position: 'fixed',
            height: '45px',
            width: '54px',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 5,
            'opacity': OPACITY
        });

        switch (menuType) {
            case TAG.TourAuthoring.MenuType.track:
                arrow.css({
                    left: '14%',
                    height: '6%',
                    width: '4%'
                });
                break;
            default:
                arrow.css({
                    'margin-top': '-1px'
                });
                break;
        }

        my.track.append(arrow);
        arrow.hide();
    })();

    /**
     * Opens menu
     * @param evt   evt from interaction event, used to reposition menu
     */
    function open(evt) {
        // close existing menus=
        var close = my.timeline.getCloseMenu();
        if (close) {
            close();
        }

        // ???
        if (my.that.getEventsPaused())
            return;

        //deselect all tracks and open the menu
        my.timeline.allDeselected();
        my.timeline.setisMenuOpen(true);
        my.timeline.setCloseMenu(forceClose);
        my.that.updateTracksEventsPaused(true);

        // update menu position and contents
        if (evt) updateMenuPos(evt);
        resetInputs();

        // remove current selections
        my.currentDisplay = null;
        if (my.currentKeyframe) {
            my.currentKeyframe.setDeselected();
            my.currentKeyframe = null;
        }

        // reattach handlers if they were removed
        if (!menu.data('events') || !(menu.data('events').click)) {
            menu.on('click', function (event) {
                inputObjects.map(updateInput);
                event.stopImmediatePropagation();
            });
        }
        if (!menu.data('events') || !(menu.data('events').MSPointerDown)) {
            menu.on('MSPointerDown', function (ev) {
                inputObjects.map(updateInput);
                ev.stopImmediatePropagation();
            });
        }
        if (!menu.data('events') || !(menu.data('events').mousedown)) {
            menu.on('mousedown', function (event) {
                inputObjects.map(updateInput);
                event.stopImmediatePropagation();
            });
        }

        // logic to close menu
        my.root.on('mousedown.editorMenu', function (event) {
            var i, ancestryCheck = false;
            for (i = 0; i < inputObjects.length; i++) { // TODO
                if ($(event.target).parents().index(inputObjects[i].input) === -1) {
                    ancestryCheck = true;
                    break;
                }
            }

            that.close();//only closes if clicked off menu
        });
    }
    that.open = open;

    /**
     * Close menu
     * Doesn't fire if menuCloseable is set
     * Call only from my.root close handler
     */
    function close(preventClose) {
        forceClose(preventClose);
    }
    that.close = close;

    /**
     * Actually closes menu, no menuCloseable check
     * Call everywhere except my.root handler
     */
    function forceClose(preventClose) {
        var i;

        my.root.off('mousedown.editorMenu');

        my.timeline.setisMenuOpen(false);
        my.timeline.setCloseMenu(null);
        my.that.updateTracksEventsPaused(false);

        menu.hide();
        arrow.hide();

        // remove current selections
        //my.currentDisplay = null;
        //if (my.currentKeyframe && my.currentKeyframe === parent) {
        //    my.currentKeyframe.setDeselected();
        //    my.currentKeyframe = null;
        //}

        // save current input states
        if (!preventClose) {
            for (i = 0; i < inputObjects.length; i++) {
                updateInput(inputObjects[i]);
            }
        }
    }
    that.forceClose = forceClose;

    ///////////////
    // CONSTRUCTION

    /**
     * Adds an input element to the menu
     * @param name      Name of element (appears on menu)
     * @param format    MenuInputFormat type
     * @param accessCallback    Function for obtaining current value of linked variable
     * @param updateCallback    Function for updating value of linked variable
     */
    function addInput(name, format, accessCallback, updateCallback) {
        var inputObj = {},
            inputContainer = $(document.createElement('div')),
            inputGroup = $(document.createElement('div')),
            input = $(document.createElement('input')),
            units = $(document.createElement('text'));

        // set up input
        input.attr('type', 'text');
        input.val(convertToString(accessCallback(), format)); // TODO: ??? do I need to parse to proper format?
        input.css({
            width: '15%',
            position: 'absolute',
            //'min-width': '0px',//override stylesheet
            right: '40%',
            'font-size':'.65em'
        });
        input.on('click', function (ev) {
            input.select();
            ev.stopImmediatePropagation();
        });
        input.on('MSPointerDown', function (ev) {
            ev.stopImmediatePropagation();
        });
        input.keypress(function (evt) { // update on enter push
            if (evt.keyCode === 13) {
                updateInput(inputObj);
                resetInputs();
            }
        });

        // set up units
        units.css({
            'position': 'absolute',
            'float': 'right',
            'font-size': '0.95em',
            'right': '15px'
        });
        switch (format) {
            case TAG.TourAuthoring.MenuInputFormats.minSec:
                units.text('min:sec');
                break;
            case TAG.TourAuthoring.MenuInputFormats.sec:
                units.text('secs');
                break;
            case TAG.TourAuthoring.MenuInputFormats.percent:
                units.text('percent');
        }

        // assemble container and attach to menu
        inputContainer.css({
            width: "95%",
            'margin-left': 'auto',
            'margin-right': 'auto',
            'font-size': '0.8em',//TAG.Util.getFontSize(200),
            'padding-top': '3%',
        });
        inputContainer.append(name);
        inputContainer.append(input);
        inputContainer.append(units);
        menu.append(inputContainer);

        // assemble object
        inputObj.input = input;
        inputObj.accessCallback = accessCallback;
        inputObj.updateCallback = updateCallback;
        inputObj.format = format;
        inputObjects.push(inputObj);
    }
    that.addInput = addInput;

    /**
     * Adds text w/ no related input or button
     * @param title     Text to appear
     */
    function addTitle(title) {
        var titlediv = $(document.createElement('label'));
        titlediv.text(title);
        titlediv.css({
            "left": "auto",
            "top": "auto",
            "position": "relative",
            "font-size": '0.8em',//TAG.Util.getFontSize(250),
            "color": "rgb(256, 256, 256)",
            "display": "block",
            'padding': '4%',
            'text-align': 'center'
        });
        menu.append(titlediv);
    }
    that.addTitle = addTitle;

    /**
     * Adds button to screen (click to fire)
     * @param title     Test to appear in button
     * @param floatPos  Side of screen to float to
     * @param callback  Function to fire when clicked
     */
    function addButton(title, floatPos, callback) {
        var buttondiv = $(document.createElement('label'));
        buttondiv.text(title);//sets button text
        buttondiv.css({
            "left": "0%",
            "position": "relative",
            "top": "5%",
            "font-size": '0.8em',//TAG.Util.getFontSize(200),
            "color": "rgb(256, 256, 256)",
            "display": "block",
            'padding': '10px 0',
            'text-align': 'center',
            'margin-left': '3%',
            'margin-right': '3%',
            float: floatPos
        });

        // additional css edits:
        switch (menuType) {
            case TAG.TourAuthoring.MenuType.track:
                buttondiv.css({
                    'width': '93%',
                    'height': '16%',
                    'border-style': 'solid',
                    'border-width': '2px',
                    'margin-left': '3%',
                    'margin-right': '3%',
                    'margin-bottom': '3%',
                    //'padding-bottom': '2%',
                    top: ''
                }).css('border-radius', '3.5px');
                break;
        }

        menu.append(buttondiv);

        TAG.Util.makeManipulatable(buttondiv[0], {
            onTapped: callback
        });

        return buttondiv;
    }
    that.addButton = addButton;

    //////////
    // UPDATES

    /**
     * Updates linked variable with new value in input
     * @param inputObj      Input to update
     */
    function updateInput(inputObj) {
        var command,
            oldValue = inputObj.accessCallback(),
            newValue = inputObj.input.val();
        // log clamping undo/redo
        function logHelper(disp, cinit, cnew) {
            var clamp_command = {
                execute: function () { disp.setTimes(cnew); },
                unexecute: function () {
                    console.log("init: " + cinit.inStart + ", new: " + cnew.inStart);
                    disp.setTimes(cinit);
                },
            };
            my.undoManager.logCommand(clamp_command);
            disp.has_been_clamped = false;
        }
        // if input is valid, push to callback
        if (isValidInput(newValue)) {
            // convert text to proper return format
            


            newValue = convertToUpdateFormat(newValue, inputObj.format);
            if (Math.abs(oldValue - newValue) > TAG.TourAuthoring.Constants.epsilon) {
                my.timeline.clamped_displays.length = 0;
                command = {
                    execute: function () {
                        inputObj.updateCallback(newValue);
                        inputObj.input.val(convertToString(inputObj.accessCallback(), inputObj.format));
                        my.update();
                    },
                    unexecute: function () {
                        inputObj.updateCallback(oldValue);
                        inputObj.input.val(convertToString(inputObj.accessCallback(), inputObj.format));
                        my.update();
                    }
                };
                command.execute();
                my.undoManager.logCommand(command);

                var num_clamped = my.timeline.clamped_displays.length;
                for (var i = 0; i < num_clamped; i++) {
                    var disp = my.timeline.clamped_displays[i];
                    logHelper(disp, disp.clamped_init, disp.clamped_new);
                }
                my.undoManager.combineLast(num_clamped + 1);
            }
        }

        // update val with new internal value
        inputObj.input.val(convertToString(inputObj.accessCallback(), inputObj.format));
    }

    /**
     * Resets inputs to match current state of associated variables
     */
    function resetInputs() {
        var i, inputObj;
        for (i = 0; i < inputObjects.length; i++) {
            inputObj = inputObjects[i];
            inputObj.input.val(convertToString(inputObj.accessCallback(), inputObj.format));
        }
    }

    /**
     * Updates position of menu and brings it on-screen
     * @param evt   Interaction event object
     */
    function updateMenuPos(evt) {
        var menuLeft, menuTop, arrowLeft, arrowTop, trackLim;

        menu.show();
        arrow.show();

        switch (menuType) {
            case TAG.TourAuthoring.MenuType.display:
            case TAG.TourAuthoring.MenuType.keyframe:
                menuLeft = my.track.offset().left + evt.position.x - (menu.width() / 2);
                arrowLeft = menuLeft + (menu.width() / 2) - (arrow.width() / 2);
                arrowTop = my.track.offset().top;
                menuTop = arrowTop - menu.height()-3; // 10 is top margin of menu

                menuLeft = Math.min(menuLeft, $(document).width() - menu.width());
                break;

            case TAG.TourAuthoring.MenuType.track:
                menuTop = my.track.offset().top + my.track.height() / 2 - menu.height() / 2;
                arrowTop = menuTop + menu.height() / 2 - arrow.height() / 2;
                menuTop = Math.min(menuTop, (trackBody.offset().top + trackBody.height()) / 2 + $(document).height() / 2 - menu.height());

                // keep left the same
                menuLeft = menu.offset().left;
                arrowLeft = arrow.offset().left;
                break;
        }

        menu.css({
            left: menuLeft + "px",
            top: menuTop + 'px'
        });
        arrow.css({
            left: arrowLeft + 'px',
            top: arrowTop + 'px'
        });
    }

    ////////
    // UTILS

    /**
     * Performs input validation
     * @param inputstr  string to check
     */
    function isValidInput(inputstr) {//works for both mm:ss and seconds input
        var i, letter,
            coloncounter = 0;

        if (!inputstr) {
            return false;
        }

        for (i = 0; i < inputstr.length; i) {//for each character in string
            letter = inputstr.charAt(i);
            if (letter === ':') {
                coloncounter++;
            }
            if (coloncounter > 1 || (isNaN(parseFloat(letter)) && letter != "." && letter != ':')) {//if too many colons, or any 
                return false;//if too many colons or any character invalid
            }
            i = i + 1;
        }
        return true;//no problems!!
    }

    /**
     * Converts string to number according to input format type
     * @param valuestr      new value in string form
     * @param format        MenuInputFormat value specifying input format
     */
    function convertToUpdateFormat(valuestr, format) {
        var min, sec;

        switch (format) {
            case TAG.TourAuthoring.MenuInputFormats.minSec:
                // 'min:sec': --> secs
                valuestr = valuestr.split(':');
                if (valuestr.length === 1) { // no min at all
                    return parseFloat(valuestr[0]);
                } else {
                    if (valuestr[0]) min = parseFloat(valuestr[0]);
                    else min = 0; // catch case where input is ':sec'
                    sec = parseFloat(valuestr[1]);
                    return sec + 60 * min;
                } break;

            case TAG.TourAuthoring.MenuInputFormats.sec:
                // 'secs' --> secs
            case TAG.TourAuthoring.MenuInputFormats.percent:
                // 'percent' --> percent
                return parseFloat(valuestr);
        }
    }

    /**
     * Converts value (typically from accessCallback) to string
     * to place in input HTML element
     * @param value     Value as number
     * @param format    MenuInputFormat type specifying format to parse number to
     */
    function convertToString(value, format) {
        var min, sec;
        switch (format) {
            case TAG.TourAuthoring.MenuInputFormats.minSec:
                // 'min:sec': --> secs
                min = Math.floor(value / 60);
                if (min < 10) min = '0' + min;

                sec = value % 60;
                sec = roundDecimals(sec);
                if (sec < 10) sec = '0' + sec;

                return min + ':' + sec;

            case TAG.TourAuthoring.MenuInputFormats.sec:
                // 'secs' --> secs
            case TAG.TourAuthoring.MenuInputFormats.percent:
                // 'percent' --> percent
                return roundDecimals(value) + '';
        }
    }

    /**
     * Round number to have only
     * TAG.TourAuthoring.Constants.menuDecimals decimal places
     * @param num       number to round
     */
    var power = Math.pow(10, TAG.TourAuthoring.Constants.menuDecimals);
    function roundDecimals(num) {
        return Math.round(num * power) / power;
    }

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.ImageTrack');

/**
 * Creates an Image track
 * @param spec              Specifications (see Track class for details);
 * @param spec.thumbnail
 * @param my                After superclass is called, will contain displays and keyframes arrays
 *              Don't pass in unless you are subclassing this
 */
TAG.TourAuthoring.ImageTrack = function (spec, my) {
    "use strict";

    // Call super-constructor
    spec.type = TAG.TourAuthoring.TrackType.image;
    my = my || {};
    var that = TAG.TourAuthoring.Track(spec, my);

    my.track.addClass('image');
    //my.svg.classed('image', true);

    // Artwork-specific functions

    // Keyframes

    // Export to RIN format

    // Associated Inks
    //TAG.TourAuthoring.InkablePart(that, my);

    return that;
};
;
TAG.Util.makeNamespace("TAG.TourAuthoring.InkAuthoring");

// Enum defining ink modes
TAG.TourAuthoring.InkMode = {
    shapes: 0, //shape manipulation
    draw: 1,
    erase: 2,
    text: 5,
};

TAG.TourAuthoring.InkCallers = {
    inkes: 1,
    componentcontrols: 2
};

/**
 * Back-end for ink authoring and editing. Instances are created in ComponentControls and InkES. In
 * ComponentControls, we need the ability to author and edit inks. In InkES, we need them to follow
 * artworks.
 * Uses the RaphaelJS library for svg manipulation.
 * @param canvId        the id of the div to which we'll assign the Raphael canvas.
 * @param html_elt      in the case that the div above is not in the dom yet, send in a variable for its html element.
 * @param calling_file  either 'inkes' or not; slightly different functionality is needed in different instances.
 * @param spec          if the calling file is ComponentControls, we make use of the undoManager etc, so just pass
 *                      in the spec variable from ComponentControls.
 */

TAG.TourAuthoring.InkAuthoring = function (canvId, html_elt, calling_file, spec) {
    "use strict";

    // set up the Raphael paper/canvas
    var that = {};
    var canvid = canvId;
    that.canvid = canvId;
    html_elt = (html_elt) ? html_elt : $("#" + canvid)[0];
    var domelement = $(html_elt);
    var textElt;
    var dataHolder = spec.dataHolder;

    var paper = new Raphael(html_elt, "100%", "100%");
    $("#" + canvid + " svg").css("position", "absolute");
    
    // brush variables
    var penColor = "#000000";
    var penOpacity = 1.0;
    var penWidth = 7;
    var eraserWidth = 5;
    var ml = []; //path M/L values (see svg path format)
    var xy = []; //path coordinates; each entry has an x and y property
    var pa = []; //path attributes
    var pathObjects = [];
    var currpaths = ""; //this will be the string representing all of our paths; to get the paths individually, split at 'M'
    


    // ellipse/rectangle variables
    var shapeStrokeColor = "#ffffff";
    var shapeStrokeOpacity = 0.7;
    var shapeStrokeWidth = 5;
    var shapeFillColor = "#000000";
    var shapeFillOpacity = 0;

    // block/isolate variables
    var marqueeFillColor = "#000000";
    var marqueeFillOpacity = 0.8;
    var trans_mode = 'isolate';
    var transCoords = [];
    var transLetters = [];
    var trans_currpath = "";
    var bounding_shapes = "";

    // text variables
    var fontFamily = "'Times New Roman', serif";
    var fontColor = "#ffffff";
    var fontSize = '12px';
    var fontOpacity = 1.0;
    var textboxid = "textbox";
    var outerdivid = "outerdiv";
    var lastText = "";
    var svgText;

    // misc variables
    var inktrack = null;
    calling_file = (calling_file === 'inkes') ? 'inkes' : 'componentcontrols';
    var marquees = []; // old marquees
    var click = false; // has the mouse been clicked?
    var datastring = "";
    var mode = TAG.TourAuthoring.InkMode.draw;
    var enabled = true; //attached ink tracks by default
    var initKeyframe = {};
    var artName = "";
    var EID = ""; // rin experience id (name of the ink track)
    var oldScale = 1;
    var firstTimeThrough = 2;
    
    // set up the coordinates for adjustViewBox
    var viewerElt;
    if (calling_file === 'inkes')
        viewerElt = ($("#rinplayer").length) ? $("#rinplayer") : $("#rinPlayer");
    else
        viewerElt = $("#rinContainer");
    var origPaperX = 0; // original coordinates of the paper (match with rinContainer)
    var origPaperY = 0;
    var origPaperW = viewerElt.width();
    var origPaperH = viewerElt.height();
    var origpx = 0; // original coordinates of the artwork
    var origpy = 0;
    var origpw = 0;
    var origph = 0;
    var lastpx = 0; // most recent coordinates of the artwork
    var lastpy = 0;
    var lastpw = 0;
    var lastph = 0;
    var lastcx = 0; // most recent coordinates of the "virtual canvas" which helps us place inks correctly
    var lastcy = 0; // the virtual canvas is where the Raphael canvas would be if it were moving with the artwork
    var lastcw = origPaperW;
    var lastch = origPaperH;
    var oldOpac = 0; // keeps track of whether an ink is on screen or not

    // componentControls-specific variables for creating an ink undo manager, getting keyframes
    var inkUndoManager;
    var playbackControls;
    var undoManager;
    var timeline;
    var timeManager;
    var viewer;
    var dataHolder;
    if (calling_file !== 'inkes') {
        playbackControls = spec.playbackControls;
        undoManager = spec.undoManager;
        timeline = spec.timeline;
        timeManager = spec.timeManager;
        viewer = spec.viewer;
        // set up the ink undo manager using existing undo/redo buttons
        inkUndoManager = new TAG.TourAuthoring.UndoManager();
        inkUndoManager.setInitialized(true);
        playbackControls.undoButton.off("click");
        playbackControls.redoButton.off("click");
        playbackControls.undoButton.on('click', function () {
            inkUndoManager.undo();
        });
        playbackControls.redoButton.on('click', function () {
            inkUndoManager.redo();
        });
    }
    
    
    // methods //

    /**
     * Sets ink params to defaults
     */
    function resetParams() {
        // brush variables
        penColor = "#000000";
        penOpacity = 1.0;
        penWidth = 7;
        eraserWidth = 5;

        // ellipse/rectangle variables
        shapeStrokeColor = "#ffffff";
        shapeStrokeOpacity = 0.7;
        shapeStrokeWidth = 5;
        shapeFillColor = "#000000";
        shapeFillOpacity = 0;

        // block/isolate variables
        marqueeFillColor = "#000000";
        marqueeFillOpacity = 0.8;
        trans_mode = 'isolate';

        // text variables
        fontFamily = "'Times New Roman', serif";
        fontColor = "#ffffff";
        fontSize = '12px';
        fontOpacity = 1.0;
    }
    that.resetParams = resetParams;

    /**
     * Helper function to parse and multiply dimensions.
     * @param rel_coord    the relative coordinate we want to convert to absolute coordinates
     * @param canv_dim     the relevant dimension of the canvas used for scaling
     * @return    the absolute coordinate
     */
    function abs_dims(rel_coord, canv_dim) {
        return parseFloat(rel_coord) * parseFloat(canv_dim);
    }
    that.abs_dims = abs_dims;

    /**
     * Takes an ellipse or rectangle and adds styling, drag events, drag handles to it.
     * @param elt     the svg element
     * @param others  styling to apply to elt
     */
    function add_attributes(elt, fillColor, fillOpacity, strokeColor, strokeOpacity, strokeWidth) {
        var origmousex;
        var origmousey;
        var origposition = { x: 0, y: 0, w: 0, h: 0 };
        var c1origposition = { x: 0, y: 0, w: 0, h: 0 };
        var c2origposition = { x: 0, y: 0, w: 0, h: 0 };
        var dcorigposition = { x: 0, y: 0, w: 0, h: 0 };
        var eltbbox, c1bbox, c2bbox, dcbbox;
        var beenMoved;

        // if attributes are not passed in, use global variables
        if (fillColor === undefined)
            fillColor = shapeFillColor;
        if (fillOpacity === undefined)
            fillOpacity = shapeFillOpacity;
        if (strokeColor === undefined)
            strokeColor = shapeStrokeColor;
        if (strokeOpacity === undefined)
            strokeOpacity = shapeStrokeOpacity;
        if (strokeWidth === undefined)
            strokeWidth = shapeStrokeWidth;

        elt.attr({ // add color attributes
            "stroke-width": strokeWidth,
            "stroke": strokeColor,
            "stroke-opacity": strokeOpacity,
            "fill": fillColor,
            "fill-opacity": fillOpacity,
            "stroke-dasharray": "-",
        });

        var C1, C2; // drag handles
        var DC; // deletion circle
        var rds = TAG.TourAuthoring.Constants.inkDragHandleRadius;

        if (elt.data("type") == "ellipse") {
            var rx = elt.data("curr_rx");
            var ry = elt.data("curr_ry");
            var cx = elt.data("currx") + rx;
            var cy = elt.data("curry") + ry;
            var x0 = rx / Math.sqrt(2.0); // fix where the top left drag handle should be in proportion to the radius
            var y0 = ry * Math.sqrt(1 - x0 * x0 / (rx * rx)); // (if ellipse is a circle, handle will be on the line between center and top left corner of bounding box)
            C1 = paper.ellipse(cx - x0 - strokeWidth/2, cy+strokeWidth / 2 - y0, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#ffffff", "fill": "#296B2F", "fill-opacity": 0.9 }).data("type", "grabHandle");
            C2 = paper.ellipse(cx + x0 + strokeWidth / 2, cy + y0 + strokeWidth / 2, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#296B2F", "fill": "#ffffff", "fill-opacity": 0.9 }).data("type", "grabHandle");
            DC = paper.ellipse(cx + x0 + strokeWidth / 2, cy + strokeWidth / 2 - y0, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#ffffff", "fill": "#880000", "fill-opacity": 0.9 }).data("type", "grabHandle");
        }
        else if (elt.data("type") == "rect") {
            var x = elt.data("currx");
            var y = elt.data("curry");
            var w = elt.data("currw");
            var h = elt.data("currh");
            C1 = paper.ellipse(x, y, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#ffffff", "fill": "#296B2F", "fill-opacity": 0.9 }).data("type", "grabHandle");
            C2 = paper.ellipse(x + w, y + h, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#296B2F", "fill": "#ffffff", "fill-opacity": 0.9 }).data("type", "grabHandle");
            DC = paper.ellipse(x + w, y, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#ffffff", "fill": "#880000", "fill-opacity": 0.9 }).data("type", "grabHandle");
        }
        C1.data("curr_cx", C1.attr("cx"));
        C1.data("curr_cy", C1.attr("cy"));
        C2.data("curr_cx", C2.attr("cx"));
        C2.data("curr_cy", C2.attr("cy"));
        DC.data("curr_cx", DC.attr("cx"));
        DC.data("curr_cy", DC.attr("cy"));

        //log in the undo manager; show and hide elements
        var command = TAG.TourAuthoring.Command({
            execute: function () {
                elt.show();
                C1.show();
                C2.show();
                DC.show();
                elt.data("visible", "yes");
            },
            unexecute: function () {
                elt.hide();
                C1.hide();
                C2.hide();
                DC.hide();
                elt.data("visible", "no");
            }
        });
        command.execute();
        inkUndoManager.logCommand(command);

        // define drag functionality for the panning handle (upper-left)
        C1.drag(function (dx, dy, mousex, mousey) { // move
            beenMoved = true;
            elt.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();
            var halfWid = (origposition.w + strokeWidth) / 2;
            var halfHei = (origposition.h + strokeWidth) / 2;

            var circleRadius = C1.attr("rx");
            //Hard stops for textbox location in ink canvas
            if (c2origposition.x + strokeWidth + circleRadius + dx <= halfWid) {
                dx = halfWid - c2origposition.x - circleRadius;
            }
            if (c2origposition.y + circleRadius +strokeWidth + dy <= halfHei) {
                dy = halfWid - c2origposition.y - circleRadius;
            }
            if (c1origposition.x + circleRadius + dx + halfWid >= canvwidth) {
                dx = canvwidth - halfWid - c1origposition.x - circleRadius;
            }
            if (c1origposition.y + circleRadius + dy + halfHei >= canvheight) {
                dy = canvheight - c1origposition.y - circleRadius - halfHei;
            }

            var c1currx = parseInt(C1.data("curr_cx"), 10);//x position at the start of drag
            var c1curry = parseInt(C1.data("curr_cy"), 10);
            var xpos = c1currx + dx; // to get new x position, just add dx
            var ypos = c1curry + dy;
            C1.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var c2currx = parseInt(C2.data("curr_cx"), 10);// x position at the start of drag
            var c2curry = parseInt(C2.data("curr_cy"), 10);
            xpos = c2currx + dx; // to get new x position, just add dx
            ypos = c2curry + dy;
            C2.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var dccurrx = parseInt(DC.data("curr_cx"), 10);
            var dccurry = parseInt(DC.data("curr_cy"), 10);
            xpos = dccurrx + dx;
            ypos = dccurry + dy;
            DC.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            var eltcurrx, eltcurry;
            if (elt.data("type") === "ellipse") {
                eltcurrx = parseInt(elt.data("currx"),10) + elt.attr("rx");// x position at the start of drag
                eltcurry = parseInt(elt.data("curry"),10) + elt.attr("ry");
            }
            else if (elt.data("type") === "rect") {
                eltcurrx = parseInt(elt.data("currx"),10);
                eltcurry = parseInt(elt.data("curry"),10);
            }
            xpos = eltcurrx + dx; // to get new x position, just add dx
            ypos = eltcurry + dy;
            elt.attr({
                x: xpos,
                y: ypos,
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });
        },
        function (x, y) { // start; record original positions
            beenMoved = false;
            eltbbox = elt.getBBox();
            origposition.x = eltbbox.x;
            origposition.y = eltbbox.y;
            origposition.w = eltbbox.width;
            origposition.h = eltbbox.height;

            c1bbox = C1.getBBox();
            c1origposition.x = c1bbox.x;
            c1origposition.y = c1bbox.y;
            c1origposition.w = c1bbox.width;
            c1origposition.h = c1bbox.height;

            c2bbox = C2.getBBox();
            c2origposition.x = c2bbox.x;
            c2origposition.y = c2bbox.y;
            c2origposition.w = c2bbox.width;
            c2origposition.h = c2bbox.height;

            dcbbox = DC.getBBox();
            dcorigposition.x = dcbbox.x;
            dcorigposition.y = dcbbox.y;
            dcorigposition.w = dcbbox.width;
            dcorigposition.h = dcbbox.height;
        },
        function (x, y) { // stop; log in undomanager and set data of element
            if (!beenMoved) {
                return;
            }
            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;
            this.data("curr_cx", c1bboxx + c1bboxw / 2.0); //reset data using bounding box coords
            this.data("curr_cy", c1bboxy + c1bboxh / 2.0);

            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data("curr_cx", c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;
            DC.data("curr_cx", dcbboxx + dcbboxw / 2.0); //reset data using bounding box coords
            DC.data("curr_cy", dcbboxy + dcbboxh / 2.0);

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            if (elt.data("type") == "ellipse") {
                elt.data("currx", elt.attr("cx") - elt.attr("rx"));
                elt.data("curry", elt.attr("cy") - elt.attr("ry"));
                elt.data("curr_rx", elt.attr("rx"));
                elt.data("curr_ry", elt.attr("ry"));
            }
            else if (elt.data("type") == "rect") {
                elt.data("currx", elt.attr("x"));
                elt.data("curry", elt.attr("y"));
            }

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            var command = TAG.TourAuthoring.Command({
                execute: function () {
                    //console.log("bbox in execute: {" + bboxx + "," + bboxy + "," + bboxw + "," + bboxh + "}");
                    elt.data("currx", bboxx);
                    elt.data("curry", bboxy);
                    elt.data("currw", bboxw);
                    elt.data("currh", bboxh);
                    elt.data("curr_rx", bboxw / 2.0);
                    elt.data("curr_ry", bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data("curr_cx", c1bboxx + c1bboxw / 2.0);
                    C1.data("curr_cy", c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data("curr_cx", c2bboxx + c2bboxw / 2.0);
                    C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data("curr_cx", dcbboxx + dcbboxw / 2.0);
                    DC.data("curr_cy", dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log("origposition in unexecute: {" + ox + "," + oy + "," + ow + "," + oh + "}");
                    elt.data("currx", ox);
                    elt.data("curry", oy);
                    elt.data("currw", ow);
                    elt.data("currh", oh);
                    elt.data("curr_rx", ow / 2.0);
                    elt.data("curr_ry", oh / 2.0);
                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data("curr_cx", o1x + o1w / 2.0);
                    C1.data("curr_cy", o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data("curr_cx", o2x + o2w / 2.0);
                    C2.data("curr_cy", o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data("curr_cx", odcx + odcw / 2.0);
                    DC.data("curr_cy", odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        // define drag functionality for the resizing handle (lower-right);
        // when we resize, keep the panning handle where it is, have the resizing handle follow the mouse,
        // set the shape to be whatever it needs to be to satisfy those constraints
        C2.drag(function (dx, dy, mousex, mousey) {
            beenMoved = true;
            elt.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();

            var currx = parseInt(C2.data("curr_cx"),10);//x position at the start of drag
            var curry = parseInt(C2.data("curr_cy"),10);
            var xpos = currx + dx; //to get new x position, just add dx
            var ypos = curry + dy;
            var x0 = C1.attr("cx");
            var y0 = C1.attr("cy");
            var handlerad = TAG.TourAuthoring.Constants.inkDragHandleRadius;

            if (xpos - x0 > 2 * handlerad) {
                C2.attr({ cx: xpos });
                DC.attr({ cx: xpos });
            }
            if (ypos - y0 > 2 * handlerad) {
                C2.attr({ cy: ypos });
            }

            var x1 = this.attr("cx");
            var y1 = this.attr("cy");

            var oldrx = elt.attr("rx");
            var CX = x0 + (x1 - x0) / 2.0;
            var CY = y0 + (y1 - y0) / 2.0;
            var RADx = (x1 - x0) / 2.0 * Math.sqrt(2);
            elt.attr({
                cx: CX,
                cy: CY,
                rx: RADx,
                ry: RADx * Math.sqrt((-(y1 - CY) * (y1 - CY)) / ((x1 - CX) * (x1 - CX) - (RADx) * (RADx))),
                width: x1 - x0,
                height: y1 - y0,
            });
        },
        function (x, y) { //start
            beenMoved = false;
            var bbox = elt.getBBox();
            origposition.x = bbox.x;
            origposition.y = bbox.y;
            origposition.w = bbox.width;
            origposition.h = bbox.height;

            bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;

            bbox = C2.getBBox();
            c2origposition.x = bbox.x;
            c2origposition.y = bbox.y;
            c2origposition.w = bbox.width;
            c2origposition.h = bbox.height;

            bbox = DC.getBBox();
            dcorigposition.x = bbox.x;
            dcorigposition.y = bbox.y;
            dcorigposition.w = bbox.width;
            dcorigposition.h = bbox.height;
        },
        function (x, y) { //stop
            if (!beenMoved) {
                return;
            }
            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data("curr_cx", c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);
            if (elt.data("type") === "ellipse") {
                elt.data("currx", elt.attr("cx") - elt.attr("rx"));
                elt.data("curry", elt.attr("cy") - elt.attr("ry"));
                elt.data("curr_rx", elt.attr("rx"));
                elt.data("curr_ry", elt.attr("ry"));
            }
            else if (elt.data("type") === "rect") {
                elt.data("currx", elt.attr("x"));
                elt.data("curry", elt.attr("y"));
                elt.data("currw", elt.attr("width"));
                elt.data("currh", elt.attr("height"));
            }

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            // log command
            var command = TAG.TourAuthoring.Command({
                execute: function () {
                    //console.log("bbox in execute: {" + bboxx + "," + bboxy + "," + bboxw + "," + bboxh + "}");
                    elt.data("currx", bboxx);
                    elt.data("curry", bboxy);
                    elt.data("currw", bboxw);
                    elt.data("currh", bboxh);
                    elt.data("curr_rx", bboxw / 2.0);
                    elt.data("curr_ry", bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data("curr_cx", c1bboxx + c1bboxw / 2.0);
                    C1.data("curr_cy", c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data("curr_cx", c2bboxx + c2bboxw / 2.0);
                    C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data("curr_cx", dcbboxx + dcbboxw / 2.0);
                    DC.data("curr_cy", dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log("origposition in unexecute: {" + ox + "," + oy + "," + ow + "," + oh + "}");
                    elt.data("currx", ox);
                    elt.data("curry", oy);
                    elt.data("currw", ow);
                    elt.data("currh", oh);
                    elt.data("curr_rx", ow / 2.0);
                    elt.data("curr_ry", oh / 2.0);
                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data("curr_cx", o1x + o1w / 2.0);
                    C1.data("curr_cy", o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data("curr_cx", o2x + o2w / 2.0);
                    C2.data("curr_cy", o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data("curr_cx", odcx + odcw / 2.0);
                    DC.data("curr_cy", odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        //define drag functionality for the shape itself (panning)
        elt.drag(function (dx, dy, mousex, mousey) { // move
            beenMoved = true;
            this.toFront();
            C1.toFront();
            C2.toFront();
            DC.toFront();
            var halfWid = (origposition.w + strokeWidth) / 2;
            var halfHei = (origposition.h + strokeWidth) / 2;
            var circleRadius = C1.attr("rx");
            if (c2origposition.x + strokeWidth + circleRadius + dx <= halfWid) {
                dx = halfWid - c2origposition.x - circleRadius;
            }
            if (c2origposition.y + circleRadius + strokeWidth + dy <= halfHei) {
                dy = halfWid - c2origposition.y - circleRadius;
            }
            if (c1origposition.x + circleRadius + dx + halfWid >= canvwidth) {
                dx = canvwidth - halfWid - c1origposition.x - circleRadius;
            }
            if (c1origposition.y + circleRadius + dy + halfHei >= canvheight) {
                dy = canvheight - c1origposition.y - circleRadius - halfHei;
            }

            var c1currx = parseInt(C1.data("curr_cx"),10);
            var c1curry = parseInt(C1.data("curr_cy"),10);
            var xpos = c1currx + dx;
            var ypos = c1curry + dy;
            C1.attr({
                cx: xpos,
                cy: ypos,
            });

            var c2currx = parseInt(C2.data("curr_cx"),10);
            var c2curry = parseInt(C2.data("curr_cy"),10);
            xpos = c2currx + dx;
            ypos = c2curry + dy;
            C2.attr({
                cx: xpos,
                cy: ypos,
            });

            var dccurrx = parseInt(DC.data("curr_cx"), 10);
            var dccurry = parseInt(DC.data("curr_cy"), 10);
            xpos = dccurrx + dx;
            ypos = dccurry + dy;
            DC.attr({
                cx: xpos,
                cy: ypos,
            });

            var eltcurrx, eltcurry;
            if (elt.data("type") == "ellipse") {
                eltcurrx = parseInt(this.data("currx"),10) + this.attr("rx");
                eltcurry = parseInt(this.data("curry"),10) + this.attr("ry");
            }
            else if (elt.data("type") == "rect") {
                eltcurrx = parseInt(this.data("currx"),10);
                eltcurry = parseInt(this.data("curry"),10);
            }
            xpos = eltcurrx + dx;
            ypos = eltcurry + dy;
            this.attr({
                x: xpos,
                y: ypos,
                cx: xpos,
                cy: ypos,
            });
        },
        function (x, y) { // start
            beenMoved = false;
            var bbox = elt.getBBox();
            origposition.x = bbox.x;
            origposition.y = bbox.y;
            origposition.w = bbox.width;
            origposition.h = bbox.height;

            bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;

            bbox = C2.getBBox();
            c2origposition.x = bbox.x;
            c2origposition.y = bbox.y;
            c2origposition.w = bbox.width;
            c2origposition.h = bbox.height;

            bbox = DC.getBBox();
            dcorigposition.x = bbox.x;
            dcorigposition.y = bbox.y;
            dcorigposition.w = bbox.width;
            dcorigposition.h = bbox.height;
        },
        function (x, y) { //stop
            if (!beenMoved) {
                return;
            }
            var c1bboxx = C1.getBBox().x;
            var c1bboxy = C1.getBBox().y;
            var c1bboxw = C1.getBBox().width;
            var c1bboxh = C1.getBBox().height;
            C1.data("curr_cx", c1bboxx + c1bboxw / 2.0); //reset data using bounding box coords
            C1.data("curr_cy", c1bboxy + c1bboxh / 2.0);

            var c2bboxx = C2.getBBox().x;
            var c2bboxy = C2.getBBox().y;
            var c2bboxw = C2.getBBox().width;
            var c2bboxh = C2.getBBox().height;
            C2.data("curr_cx", c2bboxx + c2bboxw / 2.0); //reset data using bounding box coords
            C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);

            if (elt.data("type") == "ellipse") {
                elt.data("currx", elt.attr("cx") - elt.attr("rx"));
                elt.data("curry", elt.attr("cy") - elt.attr("ry"));
                elt.data("curr_rx", elt.attr("rx"));
                elt.data("curr_ry", elt.attr("ry"));
            }
            else if (elt.data("type") == "rect") {
                elt.data("currx", elt.attr("x"));
                elt.data("curry", elt.attr("y"));
            }

            var bboxx = elt.getBBox().x;
            var bboxy = elt.getBBox().y;
            var bboxw = elt.getBBox().width;
            var bboxh = elt.getBBox().height;

            var dcbboxx = DC.getBBox().x;
            var dcbboxy = DC.getBBox().y;
            var dcbboxw = DC.getBBox().width;
            var dcbboxh = DC.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var o2x = c2origposition.x;
            var o2y = c2origposition.y;
            var o2w = c2origposition.w;
            var o2h = c2origposition.h;

            var odcx = dcorigposition.x;
            var odcy = dcorigposition.y;
            var odcw = dcorigposition.w;
            var odch = dcorigposition.h;

            // log command
            var command = TAG.TourAuthoring.Command({
                execute: function () {
                    //console.log("bbox in execute: {" + bboxx + "," + bboxy + "," + bboxw + "," + bboxh + "}");
                    elt.data("currx", bboxx);
                    elt.data("curry", bboxy);
                    elt.data("currw", bboxw);
                    elt.data("currh", bboxh);
                    elt.data("curr_rx", bboxw / 2.0);
                    elt.data("curr_ry", bboxh / 2.0);
                    elt.attr({
                        cx: bboxx + bboxw / 2.0,
                        cy: bboxy + bboxh / 2.0,
                        rx: bboxw / 2.0,
                        ry: bboxh / 2.0,
                        x: bboxx,
                        y: bboxy,
                        width: bboxw,
                        height: bboxh,
                    });

                    C1.data("curr_cx", c1bboxx + c1bboxw / 2.0);
                    C1.data("curr_cy", c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                    C2.data("curr_cx", c2bboxx + c2bboxw / 2.0);
                    C2.data("curr_cy", c2bboxy + c2bboxh / 2.0);
                    C2.attr({
                        cx: c2bboxx + c2bboxw / 2.0,
                        cy: c2bboxy + c2bboxh / 2.0,
                        rx: c2bboxw / 2.0,
                        ry: c2bboxh / 2.0,
                    });
                    DC.data("curr_cx", dcbboxx + dcbboxw / 2.0);
                    DC.data("curr_cy", dcbboxy + dcbboxh / 2.0);
                    DC.attr({
                        cx: dcbboxx + dcbboxw / 2.0,
                        cy: dcbboxy + dcbboxh / 2.0,
                        rx: dcbboxw / 2.0,
                        ry: dcbboxh / 2.0,
                    });
                },
                unexecute: function () {
                    //console.log("origposition in unexecute: {" + ox + "," + oy + "," + ow + "," + oh + "}");
                    elt.data("currx", ox);
                    elt.data("curry", oy);
                    elt.data("currw", ow);
                    elt.data("currh", oh);
                    elt.data("curr_rx", ow / 2.0);
                    elt.data("curr_ry", oh / 2.0);

                    elt.attr({
                        cx: ox + ow / 2.0,
                        cy: oy + oh / 2.0,
                        rx: ow / 2.0,
                        ry: oh / 2.0,
                        x: ox,
                        y: oy,
                        width: ow,
                        height: oh,
                    });

                    C1.data("curr_cx", o1x + o1w / 2.0);
                    C1.data("curr_cy", o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });

                    C2.data("curr_cx", o2x + o2w / 2.0);
                    C2.data("curr_cy", o2y + o2h / 2.0);
                    C2.attr({
                        cx: o2x + o2w / 2.0,
                        cy: o2y + o2h / 2.0,
                    });

                    DC.data("curr_cx", odcx + odcw / 2.0);
                    DC.data("curr_cy", odcy + odch / 2.0);
                    DC.attr({
                        cx: odcx + odcw / 2.0,
                        cy: odcy + odch / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });

        //shape deletion functionality
        DC.mousedown(function () {
            var dccommand = TAG.TourAuthoring.Command({
                execute: function () {
                    elt.hide();
                    C1.hide();
                    C2.hide();
                    DC.hide();
                    elt.data("visible", "no");
                },
                unexecute: function () {
                    elt.show();
                    C1.show();
                    C2.show();
                    DC.show();
                    elt.data("visible", "yes");
                }
            });
            dccommand.execute();
            inkUndoManager.logCommand(dccommand);
        });
    }
    that.add_attributes = add_attributes;
    ///

    function getInkUndoManager() {
        return inkUndoManager;
    }
    that.getInkUndoManager = getInkUndoManager;

    ///

    /**
     * Add an ellipse to the Raphael canvas. Called by the "Add Ellipse" button in isolate/block ink mode
     * @param cx, cy    the coordinates of the center of the ellipse
     * @param rx, ry    the radii of the ellipse
     */
    function add_ellipse(cx, cy, rx, ry) {
        var ellipse;
        set_mode(TAG.TourAuthoring.InkMode.shapes);
        //console.log("setting cx and cy for the ellipse");
        if (cx === undefined)
            cx = 100 + Math.random() * 10;
        if (cy === undefined)
            cy = 100 + Math.random() * 10;
        if (rx === undefined)
            rx = 50;
        if (ry === undefined)
            ry = 50;
        ellipse = paper.ellipse(cx, cy, rx, ry); // draw to the canvas
        ellipse.data("currx", ellipse.getBBox().x); // add data to be used by add_attributes
        ellipse.data("curry", ellipse.getBBox().y);
        ellipse.data("curr_rx", rx);
        ellipse.data("curr_ry", ry);
        ellipse.data("type", "ellipse");
        add_attributes(ellipse);
    }
    that.add_ellipse = add_ellipse;

    /**
     * DEPRECATED
     * Used to give style and drag functionality to old marquees (such as is currently in the Final
     * Garibaldi Demo). Once all old marquees have been deleted from tours, this method can be tossed.
     */
    function add_marq_attributes(marq, marqFillColor, marqFillOpacity) {
        /**
            * analogous to add_attributes(...), but for marquees. The difference is that a marquee
            * is a collection of five rectangles, and the center rectangle is the only one that gets
            * the drag handler, while the others have the color attributes.
            */
        var elt = marq.rc;
        var gl;
        var resize = 0; //if 1, we are in zoom mode rather than pan mode
        var noglow = 0; //if 1, glowing is disabled
        var origmousex;
        var origmousey;
        var w = domelement.width();
        var h = domelement.height();
        //console.log("w=" + w + ", h=" + h);
        if (marqFillColor === undefined)
            marqFillColor = marqueeFillColor;////////FIX "#" + document.getElementById("marq_color").value;
        if (marqFillOpacity === undefined)
            marqFillOpacity = marqueeFillOpacity;/////FIX document.getElementById("marq_opacity").value;

        elt.mouseover(function () {
            if (!noglow && (mode == 3)) {
                gl = elt.glow({ "width": 10, "color": "#33ff00", "opacity": 0.8 });
            }
        });
        elt.mouseout(function () {
            if (mode == 3)
                gl.remove();
        });
        elt.attr({
            "stroke-width": 0,
            "stroke": "#222222",
            "fill": "#ffffff",
            "fill-opacity": 0
        });
        elt.data("surr-fill", marqFillColor);
        elt.data("surr-opac", marqFillOpacity);
        var mset = paper.set();
        mset.push(marq.rn, marq.re, marq.rs, marq.rw);
        mset.attr({
            "stroke-width": 0,
            "stroke": "#222222",
            "fill": marqFillColor,
            "fill-opacity": marqFillOpacity
        });

        //drag(move, start, stop,...)
        elt.drag(function (dx, dy, mousex, mousey) {
            //onmove
            if (mode == 3) {
                this.toFront();
                var bbox = this.getBBox();
                if (!resize) {
                    //drag an marquee -- need to update all relevant rectangles
                    var currx = parseInt(this.data("currx"),10);//x position at the start of drag
                    var curry = parseInt(this.data("curry"),10);
                    var xpos = currx + dx; //to get new x position, just add dx
                    var ypos = curry + dy;
                    this.attr({
                        x: xpos,
                        y: ypos
                    });
                    marq.rn.attr({
                        height: ypos
                    });
                    marq.re.attr({
                        x: xpos + bbox.width,
                        y: ypos,
                        width: w - (xpos + bbox.width),
                        height: bbox.height
                    });
                    marq.rs.attr({
                        y: ypos + bbox.height,
                        height: h - (ypos + bbox.height)
                    });
                    marq.rw.attr({
                        y: ypos,
                        width: xpos,
                        height: bbox.height
                    });

                }
                else {
                    //resize a marquee -- need to update all relevant rectangles
                    this.attr({
                        width: bbox.width + mousex - origmousex,
                        height: bbox.height + mousey - origmousey
                    });
                    marq.rs.attr({
                        y: bbox.y + bbox.height + mousey - origmousey,
                        height: h - (bbox.y + bbox.height + mousey - origmousey)
                    });
                    marq.re.attr({
                        x: bbox.x + bbox.width + mousex - origmousex,
                        width: w - (bbox.x + bbox.width + mousex - origmousex),
                        height: bbox.height + mousey - origmousey
                    });
                    marq.rw.attr({
                        height: bbox.height + mousey - origmousey
                    });
                }
                //console.log("this.attr.x = " + this.attr("x") + ", y = " + this.attr("y"));
                //console.log(update_datastring());
                origmousex = mousex;
                origmousey = mousey;
            }
        }, function (x, y) {
            //onstart
            if (mode == 3) {
                origmousex = x;
                origmousey = y;
                var bbox = this.getBBox();
                //console.log("diff = " + (x - bbox.x));
                var offset_x = parseFloat(domelement.css("left"));
                var offset_y = parseFloat(domelement.css("top"));
                if ((arguments[2].offsetX > (bbox.x + bbox.width * 0.5)) && (arguments[2].offsetY > (bbox.y + bbox.height * 0.5))) {
                    resize = 1;
                }
                gl.remove();
                noglow = 1;
                this.animate({ opacity: 0.25 }, 500, "<>");
            }
        }, function () {
            //onstop
            if (mode == 3) {
                this.data("currx", this.getBBox().x); //reset data using bounding box coords
                this.data("curry", this.getBBox().y);
                marq.re.data("currx", this.getBBox().x + this.getBBox().width);
                marq.rs.data("curry", this.getBBox().y + this.getBBox().height);
                resize = 0;
                this.animate({ opacity: 1 }, 500, "<>");
                noglow = 0;
            }
        });
    }
    that.add_marq_attributes = add_marq_attributes;

    /**
     * Add a rectangle to the Raphael canvas. Called by the "Add Rectangle" button in isolate/block ink mode
     * @param x, y    the coordinates of the top left corner of the rectangle
     */
    function add_rectangle(x, y) {
        var rect;
        set_mode(TAG.TourAuthoring.InkMode.shapes);
        if (x === undefined)
            x = 200 + Math.random() * 10;
        if (y === undefined)
            y = 200 + Math.random() * 10;
        rect = paper.rect(x, y, 100, 100); // draw to the Raphael canvas
        rect.data("currx", x); // set data to be used by add_attributes
        rect.data("curry", y);
        rect.data("currw", 100);
        rect.data("currh", 100);
        rect.data("type", "rect");
        add_attributes(rect);
    }
    that.add_rectangle = add_rectangle;

    
    function getSVGText(){
        return svgText;
    }
    that.getSVGText = getSVGText;

    /** ((DAN Z))
     * Add a text box (a textarea html element) for creating text inks.
     * @param x, y     coordinates of the text box (absolute)
     * @param str      any text that should be loaded into the text box (i.e. for editing inks)
     */
    function add_text_box(x, y, w, h, str, textmag, size) {
        x = x || 75;
        y = y || 75;
        str = str || "Your text here";

        svgText = paper.text(x, y, str);
        svgText.data({
            type: "text",
            str: str,
        });
        svgText.attr({
            'alignment-baseline': 'before-edge',
            "text-anchor": "start",
        });
        set_mode(TAG.TourAuthoring.InkMode.text);

        //// style the textbox
        //textbox.attr('wrap', 'off'); //force people to do their own line breaks
        svgText.attr({
            'font-family': fontFamily,
            'font-size': fontSize,
            'fill': fontColor,
        });
        svgText.attr("text", str);
        svgText.data({
            'font': fontFamily,
            'fontsize': fontSize,
            'color': fontColor,
        });
        if (textmag) {
            var newFontSize;
            if (size) {
                newFontSize = size;
            } else {
                newFontSize = rel_dims(svgText.data("fontsize"), domelement.height()) * domelement.height();
            }
            svgText.attr({
                'font-size': newFontSize,
            });
            svgText.data({
                'fontsize': newFontSize,
            });
        }
        setTextAttributes(svgText);

        //// set up undo/redo commands for typing
        //textbox.on("keyup", function (evt) { //use onpropertychange
        //    var code = evt.keyCode;
        //    if (code != 37 && code != 38 && code != 39 && code != 40) { // exclude arrow keys
        //        var currText = $("#" + textboxid).attr('value');
        //        var oldText = lastText;
        //        var command = TAG.TourAuthoring.Command({
        //            execute: function () {
        //                $("#" + textboxid).attr('value', currText);
        //            },
        //            unexecute: function () {
        //                $("#" + textboxid).attr('value', oldText);
        //            }
        //        });
        //        inkUndoManager.logCommand(command);
        //        lastText = $("#" + textboxid).attr("value");
        //    }
        //});

        //setTextAttributes($("#" + textboxid)); // set up drag functionality and drag handlers

        //textbox.scrollTop(0);
        //textbox.scrollLeft(0);
    }
    that.add_text_box = add_text_box;

    /** ((BEN L))
     * Pans and resizes all inks to move with the artwork. Uses the initial keyframe of the artwork (converted here to absolute coordinates) and the
     * inputted dimensions to compute deltas and scale factors. Once we have these, first pan to (0,0), then scale, then pan to pos+deltas.
     * @param dims   the current dimensions of our artwork in absolute coordinates
     */
    function adjustViewBox (dims, no_opac_check) {
        var new_px = dims.x,
            new_py = dims.y,
            new_pw = dims.width,
            new_ph = dims.height,
            real_kfw, real_kfh, real_kfx, real_kfy;
        // convert weird deeepzoom keyframe coordinates to absolute coordinates
        real_kfw = origPaperW / initKeyframe.w; // deepzoom keyframe width is what we multiply the absolute width of art by to get width of viewer
        real_kfh = real_kfw * (new_ph / new_pw); // deepzoom keyframe height is kind of confusing, so use width * (1 / aspect_ratio of art)
        real_kfx = -initKeyframe.x * real_kfw; // deepzoom keyframe x times absolute width of art is what we must translate art by to reach the left of viewer
        real_kfy = -initKeyframe.y * real_kfw; // (WEIRD -- seems to place too high if use -kfy * real_kfh)
        
        // if the new position is not trivially different from the old position, pan and zoom
        if (nontrivial({ x: new_px, y: new_py, w: new_pw, h: new_ph }, { x: lastpx, y: lastpy, w: lastpw, h: lastph })) {
            //var eid_elt = $("[ES_ID='" + EID + "']");
            var lambda_w = origPaperW / real_kfw;
            var lambda_h = origPaperH / real_kfh;
            var nvw = new_pw * lambda_w; // nv*: dimensions of the new virtual canvas (where the ink canvas would be if we were panning and zooming it with the artwork)
            var nvh = new_ph * lambda_h;
            var nvx = (nvw / origPaperW) * (origPaperX - real_kfx) + new_px;
            var nvy = (nvh / origPaperH) * (origPaperY - real_kfy) + new_py;

            var SW = nvw / lastcw; // scale factor in x direction
            // var SH = nvh / lastch; // scale factor in y direction (in case we ever have non-aspect-ratio-preserving scaling)

            oldScale = new_pw / origpw;
            // oldScaleH = new_ph / origph; // in case we ever have non-aspect-ratio-preserving scaling

            if (!transCoords.length || trans_mode === 'block') { // for all ink types except isolates (can't just resize the window for them)
                var newwid = origPaperW / oldScale;
                var newhei = origPaperH / oldScale;
                paper.setViewBox(-nvx / oldScale, -nvy / oldScale, newwid, newhei); // see raphael documentation
            }
            else {
                var cw = domelement.width();
                var ch = domelement.height();
                magX = cw;
                magY = ch;
                panObjects(-lastcx / origPaperW, -lastcy / origPaperH, { cw: cw, ch: ch }, 0); // no need to draw updated ink yet
                resizeObjects(SW, SW); // still no need, since we still have to pan
                panObjects(nvx / origPaperW, nvy / origPaperH, { cw: cw, ch: ch }, 1);
            }

            // reset coordinates
            lastcx = nvx;
            lastcy = nvy;
            lastcw = nvw;
            lastch = nvh;
            lastpx = new_px;
            lastpy = new_py;
            lastpw = new_pw;
            lastph = new_ph;
        }
    }
    that.adjustViewBox = adjustViewBox;

    /** ((BEN L))
     * Pans and resizes the ink canvas to move with the artwork. Uses the initial keyframe of the artwork (converted here to absolute coordinates) and the
     * inputted dimensions to compute deltas and scale factors. Once we have these, first pan to (0,0), then scale, then pan to pos+deltas.
     * @param dims   the current dimensions of our artwork in absolute coordinates
     */
    function adjustViewBoxDiv(dims, no_opac_check) {
        var new_px = dims.x,
            new_py = dims.y,
            new_pw = dims.width,
            new_ph = dims.height,
            real_kfw, real_kfh, real_kfx, real_kfy;
        try {
            // convert weird deeepzoom keyframe coordinates to absolute coordinates
            real_kfw = origPaperW / initKeyframe.w; // deepzoom keyframe width is what we multiply the absolute width of art by to get width of viewer
            real_kfh = real_kfw * (new_ph / new_pw); // deepzoom keyframe height is kind of confusing, so use width * (1 / aspect_ratio of art)
            real_kfx = -initKeyframe.x * real_kfw; // deepzoom keyframe x times absolute width of art is what we must translate art by to reach the left of viewer
            real_kfy = -initKeyframe.y * real_kfw; // (WEIRD -- seems to place too high if use -kfy * real_kfh)
        }
        catch (err) {
            console.log("ERROR in adjustViewBox: " + err);
            real_kfx = origpx;
            real_kfy = origpy;
            real_kfw = origpw;
            real_kfh = origph;
        }

        // oldOpac tracks when the ink is actually on screen (the opacity of the ink track is 0 when the playhead is not in a display)
        if (oldOpac === 0) {
            self.origpx = new_px;
            self.origpy = new_py;
            self.origpw = new_pw;
            self.origph = new_ph;
        }

        // if the new position is not trivially different from the old position, pan and zoom
        if (nontrivial({ x: new_px, y: new_py, w: new_pw, h: new_ph }, { x: lastpx, y: lastpy, w: lastpw, h: lastph })) {
            var eid_elt = $("[ES_ID='" + EID + "']");
            var lambda_w = origPaperW / real_kfw;
            var lambda_h = origPaperH / real_kfh;
            var nvw = new_pw * lambda_w; // new dimensions of the virtual canvas
            var nvh = new_ph * lambda_h;
            var nvx = (nvw / origPaperW) * (origPaperX - real_kfx) + new_px;
            var nvy = (nvh / origPaperH) * (origPaperY - real_kfy) + new_py;

            var SW = nvw / lastcw; // scale factor in x direction
            var SH = nvh / lastch; // scale factor in y direction (in case we ever have non-aspect-ratio-preserving scaling)

            var cw = domelement.width();
            var ch = domelement.height();

            // translate to (0,0), scale by (SW,SH), translate to (nvx,nvy)
            // in panning, we divide by the width of the paper because all coordinates are in [0,1]
            panObjects(-lastcx / origPaperW, -lastcy / origPaperH, { cw: cw, ch: ch }, 0); // no need to draw updated ink yet
            resizeObjects(SW, SH); // still no need, since we still have to pan
            panObjects(nvx / origPaperW, nvy / origPaperH, { cw: cw, ch: ch }, 1);//no_opac_check || parseFloat(eid_elt[0].style.opacity));
            //if (true || parseFloat(eid_elt[0].style.opacity)) { // only draw if the ink is on screen or if we're on the initial load
            //    panObjects(nvx / origPaperW, nvy / origPaperH);
            //    console.log("DRAWING");
            //}
            //else {
            //    panObjects(nvx / origPaperW, nvy / origPaperH, 'do not draw');
            //    console.log("NOT DRAWING");
            //}

            // reset coordinates
            lastcx = nvx;
            lastcy = nvy;
            lastcw = nvw;
            lastch = nvh;
            lastpx = new_px;
            lastpy = new_py;
            lastpw = new_pw;
            lastph = new_ph;

            var new_opac;
            try {
                new_opac = parseInt(no_opac_check || eid_elt[0].style.opacity,10);
            }
            catch (err) {
                console.log("error in adjustViewBox: " + err);
            }
            oldOpac = new_opac;
        }
    }
    that.adjustViewBoxDiv = adjustViewBoxDiv;

    /**
     * Convert a string representing a block transparency to one representing an isolate transparency.
     * Block/isolate is determined by the fill property of the svg element. If we draw the path counterclockwise (rather than clockwise)
     * and also draw a path around the whole canvas, the in-between space will be filled and we will get an isolate transparency. This
     * method reverses the given path and adds the aforementioned outer path.
     * @param pth    the path to reverse
     * @return    reversed path (with outer path)
     */
    function block_to_isol(pth) {
        var new_pth = "";
        var segs = [""];
        var parsed_pth = Raphael.parsePathString(pth);
        var num_array = [];
        var ctr = 0;
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var j;

        // iterate through in reverse order
        for (var i = parsed_pth.length - 2; i >= 0; i--) {
            if (parsed_pth[i][0] == "z") {
                new_pth += "M" + num_array[0] + "," + num_array[1];
                for (j = 2; j < num_array.length; j++) {
                    new_pth += ((j % 6 == 2) ? ("C" + num_array[j]) : (num_array[j]));
                    new_pth += ((j % 6 != 1) ? (",") : "");
                }
                new_pth += "z";
                num_array.length = 0;
                num_array = []; // every time we hit a close-path command ('z'), restart num_array for new path
            }
            else if (parsed_pth[i][0] == "M") {
                num_array.push(parsed_pth[i][1]);
                num_array.push(parsed_pth[i][2]);
            }
            else {
                num_array.push(parsed_pth[i][5]);
                num_array.push(parsed_pth[i][6]);
                num_array.push(parsed_pth[i][3]);
                num_array.push(parsed_pth[i][4]);
                num_array.push(parsed_pth[i][1]);
                num_array.push(parsed_pth[i][2]);
            }
        }

        // manually add the last path, since there is no 'z' at the start of our pathstring
        new_pth += "M" + num_array[0] + "," + num_array[1];
        for (j = 2; j < num_array.length; j++) {
            new_pth += ((j % 6 == 2) ? ("C" + num_array[j]) : (num_array[j]));
            new_pth += ((j % 6 != 1) ? (",") : "");
        }
        new_pth += "z";
        new_pth += "M-5,-5L" + (cw + 5) + ",-5L" + (cw + 5) + "," + (ch + 5) + "L-5," + (ch + 5) + "L-5,-5z"; // outer path
        return new_pth;
    }
    that.block_to_isol = block_to_isol;

    /**
     * Construct the path that models the overlap between new_path and existing_path in the appropriate
     * transparency mode. For example, if the paths are intersecting circles, const_path_alg returns the
     * outline of the two; if one path is completely inside the other, the inner one is returned in isolate
     * mode and the outer is returned in block mode. Both input paths are closed (have a trailing 'z').
     * @param new_path        one path
     * @param existing_path   another path (in the scheme of things, we are building this path up by adding new_paths)
     */
    function const_path_alg(new_path, existing_path) {
        // array of points in the order they are added, format: {point: {x: __, y: __}, type: 'endpoint'/'intpoint', path: 0/1}  (0 if on new_path, 1 if on existing_path)
        var order_added = [];
        var i, j, pth_seg, next_seg, pth_seg_len;

        var first_point_added = 0;
        if (existing_path === "") // if the existing path is empty, new path should replace it
            return new_path;

        // get array of vertices for the new path
        var parsed_new_path = Raphael.parsePathString(new_path);
        for (i = 0; i < parsed_new_path.length; i++) {
            if (parsed_new_path[i][0] == "z") {
                parsed_new_path.splice(i, 1); // don't want the trailing 'z's
                i--;
            }
        }

        // get array of vertices for the old path
        var parsed_old_path = Raphael.parsePathString(existing_path);
        var old_nz = 0;
        for (i = 0; i < parsed_old_path.length; i++) {
            if (parsed_old_path[i][0] == "z") {
                parsed_old_path.splice(i, 1); // don't want the trailing 'z's
                i--;
                old_nz++;
            }
        }

        // get array of startpoints for the new path, including bezier coordinates out of the point (ax1, ay1) and into the next point (ax2, ay2)
        var new_path_startpoints = [];
        for (i = 0; i < parsed_new_path.length - 1; i++) {
            pth_seg = parsed_new_path[i];
            next_seg = parsed_new_path[(i + 1) % parsed_new_path.length];
            pth_seg_len = pth_seg.length;
            new_path_startpoints.push({ x: pth_seg[pth_seg_len - 2], y: pth_seg[pth_seg_len - 1], ax1: next_seg[1], ay1: next_seg[2], ax2: next_seg[3], ay2: next_seg[4] });
        }

        // get array of endpoints for the oldpath, including bezier coordinates as above
        var old_path_endpoints = [];
        for (i = 0; i < parsed_old_path.length - 1; i++) {
            pth_seg = parsed_old_path[(i + 1) % parsed_old_path.length];
            var ind2 = ((i + 2) % parsed_old_path.length !== 0) ? ((i + 2) % parsed_old_path.length) : 1;
            next_seg = parsed_old_path[ind2];
            pth_seg_len = pth_seg.length;
            old_path_endpoints.push({ x: pth_seg[pth_seg_len - 2], y: pth_seg[pth_seg_len - 1], ax1: next_seg[1], ay1: next_seg[2], ax2: next_seg[3], ay2: next_seg[4] });
        }

        // see if any of our endpoints are the same or are colinear; if they are, perturb one by a slight amount
        var perturbed = 0;
        for (i = 0; i < new_path_startpoints.length; i++) {
            for (j = 0; j < old_path_endpoints.length; j++) {
                if (same_point(new_path_startpoints[i], old_path_endpoints[j])) {
                    new_path_startpoints[i].x += 1;
                    new_path_startpoints[i].y += 1;
                    new_path_startpoints[i].ax1 += 1;
                    new_path_startpoints[i].ay1 += 1;
                    new_path_startpoints[i].ax2 += 1;
                    new_path_startpoints[i].ay2 += 1;
                    perturbed = 1;
                    break;
                }
            }
        }

        // if we perturbed any points above, we need to reset the string in new_path and reparse to get parsed_new_path
        if (perturbed) {
            new_path = "M" + new_path_startpoints[0].x + "," + new_path_startpoints[0].y;
            var nps;
            for (i = 1; i < new_path_startpoints.length; i++) {
                nps = new_path_startpoints[i];
                var prev = new_path_startpoints[i - 1];
                new_path += "C" + prev.ax1 + "," + prev.ay1 + "," + prev.ax2 + "," + prev.ay2 + "," + nps.x + "," + nps.y;
            }
            new_path += "C" + nps.ax1 + "," + nps.ay1 + "," + nps.ax2 + "," + nps.ay2 + "," + new_path_startpoints[0].x + "," + new_path_startpoints[0].y;
            new_path += "z";
            parsed_new_path = Raphael.parsePathString(new_path);
            for (i = 0; i < parsed_new_path.length; i++) {
                if (parsed_new_path[i][0] == "z") {
                    parsed_new_path.splice(i, 1);
                    i--;
                }
            }
        }

        // get the array of intersection points of the two paths
        var ints = Raphael.pathIntersection(new_path, existing_path);
        var seg_ints = [[], [], [], []]; // for intersections along each segment of the new path (4 segments)
        for (i = 0; i < ints.length; i++)
            seg_ints[ints[i].segment1 - 1].push(ints[i]); // segments are 1-indexed

        // sort each segment's intersections in order of increasing t-value (i.e. distance along the segment)
        function sortHelperT1(a, b) { return a.t1 - b.t1; }
        for (i = 0; i < seg_ints.length; i++)
            seg_ints[i].sort(sortHelperT1); // sort by t-value (t1 is the t-value of the int on the new path)


        var old_seg_ints = []; // for intersections along each segment of the old path
        for (i = 0; i < parsed_old_path.length - old_nz; i++)
            old_seg_ints.push([]);

        for (i = 0; i < ints.length; i++)
            old_seg_ints[ints[i].segment2 - 1].push(ints[i]);

        // sort each segment's intersections in order of increasing t2-value (maybe unnecessary)
        function sortHelperT2(a, b) { return a.t2 - b.t2; }
        for (i = 0; i < old_seg_ints.length; i++) {
            old_seg_ints[i].sort(sortHelperT2);
        }

        var outer_path = "";

        if (ints.length === 0) //if no intersections, the paths are disjoint and one may be contained in the other
        {
            if (point_inside(new_path, old_path_endpoints[0].x, old_path_endpoints[0].y))
                return ((trans_mode === 'isolate') ? existing_path : new_path); // existing_path is inside new_path
            if (point_inside(existing_path, new_path_startpoints[0].x, new_path_startpoints[1].y))
                return ((trans_mode === 'isolate') ? new_path : existing_path); // new_path is inside existing_path
            return new_path + existing_path; // paths are disjoint and neither is inside the other
        }

        // iterate through the segments of new_path
        // for each segment, add the start point if it is outside existing_path, add each intersection point, and after adding intersection points, check to see if we should add any endpoints of existing_path
        for (i = 0; i < seg_ints.length; i++) {
            // add start point if outside existing_path
            if (!point_inside(existing_path, new_path_startpoints[i].x, new_path_startpoints[i].y) && !repeat_pt(new_path_startpoints[i], order_added)) {
                if (i === 0)
                    first_point_added = 1;
                order_added.push({ point: new_path_startpoints[i], type: "endpoint", path: 0 }); // add point to order_added if it should be in the final path
            }
            var curr_ints = seg_ints[i]; // array of intersection points on the current segment of new_path
            for (j = 0; j < curr_ints.length; j++) {
                if (!repeat_pt(curr_ints[j], order_added)) {
                    // need to find which curve the previously added point is from in order to get the right bezier coordinates
                    order_added.push({ point: curr_ints[j], type: "intpoint", path: ((order_added.length) ? (order_added[order_added.length - 1].type) : 0) });
                }
                var old_seg_num = curr_ints[j].segment2 - 1; // index of int point in old_seg_ints
                var k = old_seg_num;
                var index = k;

                // iterate through old path endpoints, adding them if they are outside new_path, stopping when we hit a repeat or a point inside new_path
                while (!point_inside(new_path, old_path_endpoints[index].x, old_path_endpoints[index].y) && !repeat_pt(old_path_endpoints, order_added)) {
                    var pt1 = old_path_endpoints[index];
                    var test1 = 1;
                    var test2 = 1;
                    if (index == old_seg_num) { // still on segment of existing_path that the original intersection point was on
                        // check here if there is another intersection point farther along the current segment in the existing path (so we shouldn't add the next endpoint of existing_path)
                        for (var l = 0; l < old_seg_ints[index].length; l++) {
                            if (old_seg_ints[index][l].t2 > curr_ints[j].t2) {
                                test1 = 0;
                                break;
                            }
                        }
                    }
                    else {
                        // otherwise, we just want to make sure that there are no intersection points along the segment whose endpoint is pt1
                        if (old_seg_ints[index].length > 0)
                            test2 = 0;
                    }
                    if (!test1 || !test2 || repeat_pt(pt1, order_added))
                        break;

                    // if we're here, we should add the endpoint pt1 to order_added (with path: 1, since it's on the old path)
                    order_added.push({ point: old_path_endpoints[index], type: "endpoint", path: 1 });
                    k++;
                    index = k % (old_seg_ints.length); // wrap around to first point if necessary
                }
            }
        }
        if (!point_inside(existing_path, new_path_startpoints[0].x, new_path_startpoints[0].y)) {
            order_added.push({ point: new_path_startpoints[0], type: "endpoint", path: 0 }); // if first startpoint is outside existing_path, add it again to close the path
        }
        if (!same_point(order_added[order_added.length - 1].point, order_added[0].point)) {
            order_added.push(order_added[0]); // close path if need be
        }

        // build up outer_path using order_added
        var final_list = [];
        var pt;
        for (i = 0; i < order_added.length - 1; i++) {
            pt = order_added[i];
            var next = order_added[(i + 1) % order_added.length];
            var ob = out_bez(pt, next);
            var ib = next_in_bez(pt, next);
            final_list.push({ ax1: ob.x, ay1: ob.y, ax2: ib.x, ay2: ib.y, x: next.point.x, y: next.point.y }); // push each point along with outgoing bezier coordinates (and incoming for the next point)
        }

        // take points in final_list and build the path string
        outer_path = "M" + final_list[final_list.length - 1].x + "," + final_list[final_list.length - 1].y;
        for (i = 0; i < final_list.length; i++) {
            pt = final_list[i];
            outer_path += "C" + pt.ax1 + "," + pt.ay1 + "," + pt.ax2 + "," + pt.ay2 + "," + pt.x + "," + pt.y;
        }
        outer_path += "z";
        return outer_path;
    }
    that.const_path_alg = const_path_alg;

    /**
     * Uses the arrays ml, xy, and pa to draw paths with the correct properties.
     * First clears the canvas of existing paths, then draws new ones.
     */
    function drawPaths() {
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var paths = "";
        var cpaths = "";
        var i;
        var len = pathObjects.length;
        for (i = 0; i < len; i++) { //removes paths from canvas
            pathObjects[i].remove();
        }
        pathObjects.length = 0;
        for (i = 0; i < ml.length; i++) { //construct the paths
            if (ml[i] === 'M') {
                paths += "PATH::[pathstring]"; // the paths to be drawn now
                cpaths += "PATH::[pathstring]"; // the paths we will save for our datastring (in relative coordinates)
            }
            paths += ml[i] + (cw * xy[i][0]) + ',' + (ch * xy[i][1]); // absolute coords
            cpaths += ml[i] + (xy[i][0]) + ',' + (xy[i][1]); // relative coords
            if (ml[i + 1] != 'L') {
                // if we're here, we've reached the end of a path, so add style information to the path strings
                paths += "[stroke]" + pa[i].color + "[strokeo]" + pa[i].opacity + "[strokew]" + (ch * pa[i].width) + "[]|";
                cpaths += "[stroke]" + pa[i].color + "[strokeo]" + pa[i].opacity + "[strokew]" + pa[i].width + "[]|";
            }
        }
        var path = [];
        if (paths.length > 0) {
            path = paths.split('PATH::');
        }
        for (i = 1; i < path.length; i++) {
            var pstring = get_attr(path[i], "pathstring", "s");
            var strokec = get_attr(path[i], "stroke", "s");
            var strokeo = get_attr(path[i], "strokeo", "f");
            var strokew = get_attr(path[i], "strokew", "f");
            var drawing = paper.path(pstring); // draw the path to the canvas
            drawing.data("type", "path");
            drawing.attr({
                "stroke-width": strokew,
                "stroke-opacity": strokeo,
                "stroke": strokec,
                "stroke-linejoin": "round",
                "stroke-linecap": "round"
            });
            pathObjects.push(drawing);
        }
        currpaths = cpaths; // currpaths is used in update_datastring as the string representing all paths on the canvas
        //update_datastring();
    }
    that.drawPaths = drawPaths;

    /**
     * A helper function to draw transparencies. Takes the arrays transLetters (representing the
     * svg path commands in the transparency string) and transCoords (corresponding locations on the
     * canvas in relative coordinates) and draws the appropriate type of transparency to the canvas.
     * If the type is 'isolate,' calls block_to_isol, which reverses the path and adds an outer path
     * around the canvas to fill the in-between space.
     */
    function drawTrans() {
        remove_all(); // be careful that this method isn't called unless the type of the ink is 'trans'!
        var cw = domelement.width();
        var ch = domelement.height();
        var path = "";
        var ind = 0;
        // iterate through the transLetters array and create our svg path accordingly
        for (var i = 0; i < transLetters.length; i++) {
            if (transLetters[i] == "M" || transLetters[i] == "L") { // if M or L, add next two coords to the path
                path += transLetters[i] + (transCoords[ind] * cw) + "," + (transCoords[ind + 1] * ch);
                ind += 2;
            }
            else if (transLetters[i] == "C") {
                path += "C" + (transCoords[ind] * cw);
                for (var k = 1; k < 6; k++) { // if C, add next six coords to the path (coords represent bezier curve)
                    path += "," + ((k % 2) ? (transCoords[ind + k] * ch) : (transCoords[ind + k] * cw));
                }
                ind += 6;
            }
            else if (transLetters[i] == "z") // if z, close the path
                path += "z";
            else
                console.log("ELSE: " + transLetters[i]);
        }
        var final_path = path;
        if (trans_mode == 'isolate') // if the mode is 'isolate,' reverse the path and add an outer path
            final_path = block_to_isol(path);
        var trans = paper.path(final_path).attr({ "fill": marqueeFillColor, "fill-opacity": marqueeFillOpacity, "stroke-width": 0 }).data("type", "trans");
        trans_currpath = "TRANS::[path]" + path + "[color]" + marqueeFillColor + "[opac]" + marqueeFillOpacity + "[mode]" + trans_mode + "[]";
        update_datastring();
    }
    that.drawTrans = drawTrans;

    /**
     * Called if we drag on the ink canvas in eraser mode. Finds endpoints in the current paths close
     * to the drag event location and splices them out of the path array.
     * @param location   the locaton of the drag event
     */
    function erase(location) {
        var cw = domelement.width();
        var ch = domelement.height();
        var range = eraserWidth;
        for (var i = 0; i < xy.length; i++) { // for each coordinate, test for proximity to location
            if (location[0] - range <= (cw * xy[i][0]) && (cw * xy[i][0]) <= location[0] + range) {
                if (location[1] - range <= (ch * xy[i][1]) && (ch * xy[i][1]) <= location[1] + range) {
                    if (ml[i + 1] === 'L') { // if we splice in the middle of a path, split into two paths
                        ml[i + 1] = 'M';
                    }
                    ml.splice(i, 1);
                    xy.splice(i, 1);
                    pa.splice(i, 1);
                }
            }
        }
        var check = false;
        for (var j = 0; j < ml.length; j++) {
            if (ml[j] === "L") {
                check = true;
                break;
            }
        }
        if (!check) {
            xy.length = 0;
            ml.length = 0;
            pa.length = 0;
        }
        drawPaths(); // after we're done splicing, redraw the paths
    }
    that.erase = erase;

    /**
     * Takes in a datastring and parses for a certain attribute by splitting at "[" and "]" (these surround
     * attribute names).
     * NOTE if errors are coming from this function, could be that the datastring is empty...
     * @param str        the datastring
     * @param attr       the attribute we'll parse for
     * @param parsetype  'i' (int), 's' (string), or 'f' (float)
     * @return  the value of the attribute in the correct format
     */
    function get_attr(str, attr, parsetype) {
        if(parsetype === "f")
            return parseFloat(str.split("[" + attr + "]")[1].split("[")[0]);
        if (parsetype === "s")
            return str.split("[" + attr + "]")[1].split("[")[0];
        else
            return parseInt(str.split("[" + attr + "]")[1].split("[")[0],10);
    }
    that.get_attr = get_attr;

    function set_attr(attr, newval) {
        var arrs = datastring.split("[" + attr + "]");
        var arr2 = arrs[1].split("]");
        arr2.splice(0, 1);
        arr2[0] = "[color]"+arr2[0];
        var str2 = arr2.join("]");
        datastring = arrs[0] + "[fontsize]" + newval + str2;
    }
    that.set_attr = set_attr;
    
    /**
     * Returns the isolate/block bounding shapes.
     */
    function getBoundingShapes() {
        return bounding_shapes;
    }
    that.getBoundingShapes = getBoundingShapes;

    /**
     * Returns the current datastring.
     */
    function getDatastring() {
        return datastring;
    }
    that.getDatastring = getDatastring;

    /**
     * Uses path data representing ellipses and rectangles to get the path representing the ultimate block
     * or isolate shape.
     * @param paths     array of path strings representing ellipses/rects
     */
    function get_outer_path(paths) {
        var cw = domelement.width();
        var ch = domelement.height();
        var cumulative_path = "";
        for (var i = 0; i < paths.length; i++) {
            paths[i] = transform_pathstring_marq(paths[i], cw, ch); // transform each to absolute coords
            paths[i] = (paths[i][paths[i].length - 1] === "z") ? paths[i] : (paths[i] + "z"); // make sure each is closed
        }
        while (paths.length) {
            // take the first path, loop through the list, calling const_path_alg on any that intersect, then add to cumulative_path
            var outer_path = paths[0];
            paths.splice(0, 1);
            if (paths.length) {
                var parsed = Raphael.parsePathString(outer_path); // parses outer_path as a list of objects containing path data
                for (var j = 0; j < paths.length; j++) {
                    var jparsed = Raphael.parsePathString(paths[j]);
                    // the next line checks if paths[j] and outerpath intersect, or if one is completely inside the other
                    if (Raphael.pathIntersection(outer_path, paths[j]).length || point_inside(outer_path, jparsed[0][1], jparsed[0][2]) || point_inside(paths[j], parsed[0][1], parsed[0][2])) {
                        outer_path = const_path_alg(paths[j], outer_path);
                        paths.splice(j, 1);
                        j = -1; //if we have an intersection, another, previously non-intersecting path might now intersect, so reset j (we spliced out the current j, so no repeats)
                    }
                }
            }
            cumulative_path += outer_path;
        }
        // finally, load the resulting cumulative path onto the canvas
        load_trans_from_path(cumulative_path);
    }
    that.get_outer_path = get_outer_path;

    /**
     * Helper function to get artwork's relative coordinates within the viewer.
     * @return    an object containing relative coordinates x, y, w, h
     */
    function getArtRelativePos(proxy, cw, ch) {
        return { x: proxy.x / cw, y: proxy.y / ch, w: proxy.w / cw, h: proxy.h / ch };
    }
    that.getArtRelativePos = getArtRelativePos;

    /**
     * Helper function to get the svg element created by Raphael.
     */
    function getSVGElement() {
        return domelement.find("svg")[0];
    }
    that.getSVGElement = getSVGElement;

    /**
     * Searches the current datastring for ellipses and rectangles, stores their information in bounding_shapes.
     * Also stores their coordinates and types in an array shapes and calls shapes_to_paths on shapes
     * to transform them to path format.
     */
    function get_trans_shape_data () {
        var datastr = update_datastring();
        var shapes = [];
        var cw = domelement.width();
        var ch = domelement.height();
        if (datastr === "") {
            //console.log("no elements to attach");
            return;
        }
        var shapes2 = datastr.split("|");
        for (var i = 0; i < shapes2.length; i++) {
            var shape2 = shapes2[i];
            var type = shape2.split("::")[0];
            type = type.toLowerCase();
            switch (type) {
                case "lrect":
                case "mrect":
                case "rect":
                    // rectangle format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                    var x = abs_dims(get_attr(shape2, "x", "f"), cw);
                    var y = abs_dims(get_attr(shape2, "y", "f"), ch);
                    var w = abs_dims(get_attr(shape2, "w", "f"), cw);
                    var h = abs_dims(get_attr(shape2, "h", "f"), ch);
                    var R = { "X": x, "Y": y, "w": w, "h": h, "type": "rect" };
                    bounding_shapes += "BOUNDRECT::[x]" + (x / cw) + "[y]" + (y / ch) + "[w]" + (w / cw) + "[h]" + (h / ch) + "[fillc]#000000[fillo]0[strokec]" + get_attr(shape2, "strokec", 's') + "[strokeo]" + get_attr(shape2, "strokeo", 'f') + "[strokew]" + get_attr(shape2, "strokew", 'f') + "[]|";
                    shapes.push(R);
                    break;
                case "lellipse":
                case "mellipse":
                case "ellipse":
                    // ellipse format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                    var cx = abs_dims(get_attr(shape2, "cx", "f"), cw); // center x
                    var cy = abs_dims(get_attr(shape2, "cy", "f"), ch); // center y
                    var rx = abs_dims(get_attr(shape2, "rx", "f"), cw); // x-radius
                    var ry = abs_dims(get_attr(shape2, "ry", "f"), ch); // y-radius
                    var E = { "cx": cx, "cy": cy, "rx": rx, "ry": ry, "type": "ellipse" };
                    bounding_shapes += "BOUNDELLIPSE::[cx]" + (cx / cw) + "[cy]" + (cy / ch) + "[rx]" + (rx / cw) + "[ry]" + (ry / ch) + "[fillc]#000000[fillo]0[strokec]" + get_attr(shape2, "strokec", 's') + "[strokeo]" + get_attr(shape2, "strokeo", 'f') + "[strokew]" + get_attr(shape2, "strokew", 'f') + "[]|";
                    shapes.push(E);
                    break;
            }
        }
        shapes_to_paths(shapes);
    }
    that.get_trans_shape_data = get_trans_shape_data;

    /**
     * Returns true if the text box containing an ink being edited/authored is empty
     */
    function isTextboxEmpty() {
        return ($('#' + textboxid).attr("value") === "");
    }
    that.isTextboxEmpty = isTextboxEmpty;

    /**
     * Helper function to check if there is actually a valid ink to attach/save during ink authoring/editing. For texts, need to use isTextboxEmpty.
     * @param datastring    the datastring to check
     * @return    whether or not there are no inks on the canvas (i.e. the datastring does not represent anything useful)
     */
    function isDatastringEmpty(datastring) {
        //console.log("is data string empty :" + datastring);
        if (!pathstring && datastring === "") // MODIFIED
            return true;
        var type = datastring.split("::")[0].toLowerCase();
        var empty = false;
        switch (type) {
            case 'trans':
                if (datastring.split("[path]")[1].split("[")[0] === "")
                    empty = true;
                break;
            case 'bezier': // TO DO -- in case we go back to old paths, add currpaths or something
            case 'path':
                if (!pathstring && datastring.split("[pathstring]")[1].split("[")[0] === "") // MODIFIED
                    empty = true;
                break;
            case 'text':
                if (datastring.split("[str]")[1].split("[")[0] === "")
                    empty = true;
                break;
            default:
                break;
        }
        return empty;
    }
    that.isDatastringEmpty = isDatastringEmpty;

    /**
     * Display warning message if ink cannot be loaded
     * @param displayString     String describing error (to be displayed)
     */
    function creationError(displayString) {
        timeline.hideEditorOverlay();
        var messageBox = TAG.Util.UI.popUpMessage(null, displayString, null);
        $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
        $('body').append(messageBox);
        $(messageBox).fadeIn(500);
    }

    /**
     * Checks if currently inside display
     * @returns             true if in display, false otherwise
     */
    function checkInDisplay(track) {
        var currTime = timeManager.getCurrentTime();
        //for (var i = 0; i < displays.length ; i++) {
        //    var disp = displays[i];
        //    if (disp.getStart() <= currTime && currTime <= disp.getEnd()) {
        //        inDisplay = true;
        //        break;
        //    }
        //}
        var nearestDisplay = track.getStorageContainer().displays.nearestNeighbors(currTime, 1)[0];
        if (nearestDisplay) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Helper function to do some preprocessing on text inks before linking them.
     * @return    true if we should proceed to linking, false if there are warning messages
     */
    function link_text() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();
        if (!track || (track.getType() !== TAG.TourAuthoring.TrackType.artwork && track.getType() !== TAG.TourAuthoring.TrackType.image)) {
            creationError("There is no artwork or image track selected. Please select a valid track or create an unlinked annotation.");
            return false;
        }

        // First, check if the text is a valid (non-empty) ink by checking the value of the textbox. If invalid, show a warning message.
        if (isTextboxEmpty()) {
            creationError("Unable to attach an empty annotation. Please add to annotation component before attaching.");
            return false;
        }
        // next, check to make sure the playhead is in a display; if not, show a warning message
        var inDisplay = checkInDisplay(track);//.getDisplays());
        // also check if the selected track is an artwork or an image
        if (!inDisplay) {
            creationError("Please move the playhead within the currently selected track's display.");
            return false; // if a warning popped up, return false
        }
        var keyframe = viewer.captureKeyframe(track.getTitle());
        if (!keyframe) {
            creationError("The track selected must be fully on screen in order to attach an annotation. Please seek to a location where the track is visible.");
            return false;
        }


        save_text();
        return link();
    }
    that.link_text = link_text;

    /**
     * Helper function to do some preprocessing on text inks before creating them unattached.
     * @return     true if no warnings and we should create, false otherwise
     */
    function link_text_unattached() {
        // First, check if the text is a valid (non-empty) ink by checking the value of the textbox. If invalid, show a warning message.
        if (isTextboxEmpty()) {
            creationError("Unable to attach an empty annotation. Please add to annotation component before attaching.");
            return false;
        }
        if (!linkUnattached()) return false;
        return true;
    }
    that.link_text_unattached = link_text_unattached;

    /**
     * Helper function to do some preprocessing on transparencies before linking them.
     * @return     true if no warnings, false otherwise (see link_text for description of warnings)
     */
    function link_trans() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();
        
        if (!track || (track.getType() !== TAG.TourAuthoring.TrackType.artwork && track.getType() !== TAG.TourAuthoring.TrackType.image)) {
            creationError("There is no artwork or image track selected. Please select a valid track or create an unlinked annotation.");
            return false;
        }

        var inDisplay = checkInDisplay(track);
        
        if (!inDisplay) {
            creationError("Please move the playhead within the currently selected track's display.");
            return false; // if a warning popped up, return false
        }
        
        var keyframe = viewer.captureKeyframe(track.getTitle());
        if (!keyframe) {
            creationError("The track selected must be fully on screen in order to attach an annotation. Please seek to a location where the track is visible.");
            return false;
        }

        get_trans_shape_data();
        return link();
    }
    that.link_trans = link_trans;

    /**
     * Helper function to do some preprocessing on transparencies before creating them unattached.
     * @return     true if no warnings, false otherwise
     */
    function link_trans_unattached() {
        if (isDatastringEmpty(update_datastring())) {
            creationError("Unable to attach an empty annotation. Please add to annotation component before attaching.");
            return false;
        }
        get_trans_shape_data();
        linkUnattached();
        return true;
    }
    that.link_trans_unattached = link_trans_unattached;

    /**
     * Function to link an ink to an artwork. Called for all types of inks (possibly after preprocessing, in
     * the cases of texts and transparencies).
     * return     true if linking was successful, false if warnings
     */
    function link() {
        if (!dataHolder) {
            dataHolder = timeline.dataHolder;
        }
        var track = dataHolder.getSelectedTrack();

        if (!track || (track.getType() !== TAG.TourAuthoring.TrackType.artwork && track.getType() !== TAG.TourAuthoring.TrackType.image)) {
            creationError("There is no artwork or image track selected. Please select a valid track or create an unlinked annotation.");
            return false;
        }
        if (isDatastringEmpty(update_datastring())) { // make sure the datastring is nonempty before we attach
            creationError("Unable to attach an empty annotation. Please add to annotation component before attaching.");
            return false;
        }
        var inDisplay = checkInDisplay(track);
        // make sure the track selection is valid, it is an artwork or an image, and the playhead is in a track display
        if (!inDisplay) {
            creationError("Please move the playhead within the currently selected track's display.");
            return false; // if a warning popped up, return false
        }

        // prepare to set track data
        artName = track.getTitle();
        var cw = domelement.width();
        var ch = domelement.height();
        magX = cw;
        magY = ch;
        var proxy_div = $("[data-proxy='" + escape(artName) + "']");
        var proxy = {
            x: proxy_div.data("x"),
            y: proxy_div.data("y"),
            w: proxy_div.data("w"),
            h: proxy_div.data("h")
        };

        var datastr = update_datastring();

        var keyframe = viewer.captureKeyframe(artName);
        if (!keyframe) {
            creationError("The track selected must be fully on screen in order to attach an annotation. Please seek to a location where the track is visible.");
            return false;
        }

        var kfvx, kfvy, kfvw, kfvh,
            linkType = track.getType();
        // get initial keyframe for the artwork/image we're attaching to
        if (linkType === TAG.TourAuthoring.TrackType.artwork) {
            kfvx = keyframe.state.viewport.region.center.x;
            kfvy = keyframe.state.viewport.region.center.y;
            kfvw = keyframe.state.viewport.region.span.x;
            kfvh = keyframe.state.viewport.region.span.y;
        }
        else if (linkType === TAG.TourAuthoring.TrackType.image) {
            kfvw = 1.0 / keyframe.state.viewport.region.span.x;//$("#" + canvid).width() / (keyframe.state.viewport.region.span.x * cw);
            var rw = keyframe.state.viewport.region.span.x * domelement.width();
            kfvh = keyframe.state.viewport.region.span.y; /////bogus entry, not used
            kfvx = -keyframe.state.viewport.region.center.x * kfvw;// /
            kfvy = -(domelement.height() / rw) * keyframe.state.viewport.region.center.y;// / (.5*(keyframe.state.viewport.region.span.x
        }
        // set track data
        var inkType = datastr.split("::")[0].toLowerCase();
        inktrack = timeline.addInkTrack(track, "Ink " + decodeURI(track.getTitle()), inkType);
        inktrack.setInkLink(track);

        if (inkType === "trans")
            datastr += bounding_shapes; // if we're attaching a transparency, also include the bounding ellipse/rects in the datastring so we can edit later
        inktrack.setInkPath(datastr);
        inktrack.setInkProps({}); // not used
        inktrack.setInkInitKeyframe({ "x": kfvx, "y": kfvy, "w": kfvw, "h": kfvh });
        inktrack.setInkEnabled(true); // set linked
        inktrack.setInkType(inkType);
        inktrack.setInkRelativeArtPos(getArtRelativePos(proxy, cw, ch));

        inktrack.addInkTypeToTitle(inkType);

        enabled = true;
        domelement.remove();

        var inkDisplayTime = timeManager.getCurrentTime();
        var parentDisplay = track.getStorageContainer().displays.nearestNeighbors(inkDisplayTime, 1)[0].display;
        var boundingEdge = parentDisplay.getEnd();
        var inkDisplay = inktrack.addDisplay(timeManager.getCurrentPx(), Math.min(5, boundingEdge - inkDisplayTime)); //add a display at the playhead location

        // set parent-child association between displays
        parentDisplay.addChildDisplay(inkDisplay);
        inkDisplay.setParentDisplay(parentDisplay);

        // add linking association between tracks
        track.addAttachedInkTrack(inktrack);
        inktrack.setInkLink(track);

        // add command to undo both track creation and display at once
        undoManager.combineLast(2);

        if (dataHolder._trackArray.length > 0) {
            dataHolder._trackArray[0].track.leftAndRight({ translation: { x: 0 } }, false);
        }

        return true;
    }
    that.link = link;

    /**
     * Function to create an unattached ink. Called for all types of inks (possibly after preprocessing, in
     * the cases of texts and transparencies).
     * return     true if creation was successful, false if warnings
     */
    function linkUnattached() {
        var inkEmptyOverlay = $(TAG.Util.UI.blockInteractionOverlay());
        var inkEmptyDialog = $(document.createElement("div"));

        function okTapInkAttach(evt) {
            inkEmptyOverlay.fadeOut(200);
        }
        if (isDatastringEmpty(update_datastring())) {
            inkEmptyDialog.attr("id", "inkEmptyDialog");
            inkEmptyDialog.css({
                display: 'none',
                position: 'fixed',
                top: '40%',
                left: '30%',
                width: 'auto',
                'background-color': 'black',
                'border': '3px double white',
                'z-index': TAG.TourAuthoring.aboveRinZIndex + 5,
                'text-align': 'center',
                'padding': '1.5% 1.5% 2% 2%',
            });

            inkEmptyOverlay.append(inkEmptyDialog);
            $("body").append(inkEmptyOverlay);
            inkEmptyOverlay.fadeIn(100);

            var text = $(document.createElement("div"));
            text.text("Unable to attach an empty annotation. Please add to annotation component before attaching.");
            text.css('font-size', '1.25em', "text-align", 'left');
            inkEmptyDialog.append(text);

            var buttonDiv = $(document.createElement("div"));
            buttonDiv.css('text-align', 'center');

            var ok = $(document.createElement("button"));
            ok.text("OK");
            ok.css({
                width: 'auto',
                'background-color': 'black',
                'border': '1px solid white',
                'margin-top': '25px',
                //'margin-right':'2%'
            });
            buttonDiv.append(ok);
            inkEmptyDialog.append(buttonDiv);
            inkEmptyDialog.show();

            TAG.Util.makeManipulatable(ok[0], {
                onTapped: okTapInkAttach
            }, false);
            return false;
        }

        // add track and set track data
        inktrack = timeline.addInkTrack(null, "Unattached Annotation", 1);
        inktrack.setInkLink(null);
        var datastr = update_datastring();
        var inkType = datastr.split("::")[0].toLowerCase();
        if (inkType == "trans")
            datastr += bounding_shapes;
        inktrack.setInkPath(datastr);
        inktrack.setInkEnabled(false); // unattached
        inktrack.setInkSize(fontSize);
        inktrack.setInkInitKeyframe({}); // initial keyframe doesn't matter, since not linked
        inktrack.setInkRelativeArtPos({}); // initial art position doesn't matter, since not linked

        inktrack.addInkTypeToTitle(inkType);


        enabled = false;
        domelement.remove();
        inktrack.addDisplay(Math.min(timeManager.timeToPx(timeManager.getDuration().end - 0.5), timeManager.getCurrentPx()), Math.min(5, Math.max(0.5, timeManager.getDuration().end - timeManager.getCurrentTime()))); // add a display at the playhead location
        undoManager.combineLast(2);
        if (timeline.getTracks().length > 0) {
            timeline.getTracks()[0].leftAndRight({ translation: { x: 0 } }, false);
        }
        return true;
    }
    that.linkUnattached = linkUnattached;

    function getTextElt() {
        return textElt;
    }
    that.getTextElt = getTextElt;

    var magX = domelement.width(), magY = domelement.height();

    function getTextMagnification() {
        return magY;
    }
    that.getTextMagnification= getTextMagnification;

    /**
     * Loads an ink onto the ink canvas using its datastring (e.g. from track data).
     * @param   the datastring to be loaded (see update_datastring for datastring format)
     */
    function loadInk(datastr) {
        var shapes = datastr.split("|");
        var i;
        var cw = domelement.width();
        var ch = domelement.height();
        magX = cw;
        magY = ch;
        pathstring = "";
        var shapes_len = shapes.length;
        for (i = 0; i < shapes_len; i++) {
            var shape = shapes[i];
            var x, y, w, h, fillc, fillo, strokec, strokeo, strokew;
            if (shape && (shape !== "")) {
                var type = shape.split("::")[0];
                switch (type.toLowerCase()) {
                    case "text":
                        // format: [str]<text>[font]<font>[fontsize]<fontsize>[color]<font color>[x]<x>[y]<y>[]
                        var size = get_attr(shape, "fontsize", "f") * ch;
                        fontSize = size;
                        x = get_attr(shape, "x", "f") * cw;
                        y = get_attr(shape, "y", "f") * ch;
                        //var w, h;
                        try {
                            w = get_attr(shape, 'w', 'f');
                            h = get_attr(shape, 'h', 'f');
                        } catch (err) {
                            w = null;
                            h = null;
                        }
                        var text_color = get_attr(shape, "color", "s");
                        var text_font = get_attr(shape, "font", "s");
                        var text_text = get_attr(shape, "str", "s");
                        var text = paper.text(x, y, text_text);
                        text.attr({
                            "font-family": text_font,
                            "font-size": size + "px",
                            "fill": text_color,
                            "text-anchor": "start",
                        });
                        text.data({
                            "x": x,
                            "y": y,
                            'w': w,
                            'h': h,
                            "fontsize": size,
                            "color": text_color,
                            "font": text_font,
                            "type": "text",
                            "str": text_text,
                        });
                        textElt = text;
                        break;
                    case "path":
                        // format: [pathstring]M284,193L284,193[stroke]000000[strokeo]1[strokew]10[]
                        if (!currpaths)
                            currpaths = "";
                        currpaths += shape + "|";
                        update_ml_xy_pa(shape + "|");
                        break;
                    case "bezier": // bezier paths
                        
                        pathstring += get_attr(shape,"pathstring",'s');
                        pa.push({ color: get_attr(shape, "stroke", 's'), opacity: get_attr(shape, "strokeo", "f"), width: get_attr(shape, "strokew","f") });
                        break;
                    case "trans":
                        // format: [path]<path>[color]<color>[opac]<opac>[mode]<block or isolate>[]
                        if (!trans_currpath)
                            trans_currpath = "";
                        trans_currpath += shape + "|";
                        var pathstringt = get_attr(shape, "path", 's'); // MODIFIED
                        marqueeFillColor = get_attr(shape, "color", 's');
                        marqueeFillOpacity = get_attr(shape, "opac", "f");
                        trans_mode = get_attr(shape, "mode", 's');
                        transCoords = pathstringt.match(/[0-9.\-]+/g);
                        transLetters = pathstringt.match(/[CMLz]/g);
                        drawTrans();
                        break;
                    case "rect":
                        // format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        x = abs_dims(get_attr(shape, "x", "f"), cw);
                        y = abs_dims(get_attr(shape, "y", "f"), ch);
                        w = abs_dims(get_attr(shape, "w", "f"), cw);
                        h = abs_dims(get_attr(shape, "h", "f"), ch);
                        fillc = get_attr(shape, "fillc", "s");
                        fillo = get_attr(shape, "fillo", "f");
                        strokec = get_attr(shape, "strokec", "s");
                        strokeo = get_attr(shape, "strokeo", "f");
                        strokew = get_attr(shape, "strokew", "f");
                        var R = paper.rect(x, y, w, h);
                        R.data("currx", x);
                        R.data("curry", y);
                        R.data("currw", w);
                        R.data("currh", h);
                        R.data("type", "rect");
                        R.data("visible", "yes");
                        add_attributes(R, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case "ellipse":
                        // format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var cx = abs_dims(get_attr(shape, "cx", "f"), cw);
                        var cy = abs_dims(get_attr(shape, "cy", "f"), ch);
                        var rx = abs_dims(get_attr(shape, "rx", "f"), cw);
                        var ry = abs_dims(get_attr(shape, "ry", "f"), ch);
                        fillc = get_attr(shape, "fillc", "s");
                        fillo = get_attr(shape, "fillo", "f");
                        strokec = get_attr(shape, "strokec", "s");
                        strokeo = get_attr(shape, "strokeo", "f");
                        strokew = get_attr(shape, "strokew", "f");
                        var E = paper.ellipse(cx, cy, rx, ry);
                        E.data("currx", E.getBBox().x);
                        E.data("curry", E.getBBox().y);
                        E.data("curr_rx", rx);
                        E.data("curr_ry", ry);
                        E.data("type", "ellipse");
                        E.data("visible", "yes");
                        add_attributes(E, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case "marquee": // DEPRECATED
                        // format: [x]206[y]207[w]102[h]93[surrfillc]#222222[surrfillo].8[]
                        var topx = abs_dims(get_attr(shape, "x", "f"), cw);
                        var topy = abs_dims(get_attr(shape, "y", "f"), ch);
                        w = abs_dims(get_attr(shape, "w", "f"), cw);
                        h = abs_dims(get_attr(shape, "h", "f"), ch);
                        var surrfillc = get_attr(shape, "surrfillc", "s");
                        var surrfillo = get_attr(shape, "surrfillo", "f");
                        var botx = topx + w;
                        var boty = topy + h;
                        var rn = paper.rect(0, 0, cw, topy);
                        rn.data("currx", 0);
                        rn.data("curry", 0);
                        var re = paper.rect(botx, topy, cw - botx, boty - topy);
                        re.data("currx", botx);
                        re.data("curry", topy);
                        var rs = paper.rect(0, boty, cw, ch - boty);
                        rs.data("currx", 0);
                        rs.data("curry", boty);
                        var rw = paper.rect(0, topy, topx, boty - topy);
                        rw.data("currx", 0);
                        rw.data("curry", topy);
                        var rc = paper.rect(topx, topy, botx - topx, boty - topy);
                        rc.data("currx", topx);
                        rc.data("curry", topy);
                        rc.data("type", "marquee");
                        //var m = new marquee(rn, re, rs, rw, rc);
                        //add_marq_attributes(m, surrfillc, surrfillo);
                        //marquees.push(m);
                        break;
                }
            }
        }
        drawPaths();
        if (pathstring) {
            drawBezierPath();
        }

        // force adjustViewBox to run so viewbox is always set 
        //lastpx = origpx + 10000;
        if (enabled) {
            paper.setViewBox(0, 0, cw, ch);
            //adjustViewBox({ x: origpx, y: origpy, width: origpw, height: origph });
        }
    }
    that.loadInk = loadInk;

    /**
     * Draws a transparency to the canvas and adds the correct styling. Also sets trans_currpath, which keeps track of current transparency path.
     * @param pth    the path representing the transparency to be loaded in
     */
    function load_trans_from_path(pth) {
        var cw = domelement.width();
        var ch = domelement.height();
        var trans = paper.path(pth).attr({ "fill-opacity": marqueeFillOpacity, "fill": marqueeFillColor, "stroke-opacity": 0, "stroke": "#888888", "stroke-width": 0 });
        trans.data("type", "trans");
        trans_currpath = "TRANS::[path]" + transform_pathstring_marq(pth, 1.0 / cw, 1.0 / ch) + "[color]" + marqueeFillColor + "[opac]" + marqueeFillOpacity + "[mode]" + trans_mode + "[]|";
        update_datastring();
    }
    that.load_trans_from_path = load_trans_from_path;

    /**
     * Loads a transparency's bounding shapes -- type boundrect and boundellipse -- for editing transparencies
     * @param datastr    the datastring containing the transparency path and its bounding shapes
     */
    function load_transparency_bounding_shapes(datastr) {
        var shapes = datastr.split("|");
        var i;
        var cw = domelement.width();
        var ch = domelement.height();
        for (i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            var fillc, fillo, strokec, strokeo, strokew;
            if (shape && (shape !== "")) {
                var type = shape.split("::")[0];
                type = type.toLowerCase();
                switch (type) {
                    case "boundrect":
                        //format: [x]73[y]196[w]187[h]201[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var x = abs_dims(get_attr(shape, "x", "f"), cw);
                        var y = abs_dims(get_attr(shape, "y", "f"), ch);
                        var w = abs_dims(get_attr(shape, "w", "f"), cw);
                        var h = abs_dims(get_attr(shape, "h", "f"), ch);
                        fillc = get_attr(shape, "fillc", "s");
                        fillo = get_attr(shape, "fillo", "f");
                        strokec = get_attr(shape, "strokec", "s");
                        strokeo = get_attr(shape, "strokeo", "f");
                        strokew = get_attr(shape, "strokew", "f");
                        var R = paper.rect(x, y, w, h);
                        R.data("currx", x);
                        R.data("curry", y);
                        R.data("currw", w);
                        R.data("currh", h);
                        R.data("type", "rect");
                        R.data("visible", "yes");
                        add_attributes(R, fillc, fillo, strokec, strokeo, strokew);
                        break;
                    case "boundellipse":
                        //format: [cx]81[cy]131[rx]40[ry]27[fillc]#ffff00[fillo].5[strokec]#000000[strokeo]1[strokew]3[]
                        var cx = abs_dims(get_attr(shape, "cx", "f"), cw);
                        var cy = abs_dims(get_attr(shape, "cy", "f"), ch);
                        var rx = abs_dims(get_attr(shape, "rx", "f"), cw);
                        var ry = abs_dims(get_attr(shape, "ry", "f"), ch);
                        fillc = get_attr(shape, "fillc", "s");
                        fillo = get_attr(shape, "fillo", "f");
                        strokec = get_attr(shape, "strokec", "s");
                        strokeo = get_attr(shape, "strokeo", "f");
                        strokew = get_attr(shape, "strokew", "f");
                        var E = paper.ellipse(cx, cy, rx, ry);
                        E.data("currx", E.getBBox().x);
                        E.data("curry", E.getBBox().y);
                        E.data("curr_rx", rx);
                        E.data("curr_ry", ry);
                        E.data("type", "ellipse");
                        E.data("visible", "yes");
                        add_attributes(E, fillc, fillo, strokec, strokeo, strokew);
                        break;
                }
            }
        }
    }
    that.load_transparency_bounding_shapes = load_transparency_bounding_shapes;

    /**
     * DEPRECATED -- constructor for old marquees
     */
    //function marquee(rectN, rectE, rectS, rectW, rectC) {
    //    this.rn = rectN;
    //    this.re = rectE;
    //    this.rs = rectS;
    //    this.rw = rectW;
    //    this.rc = rectC;
    //}
    //that.marquee = marquee;

    /**
     * Using the point pt, computes the incoming bezier anchor coordinates for the next point (next) in the path.
     * This is done by using the points' types (if pt and next are both endpoints, pt.point.ax2, .ay2 give the relevant information, etc).
     * @param pt      starting point object (contains point coordinates, type of point, and which path it's on)
     * @param next    next point object
     * @return    the incoming bezier anchor coordinates to next
     */
    function next_in_bez(pt, next) {
        var bez, t, dots;
        if (pt.type == "endpoint") {
            if (next.type == "endpoint") {
                return { x: pt.point.ax2, y: pt.point.ay2 };
            }
            else { // pt is an endpoint and next is an intersection point
                bez = (pt.path === 0) ? (next.point.bez1) : (next.point.bez2);
                t = (pt.path === 0) ? (next.point.t1) : (next.point.t2);
                dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
                return { x: dots.m.x, y: dots.m.y };
            }
        }
        else { // pt is an intersection point
            if (next.type === "endpoint") {
                bez = (next.path === 0) ? (pt.point.bez1) : (pt.point.bez2);
                return { x: bez[4], y: bez[5] };
            }
            else {//both pt and next are intersection points
                bez = (next.path === 0) ? (next.point.bez1) : (next.point.bez2);
                t = (next.path === 0) ? (next.point.t1) : (next.point.t2);
                dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
                return { x: dots.n.x, y: dots.n.y };
            }
        }
    }
    that.next_in_bez = next_in_bez;

    /**
     * Helper function to determine whether p1 and p2 are effectively the same point. Returns true if so.
     */
    function nontrivial(p1, p2) {
        return ((Math.abs(p1.x - p2.x) > 0.00000001) || (Math.abs(p1.y - p2.y) > 0.00000001) || (Math.abs(p1.w - p2.w) > 0.00000001) || (Math.abs(p1.h - p2.h) > 0.00000001));
    }
    that.nontrivial = nontrivial;

    /**
     * Using the point next, computes the outgoing bezier anchor coordinates for the point pt on the path.
     * @param pt      starting point object (contains point coordinates, type of point, and which path it's on)
     * @param next    next point object
     * @return    the outgoing bezier anchor coordinates from pt
     */
    function out_bez(pt, next) {
        if (pt.type === "endpoint") {
            return { x: pt.point.ax1, y: pt.point.ay1 };
        }
        else { // pt is an intersection point
            var bez = (next.path === 0) ? (pt.point.bez1) : (pt.point.bez2);
            var t = (next.path === 0) ? (pt.point.t1) : (pt.point.t2);
            var dots = Raphael.findDotsAtSegment(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], bez[6], bez[7], t);
            return { x: dots.n.x, y: dots.n.y };
        }
    }
    that.out_bez = out_bez;

    var inkPannedX;
    var inkPannedY;
    /**
     * Pans all objects in the canvas by dx, dy.
     * @param dx, dy    the deltas
     * @param draw      should we take time to draw the objects?
     */
    function panObjects(dx, dy, canv_dims, draw) {
        var cw = canv_dims.cw;
        var ch = canv_dims.ch;
        var i;
        paper.forEach(function (elt) { // first take care of panning rects, ellipses, and texts by changing their attributes
            var type = elt.data("type");
            if ((type != "path") && (type != "bezier") && (type != "text") && (type != "trans")) {
                elt.attr({
                    'x': parseFloat(elt.attr("x")) + dx * cw,
                    'y': parseFloat(elt.attr("y")) + dy * ch,
                    'cx': parseFloat(elt.attr("cx")) + dx * cw,
                    'cy': parseFloat(elt.attr("cy")) + dy * ch,
                });
                if (type == "ellipse") {
                    elt.data("currx", parseFloat(elt.attr("cx")) - parseFloat(elt.attr("rx")));
                    elt.data("curry", parseFloat(elt.attr("cy")) - parseFloat(elt.attr("ry")));
                    elt.data("curr_rx", elt.attr("rx"));
                    elt.data("curr_ry", elt.attr("ry"));
                }
                else {
                    elt.data("currx", elt.attr("x"));
                    elt.data("curry", elt.attr("y"));
                }
            }
            else if (type == "text") {
                elt.attr({
                    'x': parseFloat(elt.attr("x")) + dx * cw,
                    'y': parseFloat(elt.attr("y")) + dy * ch,
                });
                elt.data('x', parseFloat(elt.data("x")) + dx * cw);
                elt.data('y', parseFloat(elt.data("y")) + dy * ch);
                inkPannedX = elt.attr('x');
                inkPannedY = elt.attr('y');
            }
        });

        // pan paths by modifying xy
        var xylen = xy.length;
        for (i = 0; i < xylen; i++) {
            xy[i][0] = xy[i][0] + dx;
            xy[i][1] = xy[i][1] + dy;
        }

        var coords, letters;
        coords = extractCoords(pathstring);
        letters = extractLetters(pathstring);
        for (i = 0; i < coords.length; i += 2) {
            coords[i] += dx;
            coords[i + 1] += dy;
        }
        pathstring = mergeToPath(letters, coords);

        // pan transparencies by modifying transCoords
        var tclen = transCoords.length;
        for (i = 0; i < tclen; i++) {
            transCoords[i] += ((i % 2) ? dy : dx);
        }

        // if type is drawing, call drawPaths if necessary
        if (xylen && draw)
            drawPaths();

        // if type is transparency, call drawTrans if ncecessary
        if (tclen && draw)
            drawTrans();

        if (pathstring && draw)
            drawBezierPath();

        // if the type of our ink is a text, redraw (if necessary) by just removing all and loading the datastring back in
        if (!xylen && !tclen && draw) {
            var dstring = update_datastring();
            remove_all();
            datastring = dstring;
            loadInk(datastring);
        }
    }
    that.panObjects = panObjects;

    function getPannedPos() {
        // used to return positional data for generating text in correct place
        var pannedPos = { x: inkPannedX, y: inkPannedY };
        return pannedPos;
    }
    that.getPannedPos = getPannedPos;

    /**
     * Pans all objects in the canvas by dx, dy.
     * @param dx, dy    the deltas
     * @param draw      should we take time to draw the objects?
     */
    function testPan(dx, dy, draw) {
        if (!draw) {
            paper.forEach(function (elt) {
                elt.transform("t-" + elt.data("bboxcenterx") + ",-" + elt.data("bboxcentery") + "...");
            });
        }
        else {
            paper.forEach(function (elt) {
                elt.transform("t" + (dx+elt.data("bboxcenterx")) + "," + (dy+elt.data("bboxcentery")) + "...");
            });
        }
    }
    that.testPan = testPan;

    function testScale(scale_x, scale_y, draw) {
        paper.forEach(function (elt) {
            var bbox = elt.getBBox();
            elt.transform("s" + scale_x + "...");
            elt.transform("t" + (-elt.getBBox().x) + "," + (-elt.getBBox().y)+"...");
            elt.transform("t" + (bbox.x*scale_x) + "," + (bbox.y*scale_y)+"...");
        });
    }
    that.testScale = testScale;

    /**
     * Sometimes points on the boundary of a shape do not register as being inside the shape, so check a few surrounding
     * points as well. If enough of them (2) are inside, call the point inside. This isn't bulletproof, but it should
     * work most of the time.
     * @param pth     the path whose boundary concerns us
     * @param x, y    coordinates of the point to test
     * @return    1 if enough points are inside, 0 otherwise
     */
    function point_inside(pth, x, y) {
        var test1 = Raphael.isPointInsidePath(pth, x, y);
        var test2 = Raphael.isPointInsidePath(pth, x - 1, y - 1);
        var test3 = Raphael.isPointInsidePath(pth, x + 1, y - 1);
        var test4 = Raphael.isPointInsidePath(pth, x - 1, y + 1);
        var test5 = Raphael.isPointInsidePath(pth, x + 1, y + 1);
        if (test1 || (test2 + test3 + test4 + test5 >= 2))
            return 1;
        return 0;
    }
    that.point_inside = point_inside;

    /**
     * Helper function to convert to relative coordinates.
     * @param abs_coord   the absolute coordinate
     * @param canv_dim    the relevant canvas dimension to scale by
     */
    function rel_dims(abs_coord, canv_dim) {
        return parseFloat(abs_coord) / parseFloat(canv_dim);
    }
    that.rel_dims = rel_dims;

    /**
     * Returns 1 if any points in order_added match pt.
     */
    function repeat_pt(pt, order_added) {
        for (var i = 0; i < order_added.length - 1; i++) {
            if (same_point(order_added[i].point, pt)) {
                return 1;
            }
        }
        return 0;
    }
    that.repeat_pt = repeat_pt;

    /**
     * Removes all Raphael elements from the canvas and clears arrays
     */
    function remove_all() {
        paper.clear();
        ml.length = 0;
        xy.length = 0;
        pa.length = 0;
        pathObjects.length = 0;
        marquees.length = 0;
        currpaths = "";
        datastring = '';
    }
    that.remove_all = remove_all;

    /**
     * Resizes all elements in the ink canvas.
     * @param scale_x, scale_y   the scale factors to resize by
     * @param draw               should we take the time to draw the result?
     */
    function resizeObjects(scale_x, scale_y, draw) {
        paper.forEach(function (elt) { // resize ellipses, rects, and texts by scaling attributes
            var type = elt.data("type");
            if ((type !== "path") && (type !== "bezier") && (type !== "text") && (type !== "trans") && (type !== "grabHandle")) {
                elt.attr({
                    'x': parseFloat(elt.attr("x")) * scale_x,
                    'y': parseFloat(elt.attr("y")) * scale_y,
                    'cx': parseFloat(elt.attr("cx")) * scale_x,
                    'cy': parseFloat(elt.attr("cy")) * scale_y,
                    'rx': parseFloat(elt.attr("rx")) * scale_x,
                    'ry': parseFloat(elt.attr("ry")) * scale_y,
                    'width': parseFloat(elt.attr("width")) * scale_x,
                    'height': parseFloat(elt.attr("height")) * scale_y,
                });
                if (type === "ellipse") {
                    elt.data("currx", parseFloat(elt.attr("cx")) - parseFloat(elt.attr("rx")));
                    elt.data("curry", parseFloat(elt.attr("cy")) - parseFloat(elt.attr("ry")));
                    elt.data("curr_rx", parseFloat(elt.attr("rx")));
                    elt.data("curr_ry", parseFloat(elt.attr("ry")));
                }
                else {
                    elt.data("currx", elt.attr("x"));
                    elt.data("curry", elt.attr("y"));
                }
            }
            else if (type === "text") {
                elt.attr({
                    'font-size': parseFloat(elt.attr("font-size")) * scale_y,
                    'x': elt.attr("x") * scale_x,
                    'y': elt.attr("y") * scale_y,
                });
                elt.data({
                    'fontsize': elt.data("fontsize") * scale_y,
                    'x': elt.data("x") * scale_x,
                    'y': elt.data("y") * scale_y,
                });
            }
        });

        // resize paths by scaling elements of xy
        var xylen = xy.length;
        var i;
        for (i = 0; i < xylen; i++) {
            xy[i][0] = xy[i][0] * scale_x;
            xy[i][1] = xy[i][1] * scale_y;
            pa[i].width = pa[i].width * scale_x;
        }

        var coords, letters;
        coords = extractCoords(pathstring);
        letters = extractLetters(pathstring);
        for (i = 0; i < coords.length; i += 2) {
            coords[i] *= scale_x;
            coords[i + 1] *= scale_y;
        }
        for (i = 0; i < pa.length; i++) {
            pa[i].width = pa[i].width * scale_x;
        }
        pathstring = mergeToPath(letters, coords);

        // resize transparencies by scaling elements of transCoords
        var tclen = transCoords.length;
        for (i = 0; i < tclen; i++) {
            transCoords[i] *= ((i % 2) ? scale_y : scale_x);
        }

        // call drawPaths or drawTrans to update paths and transparencies, respectively, if need be
        if (xylen && draw)
            drawPaths();
        if (tclen && draw)
            drawTrans();
        if (pathstring && draw)
            drawBezierPath();

        // update texts if need by by calling remove_all and then loading in the datastring
        if (!xylen && !tclen && draw) {
            var dstring = update_datastring();
            remove_all();
            datastring = dstring;
            loadInk(datastring);
        }
    }
    that.resizeObjects = resizeObjects;

    /**
     * Set the variables related to adjustViewBox (original artwork location) using the art proxy,
     * which keeps track of its dimensions
     */
    function retrieveOrigDims() {
        var proxy = $("[data-proxy='" + escape(artName) + "']");
        var kfx = initKeyframe.x;
        var kfy = initKeyframe.y;
        var kfw = initKeyframe.w;
        var real_kfw = origPaperW / kfw;
        var real_kfh = real_kfw * (proxy.data("h") / proxy.data("w"));
        var real_kfx = -kfx * real_kfw;
        var real_kfy = -kfy * real_kfh;
        origpx = real_kfx;
        origpy = real_kfy;
        origpw = real_kfw;
        origph = real_kfh;
        lastpx = origpx;
        lastpy = origpy;
        lastpw = origpw;
        lastph = origph;
    }
    that.retrieveOrigDims = retrieveOrigDims;

    /**
-     * Checks whether two points are effectively the same
     * @param pt1, pt2   the points in question
     * @param err        how close the points have to be to be considered the same
     * @return    whether or not the points are the same (true/false)
     */
    function same_point(pt1, pt2, err) {
        if (err === undefined)
            err = 0.00001;
        return (Math.abs(pt1.x - pt2.x) < err && Math.abs(pt1.y - pt2.y) < err);
    }
    that.same_point = same_point;

    /**
     * Helper function to convert a textbox to a Raphael text element. //========== should be deprecated
     */
    function save_text() {
        var x = svgText.left;// + parseFloat(textboxelmt.css("padding-left")); // a bit hacky -- we should figure out exactly how to compute text positioning
        var y = svgText.top;//tbe_pos.top;// + parseFloat(textboxelmt.css("padding-top")); // parseFloat(fontSize) * ((num_lines + 1) / 2.0) +
        var elt = paper.text(x, y, str); // draw the text on the canvas
        elt.attr("text-anchor", "start");
        var initX = elt.attr("x");
        var initY = elt.attr("y");
        var eltbbox=elt.getBBox();
        elt.data({
            x: initX + parseFloat(textboxelmt.css("padding-left")),//eltbbox.width / 2 + 
            y: initY + eltbbox.height + parseFloat(textboxelmt.css("padding-top")),
            font: fontFamily,
            fontsize: fontSize,
            color: fontColor,
            str: str,
            type: "text",
        });
        update_datastring();
    }
    that.save_text = save_text;

    /**
     * Setter for the artname of a linked ink's associated artwork
     */
    function setArtName(name) {
        artName = name;
    }
    that.setArtName = setArtName;

    /**
     * Set the svg element to handle all pointer events so we can draw on it
     * (and also to prevent manipulation of artwork during ink creation)
     */
    function set_editable() {
        var svgelt = getSVGElement();
        //svgelt.style.zIndex = -1;
        svgelt.style.background = "rgba(0, 0, 0, 0)";
        svgelt.style.pointerEvents = "all";
    }
    that.set_editable = set_editable;

    /**
     * Setter (sets experience id of ink)
     */
    function setEID(inEID) {
        EID = inEID;
    }
    that.setEID = setEID;

    /**
     * Sets the initial artwork keyframe
     */
    function setInitKeyframeData(kf) {
        initKeyframe = kf;
    }
    that.setInitKeyframeData = setInitKeyframeData;

    /**
     * Sets the ink mode
     */
    function set_mode(i) {
        i = parseInt(i,10);
        mode = i;
    }
    that.set_mode = set_mode;

    /**
     * Sets the internal reference to the old opacity of the ink track
     */
    function setOldOpac(val) {
        oldOpac = val;
    }
    that.setOldOpac = setOldOpac;

    /**
     * Similar to the retrieveOrigDims function, but uses a proxy variable.
     */
    function setOrigDims(proxy) {
        var kfx = initKeyframe.x;
        var kfy = initKeyframe.y;
        var kfw = initKeyframe.w;
        var real_kfw = origPaperW / kfw;
        var real_kfh = real_kfw * (proxy.h / proxy.w);
        var real_kfx = -kfx * real_kfw;
        var real_kfy = -kfy * real_kfh;
        origpx = real_kfx;
        origpy = real_kfy;
        origpw = real_kfw;
        origph = real_kfh;
        lastpx = origpx;
        lastpy = origpy;
        lastpw = origpw;
        lastph = origph;
    }
    that.setOrigDims = setOrigDims;

    function resetText() {
        datastring = "";
    }
    that.resetText = resetText;

    /**
     * Similar to add_attributes, gives text boxes drag functionality, drag handles, and undo/redo functionality.
     * @param textbox   the text box in question
     */
    function setTextAttributes(textbox) {
        var C1; //drag handles
        var rds = TAG.TourAuthoring.Constants.inkDragHandleRadius;
        var x = textbox.attrs.x,
            y = textbox.attrs.y,
            origposition = { x: 0, y: 0, },
            c1origposition = { x: 0, y: 0, },
            boundingBox = textbox.getBBox();
        var handlerad = TAG.TourAuthoring.Constants.inkDragHandleRadius;

        // set the positions of C1 and C2 using the styling of textbox
        C1 = paper.ellipse(x, y, rds - 2, rds - 2).attr({ "stroke-width": 2, "stroke": "#ffffff", "fill": "#296B2F", "fill-opacity": 0.8 }).data("type", "grabHandle");
        C1.toFront();
        textbox.toFront();
        C1.data("curr_cx", C1.attr("cx"));
        C1.data("curr_cy", C1.attr("cy"));
        textbox.data({
            'x': x,
            'y': y,
        });

        // drag handler for C1 -- the pan handle.....
        C1.drag(function (dx, dy, mousex, mousey) { // move
            var circleRadius = C1.attr("rx");
            //Hard stops for textbox location in ink canvas
            if (origposition.x + dx <= circleRadius + 5) {
                dx = (circleRadius + 5) - origposition.x;
            }
            if (origposition.y + dy <= circleRadius + 5) {
                dy = (circleRadius + 5) - origposition.y;
            }
            if (origposition.x + dx >= canvwidth - (circleRadius + 5)) {
                dx = canvwidth - (circleRadius + 5) - origposition.x;
            }
            if (origposition.y + dy >= canvheight - (circleRadius + 5)) {
                dy = canvheight - (circleRadius + 5) - origposition.y;
            }

            var c1currx = parseInt(this.data("curr_cx"),10); // x position at the start of drag
            var c1curry = parseInt(this.data("curr_cy"),10);
            var xpos = c1currx + dx; // to get new x position, just add dx
            var ypos = c1curry + dy;
            this.attr({
                cx: xpos, // xcenter
                cy: ypos, // ycenter
            });

            // move the textbox
            textbox.attr("x", origposition.x + dx);
            textbox.attr("y", origposition.y + dy);
        },
        function (x, y) { // start -- record original positions
            origposition.x = parseFloat(textbox.attrs.x);
            origposition.y = parseFloat(textbox.attrs.y);

            var bbox = C1.getBBox();
            c1origposition.x = bbox.x;
            c1origposition.y = bbox.y;
            c1origposition.w = bbox.width;
            c1origposition.h = bbox.height;
        },
        function (x, y) { // stop -- deal with undo/redo functionality
            var c1bboxx = this.getBBox().x;
            var c1bboxy = this.getBBox().y;
            var c1bboxw = this.getBBox().width;
            var c1bboxh = this.getBBox().height;
            this.data("curr_cx", c1bboxx + c1bboxw / 2.0); // reset data using bounding box coords
            this.data("curr_cy", c1bboxy + c1bboxh / 2.0);

            textbox.data({
                "x": textbox.attrs.x,
                "y": textbox.attrs.y
            });

            var bboxx = parseFloat(textbox.attrs.x);
            var bboxy = parseFloat(textbox.attrs.y);

            c1bboxx = C1.getBBox().x;
            c1bboxy = C1.getBBox().y;
            c1bboxw = C1.getBBox().width;
            c1bboxh = C1.getBBox().height;

            var ox = origposition.x;
            var oy = origposition.y;
            var ow = origposition.w;
            var oh = origposition.h;

            var o1x = c1origposition.x;
            var o1y = c1origposition.y;
            var o1w = c1origposition.w;
            var o1h = c1origposition.h;

            var command = TAG.TourAuthoring.Command({
                execute: function () {
                    svgText.attr({ x: bboxx });
                    svgText.attr({ y: bboxy });
                    textbox.attr({ x: bboxx, y: bboxy });
                    textbox.data({ x: bboxx, y: bboxy });

                    C1.data("curr_cx", c1bboxx + c1bboxw / 2.0);
                    C1.data("curr_cy", c1bboxy + c1bboxh / 2.0);
                    C1.attr({
                        cx: c1bboxx + c1bboxw / 2.0,
                        cy: c1bboxy + c1bboxh / 2.0,
                        rx: c1bboxw / 2.0,
                        ry: c1bboxh / 2.0,
                    });
                },
                unexecute: function () {
                    svgText.attr({ x: ox });
                    svgText.attr({ y: oy });
                    textbox.attr({ x: ox, y: oy });
                    textbox.data({ x: ox, y: oy });

                    C1.data("curr_cx", o1x + o1w / 2.0);
                    C1.data("curr_cy", o1y + o1h / 2.0);
                    C1.attr({
                        cx: o1x + o1w / 2.0,
                        cy: o1y + o1h / 2.0,
                    });
                }
            });
            command.execute();
            inkUndoManager.logCommand(command);
        });
    }
    that.setTextAttributes = setTextAttributes;

    /**
     * Takes transparency bounding shapes and converts them to bezier paths
     * @param shapes     array of shapes to convert
     * @return    array of corresponding paths
     */
    function shapes_to_paths (shapes) {
        //takes in an array of shapes, returns an array of paths
        var cw = domelement.width();
        var ch = domelement.height();
        var paths = [];
        remove_all();/////////////////
        for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            var path;
            var type = shape.type.toLowerCase();
            if (shape.type == "rect") { // in this case, bezier path is just four corners with bezier anchors along each segment
                var x = parseFloat(shape.X) / cw;
                var y = parseFloat(shape.Y) / ch;
                var w = parseFloat(shape.w) / cw;
                var h = parseFloat(shape.h) / ch;
                var xoff = 10.0 / cw;
                var yoff = 10.0 / ch;
                path = "M" + x + "," + y + "C" + (x + xoff) + "," + y + "," + (x + w - xoff) + "," + y + "," + (x + w) + "," + y + "C" + (x + w) + "," + (y + yoff) + "," + (x + w) + "," + (y + h - yoff) + "," + (x + w) + "," + (y + h) + "C" + (x + w - xoff) + "," + (y + h) + "," + (x + xoff) + "," + (y + h) + "," + (x) + "," + (y + h) + "C" + x + "," + (y + h - yoff) + "," + (x) + "," + (y + yoff) + "," + (x) + "," + (y) + "z";
            }
            else if (shape.type == "ellipse") { // bezier path is four points (north, east, south, west) with bezier anchors vertical/horizonal from the points a certain distance (given by the 'magic number' below)
                var cx = parseFloat(shape.cx) / cw;
                var cy = parseFloat(shape.cy) / ch;
                var rx = parseFloat(shape.rx) / cw;
                var ry = parseFloat(shape.ry) / ch;
                var k = (4.0 / 3.0) * (Math.sqrt(2) - 1); // 'magic number' defining bezier anchor coordinates for ellipses
                path = "M" + cx + "," + (cy - ry) + "C" + (cx + rx * k) + "," + (cy - ry) + "," + (cx + rx) + "," + (cy - ry * k) + "," + (cx + rx) + "," + cy + "C" + (cx + rx) + "," + (cy + ry * k) + "," + (cx + rx * k) + "," + (cy + ry) + "," + cx + "," + (cy + ry) + "C" + (cx - rx * k) + "," + (cy + ry) + "," + (cx - rx) + "," + (cy + ry * k) + "," + (cx - rx) + "," + cy + "C" + (cx - rx) + "," + (cy - ry * k) + "," + (cx - rx * k) + "," + (cy - ry) + "," + cx + "," + (cy - ry) + "z";
            }
            paths.push(path);
        }
        get_outer_path(paths);
        return paths;
    }
    that.shapes_to_paths = shapes_to_paths;

    /**
     * Debugging function; prints out the ink path in our ink track
     */
    function showInkPath() {
        try {
            console.log("showInkPath gives: " + inktrack.getInkPath());
        }
        catch (err) {
            console.log("error in showInkPath: " + err.message);
        }
    }
    that.showInkPath = showInkPath;

    /**
     * Scales a path representing a transparency/marquee.
     * @param pth               the path whose coordinates we'll scale
     * @param trans_factor_x    scale factor in x-direction
     * @param trans_factor_y    scale factor in y-direction
     * @return   scaled path
     */
    function transform_pathstring_marq (pth, trans_factor_x, trans_factor_y) {
        var nums = pth.match(/[0-9.\-]+/g); // gets coordinates from path
        var newpath = "";
        var j = 0, n = pth.length;
        for (var i = 0; i < n; i++) {
            if ((pth[i] == "M") || (pth[i] == "L")) { // if M or L, need to scale next two coords
                newpath = newpath + pth[i];
                newpath += (parseFloat(nums[j]) * trans_factor_x).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 1]) * trans_factor_y).toFixed(6);
                j = j + 2;
            }
            else if (pth[i] == "C") { // if C, need to scale next six coords
                newpath = newpath + pth[i];
                newpath += (parseFloat(nums[j]) * trans_factor_x).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 1]) * trans_factor_y).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 2]) * trans_factor_x).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 3]) * trans_factor_y).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 4]) * trans_factor_x).toFixed(6) + ",";
                newpath += (parseFloat(nums[j + 5]) * trans_factor_y).toFixed(6);
                j = j + 6;
            }
            else if (pth[i] == "z") { // if z, close path
                newpath += "z";
            }
        }
        return newpath;
    }
    that.transform_pathstring_marq = transform_pathstring_marq;

    /**
     * Returns a string giving all necessary information to recreate the current scene.
     * The result is stored in ink tracks as the 'datastring.' Also used throughout
     * InkAuthoring to make sure we have an up to date datastring. The formats for each
     * type of ink is given below (note that the trailing '[]' makes it easier to parse).
     * Note that the MARQUEE type is deprecated -- it has been replaced by TRANS type
     * transparencies represented by paths rather than collections of rectangles. The
     * BOUNDRECT and BOUNDELLIPSE types are for reloading rectangles and ellipses when we
     * edit transparencies (their formats are identical to RECT/ELLIPSE). All coordinates are relative.
     *
     *   PATH::[pathstring]<svg path string>[stroke]<color>[strokeo]<opacity>[strokew]<width>[]
     *   RECT::[x]<x>[y]<y>[w]<width>[h]<height>[fillc]<color>[fillo]<opac>[strokec]<color>[strokeo]<opac>[strokew]<width>[]
     *   ELLIPSE::[cx]<center x>[cy]<center y>[rx]<x radius>[ry]<y radius>[fillc]<color>[fillo]<opac>[strokec]<color>[strokeo]<opac>[strokew]<width>[]
     *   MARQUEE::[x]<x>[y]<y>[w]<width>[h]<height>[surrfillc]<fill color>[surrfillo]<fill opac>[]
     *   TEXT::[str]<text>[font]<font>[fontsize]<fontsize>[color]<font color>[x]<x>[y]<y>[w]<width>[h]<height>[]
     *   TRANS::[path]<path>[color]<color>[opac]<opac>[mode]<block or isolate>[]
     *   BOUNDRECT::[x]<x>[y]<y>[w]<width>[h]<height>[fillc]<color>[fillo]<opac>[strokec]<color>[strokeo]<opac>[strokew]<width>[]
     *   BOUNDELLIPSE::[cx]<center x>[cy]<center y>[rx]<x radius>[ry]<y radius>[fillc]<color>[fillo]<opac>[strokec]<color>[strokeo]<opac>[strokew]<width>[]
     *
     * @return    up to date datastring
     */
    function update_datastring () {
        var data_string = "";
        var canv_width = domelement.width();
        var canv_height = domelement.height();
        var pth;
        if (currpaths) { // add pen paths to datastring
            if (currpaths.split("Mundefined").length > 1)
                currpaths = currpaths.split("Mundefined").join("");
            data_string += currpaths;
        }
        if (trans_currpath) { // add transparency paths to datastring
            data_string += trans_currpath;
        }
        if (cpathstring) {
            data_string += cpathstring.replace(/undefined/g, '');
        }

        paper.forEach(function (elt) { // now check the canvas for rectangles, ellipses, text, old marquees
            if (elt.data("type") === "rect" && elt.data("visible") === "yes") {
                pth = "RECT::[x]" + rel_dims(elt.attr("x"), canv_width) + "[y]" + rel_dims(elt.attr("y"), canv_height);
                pth += "[w]" + rel_dims(elt.attr("width"), canv_width) + "[h]" + rel_dims(elt.attr("height"), canv_height);
                pth += "[fillc]" + elt.attr("fill") + "[fillo]" + elt.attr("fill-opacity");
                pth += "[strokec]" + elt.attr("stroke") + "[strokeo]" + elt.attr("stroke-opacity") + "[strokew]" + elt.attr("stroke-width") + "[]";
                data_string += pth + "|";
            }
            else if (elt.data("type") === "ellipse" && elt.data("visible") === "yes") {
                pth = "ELLIPSE::[cx]" + rel_dims(elt.attr("cx"), canv_width) + "[cy]" + rel_dims(elt.attr("cy"), canv_height);
                pth += "[rx]" + rel_dims(elt.attr("rx"), canv_width) + "[ry]" + rel_dims(elt.attr("ry"), canv_height);
                pth += "[fillc]" + elt.attr("fill") + "[fillo]" + elt.attr("fill-opacity");
                pth += "[strokec]" + elt.attr("stroke") + "[strokeo]" + elt.attr("stroke-opacity") + "[strokew]" + elt.attr("stroke-width") + "[]";
                data_string += pth + "|";
            }
            else if (elt.data("type") === "marquee") { //old marquees
                pth = "MARQUEE::[x]" + rel_dims(elt.attr("x"), canv_width);
                pth = pth + "[y]" + rel_dims(elt.attr("y"), canv_height);
                pth += "[w]" + rel_dims(elt.attr("width"), canv_width) + "[h]" + rel_dims(elt.attr("height"), canv_height);
                pth += "[surrfillc]" + elt.data("surr-fill") + "[surrfillo]" + elt.data("surr-opac") + "[]";
                data_string += pth + "|";
            }
            else if (elt.data("type") === "text") {
                pth = "TEXT::[str]" + elt.data("str")
                    + "[font]" + elt.data("font")
                    + "[fontsize]" + rel_dims(elt.data("fontsize"), canv_height) //scale font-size
                    + "[color]" + elt.data("color")
                    + "[x]" + rel_dims(elt.data("x"), canv_width)
                    + "[y]" + rel_dims(elt.data("y"), canv_height)
                    + "[w]" + elt.data('w')
                    + "[h]" + elt.data('h')
                    + "[]";
                data_string += pth + "|";
            }
        });
        datastring = data_string;
        return data_string;
    }
    that.update_datastring = update_datastring;

    /**
     * When we load in a path datastring, update ml, xy, and pa to reflect the new data.
     * @param str   the datastring loaded
     */
    function update_ml_xy_pa (str) {
        var i, j;

        // add info to ml and pa
        for (i = 0; i < str.length; i++) {
            if ((str[i] === "L") || (str[i] === "M")) {
                var cpth = str.substring(i).split("|")[0];
                var strokec = get_attr(cpth, "stroke", "s");
                var strokeo = get_attr(cpth, "strokeo", "f");
                var strokew = get_attr(cpth, "strokew", "f");
                ml.push(str[i]);
                pa.push({ "color": strokec, "opacity": strokeo, "width": strokew });
            }
        }

        // add info to xy (probably easier with regular expressions)
        var arr1 = str.split("L");
        for (i = 0; i < arr1.length; i++) {
            if (arr1[i].length > 0) {
                var arr2 = arr1[i].split("M");
                for (j = 0; j < arr2.length; j++) {
                    if (arr2[j].length > 0 && arr2[j].charAt(0) != 'P') {
                        var arr3 = arr2[j].split(",");
                        xy.push([parseFloat(arr3[0]), parseFloat(arr3[1])]);
                    }
                }
            }
        }
        click = false;
    }
    that.update_ml_xy_pa = update_ml_xy_pa;

    /**
     * The following are setters for various ink parameters
     * @param _    the value to be set to the corresponding ink parameter
     */
    function setPenColor(c) { penColor = (c[0] == '#') ? c : ("#" + c); }
    function setPenOpacity(o) { penOpacity = o; }
    function setPenWidth(w) { penWidth = w; }
    function setEraserWidth(w) { eraserWidth = w; }
    function setShapeStrokeColor(c) { shapeStrokeColor = (c[0] == '#') ? c : ("#" + c); }
    function setShapeStrokeOpacity(o) { shapeStrokeOpacity = o; }
    function setShapeStrokeWidth(w) { shapeStrokeWidth = w; }
    function setMarqueeFillColor(c) { marqueeFillColor = (c[0] == '#') ? c : ("#" + c); }
    function setMarqueeFillOpacity(o) { marqueeFillOpacity = o; }
    function setEnabled(en) { enabled = end; }
    function setFontFamily(f) {
        fontFamily = f;
        if (svgText) {
            svgText.attr({
                "font-family": fontFamily,
            });
            svgText.data({
                "font": fontFamily,
            });
        }
    }
    function setFontSize(f) {
        // set the value to "", change font size, reset the value so we can see the results in real-time
        fontSize = f;
        if (svgText) {
            svgText.attr({
                "font-size": fontSize
            });
            svgText.data({
                "fontsize": fontSize
            });
        }
    }
    function setFontColor(f) {
        fontColor = (f[0] == '#') ? f : ("#" + f);
        if (svgText) {
            svgText.attr({
                "fill": fontColor
            });
            svgText.data({
                "color": fontColor
            });
        }
    }
    function setFontOpacity(f) { fontOpacity = f; }
    function setTransMode(m) { trans_mode = m; }

    that.setPenColor = setPenColor;
    that.setPenOpacity = setPenOpacity;
    that.setPenWidth = setPenWidth;
    that.setEraserWidth = setEraserWidth;
    that.setShapeStrokeColor = setShapeStrokeColor;
    that.setShapeStrokeOpacity = setShapeStrokeOpacity;
    that.setShapeStrokeWidth = setShapeStrokeWidth;
    that.setMarqueeFillColor = setMarqueeFillColor;
    that.setMarqueeFillOpacity = setMarqueeFillOpacity;
    that.setEnabled = setEnabled;
    that.setFontFamily = setFontFamily;
    that.setFontSize = setFontSize;
    that.setFontColor = setFontColor;
    that.setFontOpacity = setFontOpacity;
    that.setTransMode = setTransMode;

    /**
     * The following are getters for different ink parameters.
     */
    function getPenColor() { return penColor; }
    function getPenOpacity() { return penOpacity; }
    function getPenWidth() { return penWidth; }
    function getEraserWidth() { return eraserWidth; }
    function getShapeStrokeColor() { return shapeStrokeColor; }
    function getShapeStrokeOpacity() { return shapeStrokeOpacity; }
    function getShapeStrokeWidth() { return shapeStrokeWidth; }
    function getMarqueeFillColor() { return marqueeFillColor; }
    function getMarqueeFillOpacity() { return marqueeFillOpacity; }
    function getEnabled() { return enabled; }
    function getFontFamily() { return fontFamily; }
    function getFontSize() { return fontSize; }
    function getFontColor() { return fontColor; }
    function getFontOpacity() { return fontOpacity; }
    function getTransMode() { return trans_mode; }

    that.getPenColor = getPenColor;
    that.getPenOpacity = getPenOpacity;
    that.getPenWidth = getPenWidth;
    that.getEraserWidth = getEraserWidth;
    that.getShapeStrokeColor = getShapeStrokeColor;
    that.getShapeStrokeOpacity = getShapeStrokeOpacity;
    that.getShapeStrokeWidth = getShapeStrokeWidth;
    that.getMarqueeFillColor = getMarqueeFillColor;
    that.getMarqueeFillOpacity = getMarqueeFillOpacity;
    that.getEnabled = getEnabled;
    that.getFontFamily = getFontFamily;
    that.getFontSize = getFontSize;
    that.getFontColor = getFontColor;
    that.getFontOpacity = getFontOpacity;
    that.getTransMode = getTransMode;

    /**
     * The following are essentially setters, but they take in an id, grab the
     * value of the dom element with that id, and set the correct variable accordingly
     * @param id   the id of the dom element whose value we want to use
     */
    function updatePenColor(id) {
        var val = document.getElementById(id).value;
        //console.log("col = " + val);
        if (val !== undefined) {
            if (val.indexOf("#") == -1)
                val = "#" + val;
            penColor = val;
        }
    }
    function updatePenOpacity(id) {
        var val = document.getElementById(id).value;
        //console.log("opac = " + val);
        if (val !== undefined)
            penOpacity = val;
    }
    function updatePenWidth(id) {
        var val = document.getElementById(id).value;
        //console.log("wid = " + val);
        if (val !== undefined)
            penWidth = val;
    }
    function updateEraserWidth(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            eraserWidth = val;
    }
    function updateShapeStrokeColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6) {
            shapeStrokeColor = "#" + val;
        }
    }
    function updateShapeStrokeOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeStrokeOpacity = val;
    }
    function updateShapeStrokeWidth(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeStrokeWidth = val;
    }
    function updateShapeFillColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6)
            shapeFillColor = "#" + val;
    }
    function updateShapeFillOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            shapeFillOpacity = val;
    }
    function updateMarqueeColor(id) {
        var val = document.getElementById(id).value;
        if (val.length === 6)
            marqueeFillColor = val;
    }
    function updateMarqueeOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined)
            marqueeFillOpacity = val;
    }
    function updateFontFamily(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontFamily = val;
        }
    }
    function updateFontSize(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontSize = parseFloat(val);
        }
    }
    function updateFontColor(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            if (val.indexOf("#") == -1)
                val = "#" + val;
            fontColor = val;
        }
    }
    function updateFontOpacity(id) {
        var val = document.getElementById(id).value;
        if (val !== undefined) {
            fontOpacity = val;
        }
    }

    that.updatePenColor = updatePenColor;
    that.updatePenOpacity = updatePenOpacity;
    that.updatePenWidth = updatePenWidth;
    that.updateEraserWidth = updateEraserWidth;
    that.updateShapeStrokeColor = updateShapeStrokeColor;
    that.updateShapeStrokeOpacity = updateShapeStrokeOpacity;
    that.updateShapeFillColor = updateShapeFillColor;
    that.updateShapeFillOpacity = updateShapeFillOpacity;
    that.updateMarqueeColor = updateMarqueeColor;
    that.updateMarqueeOpacity = updateMarqueeOpacity;
    that.updateFontFamily = updateFontFamily;
    that.updateFontSize = updateFontSize;
    that.updateFontColor = updateFontColor;
    that.updateFontOpacity = updateFontOpacity;

    //////// NEW PATH SMOOTHING CODE //////////
    var points = [],
        roughPoints = [],
        paper,
        thresh = 8,
        closeThresh = 5,
        canBeClosed = false,
        pathstring = "",
        closeCircle,
        old_points = [],
        old_pa = [],
        cpathstring = "",
        old_pathstring = '',
        canvW, canvH;
    domelement.on('mousedown', mstart);
    domelement.on('mouseenter', function() { // change cursor styling here
        domelement.css('cursor', ((mode == 1) || (mode == 2)) ? 'crosshair' : 'pointer');
    });

    function distance(pt1, pt2, cw, ch) {
        var dx = (pt1[0] - pt2[0]) * (cw || 1);
        var dy = (pt1[1] - pt2[1]) * (ch || 1);
        return Math.sqrt(dx*dx + dy*dy);
    }

    // get array of coordinates from a pathstring (x, y, x, y, ...)
    function extractCoords(pthstr) {
        var strCoords = pthstr.match(/[0-9.\-]+/g) || [];
        var coords = [];
        for (var i = 0; i < strCoords.length; i++) {
            coords.push(parseFloat(strCoords[i]));
        }
        return coords;
    }

    // get array of letters from a pathstring ('M', 'R', ' ', ' ', 'M', 'L', ...)
    function extractLetters(pthstr) {
        return pthstr.match(/[MLR ]/g) || [];
    }

    // merge a coordinate array and a letter array to produce a pathstring
    function mergeToPath(letters, coords) {
        var merged = "", i;
        for (i = 0; i < letters.length; i++) {
            merged += letters[i] + coords[2 * i] + "," + coords[2 * i + 1];
        }
        //points = coords.slice(0);
        return merged;
    }

    function saveOldValues() {
        old_pa = pa.slice(0);
        old_pathstring = pathstring;
    }

    // called on mousedown to start drawing
    function mstart(e) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        if (!(mode === 1 || mode === 2)) return;
        canvW = viewerElt.width(),
        canvH = viewerElt.height();
        
        click = true;
        points.length = 0;
        roughPoints.length = 0;

        // for undo/redo
        saveOldValues();

        if (mode === 1) { // draw
            pa.push({ color: penColor, opacity: penOpacity, width: penWidth / canvH });
            points.push([e.offsetX/canvW, e.offsetY/canvH]);
            constructBezierPath();
        } else if (mode === 2) { // erase
            eraseBezier([e.offsetX, e.offsetY]);
            drawBezierPath();
        }
        
        domelement.on('mousemove', mmove);
        domelement.on('mouseup', mend);
        domelement.on('mouseleave', mend);
    }

    // called on mousemove to continue drawing
    function mmove(e) {
        var len = points.length,
            pt = [e.offsetX / canvW, e.offsetY / canvH],
            ptAbs = [e.offsetX, e.offsetY];
        if (mode === 1) { // draw
            //console.log("ptAbs = " + ptAbs[0] + "," + ptAbs[1]);
            if (len === 0 || distance(ptAbs, [points[len - 1][0]*canvW, points[len-1][1]*canvH]) > thresh) {
                roughPoints.length = 0;
                points.push(pt);
                constructBezierPath();
            } else {
                roughPoints.push(pt);
                constructBezierPath();
            }
            //drawBezierPath();
        } else if (mode === 2) { // erase
            eraseBezier([e.offsetX, e.offsetY]);
            drawBezierPath();
        }
    }

    // called on mouseup and mouseleave to stop drawing
    function mend(e) {
        if (points.length > 0) {
            constructBezierPath(true);
        }
        click = false;
        points.length = 0;
        roughPoints.length = 0;
        domelement.off('mousemove');
        domelement.off('mouseup');
        domelement.off('mouseleave');
        var new_data = { pathstring: pathstring, pa: pa };
        var old_data = { pathstring: old_pathstring, pa: old_pa };
        var command = TAG.TourAuthoring.Command({
            execute: function () {
                pathstring = new_data.pathstring;
                pa = new_data.pa.slice(0);
                drawBezierPath();
            },
            unexecute: function () {
                pathstring = old_data.pathstring;
                pa = old_data.pa.slice(0);
                drawBezierPath();
            }
        });
        command.execute();
        inkUndoManager.logCommand(command);

        //console.log('pathstring = '+pathstring);
    }

    // draws either the given path or pathstring if none is provided
    function drawBezierPath(str) {
        var cw = viewerElt.width();
        var ch = viewerElt.height();
        var pathsToDraw=[], pathsToSave='', pathToDraw='';
        var raphaelpath = '',
            roughpath='',
            i, path, circle;
        str = str || pathstring;
        paper.clear();
        if (!str) return;
        var MRL = extractLetters(str);
        var coords = extractCoords(str);
        
        var paCount = 0;
        for (i = 0; i < MRL.length; i++) { //construct the paths
            if (MRL[i] === 'M') {
                pathsToSave += "BEZIER::[pathstring]";
            }
            //console.log("ch*coords["+(2*i+1)+"] = "+ch*coords[2*i+1]);
            pathToDraw += MRL[i] + (cw * coords[2*i]) + ',' + (ch * coords[2*i+1]); // absolute coords
            pathsToSave += MRL[i] + coords[2*i] + ',' + coords[2*i+1]; // relative coords
            if (MRL[i + 1] === 'M' || i === MRL.length - 1) {
                pathsToDraw.push(pathToDraw);
                pathToDraw = '';
                pathsToSave += "[stroke]" + pa[paCount].color + "[strokeo]" + pa[paCount].opacity + "[strokew]" + pa[paCount].width + "[]|";
                paCount++;
            }
        }
        //console.log("to save: "+pathsToSave);
        for (i = 0; i < pathsToDraw.length; i++) { // need to split up the paths so we can style each separately
            //console.log("to draw: " + pathsToDraw[i]);
            var drawing = paper.path(pathsToDraw[i]); // draw the path to the canvas
            drawing.data("type", "bezier");
            drawing.attr({
                "stroke-width": pa[i].width * ch,
                "stroke-opacity": pa[i].opacity,
                "stroke": pa[i].color,
                "stroke-linejoin": "round",
                "stroke-linecap": "round"
            });
        }
        cpathstring = pathsToSave; // currpaths is used in update_datastring as the string representing all paths on the canvas
    }
    that.drawBezierPath = drawBezierPath;

    // constructs bezier path to draw
    function constructBezierPath(clip) {
        var raphaelpath = '',
            roughpath = '',
            i, path, circle, len = points.length, rlen = roughPoints.length,
            p1x = points[0][0], p1y = points[0][1],
            rp1x, rp1y, matches;
        
        if (len === 1) {
            raphaelpath = "M"+p1x+","+p1y+"L"+p1x+","+p1y;
        } else if (len === 2) {
            raphaelpath = "M" + p1x + "," + p1y + "L" + points[1][0] + "," + points[1][1];//+" "+points[1][0]+","+points[1][1];
        } else if (len > 2) {
            raphaelpath = "M"+p1x+","+p1y+"R";
            for (i = 1; i < len; i++) {
                raphaelpath+=((i===1) ? "" : " ")+points[i][0]+","+points[i][1];
            }
        }
        if (rlen > 0) {
            rp1x = roughPoints[0][0];
            rp1y = roughPoints[0][1];
            if(len > 0) {
                for (i = 0; i < rlen; i++) {
                    roughpath+=" "+roughPoints[i][0]+","+roughPoints[i][1];
                }
            } else {
                if (rlen === 1) {
                    roughpath = "M" + rp1x + "," + rp1y + "L" + rp1x + "," + rp1y;
                }
                else if (rlen === 2) {
                    roughpath = "M" + rp1x + "," + rp1y + "L" + roughPoints[1][0] + "," + roughPoints[1][1];
                } else {
                    roughpath = "M" + rp1x + "," + rp1y + "R";
                    for (i = 1; i < rlen; i++) {
                        roughpath += ((i === 1) ? "" : " ") + roughPoints[i][0] + "," + roughPoints[i][1];
                    }
                }
            }
        }
        if(clip) {
            pathstring += raphaelpath;
            matches = pathstring.match(/[MLR ]/g);
            if (matches && matches[matches.length - 1] !== 'L') {
                pathstring += (rlen === 0) ? "" : " " + roughPoints[rlen - 1][0] + "," + roughPoints[rlen - 1][1];
            }
            drawBezierPath();
        } else {
            drawBezierPath(pathstring+raphaelpath+roughpath);
        }
    }

    // erase a portion of the bezier path
    function eraseBezier(location) {
        if (!pathstring) return;
        var cw = domelement.width(),
            ch = domelement.height(),
            coords = extractCoords(pathstring),
            letters = extractLetters(pathstring),
            currentPAIndex = -1;
        //console.log("start pathstring = " + pathstring);
        for (var i = 0; i < letters.length; i++) { // for each coordinate, test for proximity to location
            if (letters[i] === 'M') {
                currentPAIndex++;
            }
            if (distance(location,[cw*coords[2*i], ch*coords[2*i+1]]) < eraserWidth) {
                if (letters[i] === 'M') {
                    if (letters[i + 1] === 'R') {
                        if (letters[i + 3] === 'M' || !letters[i + 3]) { // here, we have M-R-_-M, turn to gone-M-L-M
                            //console.log('case 1');
                            letters.splice(i, 3, 'M', 'L');
                            coords.splice(2*i, 2);
                        } else { // here, M-R-_-_, turn to gone-M-R-_
                            //console.log('case 2');
                            letters.splice(i, 3, 'M', 'R');
                            coords.splice(2 * i, 2);
                        }
                    } else if (letters[i + 1] === 'L') { // M-L-M or M-L-done, turn to gone-M or gone-done
                        //console.log('case 3');
                        letters.splice(i, 2);
                        coords.splice(2 * i, 4);
                        pa.splice(currentPAIndex, 1);
                    }
                } else if (letters[i] === 'L') { // M-L, turn to gone
                    //console.log('case 4');
                    letters.splice(i - 1, 2);
                    coords.splice(2 * (i - 1), 4);
                    pa.splice(currentPAIndex, 1);
                } else if (letters[i] === 'R') {
                    if (letters[i + 2] === 'M' || !letters[i + 2]) { // M-R-_-M or M-R-_-done, turn to gone-M or gone
                        //console.log('case 5');
                        letters.splice(i - 1, 3);
                        coords.splice(2 * (i - 1), 6);
                        pa.splice(currentPAIndex, 1);
                    } else if (letters[i+3] ===' ') { // M-R-_-_-_-, turn to M-R-_-
                        //console.log('case 6');
                        letters.splice(i - 1, 4,'M','R');
                        coords.splice(2 * (i - 1), 4);
                    } else {
                        //console.log('case 6.5');
                        letters.splice(i - 1, 4, 'M', 'L');
                        coords.splice(2 * (i - 1), 4);
                    }
                } else if (letters[i] === " ") {
                    if (letters[i + 1] === 'M' || !letters[i + 1]) {
                        if (letters[i - 1] === 'R') { // M-R-_-M or M-R-_-M, turn to gone-M or gone
                            //console.log('case 7');
                            letters.splice(i - 2, 3);
                            coords.splice(2 * (i - 2), 6);
                            pa.splice(currentPAIndex, 1);
                        } else { // R-_-_-M or R-_-_, turn to R-_
                            //console.log('case 8');
                            letters.splice(i, 1);
                            coords.splice(2 * i, 2);
                        }
                    } else if (letters[i + 1] === ' ' && letters[i + 2] === ' ' && letters[i + 3] === ' ') { // R-_-*-_, turn to R-_-M-R-_
                        //console.log('case 8.1');
                        letters.splice(i, 3, "M", "R");
                        coords.splice(2 * i, 2);
                        pa.splice(currentPAIndex,0,pa[currentPAIndex]);
                    } else if (letters[i + 1] === ' ' && letters[i + 2] === ' ') {
                        //console.log('case 8.2');
                        letters.splice(i,3,"M","L");
                        coords.splice(2 * i, 2);
                        pa.splice(currentPAIndex, 0, pa[currentPAIndex]);
                    } else if (letters[i + 1] === ' ') {
                        //console.log('case 8.3');
                        letters.splice(i,2);
                        coords.splice(2*i,4);
                    } else {
                        //console.log('case 8.4');
                        letters.splice(i,1);
                        coords.splice(2*i,2);
                    }
                }
                //break;
            }
        }
        currentPAIndex = -1;
        var lastM = 0;
        for (i = 0; i < letters.length; i++) {
            if (letters[i] === 'M') {
                lastM = i;
                currentPAIndex++
                if (letters[i + 1] === 'R' && letters[i + 2] !== ' ') {
                    letters.splice(i, 2);
                    coords.splice(2 * i, 4);
                    i--;
                    pa.splice(currentPAIndex, 1);
                    currentPAIndex--;
                    lastM--;
                    continue;
                }
            }
            if (isNaN(coords[2 * i]) || isNaN(coords[2 * i + 1])) {
                for (var j = 0; j < letters.length - i; j++) {
                    if (letters[j + 1] === 'M' && !letters[j + 1]) {
                        letters.splice(lastM, i + j - lastM);
                        coords.splice(2 * lastM, 2 * (i + j - lastM));
                        pa.splice(currentPAIndex, 1);
                        currentPAIndex--;
                        i = lastM;
                        continue;
                    }
                }
            }
        }
        pathstring = mergeToPath(letters, coords);
        if (pathstring.match(/undefined/) || (pathstring && pathstring[0] !== 'M')) {
            console.log('uh oh');
        }
    }
    that.erase = erase;

    // setter for distance between bezier points
    function setThresh(val) {
        thresh = parseInt(val, 10);
    }

    // setter for close path threshold
    function setCloseThresh(val) {
        closeThresh = parseInt(val, 10);
    }
    //////////////////////////////////////////

    // allow drawing on the Raphael paper by recording mouse locations on mousemove events, add coordinates to xl (similar with erase) (old code removed)
    var old_ml = [], old_xy = [], old_pa = [], canvwidth, canvheight;
    
    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.InkTrack');
TAG.Util.makeNamespace('TAG.TourAuthoring.InkType');
TAG.Util.makeNamespace('TAG.TourAuthoring.InkShape');

TAG.TourAuthoring.InkType = {
    text: 1,
    isolate: 2,
    draw: 3,
    block: 4,
    highlight: 5
};

TAG.TourAuthoring.InkShape = {
    rectangle: 1,
    ellipse: 2
};

/**
 * Creates an Ink track
 * @param spec  Specifications (see Track class for details)"
                Additional parameters:
                -- media is ink type
                -- inkSpec is a spec object w/ ink details
                    'text'; optional params 'font', 'pt' for text
                    'drawing' for draw
                    'shape', 'position' (x,y,w,h); optional params 'opacity' for others
 * @param my    After superclass is called, will contain displays and keyframes arrays
 *              Don't pass in unless you are subclassing this
 */
TAG.TourAuthoring.InkTrack = function (spec, my) {
    "use strict";

    /////////////////////////
    // Call super-constructor
    spec.type = TAG.TourAuthoring.TrackType.ink;
    spec.fadeIn = -0.000001;
    spec.fadeOut = -0.000001;
    my = my || {};
    my.inkSpec = spec.inkSpec;
    my.inkType = spec.media; //not used

    var that = TAG.TourAuthoring.Track(spec, my);

    my.track.addClass('ink');
    //my.svg.classed('ink', true);

    // Overwrite toRin()

    // Parent component

    return that;
};
;
 TAG.Util.makeNamespace('TAG.TourAuthoring.Keyframe');

/**
 * Makes a keyframe
 * Associated with a display (keyframe sequence)
 * Maps to keyframe in RIN (duh)
 * @param spec      location (loc - x,y if audio, just x if visual), keyframe svg group (gkey) attrs
 * @param my        Update currentKeyframe param for touch handling, contains timeManager, undoManager, and svg
 */
TAG.TourAuthoring.Keyframe = function (spec, my) {
    "use strict";

    var that = {},
        _data = spec.data || { viewport: { region: { center: { x: 0, y: 0 }, span: { x: 1, y: 1 } } } },
        loc = spec.loc, // location in seconds - {x,y}
        gkey = spec.gkey, // SVG group containing keyframe
        display = spec.display, // containing display
        displayDiv = spec.displayDiv, // div of containing display (we'll append the keyframe divs to this)
        position = 0,
        captureData,
        menu = TAG.TourAuthoring.EditorMenu({
            type: TAG.TourAuthoring.MenuType.keyframe,
            parent: that
        }, my),

        // svg/div variables
        circle, line, innerCircle, offsetx, offsety, hidden = false,

        // keyframe edit command logging functionality
        _updateKeyFrameCommand, needsLogging;

    var KEYFRAME_COLOR = TAG.TourAuthoring.Constants.keyframeColor,
        KEYFRAME_LINE_W = TAG.TourAuthoring.Constants.keyframeLineW,
        KEYFRAME_STROKE_W = TAG.TourAuthoring.Constants.keyframeStrokeW,
        KEYFRAME_SIZE = TAG.TourAuthoring.Constants.keyframeSize,
        T2P = my.timeManager.timeToPx,
        P2T = my.timeManager.pxToTime;

    //that.openMenu = false;
    that.position = 0; 
    that.removed = false;

    function initVisuals() {
        var px_x = my.timeManager.timeToPx(loc.x);
        var px_y = (my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y;
        var keyframeDivs = TAG.Util.UI.createKeyframe({ container: my.track, x: px_x, y: px_y });
        line = keyframeDivs.line,
        circle = keyframeDivs.circ,
        innerCircle = keyframeDivs.innerCirc;

        circle.on('mousedown', function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        innerCircle.on('mousedown', function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        function toggleCircle() {
            hidden = !hidden;
            if (hidden) {
                circle.css('display', 'none');
                innerCircle.css('display', 'none');
            } else {
                circle.css('display', 'block');
                innerCircle.css('display', 'block');
            }
        }
        that.toggleCircle = toggleCircle;
    }
    initVisuals(); // replacing call to initSVG

    function restoreHandlers() {
        circle.off('mousedown');
        innerCircle.off('mousedown');

        circle.on('mousedown', function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });

        innerCircle.on('mousedown', function (e) {
            var offsetX = e.offsetX,
                offsetY = e.offsetY;
            _keyframeMousedown(offsetX, offsetY);
        });
    }
    that.restoreHandlers = restoreHandlers;

    function _keyframeMousedown(mouseoffsetx, mouseoffsety) {
        var oldlocx = loc.x, // for command logging
            oldlocy = loc.y;

        // Stop playback on mousedown
        my.timeManager.stop();

        // Setting movement related vars
        offsetx = mouseoffsetx;
        offsety = mouseoffsety;
        my.currentKeyframe = that;
        $('body').on('mouseup.keyframe', function () {
            var command, newlocx, newlocy;
            my.currentKeyframe = null;
            offsetx = null;
            offsety = null;
            $('body').off('mouseup.keyframe');

            // If movement has occured, update and log command for undo/redo
            if (loc.x !== oldlocx || loc.y !== oldlocy) {
                my.update();
                newlocx = loc.x;
                newlocy = loc.y;
                command = TAG.TourAuthoring.Command({
                    execute: function () {
                        loc.x = newlocx;
                        loc.y = newlocy;
                        scale();
                        my.update();
                    }, unexecute: function () {
                        loc.x = oldlocx;
                        loc.y = oldlocy;
                        scale();
                        my.update();
                    }
                });
                my.undoManager.logCommand(command);
            }
        });
    }

    function resetVisuals() {
        var px_x = T2P(loc.x);
        circle.css({
            "left": px_x - 21 - 5 + "px",
            "top": ((my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y) - 21 - 5 + "px"
        });
        innerCircle.css({
            "left": px_x - 17 + "px",
            "top": ((my.type !== TAG.TourAuthoring.TrackType.audio) ? 48 : loc.y) - 17 + "px"
        });
        line.css("left", px_x - 3 / 2 + "px");
    }
    that.resetVisuals = resetVisuals;

    function initSVG() {
        var timex = my.timeManager.timeToPx(loc.x);

        // Remember: svg height is just 100%!

        // middle marking line
        line = gkey.append('line')
            .attr('x1', timex).attr('y1', '0%')
            .attr('x2', timex).attr('y2', '100%')
            .attr('style', 'stroke:' + TAG.TourAuthoring.Constants.keyframeColor + '; stroke-width:' + TAG.TourAuthoring.Constants.keyframeLineW + ';');

        // keyframe circle
        circle = gkey.append('circle')
                     .attr('style', 'stroke:' + TAG.TourAuthoring.Constants.keyframeColor
                     + '; fill:white; stroke-width:' + TAG.TourAuthoring.Constants.keyframeStrokeW + ';');
        //circle.on('mousedown', function (d, i) {
        //    var mouse = d3.mouse(circle[0][0]);
        //    _keyframeMousedown(mouse[0] - parseInt(this.getAttribute('cx')), mouse[1] - parseInt(this.getAttribute('cy')));
        //});

        $(circle[0][0]).on('mousedown', function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            var offsetY = e.offsetY;
            _keyframeMousedown(offsetX - parseInt(circle.attr('cx'), 10), offsetY - parseInt(circle.attr('cy'), 10));
        });

        if (my.type !== TAG.TourAuthoring.TrackType.audio) { // set vertical positioning of non-audio keyframes
            loc.y = 48;
        }
        circle.attr('cx', timex)
                  .attr('cy', loc.y) // TODO: convert linear scale to dBFS (logarithmic for even fades)
                  .attr('r', TAG.TourAuthoring.Constants.keyframeSize);

        innerCircle = gkey.append('circle')
                        .attr('cx', timex)
                        .attr('cy', loc.y)
                        .attr('r', TAG.TourAuthoring.Constants.innerKeyframeSize)
                        .attr('style', 'display:none; stroke:' + TAG.TourAuthoring.Constants.keyframeColor + '; fill:' + TAG.TourAuthoring.Constants.keyframeColor + '; stroke-width:0;');
        //innerCircle.on('mousedown', function (d, i) {
        //    var mouse = d3.mouse(circle[0][0]);
        //    _keyframeMousedown(mouse[0] - parseInt(this.getAttribute('cx')), mouse[1] - parseInt(this.getAttribute('cy')));
        //});

        $(innerCircle[0][0]).on('mousedown', function (e) {
            console.log("using new events");
            var offsetX = e.offsetX;
            var offsetY = e.offsetY;
            _keyframeMousedown(offsetX - parseInt(innerCircle.attr('cx'), 10), offsetY - parseInt(innerCircle.attr('cy'), 10));
        });

        function toggleCircle() {
            hidden = !hidden;
            if (hidden) {
                circle.attr('display', 'none');
                innerCircle.attr('display', 'none');
            } else {
                circle.attr('display', null);
                innerCircle.attr('display', null);
            }
        }
        that.toggleCircle = toggleCircle;

        /**
         * Helper function to set currentKeyframe and other vars in prep for movement
         */
        function _keyframeMousedown(mouseoffsetx, mouseoffsety) {
            var oldlocx = loc.x, // for command logging
                oldlocy = loc.y;

            // Stop playback on mousedown
            my.timeManager.stop();

            // Setting movement related vars
            offsetx = mouseoffsetx;
            offsety = mouseoffsety;
            my.currentKeyframe = that;
            $('body').on('mouseup.keyframe', function () {
                var command, newlocx, newlocy;
                my.currentKeyframe = null;
                offsetx = null;
                offsety = null;
                $('body').off('mouseup.keyframe');

                // If movement has occured, update and log command for undo/redo
                if (loc.x !== oldlocx || loc.y !== oldlocy) {
                    my.update();
                    newlocx = loc.x;
                    newlocy = loc.y;
                    command = TAG.TourAuthoring.Command({
                        execute: function () {
                            loc.x = newlocx;
                            loc.y = (my.type === TAG.TourAuthoring.TrackType.audio) ? newlocy : 48;
                            scale();
                            my.update();
                        }, unexecute: function () {
                            loc.x = oldlocx;
                            loc.y = (my.type === TAG.TourAuthoring.TrackType.audio) ? oldlocy : 48;
                            scale();
                            my.update();
                        }
                    });
                    my.undoManager.logCommand(command);
                }
            });
        }
    }
    //initSVG();

    (function initMenu() {
        menu.addInput('Time', TAG.TourAuthoring.MenuInputFormats.minSec,
            getTime, setTime);
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            menu.addInput('Volume', TAG.TourAuthoring.MenuInputFormats.percent,
                getVolume, setVolume);
        }
        menu.addButton('Delete', 'left', removeHelper);
        //menu.addButton('Duplicate', 'left', duplicate);
        menu.addButton('Close', 'right', menu.forceClose);
    })();

    //function duplicate() {
    //    var copyTo = Math.min(display.getEnd(), loc.x + TAG.TourAuthoring.Constants.epsilon),
    //        newKey = display.addKeyframe(copyTo);

    //    newKey.loadRIN({ state: _data });
    //}

    function removeHelper() {
        remove(true);
    }
    that.removeHelper = removeHelper;

    function remove(displayRemoved, preventClose) {
        closeMenu(preventClose);
        var index,
            command = TAG.TourAuthoring.Command({
            execute: function () {
                index = display.removeKeyframe(that);
                circle.remove();
                line.remove();
                innerCircle.remove();
                that.removed = true;
                display.getTrack().drawLines();
                scale();
                my.update();
            }, unexecute: function () {
                reactivateKeyframe();
                display.insertKeyframe(that, index);
                display.getTrack().drawLines();
                scale();
                my.update();
            }
        });
        command.execute();
        if (displayRemoved) {
            my.undoManager.logCommand(command);
        }
    }
    that.remove = remove;

    function reactivateKeyframe() {
        that.removed = false;
        initVisuals();//initSVG();
    }
    that.reactivateKeyframe = reactivateKeyframe;

    function updatePosition(newpos) {
        position = newpos;
    }
    that.updatePosition = updatePosition;

	function getPosition() {
		return position;
	}
	that.getPosition = getPosition;

	function getCaptureData() {
	    return captureData;
	}
	that.getCaptureData = getCaptureData;

    function closeMenu(preventClose) {
        menu.close(preventClose);
    }
    that.closeMenu = closeMenu;

    function menuIsOpen() {
        return menu.menuCloseable;
    }

    function setMenuCloseable(state) {
        menu.menuCloseable = state;
    }

    // handles long press on a keyframe
    function rightTapped(evt) {
        menu.open(evt);
    }
    that.rightTapped = rightTapped;

    function tapped(evt) {
        my.timeManager.seek(loc.x);
        setSelected();
    }
    that.tapped = tapped;

    var setSelectedDebounced = $.debounce(250, function () {
        if (my.type !== TAG.TourAuthoring.TrackType.audio) {
            my.selectedKeyframe = that;
            $('.keyframeInnerCirc').css('background-color', '#ffffff');
            circle.css({ 'background-color': 'white' });
            innerCircle.css('background-color', '#296b2f');

            var currData = _data;
            var command = createKeyframeCommand();
            //my.undoManager.logCommand(command);
            _updateKeyFrameCommand = command;
        }

        function createKeyframeCommand() {
            return TAG.TourAuthoring.Command({
                execute: function () {

                },
                unexecute: function () {
                    _data = currData;
                    my.update();

                    if (my.selectedKeyframe === that) {
                        _updateKeyFrameCommand = createKeyframeCommand();
                        needsLogging = true;
                    }
                }
            });
        }
    });

    /**
     * functions for changing keyframe style based on selected status
     */
    function setSelected(forceInstant) {
        //if (my.type !== TAG.TourAuthoring.TrackType.audio) {
        //    my.selectedKeyframe = that;
        //    $("circle").css({ 'fill': 'white' });
        //    innerCircle.attr('style', 'display: inherit; fill: #296b2f');

        //    var currData = _data;
        //    var command = createKeyframeCommand();
        //    if (!delayLogging) {
        //        my.undoManager.logCommand(command);
        //    }
        //    needsLogging = !!delayLogging; // convert null or undefined to false
        //    _updateKeyFrameCommand = command;
        //}

        function createKeyframeCommand() {
            return TAG.TourAuthoring.Command({
                execute: function () {

                },
                unexecute: function () {
                    _data = currData;
                    my.update();

                    if (my.selectedKeyframe === that) {
                        _updateKeyFrameCommand = createKeyframeCommand();
                        needsLogging = true;
                    }
                }
            });
        }

        if (forceInstant) {
            my.selectedKeyframe = that;
            circle.css({ 'background-color': 'white' });
            innerCircle.css({'display': 'inherit','background-color': '#296b2f'});
        } else {
            setSelectedDebounced();
        }
    }
    that.setSelected = setSelected;

    function setDeselected() {
        _updateKeyFrameCommand = null;
        my.selectedKeyframe = null;
        innerCircle.css('background-color', 'white');
    }
    that.setDeselected = setDeselected;


    
    // Gets x location (time in px) of keyframe
    function getTime() {
        return loc.x;
    }
    that.getTime = getTime;

    function setTime(newtime) {
        var timex,
            keyframes = display.getKeyframes(),
            leftbound = (position > 0)
                        ? Math.max(keyframes[position - 1].getTime(), display.getStart())
                        : display.getStart(),
            rightbound = (position + 1 < keyframes.length)
                        ? Math.min(keyframes[position + 1].getTime(), display.getEnd())
                        : display.getEnd();

        loc.x = Math.constrain(newtime,
                                leftbound + TAG.TourAuthoring.Constants.epsilon,
                                rightbound + TAG.TourAuthoring.Constants.epsilon);

        timex = my.timeManager.timeToPx(loc.x);
        circle.css('left', (timex - 21 - 5)+"px"); // DON'T HARDCODE
        line.css('left', (timex - 3/2)+"px");
        innerCircle.css('left', (timex - 17)+"px");
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            display.getTrack().drawLines();
        }

        setDeselected();
    }
    that.setTime = setTime;

    // Gets y location (volume in px) of keyframe
    function getVolumePx() {
        return loc.y;
    }
    that.getVolumePx = getVolumePx;

    // Gets volume (in percent) of keyframe
    function getVolume() {
        return heightToPercent(loc.y);
    }
    that.getVolume = getVolume;

    /**
     * Sets keyframe volume
     * @param newvolume     new volume in percent
     */
    function setVolume(newvolume) {
        loc.y = percentToHeight(Math.constrain(newvolume, 0, 100));
        circle.css('top', (loc.y - 21 - 5)+"px");
        innerCircle.css('top', (loc.y - 17)+"px");
        my.that.drawLines();
    }
    that.setVolume = setVolume;

    // generate vertical fader value out of 100% based on track height constant
    function heightToPercent(height) {
        //rounds to 2 decimal places
        return (Math.round(((TAG.TourAuthoring.Constants.trackHeight - height) * 100 / TAG.TourAuthoring.Constants.trackHeight) * 100) / 100);
    }

    // generate raw height value from percentage vertical fader value
    function percentToHeight(percent) {
        return TAG.TourAuthoring.Constants.trackHeight - (percent * TAG.TourAuthoring.Constants.trackHeight / 100);
    }

    // Gets containing display
    function getContainingDisplay() {
        return display;
    }

    // Gets whether the keyframe has been removed
    function isRemoved() {
        return that.removed;
    }
    that.isRemoved = isRemoved;
    that.getContainingDisplay = getContainingDisplay;

    /**   
     * Logic for manipulation + dragging of keyframes
     * Moves keyframe to an absolute position given in res
     * currentKeyframe and offsets should be set, see initSVG / _keyframeMousedown for details
     * Automatically bounds keyframe movement to associated display
     * @param res           event from makeManipulable, onManipulate
     * @param leftbound     leftmost position keyframe can move to (not required)
     * @param rightbound    rightmost position keyframe can move to (not required)
     */
    function move(res, leftbound, rightbound) {
        var timex;

        // If no bounds are set, keyframe can be anywhere within display except non-negative times
        leftbound = leftbound || 0;
        rightbound = rightbound || Infinity;

        // error checking
        if ((!offsetx && offsetx !== 0) || (!offsety && offsety !== 0) || !my.currentKeyframe) {
            console.log('Move keyframe called when no keyframe is selected!');
        }
        // Editing
        else {
            loc.x = Math.constrain(my.timeManager.pxToTime(res.pivot.x - offsetx),
                                    Math.max(leftbound, display.getStart()) + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.fadeBtnSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.keyframeSize),
                                    Math.min(rightbound, display.getEnd()) - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.fadeBtnSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.keyframeSize));
            if (loc.x < display.getStart() || loc.x > display.getEnd()) {
                loc.x = (display.getStart() + display.getEnd()) / 2;
            }
            if (loc.x < leftbound) {
                loc.x = leftbound;
            }
            if (loc.x > rightbound) {
                loc.x = rightbound;
            }
            timex = my.timeManager.timeToPx(loc.x);
            circle.css('left', (timex - 21 - 5)+"px"); // DON'T HARDCODE
            line.css('left', (timex-3/2)+"px");
            innerCircle.css('left', (timex - 17)+"px");
            if (my.type === TAG.TourAuthoring.TrackType.audio) { // Change y loc only if keyframe is audio
                loc.y = Math.constrain(res.pivot.y - offsety, 0, TAG.TourAuthoring.Constants.trackHeight); // bound y movement to svg!
                circle.css('top', (loc.y - 21 - 5) + "px");
                innerCircle.css('top', (loc.y - 17) + "px");
                display.getTrack().drawLines();
                // leave as pixel values
            } else {
                loc.y = 48;
            }
            setDeselected();
            //my.update();
            // TODO: command logging
        }
    }
    that.move = move;

    /**
     * Used to debug move from command line
     * Flips internal state to simulate clicks
     * Resets state when finished
     * Use only in test code or functions inside display
     */
    function internalMove(x, y, leftbound, rightbound) {
        var res = {
            pivot: { x: x, y:y}
        };
        offsetx = 0;
        offsety = 0;
        my.currentKeyframe = that;

        move(res, leftbound, rightbound);
        display.sortKeyframes();
        my.update();

        offsetx = null;
        offsety = null;
        my.currentKeyframe = null;
    }
    that.internalMove = internalMove;

    /**
     * Translates keyframe by t secs
     * @param t     amount of translation
     */
    function translate(t) {
        var timex;
        //loc.x = !isNaN(loc.x) ? Math.constrain(loc.x + t, display.getStart(), display.getEnd()) : Math.constrain(t, display.getStart(), display.getEnd());
        loc.x = Math.constrain(loc.x + t, display.getStart(), display.getEnd());
        timex = my.timeManager.timeToPx(loc.x);
        circle.css('left',( timex - 21 - 5)+"px");
        line.css('left', (timex - 3/2)+"px");
        innerCircle.css('left', (timex - 17)+"px");
        setDeselected();
        //newVal.val(createminsec(loc.x));
        //my.update();
    }
    that.translate = translate;

    /**
     * Called when ratio of time to pixels is changed
     * Just resets positioning of keyframes
     */
    function scale() {
        var timex = my.timeManager.timeToPx(loc.x);
        circle.css({'left': (timex - 21 - 5) + "px", 'top': (loc.y-21-5)+"px"});
        line.css('left', (timex - 3/2)+"px");
        innerCircle.css({ 'left': (timex - 17) + "px", 'top': (loc.y - 17) + "px" });
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            display.getTrack().drawLines();
        }
    }
    that.scale = scale;

    /**
     * Converts the y location of the keyframe onto scale from 0 to 1
     * 0 is bottom of timeline, 1 is top
     * Scale is linear
     * Used for audio keyframes only
     */
    function ypixToVolume() {
        return Math.constrain((TAG.TourAuthoring.Constants.trackHeight - loc.y) / TAG.TourAuthoring.Constants.trackHeight, 0, 1);
    }

    /**
     * Maps keyframe to RIN keyframe
     */
    function toRIN() {
        var keyframe;
        switch (my.type) {
            case TAG.TourAuthoring.TrackType.artwork:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: _data
                    /*data: { // Need to determine where keyframe info is getting stored, also why does it need a media source?
                        'default': _data,
                        TransitionTime: "<TransitionTime>3</TransitionTime>",
                        PauseDuration: "<PauseDuration>1</PauseDuration>",
                        keyframeThumbnail: "<Thumbnail></Thumbnail>"
                    }*/
                };
                break;
            case TAG.TourAuthoring.TrackType.image:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: _data
                };
                break;
            case TAG.TourAuthoring.TrackType.audio:
                keyframe = {
                    offset: loc.x - display.getStart(),
                    init: false,
                    holdDuration: 0,
                    state: { // Need to determine where keyframe info is getting stored, also why does it need a media source?
                        'sound': {
                            'volume': ypixToVolume()
                        }
                    }
                };
                break;
            default:
                console.log('RIN track type not yet implemented');
                break;
        }
        return keyframe;
    }
    that.toRIN = toRIN;

    /**
     * Initializes keyframe using RIN data
     * @param data      keyframe in RIN xml format
     */ 
    function loadRIN(data) {
        captureData = data;
        if (data.state) {
            _data = data.state;
        }
        else if (data.data) {
            var xml = data.data.default,
            center = {
                x: Number((/Viewport_X='([^']+)'/.exec(xml))[1]),
                y: Number((/Viewport_Y='([^']+)'/.exec(xml))[1])
            },
            span = {
                x: Number((/Viewport_Width='([^']+)'/.exec(xml))[1]),
                y: Number((/Viewport_Height='([^']+)'/.exec(xml))[1])
            };
            _data = {
                viewport: {
                    region: {
                        center: center,
                        span: span
                    }
                }
            };
            // parse into new format
        }
        if (_updateKeyFrameCommand) {
            (function (command) {
                command.execute = function () {
                    _data = data;
                    my.update();
                    _updateKeyFrameCommand = command;
                    needsLogging = false;
                };
            })(_updateKeyFrameCommand);

            if (needsLogging) {
                my.undoManager.logCommand(_updateKeyFrameCommand);
                needsLogging = false;
            }
        }
    }
    that.loadRIN = loadRIN;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.PlaybackControl');

/**
 * Component menu at the bottom of the screen
 * Contains controls for playing and seeking tour
 * @param spec      timeManager attr undoManager
 * @param my        not used
 */
TAG.TourAuthoring.PlaybackControl = function (spec, my) {
    "use strict";

    var that = {},
        bottombar = $(document.createElement('div')),
        playing = false,//keeps track of when the player is on
        undoManager = spec.undoManager,
        timeManager = spec.timeManager,
        viewer = spec.viewer,
        timeline = spec.timeline,
        root = spec.root,
        playHeadGroup,//represents the black, long playhead
        lastScale = timeManager.getDuration().scale;//stores the scale of the timeline, which can change because of zoom (?)

    (function _createHTML() {
        bottombar.css({
            "background-color": "rgb(219,218,199)",
            "height": "9.25%",
            "width": "96.95%", "bottom": "0%",
            'margin-left': '1.25%',
            "position": "absolute",
            "box-shadow": "0px -16px 14px -14px #888",
            'z-index': '102',

        });
        bottombar.attr('id', 'playback-controls');

        // Play button
        var playButton = $(document.createElement('img'));
        playButton.css({
            "margin-top": "1%",
            'margin-left': '2%',
            'width': '4%',
            'height': '60%',
            "position": "relative",
            'display': 'inline-block'
        });
        playButton.attr('src', tagPath + 'images/icons/Play.svg');
        playButton.attr('id', 'playButton');
        playButton.click(function () { // Start and stop playback
            togglePlay();
        });
        bottombar.append(playButton);

        //allow space bar to play/pause
        root.on('keyup', function (evt) { // Start and stop playback
            if (evt.which === 32) {
                togglePlay();
            }
        });

        $('#rinContainer').on('click', function (event) {
            event.preventDefault();
            event.stopPropagation();
        });

        function togglePlay() {
            if (!timeline.getEditInkOn()) {
                if (!playing) {
                    timeManager.play();
                } else {
                    timeManager.stop();
                }
            }
        }

        // on play and stop update the play button image and internal state
        timeManager.onPlayStart(function () {
            playButton.attr('src', tagPath + 'images/icons/Pause.svg');
            playing = true;
        });
        timeManager.onStop(function () {
            playButton.attr('src', tagPath + 'images/icons/Play.svg');
            playing = false;
        });

        // Playhead Location slider
        var playheadLocContainer = $(document.createElement('div'));
        playheadLocContainer.attr('id', 'playhead-location');
        playheadLocContainer.css({
            'margin-left': '12%', 'height': '100%', 'margin-top': '1%',
            'width': '37.5%', 'position': 'relative', 'display': 'inline-block', 'vertical-align': 'middle',
            'color': 'black',
        });
        bottombar.append(playheadLocContainer);

        // Label for control
        var locationLabel = $(document.createElement('label'));
        locationLabel.attr('id', 'playLabel');
        locationLabel.text('Timeline Overview');
        locationLabel.css({
            'font-weight': '600', 'font-size': '0.8em',//TAG.Util.getFontSize(150)
            'margin': '0px 2% 0px 0px',
            'top': '4%',
            'vertical-align': 'top',
            'position': 'relative',
            'display':'inline-block'
        });
        playheadLocContainer.append(locationLabel);

        //container for slider
        var sliderContainer = $(document.createElement('div'));
        sliderContainer.attr('id', 'sliderContainer');
        sliderContainer.css({
            'position': 'absolute', 'width': '40%', 'height': '100%', 'margin-top': '-2%', 'display': 'inline-block',
        });
        playheadLocContainer.append(sliderContainer);

        // Container and background for Slider
        var slider = $(document.createElement('div'));
        slider.attr('id', 'timelineSlider');
        slider.css({
            'position': 'relative', 'margin-left': '4%', 'display': 'inline-block', 'width': '100%', 'height': '20%',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', 'background-color': 'white', 'margin-top': '8.5%',
        });
        sliderContainer.append(slider);

        // HK25
        // Slider box to display the current view of the timeline

        // Hardcoded the slider box width currently as the css width of tracks region and time ruler returned 0.
        // The hardcoded value is the inital value for the track.
        var sliderBoxWidth = 125;
        var sliderBox = $(document.createElement('div'));
        sliderBox.attr('id', 'timelineSliderBox');
        sliderBox.css({
            'position': 'absolute', 'width': sliderBoxWidth + 'px',
            'height': '130%', 'border': '2px none black', 'margin-top': '-2%'
        });
        sliderBox.draggable({
            // Updates the view using the element id. Be careful changing element ids
            axis: 'x',
            drag: function (evt, ui) {
                if (timeline.getEditInkOn()) {
                    return false;
                }

                //var tracks = $('.track');
                // Be careful changing timelineSliderBox border!
                var sliderMax = slider.width() - sliderBox.width();//-7; Why was this here? jake

                ui.position.left = Math.constrain(ui.position.left, 0, sliderMax);

                var leftt = (ui.position.left / (sliderMax + Math.ceil(sliderBox.width())) * timeline.getTimeRuler().width());
                timeline.registerUpdateSlider(null);
                timeline.getTrackBody().scrollLeft(leftt);
                timeline.cancelAccel();
                timeline.registerUpdateSlider(sliderBoxUpdate);
                //tracks.css('left', leftt + 'px')
                //playhead.css('left', leftt + 'px')
            }
        });
        slider.append(sliderBox);

        sliderBox.mousedown(function (evt) {
            evt.stopPropagation();
        });



        //represents the green part of the timeline for artworks and the gray part for inks -- indicates the length
        var greenBoxInSlider = $(document.createElement('div'));
        greenBoxInSlider.css({
            'background-color': 'DarkGreen', 'top': '10%', 'height': '80%', 'position': 'absolute',
            'width': '100%', 'border': '2px solid black',
        });
        sliderBox.append(greenBoxInSlider);

        // Fader
        var fader = createPlayhead();
        fader.css({
            'height': '155%', 'width': '0%', 'margin-top': '-4%',
            'position': 'absolute', 'left': '0%'
        });
        fader.attr('id', 'fader');
        fader.draggable({
            axis: 'x',
            drag: function (event, ui) {//changes ui on dragging end keyframes
                if (timeline.getEditInkOn()) {
                    return false;
                }
                var sliderWidth = slider.width();
                ui.position.left = Math.constrain(ui.position.left, 0, sliderWidth);

                var percent = Math.constrain(ui.position.left / (sliderWidth - fader.width()), 0, 1);
                timeManager.seekToPercent(percent);
            },
            stop: function () {
                if (fader.offset().left > slider.offset().left + slider.width()) {
                    fader.css('left', slider.width() + 'px');
                }
            }
        });
        var faderUpdate = function (ev) {
            fader.css('left', ((fader.offsetParent().width() - fader.width()) * ev.percent) + 'px');
        };
        that.faderUpdate = faderUpdate;

        function updateFader() {
            timeManager.onSeek(faderUpdate);
            timeManager.onPlay(faderUpdate);
            timeManager.onSizing(faderUpdate);
            slider.append(fader);
        }
        that.updateFader = updateFader;
        updateFader();

        var sliderLabel = $(document.createElement('label'));
        sliderLabel.attr('id', 'playhead-position');
        sliderLabel.css({
            'position': 'relative',
            'left': '45%',
            'color': 'black',
            'display': 'inline-block',
            'font-weight': '600',
            'font-size': '0.8em',//TAG.Util.getFontSize(150)
            'margin': '0px 2% 0px 0px',
            'top': '4%',
            'vertical-align': 'top',
        });
        sliderLabel.text('0:00/1:00');
        var labelUpdate = function (ev) {
            var current = timeManager.getCurrentTime();
            var end = timeManager.getDuration().end;
            var timeLeft;
            var timeRight;

            if (isNaN(current) || isNaN(end)) {
                timeLeft = '0:00';
                timeRight = '0:00';
            } else {
                timeLeft = timeManager.formatTime(current);
                timeRight = timeManager.formatTime(end);
            }
            sliderLabel.text(timeLeft + '/' + timeRight);
        };
        timeManager.onSeek(labelUpdate);
        timeManager.onPlay(labelUpdate);
        timeManager.onSizing(labelUpdate);
        playheadLocContainer.append(sliderLabel);

        var zoomSliderContainter = $(document.createElement('div'));
        zoomSliderContainter.css({
            'position': 'relative',
            'display': 'inline-block',
            'width': '20%', 'height': '60%',
            'vertical-align': 'middle',
            'margin-top': '-1%',
            'margin-right': '2%'
        });
        bottombar.append(zoomSliderContainter);

        // Container for smaller lens.png
        var imgContainer = $(document.createElement('div'));
        imgContainer.attr('id', 'imgContainer');
        imgContainer.css({
            'position': 'absolute', 'display': 'inline-block', 'height': '50%'
        });
        zoomSliderContainter.append(imgContainer);

        // lens smaller
        var lensSmaller = $(document.createElement('img'));
        lensSmaller.css({
            "margin-top": "8%",
            'margin-left': '0%',
            'height': '85%',
            'width': 'auto',
            "position": "relative",
            'display': 'inline-block'
        });
        lensSmaller.attr('src', tagPath + 'images/icons/Lens.svg');
        lensSmaller.attr('id', 'lensSmall');
        lensSmaller.click(function () {
            var pos = zoomfader.position().left - 0.1 * (zoomslider.width());
            if (pos >= 0) {
                zoomfader.css('left', pos + "px");
            } else {
                zoomfader.css('left', "0px");
            }
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
        });
        imgContainer.append(lensSmaller);

        // Container and background for zoom bar
        var zoomslider = $(document.createElement('div'));
        zoomslider.attr('id', 'zoomslider');
        zoomslider.css({
            'position': 'absolute', 'display': 'inline-block', 'width': '68%', 'height': '35%', 'margin-top': '2%', 'margin-left': '10%',
            'background-color': 'rgb(136, 134, 134)', "border-radius": "25px"
        });
        zoomslider.mousedown(function (evt) {
            if (evt.which != 1)
                return;
            zoomfader.css('left',
                Math.constrain(evt.pageX - zoomslider.offset().left - zoomfader.width() / 2, 0, zoomslider.width() - zoomfader.width()));
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
            //timeline.onUpdate();
            zoomfader.trigger(evt);
        });
        zoomSliderContainter.append(zoomslider);

        // zoomFader
        var zoomfader = $(document.createElement('div'));
        zoomfader.attr('id', 'zoomPoint');
        var currScale = timeManager.getDuration().scale;
        // Hardcoded the zoomPoint left
        var minScale = 1581 / timeManager.getDuration().end;
        var zoomFaderLeftInit = (currScale - minScale) / (TAG.TourAuthoring.Constants.maxZoom - minScale) * 100;
        zoomfader.css({
            'background-color': 'white', 'height': '110%', 'width': '10%',
            'position': 'absolute', 'top': '-10%', 'left': zoomFaderLeftInit + '%',
            'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%"
        });
        zoomslider.append(zoomfader);
        zoomfader.mousedown(function (evt) {
            evt.stopPropagation();
        });
        zoomfader.draggable({
            axis: 'x', containment: 'parent',
            drag: function () {
                var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
                zoom(percent);
                timeline.cancelAccel();
            }
        });
        $('#timeRuler').livequery(function () {
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
            $('#timeRuler').expire();
        });

        var zoomfaderUpdate = function (ev) {
            zoomfader.css('left', ((zoomfader.offsetParent().width() - zoomfader.width()) * ev.percent) + 'px');
        };

        var oldpercent = 0;
        var oldPos = 0.0;
        var newPos = 0.0;

        // dan zhang - revamped zoom to lock when playhead is onscreen and zoom more intelligently while playhead is offscreen
        // handles zoom
        function zoom(percent) {
            var trackBody = timeline.getTrackBody(),
                timeRuler = timeline.getTimeRuler(),
                dur = timeManager.getDuration(),
                oldScale = dur.scale,
                totalTime = dur.end,
                minScale = trackBody.width() / totalTime,
                newScale = minScale + percent * (TAG.TourAuthoring.Constants.maxZoom - minScale);

            newScale = Math.min(Math.max(newScale, minScale), TAG.TourAuthoring.Constants.maxZoom);
            lastScale = oldScale;

            // zoom is getting called on onSizing now to appropriately adjust to timeline
            // length changes.  Zoom also causes onSizing events to fire when it adjusts
            // the scale, so if the scale doesn't change don't call setScale.   
            if (newScale === oldScale) {
                return;
            }

            // data for zooming
            var viewWidth = trackBody.width();
            var midpoint = viewWidth * 0.5;
            var anchorPoint = viewWidth * 0.45; // see below for explanation
            var oldTrackLength = timeManager.timeToPx(totalTime);
            var newTrackLength = newScale * dur.end; // (px per second) x (total seconds)
            var oldPlayheadPosition = timeManager.timeToPx(timeManager.getCurrentTime());
            var oldWindowPosition = trackBody.scrollLeft();
            var newWindowPosition; //for use later
            // if playhead is onscreen, zooming in and out fixes left viewer boundary at the 
            // same pixel distance to the playhead.
            if (oldPlayheadPosition >= oldWindowPosition && oldPlayheadPosition <= oldWindowPosition + viewWidth) {

                // hack is necessary for the moment because setScale causes the scroll to 
                // crash into the right edge while zooming out by a large magnification 
                // factor. SetScale will need to be restructured or assimilated into zoom 
                // to accomodate an implementation which avoids collisions intelligently.
                if (newScale < oldScale) {
                    //timeRuler.scrollLeft(0);
                    trackBody.scrollLeft(0);
                }

                // checking zoom boundaries and applying scale to timeManager
                if (newScale >= minScale) { // min zoom
                    if (newTrackLength >= trackBody.width()) {
                        timeManager.setScale(newScale);
                    }
                } else if (newScale <= TAG.TourAuthoring.Constants.maxZoom) { // max zoom
                    timeManager.setScale(newScale);
                }
                // end checking zoom boundaries

                // begin zoom functionality
                var leftViewerBoundaryOffset = oldPlayheadPosition - oldWindowPosition;
                var newPlayheadPosition = timeManager.getCurrentPx();
                var windowPosition = newPlayheadPosition - leftViewerBoundaryOffset;
                trackBody.scrollLeft(windowPosition);
                //timeRuler.scrollLeft(windowPosition);

            } else { // if playhead not onscreen, zoom in and zoom out have different anchor points

                // zooming out anchors to center
                if (newScale < oldScale) {
                    // hack is necessary for the moment because setScale causes the scroll to 
                    // crash into the right edge while zooming out by a large magnification 
                    // factor. SetScale will need to be restructured or assimilated into zoom 
                    // to accomodate an implementation which avoids collisions intelligently.
                    //timeRuler.scrollLeft(0);
                    trackBody.scrollLeft(0);

                    // checking zoom boundaries and applying scale to timeManager
                    if (newScale >= minScale) { // min zoom
                        if (newTrackLength >= trackBody.width()) {
                            timeManager.setScale(newScale);
                        }
                    } else if (newScale <= TAG.TourAuthoring.Constants.maxZoom) { // max zoom
                        timeManager.setScale(newScale);
                    }
                    // end scale check

                    // begin zoom functionality
                    // find viewer center's relative position to the entire track length
                    var relativeCenterPosition = (oldWindowPosition + midpoint) / oldTrackLength;

                    // calculate viewer center's new absolute position for new track length
                    var newAbsoluteCenterPosition = relativeCenterPosition * newTrackLength;

                    // determine window position by subtracting midpoint pixel distance
                    newWindowPosition = newAbsoluteCenterPosition - midpoint;

                    // determine practical view window position based on theoretical position and boundaries
                    if (newWindowPosition + viewWidth > newTrackLength) {
                        // at hard right boundary (track end), expand left side
                        //timeRuler.scrollLeft(newTrackLength - viewWidth);
                        trackBody.scrollLeft(newTrackLength - viewWidth);
                    } else if (newWindowPosition < 0) {
                        // at hard left boundary (track start), expand right side
                        //timeRuler.scrollLeft(0);
                        trackBody.scrollLeft(0);
                    } else {
                        // somewhere in between, expand from center as calculated
                        //timeRuler.scrollLeft(newWindowPosition);
                        trackBody.scrollLeft(newWindowPosition);
                    }
                }

                    // zooming in anchors 45% left because we read left-to-right; this makes zoom more intuitive as while you are traversing the timeline you are more likely to be reading from the left side.
                    // eventual TODO: if display or keyframe is selected, anchor (or soft-anchor?) to display or keyframe since keyframe/display selection (keyframes in particular) does not guarantee playhead is onscreen
                else {
                    // checking zoom boundaries and applying scale to timeManager
                    if (newScale >= minScale) { // min zoom
                        if (newTrackLength >= trackBody.width()) {
                            timeManager.setScale(newScale);
                        }
                    } else if (newScale <= TAG.TourAuthoring.Constants.maxZoom) { // max zoom
                        timeManager.setScale(newScale);
                    }
                    // end scale check

                    // begin zoom functionality
                    // find anchor's relative position to the entire track length
                    var relativeAnchorPosition = (oldWindowPosition + anchorPoint) / oldTrackLength;

                    // calculate anchor's new absolute position for new track length
                    var newAbsoluteAnchorPosition = relativeAnchorPosition * newTrackLength;

                    // determine window position by subtracting anchor pixel distance
                    newWindowPosition = newAbsoluteAnchorPosition - midpoint;

                    // and then position window based on theoretical position and boundaries
                    if (newWindowPosition + viewWidth > newTrackLength) {
                        // at hard right boundary (track end), expand left side
                        //timeRuler.scrollLeft(newTrackLength - viewWidth);
                        trackBody.scrollLeft(newTrackLength - viewWidth);
                    } else if (newWindowPosition < 0) {
                        // at hard left boundary (track start), expand right side
                        //timeRuler.scrollLeft(0);
                        trackBody.scrollLeft(0);
                    } else {
                        // somewhere in between, expand from center as calculated
                        //timeRuler.scrollLeft(newWindowPosition);
                        trackBody.scrollLeft(newWindowPosition);
                    }
                }
            }
            oldpercent = percent;
        }

        // Container for bigger lens.png
        var imgContainer2 = $(document.createElement('div'));
        imgContainer2.attr('id', 'imgContainer');
        imgContainer2.css({
            'position': 'absolute', 'display': 'inline-block', 'height': '40%', 'margin-left': '80%'
        });
        zoomSliderContainter.append(imgContainer2);

        // lens bigger
        var lensBigger = $(document.createElement('img')); //larger lens icon, shown on the right
        lensBigger.height = 1;
        lensBigger.width = 1;
        lensBigger.css({
            "margin-top": "-7%",
            'height': '170%',
            'width': 'auto',
            "position": "relative",
            'display': 'inline-block'
        });
        lensBigger.attr('src', tagPath + 'images/icons/Lens.svg');
        lensBigger.attr('id', 'lensBig');
        lensBigger.click(function () {
            var pos = zoomfader.position().left + 0.1 * (zoomslider.width());
            if (pos <= (zoomfader.offsetParent().width() - zoomfader.width())) {
                zoomfader.css('left', pos + "px");
            } else {
                zoomfader.css('left', (zoomfader.offsetParent().width() - zoomfader.width()) + "px");
            }
            var percent = zoomfader.position().left / (zoomfader.offsetParent().width() - zoomfader.width());
            zoom(percent);
        });
        imgContainer2.append(lensBigger);

        //container for volume
        var volumeSliderContainer = $(document.createElement('div'));
        volumeSliderContainer.css({
            'position': 'relative',
            'display': 'inline-block',
            'width': '5%', 'height': '60%',
            'vertical-align': 'middle',
            'margin-top': '-1%',
            'margin-right': '2%'
        });
        bottombar.append(volumeSliderContainer);

        //// Container for the mute image
        //var muteContainer = $(document.createElement('div'));
        //muteContainer.css({
        //    'position': 'absolute', 'display': 'inline-block', 'height': '50%'
        //});
        //volumeSliderContainer.append(muteContainer);

        //// mute volume
        //var muteVolumeImage = $(document.createElement('img'));
        //muteVolumeImage.css({
        //    "margin-top": "1%",
        //    'margin-left': '0%',
        //    'height': '100%',
        //    'width': 'auto',
        //    "position": "relative",
        //    'display': 'inline-block'
        //});
        //muteVolumeImage.attr('src', tagPath + 'images/icons/VolumeDown4.svg');
        //muteVolumeImage.attr('id', 'muteVolume');
        //muteVolumeImage.click(function () {
        //    var pos = volumefader.position().left - 0.1 * (volumeslider.width());
        //    if (pos >= 0) {
        //        volumefader.css('left', pos + "px");
        //    } else {
        //        volumefader.css('left', "0px");
        //    }
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //});
        //muteContainer.append(muteVolumeImage);

        //// Container and background for zoom bar
        //var volumeslider = $(document.createElement('div'));
        //volumeslider.css({
        //    'position': 'absolute', 'display': 'inline-block', 'width': '70%', 'height': '35%', 'margin-top': '2%', 'margin-left': '12%',
        //    'background-color': 'rgb(136, 134, 134)', "border-radius": "25px"
        //});
        //volumeSliderContainer.append(volumeslider);

        //// volumeFader
        //var volumefader = $(document.createElement('div'));
        //volumefader.css({
        //    'background-color': 'white', 'height': '113%', 'width': '13%',
        //    'position': 'absolute', 'top': '-11%', 'right': '0%',
        //    'border': '1px', 'border-style': 'solid', 'border-color': 'gray', "border-radius": "50%"
        //});
        //volumefader.draggable({
        //    axis: 'x', containment: 'parent',
        //    drag: function () {
        //        var percent = Math.constrain(volumefader.position().left / (volumeslider.width()-volumefader.width()), 0, 1);
        //        viewer.volume(percent);
        //        console.log("volume: " + percent);
        //    }
        //});

        //volumeslider.mousedown(function (evt) {
        //    if (evt.which != 1)
        //        return;
        //    volumefader.css('left',
        //        Math.constrain(evt.pageX - volumeslider.offset().left - volumefader.width() / 2, 0, volumeslider.width() - volumefader.width()));
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //    volumefader.trigger(evt);
        //});

        //volumefader.mousedown(function (evt) {
        //    evt.stopPropagation();
        //});

        //volumeslider.append(volumefader);

        //// Container for volume up
        //var volumeContainer = $(document.createElement('div'));
        //volumeContainer.css({
        //    'position': 'absolute', 'display': 'inline-block', 'height': '50%', 'margin-left': '85%'
        //});
        //volumeSliderContainer.append(volumeContainer);

        //// volume up
        //var volumeUpImage = $(document.createElement('img'));
        //volumeUpImage.css({
        //    "margin-top": "1%",
        //    'margin-left': '2%',
        //    'height': '100%',
        //    'width': 'auto',
        //    "position": "relative",
        //    'display': 'inline-block'
        //});
        //volumeUpImage.attr('src', tagPath + 'images/icons/VolumeUp.svg');
        //volumeUpImage.click(function () {
        //    var pos = volumefader.position().left + 0.1 * (volumeslider.width());
        //    if (pos <= (volumeslider.width() - volumefader.width())) {
        //        volumefader.css('left', pos + "px");
        //    } else {
        //        volumefader.css('left', (volumeslider.width() - volumefader.width()) + "px");
        //    }
        //    var percent = Math.constrain(volumefader.position().left / (volumeslider.width() - volumefader.width()), 0, 1);
        //    viewer.volume(percent);
        //});
        //volumeContainer.append(volumeUpImage);

        /**
         * HK25: Wrote this function for updating the slider box as it is moved.
         */
        function sliderBoxUpdate(ev) {
            var timeRuler = timeline.getTimeRuler();
            var trackBody = timeline.getTrackBody();
            ev = ev || timeManager.getDuration();
            var oldWidth = sliderBox.width();

            // Check if the function is getting called before the elements are added to the page
            if (timeRuler.position()) {
                var newWidth = trackBody.width() / timeManager.timeToPx(ev.end) * (slider.width());
                // subtract extra 4px to remove influence of border
                var newLeft = (trackBody.scrollLeft()) / timeManager.timeToPx(ev.end) * (slider.width()) - 2;

                if (newWidth && oldWidth !== Math.ceil(newWidth)) {
                    // If the sliderBox would go past the edge of the slider then adjust
                    // it so that it does not.  This requires moving the timeline to the correct
                    // position to match the sliderBox.
                    if (newWidth + newLeft > slider.position().left + slider.width()) {
                        if (newWidth > slider.width()) {
                            newWidth = slider.width();
                        }
                        newLeft = slider.position().left + slider.width() - newWidth;
                    }
                    sliderBox.css('width', newWidth + 'px');
                }
                sliderBox.css('left', newLeft + 'px');
            }
        }
        // Livequery plugin calls the specified function when the element is
        // actually added to the DOM.  This makes the slider box update for the
        // initial time properly.
        $('#editor').livequery(function () {
            sliderBoxUpdate(timeManager.getDuration());
            $('#editor').expire();
        });
        // Update the sliderBox when the timeManager changes size
        timeManager.onSizing(sliderBoxUpdate);
        timeline.registerUpdateSlider(sliderBoxUpdate);

        //undo/redo buttons

        // create div for undo and redo button
        var undoRedoButtonArea = $(document.createElement('div'));
        var undoRedoInkOnly = $(document.createElement('div'));
        that.undoRedoInkOnly = undoRedoInkOnly;

        undoRedoInkOnly.text("Affects Ink Only");
        undoRedoInkOnly.css({
            "color": "green",
            "margin-top": "-2.5%",
            "position": "relative",
            'display': 'none',
            'margin-left': '10%', 'font-weight': '600', 'font-size': '0.8em'//TAG.Util.getFontSize(150)
        });

        undoRedoButtonArea.css({
            "margin-top": "-2%",
            "position": "relative",
            'z-index': 0,
            'height': '60%',
            'width': '15%',
            'vertical-align': 'middle',
            'display': 'inline-block'
        });
        undoRedoButtonArea.attr('id', 'undoRedoButtonArea');

        var undoRedoButtonCSS = { 'height': '70%', 'width': 'auto', 'margin-left': '15%', 'opacity': '0.4' };

        // undo and redo buttons
        var undoButton = $(document.createElement('img'));
        $(undoButton).addClass('undoButton');
        undoButton.attr('src', tagPath + 'images/icons/Undo.svg');
        undoButton.css(undoRedoButtonCSS);
        undoButton.click(function () {
            undoManager.undo();
        });
        undoRedoButtonArea.append(undoButton);
        that.undoButton = undoButton;

        var redoButton = $(document.createElement('img'));
        $(redoButton).addClass('redoButton');
        redoButton.attr('src', tagPath + 'images/icons/Redo.svg');
        redoButton.css(undoRedoButtonCSS);
        redoButton.click(function () {
            undoManager.redo();
        });
        undoRedoButtonArea.append(redoButton);
        that.redoButton = redoButton;
        undoRedoButtonArea.append(undoRedoInkOnly);
        bottombar.append(undoRedoButtonArea);

        function createPlayhead() {
            var playHeadDiv = $(document.createElement('div'));
            var playheadSVG = d3.select(playHeadDiv[0])
                                        .append("svg")
                                        .style('position', 'absolute')
                                        .style('left', '0px').style('top', '-110%')
                                        .attr("width", '0%')
                                        .attr("height", '100%'); // div to be transformed into an svg group

            playHeadGroup = playheadSVG.append("g");

            var playHeadTop = playHeadGroup.append("circle")
                                       .attr('cx', '0')
                                       .attr('cy', '80%')
                                       .attr('r', '40%')
                                       .attr('fill', 'black')
                                       .attr('stroke', 'black')
                                       .attr('stroke-width', '10%')
                                       .attr('fill-opacity', '0');

            var playHead = playHeadGroup.append("line")
                                             .attr('x1', '0')
                                             .attr('y1', '110%') // 11.4%
                                             .attr('x2', '0')
                                             .attr('y2', '210%')
                                             .attr('pointer-events', 'none')
                                             .attr('stroke', 'black')
                                             .attr('stroke-width', '10%');
            return playHeadDiv;
        }
    })();

    function addToDOM(container) {
        container.appendChild(bottombar[0]);
    }
    that.addToDOM = addToDOM;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.Tests');

/**
UI Tests:
Drag playhead and playback location fader TODO: test ensuring RIN and playhead are synced
Click "Play" button twice (start and stop)
*/

/**
 * Automated tests module for TourAuthoring
 */
TAG.TourAuthoring.Tests = (function () {
    "use strict";

    // Resources to pass to tracks
    var testResources = [
            'http://cs.brown.edu/research/TAG/TAG2.0Data/Documents/monethay/monet%20haystacks/monet%20haystacks.xml',
            'http://cs.brown.edu/research/TAG/TAG2.0Data/Documents/gari/garidz/dz.xml',
            'http://cs.brown.edu/research/TAG/TAG2.0Data/Documents/rembrandtself/rembrandt%20self/rembrandt%20self.xml',
            'http://cs.brown.edu/research/TAG/TAG2.0Data/Documents/marcdream/marc%20dream/marc%20dream.xml',
            'http://cs.brown.edu/research/TAG/TAG2.0Data/Documents/dirck/dirck/dirck.xml',
            'http://10.116.71.58:8086/Images/20121105221815/dz.xml' // Portion of Garibaldi in James' tour
    ],
        testAudio = [
            'http://archive.bsrlive.brown.edu/archives/bsrbonusbeats/kurtboone.mp3', // Ryan's test - an old interview he did - don't mess with - 5.8Mb
            'http://archive.bsrlive.brown.edu/archives/bsrbonusbeats/GaribaldiScene43Tour_mastered.mp3',
            'http://archive.bsrlive.brown.edu/archives/bsrbonusbeats/GariEdit.mp3',
            'http://10.116.71.58:8086/Images/20121104223746.mp3'
        ];

    /**
     * Makes a bunch of tracks and displays and keyframes and adds them to the DOM
     * @param timeline
     */
    function trackEditTest(timeline, timeManager) {
        // Test adding tracks
        var i, displays, rin,
            testtrack, disp0, disp1, keyframe0; // Only holding reference to single track

        // Add a few more for UI checks
        timeline.addAudioTrack(testAudio[0]);
        testtrack = timeline.addArtworkTrack(testResources[0]);
        timeline.addArtworkTrack(testResources[1]);
        timeline.addArtworkTrack(testResources[2]);

        // Test adding displays
        disp0 = testtrack.addDisplay(timeManager.timeToPx(0), 5);
        disp1 = testtrack.addDisplay(timeManager.timeToPx(10), 5);
        testtrack.addDisplay(timeManager.timeToPx(30), 19);
        // test movement
        disp0.internalMove(timeManager.timeToPx(1), 0, 10, 'fade-in', 0);
        disp0.internalMove(timeManager.timeToPx(4), 0, 10, 'fade-out', 0);
        disp0.internalMove(timeManager.timeToPx(4), 0, 10, 'main', 0);
        // test bounding movement
        disp0.internalMove(timeManager.timeToPx(9.8), 0, 10, 'fade-out', 0); // fade-out should collide into next display
        disp0.internalMove(timeManager.timeToPx(-1), 0, 10, 'fade-in', 0); // fade-in collides with 0 secs
        disp0.internalMove(timeManager.timeToPx(0.25), 0, 10, 'fade-out', 0); // fade-out collides with fade-in
        disp0.internalMove(timeManager.timeToPx(9.5), 0, 10, 'main', 0); // right edge should be touching next display
        disp0.internalMove(timeManager.timeToPx(100), 0, 10, 'fade-in', 0); // no change

        displays = testtrack.getDisplays();
        for (i = 0; i < displays.length; i++) {
            console.log(i + ': ' + displays[i].getStart());
        }

        // Keyframes
        keyframe0 = displays[1].addKeyframe(timeManager.timeToPx(12));
        //keyframe move
        keyframe0.internalMove(timeManager.timeToPx(14.5));

        // test movement of display w/ keyframe
        disp1.internalMove(timeManager.timeToPx(15), 10, 30, 'main', 0);
        keyframe0.internalMove(timeManager.timeToPx(15.5));

        // Basic RIN test
        /*$(window).load(function () {
            timeline.onUpdate();
        });*/
        rin = timeline.toRIN(); // easiest way to check basic RIN formatting is prolly breakpoint and read
        timeline.onUpdate();
    }

    /**
     * Makes two tracks w/ alternating display regions and calls onUpdate on the timeline
     */
    function testTrackReload(timeline, timeManager) {
        var i, displays, rin,
            track0 = timeline.addArtworkTrack(testResources[0], "Monet"),
            //track1 = timeline.addArtworkTrack(testResources[1], "Garibaldi"),
            track1 = timeline.addAudioTrack(testAudio[0], "AudioTest");//,
            //track2 = timeline.addArtworkTrack(testResources[2]),
            //track3 = timeline.addArtworkTrack(testResources[3]),
            //track4 = timeline.addArtworkTrack(testResources[4]);

        track0.addDisplay(timeManager.timeToPx(0), 5);
        //track1.addDisplay(timeManager.timeToPx(5), 5);
        track0.addDisplay(timeManager.timeToPx(10), 7);
        //track1.addDisplay(timeManager.timeToPx(17), 8);
        track0.addDisplay(timeManager.timeToPx(25), 10);

        timeline.onUpdate();
    }

    /**
     * Material for demo
     */
    function testDemo(timeline, timeManager) {
        var i, displays, rin,
            track0 = timeline.addArtworkTrack(testResources[0], "Haystacks"),
            track1 = timeline.addArtworkTrack(testResources[1], "Garibaldi Panorama"),
            track2 = timeline.addAudioTrack(testAudio[1], "Audio"),
            disp0, key0, key1;

        //track0.addDisplay(timeManager.timeToPx(0), 8);
        //track1.addDisplay(timeManager.timeToPx(8), 6);
        track0.addDisplay(timeManager.timeToPx(0), 4);
        disp0 = track1.addDisplay(timeManager.timeToPx(4), 10);
        track0.addDisplay(timeManager.timeToPx(14), 5);

        // audio
        track2.addDisplay(timeManager.timeToPx(0), 180);

        key0 = disp0.addKeyframe(timeManager.timeToPx(5));
        key0.loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0' Viewport_Y='-0.09984642817137874' Viewport_Width='1' Viewport_Height='0.2109375'/>");
        key1 = disp0.addKeyframe(timeManager.timeToPx(9));
        key1.loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0.021664630037101146' Viewport_Y='0.00045129340904827893' Viewport_Width='0.049606282874006216' Viewport_Height='0.010463825293735686'/>");
        disp0.addKeyframe(timeManager.timeToPx(13)).loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0.040299281871932956' Viewport_Y='0.00041899765196884864' Viewport_Width='0.049606282874006216' Viewport_Height='0.010463825293735686'/>");

        timeline.onUpdate();
    }

    function testOverlap(timeline, timeManager) {
        var i, displays, rin,
            track0 = timeline.addArtworkTrack(testResources[0], "Haystacks"),
            track1 = timeline.addArtworkTrack(testResources[1], "Garibaldi Panorama"),
            track2 = timeline.addAudioTrack(testAudio[1], "Audio"),
            disp0, key0, key1;

        //track0.addDisplay(timeManager.timeToPx(0), 8);
        //track1.addDisplay(timeManager.timeToPx(8), 6);
        track0.addDisplay(timeManager.timeToPx(0), 4);
        disp0 = track1.addDisplay(timeManager.timeToPx(4), 10);
        track0.addDisplay(timeManager.timeToPx(10), 7);

        // audio
        track2.addDisplay(timeManager.timeToPx(0), 180);

        key0 = disp0.addKeyframe(timeManager.timeToPx(5));
        key0.loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0' Viewport_Y='-0.09984642817137874' Viewport_Width='1' Viewport_Height='0.2109375'/>");
        key1 = disp0.addKeyframe(timeManager.timeToPx(9));
        key1.loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0.021664630037101146' Viewport_Y='0.00045129340904827893' Viewport_Width='0.049606282874006216' Viewport_Height='0.010463825293735686'/>");
        disp0.addKeyframe(timeManager.timeToPx(13)).loadRIN("<ZoomableMediaKeyframe Media_Type='SingleDeepZoomImage' Viewport_X='0.040299281871932956' Viewport_Y='0.00041899765196884864' Viewport_Width='0.049606282874006216' Viewport_Height='0.010463825293735686'/>");

        timeline.onUpdate();
    }

    /**
     * Dumb + fast test of viewer updating using pre-coded TAGTest narrative
     * @param viewer
     */
    function testRINreload(viewer) {
        viewer.loadTour('js/RIN/web/narratives/TAGTest/narrative.js', function () { console.log('TAG RIN data loaded !!! ???'); });
    }

    /**
     * Testing JSON RINdata + server send/recieve
     */
    function testServer() {
        var repository = "http://cs.brown.edu/research/TAG/TAG2.0Data/repository.xml",
            tourdoq;
        TAG.Worktop.Database.load(repository);

        testNewTour();
        //load all tours
        var alltours = TAG.Worktop.Database.getAllTours();
        testModifyTour(alltours[0].Identifier);
        alltours = TAG.Worktop.Database.getAllTours();
        testModifyTour(testNewTour().Identifier);
        alltours = TAG.Worktop.Database.getAllTours();
    }

    /**
     * Test creating tours
     */
    function testNewTour() {
        //create a new tour
        tourdoq = TAG.Worktop.Database.createTour();
        return tourdoq;
    }

    /**
     * Test modification of Name, Content, and Thumbnail fields
     * These are the only fields Tour Authoring needs to worry about
     */
    function testModifyTour(id) {
        //modify/update the tour
        var xml = TAG.Worktop.Database.getDoqXML(id);
        var parser = new DOMParser();
        var tourXML = $(parser.parseFromString(xml, 'text/xml'));
        //change name
        tourXML.find('Name').text("new name");
        //change content, the json object
        tourXML.find("d3p1\\:Key:contains('Content') + d3p1\\:Value").text("[]");
        //change thumbnail
        tourXML.find("d3p1\\:Key:contains('Thumbnail') + d3p1\\:Value").text("http://www.cs.brown.edu/research/TAG/images/waterfallzoom.jpg");
        TAG.Worktop.Database.pushXML(tourXML[0], id, "Tour");
    }

    /**
     * Test deletion
     */
    function testDeleteTour(id) {
        TAG.Worktop.Database.deleteDoq(id, "Tour");
    }

    /**
     * Hack to get audio loaded for editing
     */
    function makeDemo(timeline) {
        timeline.addAudioTrack(testAudio[2], "Audio");
    }

    return {
        trackEditTest: trackEditTest,
        testRINreload: testRINreload,
        testDemo: testDemo,
        testTrackReload: testTrackReload,
        testServer: testServer,
        makeDemo: makeDemo,
        testOverlap: testOverlap
    };
})();
;
TAG.Util.makeNamespace('TAG.TourAuthoring.Timeline');

/**
 * Manages user editing of tracks
 * @param spec      timeManager, undoManager, viewer params
 */
TAG.TourAuthoring.Timeline = function (spec, my) {
    "use strict";

    // Divs that need to be held onto
    var that = {},
        tourExited = false,
        loaded = false, // boolean blocking timeline reloads until tour is fully initialized
        tracks = [],
        mainScrollHider,
        editor,
        trackTitleWrapper,
        timeRuler,
        timeline,
        trackBody,
        playhead, //div containing the playhead svg
        playheadtop, // div containing the playhead handle svg
        playheadSVG,
        playHeadGroup,
        playHeadTop,
        playHead,
        compCont,
        onUpdateNumCalls = 0,
        trackid = 0, // IDs for uniquely identifying tracks
        // docfrag
        docfrag,
        // Handles time stuff
        playbackControls = spec.playbackControls,
        timeManager = spec.timeManager,
        root = spec.root,
        manipObjects = {},
        // undo
        undoManager = spec.undoManager,
        viewer = spec.viewer,
        verticalScroller,
        sliderPane,
        dataHolder = spec.dataHolder,

        lastScale = timeManager.getDuration().scale,
        audioCheck = false,
        videoCheck = false,
        artworkCheck = false,
        imageCheck = false,
        inkCheck = false,
        isMenuOpen, editInkOn = false, modifyingInk = false,

        selectedTrack = {current: null}; // this is an object so contents can be manipulated by track objects
    that.isMenuOpen = false;
    var editInkOverlay = $(TAG.Util.UI.blockInteractionOverlay());//overlay for when 'edit ink' component option is selected while playhead is not over the art track
    editInkOverlay.addClass('editInkOverlay');
    var overlayLabel = $(document.createElement('div'));
    overlayLabel.text("Annotation is being edited...");
    var deleteConfirmationOverlay = $(document.createElement('div'));
    that.editInkOn = false;
    that.clamped_displays = [];

    // Set timeline in viewer
    viewer.setTimeline(that);

    var sendScrollLeft = true;
    var sendScrollTop = true;

    var multiSelection = false;
    var multiSelectionArray = [];//Xiaoyi&Libby

    //!!!!!!
    var editorWidth = $(window).width() * 0.995;
    var editorHeight = $(window).height() * 0.4825;
    //var editorHeight = $(window).height();
    var trackTitleWidth = 0.127 * $(window).width();
    var trackAreaHeight = editorHeight - 5 - TAG.TourAuthoring.Constants.timeRulerSize;
    //var trackAreaHeight = editorHeight;

    // HTML
    (function _makeHTML() {
        // container div that hides vertical scrollbar of top-level container
        mainScrollHider = $(document.createElement('div'));
        mainScrollHider.attr('class', 'mainScrollHider');
        mainScrollHider.css({
            "background-color": "rgb(219,218,199)",
            'overflow': 'hidden',
            'height': editorHeight + 'px',
            'width': editorWidth + 'px',
            'margin-top': '3%',
            'position': 'relative',
        });

        // Top-level container, vertical scrolling
        editor = $(document.createElement('div'));
        editor.attr('id', 'editor');
        editor.css({
            'height': '100%',
            "width": '100%', 
            //'width': '100%',
            'overflow': 'hidden',
        });


        // veil for track title scrollbar
        var trackScrollVeil = $(document.createElement('div'));
        trackScrollVeil.attr('id', 'trackScrollVeil');
        trackScrollVeil.css({
            'width': trackTitleWidth + 20 + 'px',
            'height': trackAreaHeight + 'px',
            'margin-left': $(window).width() * 0.02 - 20 + 'px',
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',
            'float': 'left',
            'clear': 'left',
            'top': '0px',
            'position':'relative'
        });
        // div with track heads, no scrolling at all
        trackTitleWrapper = $(document.createElement('div'));
        trackTitleWrapper.attr('id', 'trackTitleWrapper');
        trackTitleWrapper.css({
            'width': trackTitleWidth + 20 + "px",
            'height': '100%',
            'margin-left': '1.5%',
            'position': 'relative',
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',
            'z-index': '102',
            'background-color': 'rgb(219, 218, 199)',
        });

        // Track body container, xy scrolling
        trackBody = $(document.createElement('div'));
        trackBody.attr('id', 'trackBody');
        trackBody.css({
            'height': trackAreaHeight + 'px',
            'margin-left': '15%',
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',
            'position': 'relative',
        });

        // Ruler for measuring time in the timeline
        // Placed at the top of the timeline
        timeRuler = $(document.createElement('div'));
        timeRuler.css({
            'position': 'relative',
            'height': (TAG.TourAuthoring.Constants.timeRulerSize + 17) + 'px', // changed 12 %
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',
        });
        timeRuler.attr('id', 'timeRuler');

        // Track area div with time ruler and track body, horizontal scrolling
        timeline = $(document.createElement('div'));
        timeline.attr('id', 'timeline');
        timeline.css({
            'height': '200%',
            'width': '97%',
            'overflow': 'hidden',
            'position': 'relative',
        });

        // Cover block to hide playhead outside of display area
        var horizBlock = $(document.createElement('div'));
        horizBlock.attr('id', 'horizBlock');
        horizBlock.css({
            'height': TAG.TourAuthoring.Constants.timeRulerSize + 'px',
            'width': '15.5%',
            "background-color": "rgb(219,218,199)",
            'position': 'absolute',
            'z-index': '102',
        });

        var vertBlock = $(document.createElement('div'));
        vertBlock.attr('id', 'vertBlock');
        vertBlock.css({
            'height': '100%',
            'width': '1.5%',
            "background-color": "rgb(219,218,199)",
            'position': 'absolute',
            'z-index': '102',
        });

        // ruler scrollbar veil
        var rulerScrollVeil = $(document.createElement('div'));
        rulerScrollVeil.attr('id', 'rulerScrollVeil');
        rulerScrollVeil.css({
            'height': TAG.TourAuthoring.Constants.timeRulerSize + 'px',
            'width': '85%',
            'margin-left': '15.4%',
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',

        });

        // time ruler wrapper
        var rulerWrapper = $(document.createElement('div'));
        rulerWrapper.attr('id', 'rulerWrapper');
        rulerWrapper.css({
            'width': '85%',
            'height': (TAG.TourAuthoring.Constants.timeRulerSize) + 'px',
            'overflow-x': 'hidden',
            'overflow-y': 'hidden',
            'position': 'absolute',
            'z-index': '100',
            'box-shadow' : '-7px 5px 10px #888',
        });

        // this function will be called when change tour length to update fader position
        function faderUpdate() {
            timeManager.seek(timeManager.pxToTime(timeManager.getCurrentPx() + trackBody.scrollLeft()));
        }
        that.faderUpdate = faderUpdate;

        manipObjects.ruler = (TAG.Util.makeManipulatable(rulerWrapper[0], {
            onManipulate: function (res) {
                rulerWrapper.scrollLeft(rulerWrapper.scrollLeft() - res.translation.x);
                manipObjects.track.cancelAccel();
            },
            onScroll: function (delta) {
                var close = getCloseMenu();
                if (close) {
                    close();
                }

                if (delta === 1.1) {
                    rulerWrapper.scrollLeft(rulerWrapper.scrollLeft() - 30);
                } else {
                    rulerWrapper.scrollLeft(rulerWrapper.scrollLeft() + 30);
                }

                manipObjects.track.cancelAccel();
            },
            onTapped: function (evt) {
                if (modifyingInk) {
                    return false;
                }
                timeManager.seek(timeManager.pxToTime(evt.position.x + trackBody.scrollLeft()));
            }
        }));

        var toMoveLR = 0;
        var throttleLR;
        var toMoveUD = 0;
        var throttleUD;
        manipObjects.track = (TAG.Util.makeManipulatable(trackBody[0], {
            onManipulate: function (res) {
                manipObjects.ruler.cancelAccel();
                if (res.translation.x !== 0) {
                    console.log('trans = '+res.translation.x);
                    console.log('pivot = '+res.pivot.x);
                    trackBody.scrollLeft(trackBody.scrollLeft() - res.translation.x);
                }
                if (res.translation.y !== 0) {
                    if (calculateTotalTrackHeight() > trackBody.height()) {
                        var newY = trackBody.scrollTop() - res.translation.y;
                        trackBody.scrollTop(newY);
                        scrollWithBody(newY);
                    }
                }
            }
        }));

        rulerWrapper.scroll(function (evt) {
            if (sendScrollLeft) {
                sendScrollLeft = false;
                trackBody.scrollLeft(rulerWrapper.scrollLeft());
            } else {
                sendScrollLeft = true;
            }
        });

        trackTitleWrapper.scroll(function (evt) {
            if (sendScrollTop) {
                sendScrollTop = false;
                trackBody.scrollTop(trackTitleWrapper.scrollTop());
                scrollWithBody(trackTitleWrapper.scrollTop());
            } else {
                sendScrollTop = true;
            }
        });

        trackBody.scroll(function (evt) {
            if (sendScrollLeft) {
                sendScrollLeft = false;
                rulerWrapper.scrollLeft(trackBody.scrollLeft());
            } else {
                sendScrollLeft = true;
            }

            // Would be nice to figure out a way to avoid calling this unnecessarily
            // (ie. when the slider is moved)
            if (updateSlider) updateSlider();
            
            _seekPlayhead();

            if (sendScrollTop) {
                sendScrollTop = false;
                if (calculateTotalTrackHeight() < trackBody.height()) {
                    return;
                }
                trackTitleWrapper.scrollTop(trackBody.scrollTop());
                updateVerticalScroller();
                scrollWithBody(trackTitleWrapper.scrollTop());
            } else {
                sendScrollTop = true;
            }
        });

        var updateSlider = null;
        function registerUpdateSlider(realUpdate) {
            updateSlider = realUpdate;
        }
        that.registerUpdateSlider = registerUpdateSlider;


        var _timeRulerSize = function (ev) {
            timeRuler.css('width', timeManager.timeToPx(ev.end) + 'px');
        };
        _timeRulerSize(timeManager.getDuration());
        timeManager.onSizing(_timeRulerSize);

        /*******************************Xiaoyi/Libby****************************************/
        var multiSelButtonPanel = $(document.createElement('div'));
        multiSelButtonPanel.addClass("multiSelButtonPanel");
        multiSelButtonPanel.css({
            'top': '11%',
            'left': '25%',
            'position': 'relative',
            "width": '60%',
            'height': '75%',
            'float': 'left',
            'z-index': '5',
        });

        var multiSelButton = $(document.createElement('button')).css('border-radius', '3.5px');
        multiSelButton.attr('type', 'button');
        multiSelButton.attr('id', "multiSelButton");
        multiSelButton.text("Multi-Select");
        multiSelButton.attr('type', 'button');

        var multiSelButtonSpecs = TAG.Util.constrainAndPosition($(window).width() * 0.8, $(window).height() * 0.08,
        {
            center_v: true,
            width: 0.1,
            height: 0.42,
        });
        var fontsize = TAG.Util.getMaxFontSizeEM('Multi-Select', 0.2, 0.6 * multiSelButtonSpecs.width, 0.75 * multiSelButtonSpecs.height, 0.01);

        multiSelButton.css({
            "color": "black",
            "border-color": "black",
            //"left": "5%",
            //'top': '3%',
            "position": "absolute",
            "font-size": fontsize,
            'float': 'left',
            width: multiSelButtonSpecs.width + 'px',
            height: multiSelButtonSpecs.height + 'px',
        });
        
        $(multiSelButton).click(function () {
            if (getEditInkOn() === true) {
                //multiSelButton.css({
                //    'color': 'gray',
                //});
                return false;
            }
            if (multiSelection === true) {
                multiSelection = false;
                multiSelButton.css({
                    'color': 'black',
                    'background-color': 'transparent',
                    "border-color": "black"
                });
            }
            else {
                multiSelection = true;
                multiSelButton.css({
                    'color': 'white',
                    'background-color': 'darkgreen',
                    "border-color": "white",
                });
            }
        });

        editInkOverlay.css({
            top: TAG.Util.Constants.timeRulerSize,
            width: '100%',
            height: '100%',
            'margin-left': "2%",
            'position': 'absolute',
            'z-index': '10000',
            'background-color': 'rgba(0, 0, 0, 0.5)'
        });

        overlayLabel.css({
            'position': 'relative',
            'left': '33.5%',
            'top': '35%',
            'font-size': '22pt',
        });

        editInkOverlay.hide();

        // Container and background for Slider
        sliderPane = $(document.createElement('div'));
        sliderPane.attr('id', 'verticalSliderPane');
        sliderPane.css({
            'position': 'absolute',
            'left': '97.35%',
            'top': 54 + 'px',
            'display': 'inline-block',
            'width': '1%',
            'height': trackAreaHeight - 8 + 'px',
        });
        
        var sliderParts = createVerticalScroller(sliderPane);
        sliderPane.append(sliderParts[0]);
        sliderPane.append(sliderParts[1]);

        // appending elements to documentFragment, which is then appended in AddToDOM method
        docfrag = document.createDocumentFragment();

        docfrag.appendChild(mainScrollHider[0]);
            mainScrollHider.append(editor); // editor => horiz scrolling hider
                editor.append(timeline); // track body + ruler area => editor
                        multiSelButtonPanel.append(multiSelButton);
                        horizBlock.append(multiSelButtonPanel);
                    timeline.append(horizBlock);
                    timeline.append(vertBlock);
                    timeline.append(rulerScrollVeil);
                        rulerScrollVeil.append(rulerWrapper);
                            rulerWrapper.append(timeRuler);
                editor.append(sliderPane);
                editor.append(editInkOverlay);
                    editInkOverlay.append(overlayLabel);
                    timeline.append(trackScrollVeil);
                        trackScrollVeil.append(trackTitleWrapper); // track head panel => editor
                    timeline.append(trackBody);

               

        var constrainedHeight = editorHeight - 5;
        var constrainedWidth = editorWidth - 17;
        mainScrollHider.css({
            'height': constrainedHeight + "px",
            'width': constrainedWidth + "px",
        });
        multiSelButton.fitText(0.8);

        /***************************************************************************/
        ///////////
        // Playhead
        //Creating the svg version of the playhead. -David Correa
        playheadSVG = d3.select(timeline[0])
                                    .append("svg")
                                    .style('position', 'absolute')
                                    .style('left', '0px').style('top', '0px')
                                    .attr('id', 'playhead')
                                    .attr("width", '0%')
                                    .style("z-index","101")
                                    .attr("height", '100%'); // div to be transformed into an svg group
        var rawSvgElem = playheadSVG[0][0];

        playHeadGroup = playheadSVG.append("g").attr("transform", "translate(5,0)");
        var rawGElem = playHeadGroup[0][0];

        playHeadTop = playHeadGroup.append("circle")
                                   .attr('cx', '0')
                                   .attr('cy', '27px')
                                   .attr('r', '18px')
                                   .attr('fill', 'black')
                                   .attr('stroke', 'black')
                                   .attr('stroke-width', '7px')
                                   .attr('fill-opacity', '0');
        
        playHead = playHeadGroup.append("line")
                                         .attr('x1', '0')
                                         .attr('y1', '45px') // 11.4%
                                         .attr('x2', '0')
                                         .attr('y2', '100%')
                                        .attr('pointer-events', 'none')
                                         .attr('stroke', 'black')
                                         .attr('stroke-width', '1px');

        var $body = $('body');
        playHeadGroup.on('mousedown', function () {
            var start, startTime, time;

            start = d3.mouse($body[0])[0];
            startTime = timeManager.getCurrentPx();

            $body.on('mousemove.playhead', function (ev) {
                if (editInkOn === true) {      
                    return false;
                }
                time = startTime + (ev.pageX - start);
                // Don't let the playhead be moved out of bounds
                if (time > $('#timeRuler').width()) {
                    time = $('#timeRuler').width();
                } else if (time < 0) {
                    time = 0;
                } else {
                    // Only update start if the mouse isn't out of bounds so the mouse
                    // correctly synchronizes with the playhead.
                    start = ev.pageX;
                }
       
                timeManager.seek(timeManager.pxToTime(time));
                startTime = time;
            });
            $body.on('mouseup.playhead', function () {
                $body.off('mousemove.playhead');
                $body.off('mouseup.playhead');
            });
        });

        var _seekPlayhead = function () {
            var time = timeManager.getCurrentPx(); // fix editor.width() * 0.15 -- if we ever change the margin of trackBody, this will be really confusing!
            playHeadGroup.attr("transform", "translate(" + (time + editor.width() * 0.15 - trackBody.scrollLeft()) + ")");
        };

        timeManager.onSeek(_seekPlayhead);
        timeManager.onSizing(_seekPlayhead);
        timeManager.onPlay(_seekPlayhead);
    })();

    function showEditorOverlay() {
        $('#resizeButton').attr('src', tagPath + 'images/icons/Ellipsis_gray.svg');
        setEditInkOn(true);
        $('#multiSelButton').css({
            'color': 'gray',
            'border-color': 'gray'
        });
           
        playHeadTop.attr('fill', 'gray');
        playHeadTop.attr('stroke', 'gray');

        
        var overlayLabelSpec = TAG.Util.constrainAndPosition(editInkOverlay.width(), editInkOverlay.height(),
            {
                center_h: true,
                center_v: true,
                width: 0.3,
                height: 0.2,
                max_width: 550,
                max_height: 100, 
            });

        var labelFontSize = TAG.Util.getMaxFontSizeEM("Annotation is being edited...", 0, overlayLabelSpec.width - 10, overlayLabelSpec.height, 0.01);

        overlayLabel.css({
            top: overlayLabelSpec.y + 'px',
            left: overlayLabelSpec.x + 'px',
            width: overlayLabelSpec.width + 'px',
            height: overlayLabelSpec.height + 'px',
            'font-size': labelFontSize,
            'overflow': 'hidden',
        });
        
        editInkOverlay.show();
    }
    that.showEditorOverlay = showEditorOverlay;

    function hideEditorOverlay() {
        $('#resizeButton').attr('src', tagPath + 'images/icons/dragTourWindowTwoBars.svg');
        setEditInkOn(false);
        $('#multiSelButton').css({
            'color': 'black',
            'border-color':'black'
        });
        playHeadTop.attr('fill', 'black');
        playHeadTop.attr('stroke', 'black');
        editInkOverlay.hide();
    }
    that.hideEditorOverlay = hideEditorOverlay;

    // Creating a vertical scroll visualizer widget
    function createVerticalScroller(container) {
        var elements = [];
        var widget = $(document.createElement('div'));
        widget.css({
            'position': 'relative',
            'background-color': 'rgb(255,255,255)',
            'width': '70%',
            'left': '15%',
            'height': '100%',
            'overflow': 'hidden',
            'border': '1px solid gray',
        });

        verticalScroller = $(document.createElement('div'));
        verticalScroller.attr('id', 'verticalSlider');
        verticalScroller.css({
            'position': 'absolute',
            'height': '100px',
            'width': '100%',
            'border': '2px none black',
            'left': '-1px',
        });

        verticalScroller.draggable({
            axis: 'y',
            drag: function (evt, ui) {
                evt.stopPropagation();
                ui.position.top = Math.constrain(ui.position.top, 0, sliderPane.height() - verticalScroller.height() - 2);
                var newRelativeScroll = ui.position.top / (sliderPane.height() - verticalScroller.height() - 4);
                var newAbsoluteScroll = newRelativeScroll * (calculateTotalTrackHeight() - trackBody.height() + 8);                

                trackBody.scrollTop(newAbsoluteScroll);
                trackTitleWrapper.scrollTop(newAbsoluteScroll);
                cancelAccel();
            }
        });
        
        elements.push(widget);
        elements.push(verticalScroller);

        verticalScroller.mousedown(function (evt) {
            evt.stopPropagation();
        });

        //represents the green part of the timeline for artworks and the gray part for inks -- indicates the length
        var greenBoxInSlider = $(document.createElement('div'));
        greenBoxInSlider.css({
            'background-color': 'rgb(63, 55, 53)',
            'top': '0%',
            'left': '15%',
            'height': '100%',
            'position': 'absolute',
            'width': '70%',
            'border': '2px solid white',
        });
        verticalScroller.append(greenBoxInSlider);

        return elements;
    }

    // used by vertical position viz to update its location when scrolling occurs on other vertically-scrollable elements.
    function scrollWithBody(scrollPos) {
        var totalTrackHeight = calculateTotalTrackHeight();
        var newTop = scrollPos / totalTrackHeight * sliderPane.height();
        if (newTop < 0) {
            newTop = 0;
        } else if (newTop > sliderPane.height() - verticalScroller.height() - 2) {
            newTop = sliderPane.height() - verticalScroller.height() - 2;
        }
        verticalScroller.css({
            'top': newTop + 'px'
        });
    }

    function updateVerticalScroller() {
        var oldVertHeight = verticalScroller.height();
        var totalTrackHeight = calculateTotalTrackHeight();
        var newTop = trackBody.scrollTop() / totalTrackHeight * sliderPane.height() - 4;
        if (newTop < 0) {
            newTop = 0;
        }

        sliderPane.height(trackTitleWrapper.height() - 10);

        if (verticalScroller.scrollTop() === newTop) {
            return;
        }

        //sliderPane.height(trackTitleWrapper.height() - 10);

        if (totalTrackHeight === 0) { // edge case for no tracks onscreen
            sliderPane.height(trackBody.height() - 10);
            verticalScroller.css({
                'height': sliderPane.height() + 'px',
                'top': '0px',
            });
            enableDisableDrag();
            return;
        }

        if (oldVertHeight !== (trackTitleWrapper.height() - 4) * sliderPane.height() / totalTrackHeight) {
            if (totalTrackHeight < trackTitleWrapper.height()) {
                verticalScroller.css({
                    'height': '100%',
                });
            } else {
                verticalScroller.css({
                    'height': (trackTitleWrapper.height() - 4) * sliderPane.height() / totalTrackHeight + 'px',
                });
            }
            verticalScroller.css({
                'top': newTop + 'px',
            });
        }
    }
    that.updateVerticalScroller = updateVerticalScroller;

    function enableDisableDrag() {
        if (calculateTotalTrackHeight() < trackTitleWrapper.height() - 10) {
            verticalScroller.draggable("disable");
            sliderPane.hide();
            verticalScroller.css({
                'height': '100%',
            });
        } else {
            verticalScroller.draggable("enable");
            sliderPane.show();
            verticalScroller.css({
                'height': (trackTitleWrapper.height() - 4) * sliderPane.height() / calculateTotalTrackHeight() + 'px',
            });
        }
    }
    that.enableDisableDrag = enableDisableDrag;

    function calculateTotalTrackHeight() {
        var i, total = 0;
        for (i = 0; i < dataHolder._trackArray.length; i++) {
            var ct = dataHolder._trackArray[i].track;
            if (ct.getMinimizedState()) {
                total = total + TAG.TourAuthoring.Constants.minimizedTrackHeight;
            } else {
                total = total + TAG.TourAuthoring.Constants.trackHeight;
            }
        }
        return total + dataHolder._trackArray.length * 2; // 2px border per track
    }

    // Updates notches on time ruler when time duration changes (event handler)
    var queue = TAG.Util.createQueue(),
        newLabels = $();
    function _updateTimeMarkers(ev) {
        var i,
            finalTime,
            scale = ev.scale,
            seconds = scale,
            divChilds = timeRuler.children('div'),
            start = Date.now();

        queue.clear();
        newLabels = document.createDocumentFragment();
        divChilds.text('');

        sendScrollLeft = true;
        trackBody.scrollLeft(trackBody.scrollLeft());

        // what are these doing? seems like the second while will push seconds*scale back below 80. What are 80 and 100 here?
        while (seconds * scale < 80) {
            seconds = seconds * 2;
        }

        while (seconds * scale > 100) {
            seconds = seconds / 2;
        }

        seconds = Math.ceil(seconds);
        
        var left = timeManager.pxToTime(trackBody.scrollLeft()),
            leftmod = left - (left % seconds),
            right = left + timeManager.pxToTime(trackBody.width());

        // init w/ markers currently on screen
        //queue.add(function () {
        var j, initLoad = document.createDocumentFragment();
        divChilds.remove();
        for (j = leftmod; j <= right; j += seconds) {
            initLoad.appendChild(createTimeLabel(j)[0]);
        }
        timeRuler.append(initLoad);
        //});

        var perQueueOp = 20,
            opLim = perQueueOp * seconds;

        function newLabelHelper(i) {
            queue.add(function () {
                var j;
                for (j = i; j <= i + opLim; j = j + seconds) {
                    newLabels.appendChild(createTimeLabel(j)[0]);
                }
                //if (i + seconds < ev.end) {
                //    newLabels.push(createTimeLabel(i + seconds));
                //}
            });
        }
        for (i = ev.start; i <= ev.end; i = Math.min(i + opLim, ev.end)) {
            newLabelHelper(i);
            if (i === ev.end) break;
        }

        // clear and replace once finished
        queue.add(function () {
            var i;
            divChilds.remove();
            timeRuler.append(newLabels);
            console.log('time ruler update elapsed: ' + (Date.now() - start));
        });

        // creates a time label and appends it to the time ruler
        // returns time label
        function createTimeLabel(i) {
            var time = Math.min(i, ev.end),
                timeString = timeManager.formatTime(i),
                fontsize = TAG.Util.getFontSize(100),
                markLoc = timeManager.timeToPx(i),
                timeLabel = $(document.createElement('div'))
                            .addClass('time-label')
                            .text(timeString)
                            .css({
                                'border-width': '0px 0px 0px 1px',
                                'border-color': 'black',
                                'border-style': 'solid',
                                'position': 'absolute',
                                'left': markLoc + 'px',
                                'padding-left': '5px',
                                'font-size': '.65em',
                                //'font-weight': '200',
                                'color': 'black',
                                'height': '100%',
                            });
            return timeLabel;
        }
    }
    _updateTimeMarkers(timeManager.getDuration()); // Initialization
    timeManager.onSizing(function (ev) {
        timeRuler.children('div').text('');
        setTimeout(function () {
            _updateTimeMarkers(ev);
        }, 2);
    });

    // PUBLIC FUNCTIONS

    // Add Timeline HTML

    function getEditInkOn() {
        return editInkOn;
    }
    that.getEditInkOn = getEditInkOn;
    
    function setEditInkOn(status) {
        editInkOn = status;
    }
    that.setEditInkOn = setEditInkOn;

    function addToDOM (container) {
        container.appendChild(docfrag);
    }
    that.addToDOM = addToDOM;

    that.selectedTrack = selectedTrack;

    function setCompControl(comp) {
        compCont = comp;
    }
    that.setCompControl = setCompControl;

    function showEditDraw(track,datastring) {
        compCont.showEditDraw(track, datastring);
        modifyingInk = true;
    }
    that.showEditDraw = showEditDraw;

    function showEditText(track,datastring, dims) {
        compCont.showEditText(track, datastring, dims);
        modifyingInk = true;
    }
    that.showEditText = showEditText;

    function showEditTransparency(track, datastring,trans_type) {
        compCont.showEditTransparency(track, datastring, trans_type);
        modifyingInk = true;
    }
    that.showEditTransparency = showEditTransparency;

    function setModifyingInk(state) {
        modifyingInk = state;
    }
    that.setModifyingInk = setModifyingInk;

    function removeInkSession() {
        compCont.removeInkCanv();
        compCont.hideInkControls();
    }
    that.removeInkSession = removeInkSession;

    /**Xiaoyi Libby
    *get the limiting distance for multi select
    *@return bound: the array of the smallest distances
    **/
    function getMSBounds(currentDisplay) {
        //var bounds = [];
        //bounds[0] = Number.MAX_VALUE;
        //bounds[1] = Number.MAX_VALUE;
        //bounds[2] = Number.MAX_VALUE;
        //bounds[3] = Number.MAX_VALUE;
        ////hacky way to solve mutli selection not working when dragging a display with 0 fadeout.
        //var hasZeroFadeout = false;
        //if (currentDisplay) { 
        //    if (currentDisplay.getFadeOut() === 0){
        //        hasZeroFadeout = true;
        //    }
        //}
        ////loop through the four bounds for each selected display and find the smallest distance (in seconds) that 
        ////the displays as a whole will be bounded by
        //for (var i = 0; i < multiSelectionArray.length; i++) {
        //    var currBounds = multiSelectionArray[i].getTrack().boundHelper(multiSelectionArray[i],hasZeroFadeout);
        //    //get the bounds for the each selected display
        //    if (currBounds[0] < bounds[0]) {
        //        bounds[0] = currBounds[0];
        //    }
        //    if (currBounds[1] < bounds[1]) {
        //        bounds[1] = currBounds[1];
        //    }
        //    if (currBounds[2] < bounds[2]) {
        //        bounds[2] = currBounds[2];
        //    }
        //    if (currBounds[3] < bounds[3]) {
        //        bounds[3] = currBounds[3];
        //    }
        //}
        //return bounds;

        /***rewritten using binheaps***/
        /****THIS FUNCTION IS GREATLY REDUCED****/
        //just have each display that is selected push its bounds into the heaps
        //hacky way to solve mutli selection not working when dragging a display with 0 fadeout.
        var hasZeroFadeout = false;
        if (currentDisplay) { 
            if (currentDisplay.getFadeOut() === 0){
                hasZeroFadeout = true;
            }
        }
        //instantiate new binheaps every time the selected displays are dragged
        //so that old bounds do not erroneously conflict with new ones
        dataHolder.reInitHeaps();

        for (var i = 0; i < multiSelectionArray.length; i++) {
            multiSelectionArray[i].getTrack().boundHelper(multiSelectionArray[i], hasZeroFadeout);
        }
    }
    that.getMSBounds = getMSBounds;

    /**Xiaoyi & Libby
    *turn of the button for multi select 
    */
    function turnOffMS() {
        multiSelection = false;
        $('#multiSelButton').css({
            'color': 'black',
            'background-color': 'transparent',
            "border-color": "black"
        });
    }
    that.turnOffMS = turnOffMS;


    var data = [],
        olddata=[];//data stores the current positions for undo, and olddata stores previous positions for redo


    /**Xiaoyi & Libby
    *update the olddata for each selected displays when the mouse goes up
    *this is used in undo/redo to store the previous positions of all of the selected displays
    */
    function updateOldData() {
        /**REWRITTEN WITH BINHEAPS*/
        var selectDisplays = getMultiSelectionArray();
        var selectDisplaysLength = selectDisplays.length;
        if (selectDisplays.length === 0) {
            return;
        }
        olddata = new Array(selectDisplaysLength);
        
        //update bounds
        getMSBounds();
        var leftDist = dataHolder._leftExternal.peek(), //boundArray[0],
            rightDist = dataHolder._rightExternal.peek(); //boundArray[1];
        if (leftDist) { //null checking
            leftDist = leftDist.bound;
        }
        if (rightDist) { //null checking
            rightDist = rightDist.bound;
        }
        for (var i = 0; i < selectDisplaysLength; i++) {
            olddata[i] = new Array(5);
            var leftbound = selectDisplays[i].getStart() - leftDist;
            var rightbound = selectDisplays[i].getEnd() + rightDist;
            olddata[i][0] = selectDisplays[i].getStart();
            olddata[i][1] = selectDisplays[i].getMainStart();
            olddata[i][2] = selectDisplays[i].getOutStart();
            olddata[i][3] = leftbound;
            olddata[i][4] = rightbound;
        }
    }
    that.updateOldData = updateOldData;
    function newDataArray() {
        data = [];
    }
    that.newDataArray = newDataArray;
    function getOldData() {
        return olddata;
    }
    that.getOldData = getOldData;

    /**Xiaoyi & Libby
    *move the selected displays when user drags one of them
    *@param: res: mouse input
    *@param: currentDisplay: the one user is dragging. 
    */
    function moveSelect(res, currentDisplay) {
        //turn off multi-select once any kind of edit is made to the selection
        turnOffMS();
        //move all selected tracks
        /**THIS IS BEING HANDLED DIFFERENTLY WITH BINHEAPS**/
        //var boundArray = getMSBounds(currentDisplay),
        getMSBounds(currentDisplay);
        var leftDist = dataHolder._leftExternal.peek().bound, //boundArray[0],
            rightDist = dataHolder._rightExternal.peek().bound, //boundArray[1],
            fadeInRightDist = dataHolder._leftInternal.peek().bound, //boundArray[2],
            fadeOutLeftDist = dataHolder._rightInternal.peek().bound, //boundArray[3],
            loc = currentDisplay.getLoc(),
            selectDisplays = getMultiSelectionArray(),
            currentDisplayleft = currentDisplay.getStart() - leftDist,
            currentDisplayright = currentDisplay.getEnd() + rightDist,
            translation = currentDisplay.getTranslation(res, currentDisplayleft, currentDisplayright, fadeInRightDist, fadeOutLeftDist),//get the distance the display has been dragged
            leftbound,
            rightbound,
            fadeinrightbound,
            fadeoutleftbound;
        var offset = currentDisplay.getOffset();//distance from the main to fadein that user clicks on
        if (data[0] === null || data[0] === undefined) {//update the data for undo at the moment mouse is down, no need to update if user keeps the mouse down and drag multi times.
            data = new Array(getMultiSelectionArray().length);
            for (var i = 0; i < selectDisplays.length; i++) {
                leftbound = selectDisplays[i].getStart() - leftDist;
                rightbound = selectDisplays[i].getEnd() + rightDist;
                fadeinrightbound = selectDisplays[i].getStart() + fadeInRightDist;
                fadeoutleftbound = selectDisplays[i].getEnd() - fadeOutLeftDist;
                if (data[i] === null || data[i] === undefined) {
                    data[i] = new Array(10);
                    data[i][0] = selectDisplays[i].getStart();
                    data[i][1] = selectDisplays[i].getMainStart();
                    data[i][2] = selectDisplays[i].getOutStart();
                    data[i][3] = leftbound;
                    data[i][4] = rightbound;
                    data[i][5] = translation;
                    data[i][6] = loc;
                    data[i][7] = offset;
                    data[i][8] = fadeinrightbound;
                    data[i][9] = fadeoutleftbound;
                }        
            }
        }
        currentDisplay.msMove(selectDisplays, translation);//move all selectedDisplays
    }
    that.moveSelect = moveSelect;


    function getDisplayData() {
        return data;
    }
    that.getDisplayData = getDisplayData;

    
    /**Xiaoyi & Libby
    *deselect all displays when the user clicks white space in track or right clicks on the menu
    */
    function allDeselected() {
        turnOffMS();//turn off the button
        var selectedarray = getMultiSelectionArray();
        var selectednumber = getMultiSelectionArray().length;
        if (selectedarray.length > 0) {
            for (var i = 0; i < selectednumber; i++) {
                selectedarray[0].getTrack().setDisplayDeselected(selectedarray[0], false);
            }
        }
        olddata = [];
        data = [];
        multiSelectionArray = [];
    }
    that.allDeselected = allDeselected;

    /////////
    // TRACKS

    /**
     * Public API for adding tracks (called from ComponentControls)
     * @param media     URL of added resource (for audio, video, artwork)
     * @param track     Associated track (for ink)
     */

    //Xiaoyi Libby
    function getMultiSelection() {
        return multiSelection;
    }
    that.getMultiSelection = getMultiSelection;

    function getMultiSelectionArray() {
        return multiSelectionArray;
    }
    that.getMultiSelectionArray = getMultiSelectionArray;

    function getTrackslength() {
        return tracks.length;
    }
    that.getTrackslength = getTrackslength;

    function getTracks() {
        return tracks;
    }
    that.getTracks = getTracks;
    
    function getTimelineArea() {
        return trackBody[0];
    }
    that.getTimelineArea = getTimelineArea;

    function getTimeRuler() {
        return timeRuler;
    }
    that.getTimeRuler = getTimeRuler;

    function getisMenuOpen() {
        return isMenuOpen;
    }
    that.getisMenuOpen = getisMenuOpen;

    function setisMenuOpen(menustate) {
        isMenuOpen = menustate;
    }
    that.setisMenuOpen = setisMenuOpen;

    var closeMenuHolder;
    function setCloseMenu(closeFunction) {
        closeMenuHolder = closeFunction;
    }
    that.setCloseMenu = setCloseMenu;
    function getCloseMenu() {
        return closeMenuHolder;
    }
    that.getCloseMenu = getCloseMenu;

    var closeableFunction;
    function setCloseableFunction(func) {
        closeableFunction = func;
    }
    that.setCloseableFunction = setCloseableFunction;

    function getCloseableFunction(state) {
        if (closeableFunction) { setTimeout(closeableFunction(state), 0); }
    }
    that.getCloseableFunction = getCloseableFunction;

    /**
     * Utility to get track object from title
     * Used to load ink
     */
    function findTrackByTitle(title) {
        //moved to dataholder
        //var i;
        //for (i = 0; i < tracks.length; i++) {
        //    if (tracks[i].getTitle() === title) {
        //        return tracks[i];
        //    }
        //}
        //return null;
        return dataHolder.findTrackByTitle(title);
    }

    /**
    * searches through all displays and compares end times of each
    * @returns allDisplaysEnd, the highest end time of all displays
    */
    function getLastDisplayTime() {
        //var i, j, displays, allDisplaysEnd = 0, currDisplayEnd;
        //for (i = 0; i < tracks.length; i++) {
        //    displays = tracks[i].getDisplays();
        //    for (j = 0; j < displays.length; j++) {
        //        currDisplayEnd = displays[j].getFadeOut() + displays[j].getOutStart();
        //        if (currDisplayEnd > allDisplaysEnd){
        //            allDisplaysEnd = currDisplayEnd;
        //        }
        //    }
        //}
        //return allDisplaysEnd;
        var i, 
            allDisplaysEnd = 0, 
            tracks = dataHolder.getTracks();
        for (i = 0; i < tracks.length; i++) {
            var endDisplay = dataHolder.maxDisplay(tracks[i].track.getPos());
            var endDisplayTime = endDisplay.display.getFadeOut() + endDisplay.display.getOutStart();
            if (endDisplayTime > allDisplaysEnd) {
                allDisplaysEnd = endDisplayTime;
            }
        }
        return allDisplaysEnd;
    }
    that.getLastDisplayTime = getLastDisplayTime;

    /**
     * Searches list of tracks for track w/ duplicate name
     * If duplicate exists, changes name to prevent duplication
     * @param title     the new title
     * @param id        id of the track whose title is being changed
     */
    function fixTrackTitle(title, id) {
        var i, currTitle, result, j, ct,
            titleExp, //= new RegExp(title + '(?:-([0-9]+))?'),
            extraNums = [],
            finalNum = -1;
        id = id || -1;
        var pattern = new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>/?~！@#￥……&*（）——|{}【】‘；：”“'。，、？]");
        var rs = "";
        for (i = 0; i < title.length; i++) {//removes any irregular characters from title
            rs = rs + title.substr(i, 1).replace(pattern, '');
        }
        titleExp = new RegExp(rs + '(?:-([0-9]+))?'); //checks if there are any numbers added onto the title we have

        //for (i = 0; i < this._trackArray.length; i++) {//for each track
        //    currTitle = this._trackArray[i].getTitle();
        //    ct = "";
        //    for (j = 0; j < currTitle.length; j++) {//remove special characters
        //        ct = ct + currTitle.substr(j, 1).replace(pattern, '');
        //    }
        //    result = titleExp.exec(ct);//check if any numbers added to original

        //    if (result && result[0] === ct && id !== this._trackArray[i].getID()) {
        //        // match
        //        // if there is a trailing number
        //        if (result[1]) {
        //            extraNums.push(parseInt(result[1], 10));
        //        }
        //            // if there is no trailing number, pretend substr is -1
        //        else {
        //            extraNums.push(-1);
        //        }
        //    }
        //}
        dataHolder.mapTracks(function (i) {
            currTitle = i.track.getTitle();
            ct = "";
            for (j = 0; j < currTitle.length; j++) {//remove special characters
                ct = ct + currTitle.substr(j, 1).replace(pattern, '');
            }
            result = titleExp.exec(ct);//check if any numbers added to original

            if (result && result[0] === ct && id !== i.track.getID()) {
                // match
                // if there is a trailing number
                if (result[1]) {
                    extraNums.push(parseInt(result[1], 10));
                }
                    // if there is no trailing number, pretend substr is -1
                else {
                    extraNums.push(-1);
                }
            }
        });

        if (extraNums.length > 0) {
            extraNums.sort(function (a, b) { return a - b; });
            for (i = 0; i < extraNums.length; i++) {
                if (extraNums[i] + 1 !== i) {
                    finalNum = i - 1;
                    break;
                }
                finalNum++;
            }
            if (finalNum !== -1) {
                return title + '-' + finalNum;
            } else { // track w/ no appended number does not already exist
                return title;
            }
        } else {
            return title;
        }
    }
    that.fixTrackTitle = fixTrackTitle;

    function addAudioTrack(media, name, pos, mediaLength) {
        // Add some stuff to spec
        pos = pos || (dataHolder.getSelectedTrack() ? dataHolder.getSelectedTrack().getPos() : 0);
        var spec = {
            dataHolder: dataHolder,
            media: media,
            mediaLength: mediaLength,
            root: root,
            id: pos,
            title: fixTrackTitle(name),
            timeManager: timeManager,
            undoManager: undoManager,
            update: onUpdate,
            timeline: that,
            trackarray: tracks,
            selectedTrack: selectedTrack
        },

        oldPos,

        // Create the track, wrap command
        newTrack = TAG.TourAuthoring.AudioTrack(spec),
        command = TAG.TourAuthoring.Command({
            execute: function () {
                _addTrack(newTrack);
                dataHolder.insertTrack(newTrack, oldPos);
                newTrack.setTitle(newTrack.getTitle());
            },
            unexecute: function () {
                oldPos = newTrack.getPos();
                _removeTrack(newTrack);
            }
        });
        //command.execute();

        _addTrack(newTrack);
        dataHolder.insertTrack(newTrack, pos);
        oldPos = newTrack.getPos();

        if (name) {
            newTrack.setTitle(name);
        }

        undoManager.logCommand(command);

        return newTrack;
    }
    that.addAudioTrack = addAudioTrack;

    function addVideoTrack (media, name, pos, mediaLength,toconvert,converted,firstupload) {
        // Add some stuff to spec
        pos = pos || (dataHolder.getSelectedTrack() ? dataHolder.getSelectedTrack().getPos() : 0);
        var spec = {
            dataHolder: dataHolder,
            media: media,
            mediaLength: mediaLength,
            converted:converted,
            toConvert:toconvert,
            root: root,
            id: pos,
            title: fixTrackTitle(name),
            timeManager: timeManager,
            undoManager: undoManager,
            update: onUpdate,
            timeline: that,
            trackarray: tracks,
            selectedTrack: selectedTrack,
            firstupload:firstupload
        },
        
        oldPos,

        // Create the track, wrap command
        newTrack = TAG.TourAuthoring.VideoTrack(spec),
        command = TAG.TourAuthoring.Command({
            execute: function () {
                _addTrack(newTrack);
                dataHolder.insertTrack(newTrack, oldPos);
                newTrack.setTitle(newTrack.getTitle());
            },
            unexecute: function () {
                oldPos = newTrack.getPos();
                _removeTrack(newTrack);
            }
        });

        //command.execute();

        _addTrack(newTrack);
        dataHolder.insertTrack(newTrack, pos);
        oldPos = newTrack.getPos();

        if (name) {
            newTrack.setTitle(name);
        }

        undoManager.logCommand(command);

        return newTrack;
    }
    that.addVideoTrack = addVideoTrack;

    function addArtworkTrack (media, name, guid, pos) {
        // Add some stuff to spec
        pos = pos || (dataHolder.getSelectedTrack() ? dataHolder.getSelectedTrack().getPos() : 0);
        var spec = {
            dataHolder: dataHolder,
            media: media,
            root: root,
            id: pos,
            guid: guid,
            title: fixTrackTitle(name),
            timeManager: timeManager,
            undoManager: undoManager,
            update: onUpdate,
            timeline: that,
            trackarray: tracks,
            selectedTrack: selectedTrack
        },

        oldPos, // for saving position
        // Create the track, wrap command
        newTrack = TAG.TourAuthoring.ArtworkTrack(spec),
        command = TAG.TourAuthoring.Command({
            execute: function () {
                _addTrack(newTrack);
                dataHolder.insertTrack(newTrack, oldPos);
            },
            unexecute: function () {
                oldPos = newTrack.getPos();
                _removeTrack(newTrack);
            }
        });
        //command.execute();

        _addTrack(newTrack);
        dataHolder.insertTrack(newTrack, pos);
        oldPos = newTrack.getPos();
        
        undoManager.logCommand(command);
        return newTrack; // Return statement for testing purposes only!!! comment out in final build
    }
    that.addArtworkTrack = addArtworkTrack;

    function addImageTrack(media, name, pos) {
        // Add some stuff to spec
        pos = pos || (dataHolder.getSelectedTrack() ? dataHolder.getSelectedTrack().getPos() : 0);
        var spec = {
            dataHolder: dataHolder,
            media: media,
            root: root,
            id: pos,
            title: fixTrackTitle(name),
            timeManager: timeManager,
            undoManager: undoManager,
            update: onUpdate,
            timeline: that,
            trackarray: tracks,
            selectedTrack: selectedTrack
        },

        oldPos,

        // Create the track, wrap command
        newTrack = TAG.TourAuthoring.ImageTrack(spec),
        command = TAG.TourAuthoring.Command({
            execute: function () {
                _addTrack(newTrack);
                dataHolder.insertTrack(newTrack, oldPos);
                newTrack.setTitle(newTrack.getTitle());
            },
            unexecute: function () {
                oldPos = newTrack.getPos();
                _removeTrack(newTrack);
            }
        });
        //command.execute();

        _addTrack(newTrack);
        dataHolder.insertTrack(newTrack, pos);
        oldPos = newTrack.getPos();

        if (name) {
            newTrack.setTitle(name);
        }

        undoManager.logCommand(command);


        return newTrack; // Return statement for testing purposes only!!! comment out in final build
    }
    that.addImageTrack = addImageTrack;

    // Additional param in spec: associated-track (either pass by id or direct reference?)
    function addInkTrack(track, name, inkType, inkSpec, pos) {
        var selected = dataHolder.getSelectedTrack();
        if (!pos) {
            if (selected) {
                pos = selected.getPos();
            } else if (track) {
                pos = track.getPos();
            } else {
                pos = 0;
            }
        } 
        var spec = {
            dataHolder: dataHolder,
            media: inkType,
            root: root,
            inkSpec: inkSpec,
            id: pos,
            title: fixTrackTitle(name),
            timeManager: timeManager,
            undoManager: undoManager,
            update: onUpdate,
            timeline: that,
            trackarray: tracks,
            selectedTrack: selectedTrack,
            //experienceId: selectedTrack
        },

        oldPos,

        // Create the track, wrap command
        newTrack = TAG.TourAuthoring.InkTrack(spec),
        command = TAG.TourAuthoring.Command({
            execute: function () {
                _addTrack(newTrack);
                dataHolder.insertTrack(newTrack, oldPos);
                newTrack.setTitle(newTrack.getTitle());
            },
            unexecute: function () {
                oldPos = newTrack.getPos();
                _removeTrack(newTrack);
            }
        });
        //command.execute();

        _addTrack(newTrack);
        dataHolder.insertTrack(newTrack, pos);
        oldPos = newTrack.getPos();

        if (name) {
            newTrack.setTitle(name);
        }

        undoManager.logCommand(command);

        return newTrack;
    }
    that.addInkTrack = addInkTrack;

    var trackNum = 0;

    /* Fixed by reinitializing the menu whenever it is swapped -Jake
    */

    function _addTrack(track) {
        var i;

        track.addTitleToDOM(trackTitleWrapper);
        track.addEditorToDOM(trackBody);
//        if(verticalSlider.height())
        //track.detach();
        //track.reloadTrack();
        //trackNum += 1;
    }

    function _removeTrack(track) {
        var i;
        //track.updatePos(tracks.indexOf(track));
        dataHolder.removeTrack(track);
        track.updatePos(track.getPos());
        if (track.getType() === TAG.TourAuthoring.TrackType.ink && track.getInkEnabled()) {
            track.getInkLink().removeAttachedInkTrack(track);
        }
        track.detach();
        //tracks.map(function (track, i) {
        //    track.updatePos(i);
        //});
        dataHolder.mapTracks(function (track, i) {
            track.track.updatePos(i);
        });
        onUpdate();
    }
    that.removeTrack = _removeTrack;


    //allows track to prepend itself to DOM.
    function prependAddToDom(track, trackTitle) {
        trackTitleWrapper.prepend(trackTitle);
        trackBody.prepend(track);
    }
    that.prependAddToDom = prependAddToDom;

    function getNumTracks() {
        //return tracks.length;
        return dataHolder.numTracks();
    }
    that.getNumTracks = getNumTracks;

    /**
     * List of related artworks to be registered in database
     * @returns     GUIDs of all artworks loaded into tracks
     */
    function getRelatedArtworks() {
        var track, i, related = [];
        //for (i = 0; i < tracks.length; i++) {
        //    track = tracks[i];
        //    if (track.getType() === TAG.TourAuthoring.TrackType.artwork) {
        //        related.push(track.getGUID());
        //    }
        //}
        dataHolder.mapTracks(function (i) {
            track = i;
            if (track.track.getType() === TAG.TourAuthoring.TrackType.artwork) {
                related.push(track.track.getGUID());
            }
        });
        return related;
    }
    that.getRelatedArtworks = getRelatedArtworks;

    function getTrackBody() {
        return trackBody;
    }
    that.getTrackBody = getTrackBody;

    function getPlayhead() {
        return playheadSVG;
    }
    that.getPlayhead = getPlayhead;

    /**
    * Checks if there are any artworks or images in the timeline
    * Used in ComponentControls to check if ink can be added
    * @returns      true if there are artworks loaded
    */
    function checkForArtworks(numArtworks) {
        //var track, i;
        //for (i = 0; i < tracks.length; i++) {
        //    track = tracks[i];
        //    if (track.getType() === TAG.TourAuthoring.TrackType.artwork || track.getType() === TAG.TourAuthoring.TrackType.image) {
        //        return true;
        //    }
        //}
        //dataHolder.mapTracks(function (i) {
        //    track = i;
        //    if (dataHolder.getType(track.track) === TAG.TourAuthoring.TrackType.artwork || dataHolder.getType(track.track) === TAG.TourAuthoring.TrackType.image) {
        //        return true;
        //    }
        //});]
        for (var i = 0; i < dataHolder._trackArray.length; i++) {
                var track = dataHolder._trackArray[i].track;
                if (track.getType() === TAG.TourAuthoring.TrackType.artwork || track.getType() === TAG.TourAuthoring.TrackType.image) {
                    return true;
                }
        }
        return false;
    }
    that.checkForArtworks = checkForArtworks;

    //this calls component controls from tracks, telling ink to be disabled
    function disableInk() {
        compCont.disableInk();
    }
    that.disableInk = disableInk;

    //used by Track to tell componentcontrols if component options has been clicked
    var fadeHidden = true;
    function setFadeHidden(fade) {
        fadeHidden = fade;
    }
    that.setFadeHidden = setFadeHidden;

    //used in componentcontrols to check if component options has been clicked
    function isFadeHidden() {
        return fadeHidden;
    }
    that.isFadeHidden = isFadeHidden;

    /**
     * Call when tour has been fully initialized
     * RIN reloads fired by edits are blocked until this is called!
     */
    function setLoaded() {
        loaded = true;
        undoManager.setInitialized(true);
    }
    that.setLoaded = setLoaded;

    /**
     * Updates selected keyframe (or new keyframe) w/ keyframe data from RIN
     * @param trackName     name of the track whose media is being manipulated
     * @param capture       keyframe data in RIN format (needs to be parsed)
     * @param select        whether receiving keyframe should be selected
     */
    function receiveKeyframe(trackName, capture, select) {
        //for (i = 0; i < tracks.length; i++) {
        //    track = tracks[i];
        //    // If this is the track pass on the keyframe data
        //    if (track.getTitle() === trackName) {
        //        track.receiveKeyframe(capture, select);
        //        return;
        //    }
        //}
        for (var i = 0; i < dataHolder._trackArray.length; i++) {
            var currentTrack = dataHolder._trackArray[i].track;
            // If this is the track pass on the keyframe data
            if (currentTrack.getTitle() === trackName) {
                currentTrack.receiveKeyframe(capture, select);
                break;
            }
        }
    }
    that.receiveKeyframe = receiveKeyframe;

    /**
     * Deselects selected keyframes on all tracks
     */
    function capturingOff() {
        var i;
        //for (i = 0; i < tracks.length; i++) {
        //    tracks[i].deselectKeyframe();
        //}
        dataHolder.mapTracks(function (i) {
            i.track.deselectKeyframe();
        });
    }
    that.capturingOff = capturingOff;

    /**
     * Grabs current keyframe state from viewer
     * @returns     Keyframe data in xml
     */
    function captureKeyframe(artname) {
        return viewer.captureKeyframe(artname);
    }
    that.captureKeyframe = captureKeyframe;

    function getViewer() {
        return viewer;
    }
    that.getViewer = getViewer;

    function getDataHolder() {
        return dataHolder;
    }
    that.getDataHolder = getDataHolder;

    ///////////
    // RIN Code

    /**
     * @returns     JSON object representing current state of timeline in RIN format
     */
    function toRIN() {
        var rin = {}, title = "TAGAuthoringPreview";

        // v2 code
        rin.version = '1.0';
        rin.defaultScreenplayId = "SCP1";
        rin.screenplayProviderId = 'screenplayProvider';
        rin.data = {
            narrativeData: {
                guid: "e3ced195-0c8b-48f6-b42c-f989e52b4f03",
                timestamp: new Date().toISOString(),
                title: title,
                author: "TAG Authoring Tool",
                aspectRatio: "WideScreen",
                estimatedDuration: timeManager.getDuration().end,
                description: "TAG Tour",
                branding: "TAG"
            }
        };
        rin.providers = {
            ZMES: {
                name: "MicrosoftResearch.Rin.ZoomableMediaExperienceStream",
                version: "1.0"
            },
            AES: {
                name: 'MicrosoftResearch.Rin.AudioExperienceStream',
                version: "1.0"
            },
            screenplayProvider: {
                name: "MicrosoftResearch.Rin.DefaultScreenplayProvider",
                version: "1.0"
            },
            FadeInOutTransitionService: {
                name: "MicrosoftResearch.Rin.FadeInOutTransitionService",
                version: "1.0"
            },
            InkES: {
                name: "MicrosoftResearch.Rin.InkExperienceStream",
                version: "0.0"
            },
            VideoES: {
                "name": "MicrosoftResearch.Rin.VideoExperienceStream",
                "version": 0.0
            },
            ImageES: {
                name: "MicrosoftResearch.Rin.ImageExperienceStream",
                version: "1.0"
            },
        };

        rin.resources = _getResourceTable();

        rin.experiences = _getExperienceStreams();

        rin.screenplays = {
            SCP1: {
                data: {
                    experienceStreamReferences: _getScreenPlay()
                }
            }
        };

        
        return rin;
    }
    that.toRIN = toRIN; // public for testing purposes only?

    /**
     * Helper function to collect track resource entries
     * @returns     JSON object table of resources
     */
    function _getResourceTable() {
        var i,
            table = {};
        //for (i = 0; i < tracks.length; i++) {
        //    tracks[i].addResource(table);
        //}
        dataHolder.mapTracks(function (i) {
            i.track.addResource(table);
        });
        return table;
        
    }

    /**
     * Helper function to collect track experience streams
     * @returns     JSON object table of ESs
     */
    function _getExperienceStreams() {
        var i,
            es = {};
        //for (i = 0; i < tracks.length; i++) {
        //    tracks[i].addES(es);
        //}
        dataHolder.mapTracks(function (i) {
            i.track.addES(es);
        });
        return es;
    }

    /**
     * Helper function for constructing screenplay xml string from tracks
     * @returns     XML screenplay string
     */
    function _getScreenPlay() {
        var i,
            screenplayStorage = [];
        //for (i = 0; i < tracks.length; i++) {
        //    tracks[i].addScreenPlayEntries(screenplayStorage);
        //}
        dataHolder.mapTracks(function (i) {
            i.track.addScreenPlayEntries(screenplayStorage);
        });
        screenplayStorage.sort(function (a, b) { return a.begin - b.begin; }); // Screenplay must be sorted
        return screenplayStorage;
    }

    function setTourExited(val) {
        tourExited = val;
    }
    that.setTourExited = setTourExited;

    /**
     * Function passed into tracks to be called on track changes to update RIN data
     */
    // debounce will prevent the function from being called
    // until the debounce function hasn't been called for
    // the specified number of milliseconds
    var debounce = $.debounce(200, coreUpdate);
    function coreUpdate() {
        onUpdateNumCalls = onUpdateNumCalls + 1;

        timeManager.stop();

        var rin;
        if (loaded) {
            viewer.setIsReloading(true);
            timeManager.stop();

            viewer.capturingOff();
            capturingOff();

            rin = toRIN();
            viewer.reloadTour(rin);
        }

        updateVerticalScroller();
        enableDisableDrag();
    }

    function onUpdate(noDebounce) {
        if (!noDebounce) {
            debounce();
        } else {
            coreUpdate();
        }
    }
    that.onUpdate = onUpdate;

    /**
     * Loads tour file and initializes timeline UI accordingly
     */
    function loadRIN(rin, callback) {
        var parser = TAG.Util.createQueue(),
            r, e, es, i, j, y, eobj,
            experienceArray, screenplayEntries,
            trackname, exp, expstr, expstrname, currScp,
            defaultseq,
            mediaLength,
            begin, fadeIn, fadeOut,
            track, display,
            type, length, zIndex,
            experienceStreams,
            keyframes, currKey, key, keyloc, keylocy,
            linkTrack,
            inks = [], // need to do some ink init after everything else has been loaded, save it here
            narrativeData = rin.data.narrativeData,
            resources = rin.resources,
            experiences = rin.experiences,
            screenplay = rin.screenplays.SCP1.data.experienceStreamReferences;
        // parse narrative data
        timeManager.setEnd(narrativeData.estimatedDuration);

        // ignore providers

        // parse resources and experiences simultaneously
        // first, get experiences and sort by zIndex in decending order
        screenplayEntries = rin.screenplays.SCP1.data.experienceStreamReferences;
        experienceArray = [];
        for (e in experiences) {
            if (experiences.hasOwnProperty(e)) {
                experienceArray.push({ name: e + '', exp: experiences[e] });
            }
        }
        function compareExps(a, b) {
            var az = a.exp.data.zIndex,
                bz = b.exp.data.zIndex,
                astr, bstr, expstr, i, currscp,
                astreams = a.exp.experienceStreams,
                bstreams = b.exp.experienceStreams;
            
            if (!az) {
                for (expstr in astreams) {
                    if (astreams.hasOwnProperty(expstr)) {
                        astr = astreams[expstr];
                        if (astr) {
                            az = astr.data.zIndex;
                        }
                        break;
                    }
                }
            }
            if (!bz) {
                for (expstr in bstreams) {
                    if (bstreams.hasOwnProperty(expstr)) {
                        bstr = bstreams[expstr];
                        if (bstr) {
                            bz = bstr.data.zIndex;
                        }
                        break;
                    }
                }
            }
            if (az) {
                if (bz) {
                    return bz - az;
                } else {
                    // b does not exist
                    return -1;
                }
            } else {
                if (bz) {
                    // a does not exist
                    return 1;
                } else {
                    // a and b do not exist
                    return 0;
                }
            }
        }

        experienceArray.sort(compareExps);

        // now parse
        function parseHelper(eobj, e) {
            parser.add(function () {
                parseTrack(eobj, e);
            });
        }
        for (e = 0; e < experienceArray.length; e++) {
            //parseTrack(experienceArray[e], e);
            parseHelper(experienceArray[e], e);
        }


        // finally, ink init
        parser.add(function () {
            var parentDisp, parentDisplays;
            for (i = 0; i < inks.length; i++) {
                linkTrack = findTrackByTitle(inks[i].link);
                inks[i].track.setInkLink(linkTrack);
                if (inks[i].track.getInkEnabled()) {//if is attached ink, set parent displays for each display inside
                    dataHolder.mapDisplays(inks[i].track.getStorageContainer(), function (currentDisplay) {
                        parentDisplays = linkTrack.getStorageContainer().displays.nearestNeighbors(currentDisplay.display.getStart(), 1);//array of nearest neighbor's in parent track's display 
                        parentDisp = parentDisplays[0] && parentDisplays[0].display;
                        currentDisplay.display.setParentDisplay(parentDisp);
                        parentDisp && parentDisp.addChildDisplay(currentDisplay.display);
                    });
                }
                if (linkTrack) {
                    linkTrack.addAttachedInkTrack(inks[i].track);
                }
            }
        });

        dataHolder.mapTracks(function (container, i) {
            container.track.updatePos(i);
        });

        //var parentDisp, parentDisplays;
        //for (i = 0; i < inks.length; i++) {
        //    linkTrack = findTrackByTitle(inks[i].link);
        //    inks[i].track.setInkLink(linkTrack);
        //    if (inks[i].track.getInkEnabled()) {//if is attached ink, set parent displays for each display inside
        //        dataHolder.mapDisplays(inks[i].track.getStorageContainer(), function (currentDisplay) {
        //            parentDisplays = linkTrack.getStorageContainer().displays.nearestNeighbors(currentDisplay.display.getStart(), 1);//array of nearest neighbor's in parent track's display 
        //            parentDisp = parentDisplays[0].display;
        //            currentDisplay.display.setParentDisplay(parentDisp);
        //        });
        //    }
        //}

        

        parser.add(function () {
            setLoaded();
        });
        parser.add(function () {
            /* do async viewer resize to make sure resize runs
             * after callback adds tour authoring to DOM
             */
            setTimeout(viewer.resize, 1);

            if (typeof callback === 'function') {
                callback();
            }

        });

        function confirmDeleteDisableInk(name, display, myy) {
            // create dialog
            root.append(deleteConfirmationOverlay);
            deleteConfirmationOverlay.attr('id', 'deleteConfirmationOverlay');
            deleteConfirmationOverlay.css({
                display: 'none',
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                'background-color': 'rgba(0,0,0,0.6)',
                'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex,
            });

            // Actual dialog container
            var deleteConfirmation = $(document.createElement('div'));
            deleteConfirmation.attr('id', 'deleteConfirmation');
            deleteConfirmation.css({
                position: 'absolute',
                left: '32.5%',
                'width': '35%',
                'top': '30%',
                border: '3px double white',
                'background-color': 'black',
                'padding': '2.5% 2.5%',
            });
            deleteConfirmationOverlay.append(deleteConfirmation);

            var dialogTitle = $(document.createElement('div'));
            dialogTitle.attr('id', 'dialogTitle');
            dialogTitle.css({
                color: 'white',
                'font-size': '1.25em',
                'margin-bottom': '10px',
                'word-wrap': 'normal',
            });
            deleteConfirmation.append(dialogTitle);
            deleteConfirmation.append(document.createElement('br'));

            // Container for "continue / cancel" buttons
            var buttonRow = $(document.createElement('div'));
            buttonRow.css({
                'margin-top': '10px',
                'text-align': 'center',
            });
            deleteConfirmation.append(buttonRow);

            var submitButton = $(document.createElement('button'));
            submitButton.css({
                width: 'auto',
                border: '1px solid white',
                padding: '1%',
                'margin-right': '3%',
            });
            submitButton.text('Continue');
            $(submitButton).click(function () {
                var len = display.removeAttachedInkDisplays();
                display.removeDisplay(true);
                if (len > 0) {
                    undoManager.combineLast(len + 1);
                }
                // disabling this for now
                //deleteAttachedInkDisplays(myy);
                deleteConfirmationOverlay.fadeOut(500);
            });

            buttonRow.append(submitButton);

            var cancelButton = $(document.createElement('button'));
            cancelButton.css({
                width: 'auto',
                border: '1px solid white',
                padding: '1%'
            });
            cancelButton.text('Cancel'); 
            cancelButton.click(function () {
                deleteConfirmationOverlay.fadeOut(500);
            });
            buttonRow.append(cancelButton);

            // fade in the overlay
            deleteConfirmationOverlay.fadeIn(500);
            dialogTitle.text('Deleting the last display in track "' + name + '" will disable all attached ink tracks. Any existing ink displays will not function until a new artwork display has been created at an overlapping time.');

            // deletes all ink displays - not activating this for now, only giving them a warning
            /***
            function deleteAttachedInkDisplays(data) {
                var i;
                for (i = 0; i < data.attachedInks.length; i++) {
                    data.attachedInks[i].clearDisplays();
                }
            }
            ***/
        }
        that.confirmDeleteDisableInk = confirmDeleteDisableInk;
        

        /**
         * Parses an individual track
         * Note that this is scoped into loadRIN function! (needs access to inks variable)
         * @param eobj      two params, name is track name, exp is rin format experience object
         * @param e         track position of eobj
         */
        function parseTrack(eobj, e) {
            // initialization of track
            trackname = eobj.name; // track name is simply key / property name
            exp = eobj.exp; // actual experience entry
            type = exp.providerId; // ZMES or AES or ...
            zIndex = exp.data.zIndex;
            if (exp.resourceReferences.length !== 0) {
                r = exp.resourceReferences[0].resourceId; // id used to get media url out of resources
            }
            track = null;
            if (type === 'ZMES') {
                track = addArtworkTrack(resources[r].uriReference, trackname, exp.data.guid, e);
            } else if (type === 'ImageES') {
                track = addImageTrack(resources[r].uriReference, trackname, e);
            } else if (type === 'VideoES') {
                mediaLength = exp.data.mediaLength;
                var toConvert = exp.data.toConvert;
                var converted = exp.data.converted || false;
                track = addVideoTrack(resources[r].uriReference, trackname, e, mediaLength, toConvert, converted);
            } else if (type === 'AES') {
                mediaLength = exp.data.mediaLength;
                track = addAudioTrack(resources[r].uriReference, trackname, e, mediaLength);
            } else if (type === 'InkES') {
                track = addInkTrack(null, trackname, 1, null, e);
                track.setInkPath(exp.data.linkToExperience.embedding.element.datastring.str);
                track.setInkEnabled(exp.data.linkToExperience.embedding.enabled);
                track.setInkInitKeyframe(exp.data.linkToExperience.embedding.initKeyframe);
                track.setInkRelativeArtPos(exp.data.linkToExperience.embedding.initproxy);
                track.link = exp.data.linkToExperience.embedding.experienceId;
                track.addInkTypeToTitle(exp.data.linkToExperience.embedding.element.datastring.str.split('::')[0].toLowerCase());



                inks.push({ 'track': track, 'link': exp.data.linkToExperience.embedding.experienceId }); // do link init later
                //create ink canvas and load datastring
            } else {
                console.log('Experience not yet implemented');
            }

            // check track ordering is correct
            if (track.getPos() !== experienceArray.length - zIndex) {
                console.log('zIndex and track array position are not the same for: ' + trackname);
            }

            // add displays from experience streams
            if (track) {
                experienceStreams = exp.experienceStreams;
                for (var es in experienceStreams) {
                    if (experienceStreams.hasOwnProperty(es)) {
                        expstrname = es + '';
                        expstr = experienceStreams[es]; // actual experience stream
                        length = expstr.duration;

                        // to find start + end of displays, need to scan screenplay
                        for (i = 0; i < screenplay.length; i++) {
                            currScp = screenplay[i];
                            if (currScp.experienceStreamId === expstrname) { // found a match
                                // note: scp length is fadeIn + main, expstr length is just main
                                // easy shortcut for reading fades
                                begin = currScp.begin;
                                if (expstr.data.transition && expstr.data.transition.providerId) {
                                    fadeIn = expstr.data.transition.inDuration;
                                    fadeOut = expstr.data.transition.outDuration;
                                } else {
                                    fadeIn = 0;
                                    fadeOut = 0;
                                }
                                display = track.addDisplay(timeManager.timeToPx(begin));
                                display.setMain(length);
                                display.setIn(fadeIn);
                                display.setOut(fadeOut);

                                // add keyframes
                                if (exp.providerId !== 'InkES' && exp.providerId !== 'VideoES') {
                                    defaultseq = expstr.header.defaultKeyframeSequence;
                                    keyframes = expstr.keyframes;
                                    for (j = 0; j < keyframes.length; j++) {
                                        currKey = keyframes[j];

                                        // ignore initialization keyframe
                                        if (currKey.init) {
                                            continue;
                                        }

                                        keyloc = timeManager.timeToPx(currKey.offset + display.getStart());
                                        if (type === 'ZMES' || type === 'ImageES') {
                                            key = display.addKeyframe(keyloc, TAG.TourAuthoring.Constants.trackHeight/2);
                                            if (key) key.loadRIN(currKey);
                                        } else if (type === 'AES') {
                                            // get audio to set y location
                                            y = currKey.state.sound.volume;
                                            y = Math.constrain(TAG.TourAuthoring.Constants.trackHeight - TAG.TourAuthoring.Constants.trackHeight * y, 0, TAG.TourAuthoring.Constants.trackHeight);
                                            key = display.addKeyframe(keyloc, y);
                                            if (key) track.addKeyframeToLines(key);
                                        } else if (type === 'VideoES') { //not used b/c of if check above
                                            // get video to set y location
                                            //y = 0;
                                            //key = display.addKeyframe(keyloc, y);
                                        } else {
                                            console.log('Experience not yet implemented');
                                        }
                                    }
                                }

                                // done with this display
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    that.loadRIN = loadRIN;    

    function cancelAccel() {
        manipObjects.ruler.cancelAccel();
        manipObjects.track.cancelAccel();
    }
    that.cancelAccel = cancelAccel;

    return that;
   
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.TopMenu');

/**
 * Main menu for Tour Authoring
 * Back button, rename tour controls, save button, tour options
 * @param spec      not used
 * @param my        not used
 */
TAG.TourAuthoring.TopMenu = function (spec, my) {
    "use strict";

    var that = {},
        viewer = spec.viewer,
        undoManager = spec.undoManager,
        timeline = spec.timeline,
        timeManager = spec.timeManager,
        tourobj = spec.tourobj,
        playbackControls = spec.playbackControls,
        root = spec.root,
        componentControls = spec.componentControls,
        topbar = $(document.createElement('div')),
        //dialogOverlay = $(document.createElement('div')), // NOTE: TODO: figure out how to place dialogOverlay inside of topbar to maintain modularity?

        dialogOverlay = $(TAG.Util.UI.blockInteractionOverlay()),
        //backDialogOverlay = $(document.createElement('div'));
        backDialogOverlay = $(TAG.Util.UI.blockInteractionOverlay());

    (function _createHTML() {
        topbar.css({ "background-color": "rgb(63,55,53)", "height": "8%", "width": "100%" });
        topbar.attr('id', 'topbar');

        var buttonHeight = $(window).height() * 0.0504; // matches effective % size from SettingsView
        var backButtonArea = $(document.createElement('div'));
        backButtonArea.css({
            "top": "18.5%",
            'margin-left': '1.2%',
            'height': '63%',
            "width": buttonHeight + 'px',
            "position": "relative",
            "float": "left"
        });
        var backButton = $(document.createElement('img'));
        backButton.attr('src', tagPath + 'images/icons/Back.svg');
        backButton.css({ 'width': '100%', 'height': '100%' });

        backButton.mousedown(function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, false);
        });

        backButton.mouseleave(function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, true);
        });

        //save method saves all changes made
        var saveClicked = false;
        var nameChanged = false;
        function save(stayOnPage) {
            console.log("isUploading === " + componentControls.getIsUploading());
            saveClicked = true;
            nameChanged = false;
            if ($("#inkEditText").css('display') !== "none") {
                componentControls.saveText();
            }
            else if ($("#inkEditDraw").css('display') !== "none") {
                componentControls.saveDraw();
            }
            else if ($("#inkEditTransparency").css('display') !== "none") {
                componentControls.saveTrans();
            }
            timeline.hideEditorOverlay();

            undoManager.setPrevFalse();//method sets savedState of top element of undoStack to true to indicate further prompt for saving is not required on leaving page
            //var xml = TAG.Worktop.Database.getDoqXML(tourobj.Identifier);
            //var parser = new DOMParser();
            //var tourXML = $(parser.parseFromString(xml, 'text/xml'));

            var name = textArea.val();
            var content = JSON.stringify(timeline.toRIN(true));
            var related = JSON.stringify(timeline.getRelatedArtworks());
            //var thumbnail = optionsBuffer && optionsBuffer.thumbnail;

            var options = {
                Name: name,
                Content: content,
                RelatedArtworks: related
            }

            TAG.Worktop.Database.changeTour(tourobj, options, function () {
                // success
                dialogOverlay.fadeOut(500);
                !stayOnPage && goBack();
            }, function () {
                // unauth
                dialogOverlay.hide();
                var popup = TAG.Util.UI.popUpMessage(null, "Tour not saved.  You must log in to save changes.");
                $('body').append(popup);
                $(popup).show();
            }, function (jqXHR, ajaxCall) {
                // conflict
                // Ignore conflict for now
                ajaxCall.force();
            }, function () {
                // error
                dialogOverlay.hide();
                var popup = TAG.Util.UI.popUpMessage(null, "Tour not saved.  There was an error contacting the server.");
                $('body').append(popup);
                $(popup).show();
            });   
        }
        // Takes you back to the tour authoring menu page
        function goBack() {
            var messageBox;
            // first, make sure that a tour reload isn't in progress
            if (viewer.getIsReloading()) {
                messageBox = TAG.Util.UI.popUpMessage(null, "Tour reload in progress. Please wait a few moments.", null);
                $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                $('body').append(messageBox);
                $(messageBox).fadeIn(500);
                return;
            }
            backButton.off('click');
            $('.rightClickMenu').hide();//shuts the menu that appears on right clicking on a track
            var tempSettings = new TAG.Authoring.SettingsView('Tours', null, null, tourobj.Identifier);
            viewer.stop();
            viewer.unload();
            TAG.Util.UI.slidePageRight(tempSettings.getRoot());
        }
        //backDialogOverlay.attr('id', 'backDialogOverlay');
        //backDialogOverlay.css({
        //    display: 'none',
        //    position: 'absolute',
        //    top: 0,
        //    left: 0,
        //    width: '100%',
        //    height: '100%',
        //    'background-color': 'rgba(0,0,0,0.6)',
        //    'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex,
        //    //'height': '30%',
        //    //'width': '45%',
        //    //'position': 'fixed',
        //    //'top': '50%',
        //    //'left': '50%',
        //    //'margin-top': '-15%',
        //    //'margin-left': '-22.5%',
        //    //'background-color': 'black',
        //    //'z-index': TAG.TourAuthoring.aboveRinZIndex+5,
        //    //'border': '3px double white',
        //});
        //// Actual dialog container for when back button is pressed
        //var backDialog = $(document.createElement('div'));
        //backDialog.attr('id', 'backDialog');

        /////new css
        //var backDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
        //   {
        //       center_h: true,
        //       center_v: true,
        //       width: 0.5,
        //       height: 0.35,
        //       max_width: 560,
        //       max_height: 200,
        //   });
        //backDialog.css({
        //    position: 'absolute',
        //    left: backDialogSpecs.x + 'px',
        //    top: backDialogSpecs.y + 'px',
        //    width: backDialogSpecs.width + 'px',
        //    height: backDialogSpecs.height + 'px',
        //    border: '3px double white',
        //    'background-color': 'black',
        //});

        //backDialogOverlay.append(backDialog);
        //var backDialogTitle = $(document.createElement('div'));
        //backDialogTitle.attr('id', 'backDialogTitle');
        ////var fontsize = TAG.Util.getMaxFontSizeEM('Entering authoring mode, please enter password.', 0.8, 0.8 * loginDialog.width(), 0.2 * loginDialog.height(), 0.05);
        //backDialogTitle.css({
        //    color: 'white',
        //    'width': '80%',
        //    'height': '15%',
        //    'left': '10%',
        //    'top': '12.5%',
        //    'font-size': '1.25em',
        //    'position': 'relative',
        //    'text-align': 'center',
        //   // 'overflow': 'hidden',
        //    'word-wrap':'break-word',
        //});

        //backDialog.append(backDialogTitle);
        //backDialog.append(document.createElement('br'));
         
        //var backButtonRow = $(document.createElement('div'));
        //backButtonRow.css({
        //    'position': 'relative',
        //    'display': 'block',
        //    'width': '80%',
        //    'left': '10%',
        //    'top':'40%'
        //});

        //var backSaveButton = $(document.createElement('button'));
        //backSaveButton.css({
        //    'padding': '1%',
        //    'border': '1px solid white',
        //    'width': 'auto',
        //    'position': 'relative',
        //    'margin-top': '1%',
        //});
        //backSaveButton.text('Save');

        //$(backSaveButton).click(function () {
        //    save();
        //});

        //backButtonRow.append(backSaveButton);

        //var backDontSaveButton = $(document.createElement('button'));
        //backDontSaveButton.css({
        //    'padding': '1%',
        //    'border': '1px solid white',
        //    'width': 'auto',
        //    'position': 'relative',
        //    'margin-top': '1%',
        //    'left': '20%'

        //});
        //backDontSaveButton.text('Don\'t Save');
        //$(backDontSaveButton).click(function () {
        //    goBack();
        //});

        //backButtonRow.append(backDontSaveButton);

        //var backCancelButton = $(document.createElement('button'));
        //backCancelButton.css({
        //    'padding': '1%',
        //    'border': '1px solid white',
        //    'width': 'auto',
        //    'position': 'relative',
        //    'margin-top': '1%',
        //    'float': 'right'
        //});
        //backCancelButton.text('Cancel');
        //backCancelButton.click(function () { backDialogOverlay.fadeOut(500); });
        //backButtonRow.append(backCancelButton);

        //backDialog.append(backButtonRow);

        backButton.click(function () {
            var messageBox;

            $('.rightClickMenu').hide();//shuts the menu that appears on right clicking on a track

            if (viewer.getIsReloading()) {
                messageBox = TAG.Util.UI.popUpMessage(null, "Tour reload in progress. Please wait a few moments.", null);
                $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                $('body').append(messageBox);
                $(messageBox).fadeIn(500);
                return;
            }

            if (nameChanged || (undoManager.dirtyStateGetter() === false) || 
                (componentControls.getInkUndoManager() && (componentControls.getInkUndoManager().dirtyStateGetter() === false) /*&& (componentControls.getInkUndoManager().undoStackSize() != 0)*/)) {
                //backDialogOverlay.fadeIn(500);
                if (textArea.val().length === 0) {
                    textArea.val('Untitled Tour');
                }
                var backDialog = TAG.Util.UI.PopUpConfirmation(function () {
                    $("#popupConfirmButton").text('Saving...').attr('disabled', true);
                    save();
                }, 'Save changes to ' +textArea.val() + ' before leaving?', "Save", false, function () {
                    goBack();
                    $("#popupConfirmButton").attr('disabled', true);//.css({ 'color': 'rgba(255, 255, 255, 0.5)' });
                    $("#popupCancelButton").attr('disabled', true).css({ 'color': 'rgba(255, 255, 255, 0.5)' });
                }, null, null, true);
                root.append(backDialog);
                TAG.Util.multiLineEllipsis($($($(backDialog).children()[0]).children()[0]));

                $(backDialog).css('z-index', 1000000);
                $(backDialog).show();
            }
            else {
                goBack();
            }


       });
        backButtonArea.append(backButton);
        topbar.append(backButtonArea);

        // Title text area, users can retype and redefine title name
        var textArea = $(document.createElement('input'));
        textArea.type = "text";
        /*textArea.on('keyup', function () {
            var txt = (textArea && textArea[0] && textArea[0].value) ? textArea[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (textArea && textArea[0] && textArea[0].value && textArea[0].value!=txt) {
                textArea[0].value = txt;
            }
        });*/
        var textAreaSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            center_v: true,
            width: 0.2,
            height: 0.5,
            x_offset: 0.05,
            x_max_offset: 60,
        });
        textArea.css({
            'margin-left': '3%',
            'position': 'absolute',
            'border': '3px solid',
            'border-color': '#666666',
            top: textAreaSpecs.y - 7 + 'px',
            'left': textAreaSpecs.x + 'px',
            width: textAreaSpecs.width + 'px',
            height: textAreaSpecs.height + 'px',
            'font-size':'.7em'
        });

        textArea.attr({
            display: 'block',
            type: 'text',
            id: 'textArea',
            name: 'textArea',
            value: tourobj.Name
        });

        textArea.on('keydown', function (ev) {
            ev.stopImmediatePropagation();
        });
        textArea.on('keypress', function (ev) {
            ev.stopImmediatePropagation();
        });
        textArea.on('keyup', function (ev) {
            nameChanged = true;
            ev.stopImmediatePropagation();
        });

        topbar.append(textArea);

        // NOTE: save button click event handler is below dialog code
        var saveButton = $(document.createElement("button"));
        saveButton.text("Save").css('border-radius', '3.5px');
        saveButton.attr('type', 'button');      
        saveButton.attr('id', 'tourSaveButton');
        //Initially disable save button since there have been no changes
        saveButton.prop('disabled', true);
        saveButton.css('opacity', '0.4');

        //Save button highlighting
        saveButton.on('mousedown', function () {
            if (!saveButton.is(":disabled")) {
                saveButton.css({ "background-color": "white", "color": "black" });
            }
        });

        saveButton.on('mouseup', function () {
            if (!saveButton.is(":disabled")) {
                saveButton.css({ "background-color": "transparent", "color": "white" });
            }
        });

        saveButton.on('mouseout', function () {
            if (!saveButton.is(":disabled")) {
                saveButton.css({ "background-color": "transparent", "color": "white" });
            }
        });


        var saveButtonSpecs = TAG.Util.constrainAndPosition($(window).width() * 0.8, $(window).height() * 0.08,
        {
            center_v: true,
            width: 0.13,
            height: 0.5,
        });
        var fontsize = TAG.Util.getMaxFontSizeEM('Save', 0.2, 0.63 * saveButtonSpecs.width, 0.75 * saveButtonSpecs.height, 0.01);
        saveButton.css({
            "color": "white",
            "border-color": "white",
            'position': 'absolute',
            width: saveButtonSpecs.width + 'px',
            height: saveButtonSpecs.height + 'px',
            'top': saveButtonSpecs.y + 'px',
            'font-size': fontsize,
            'left': parseInt(textArea.css('left'),10) + textArea.width() + 45 + ($(window).width() * 0.022) + 'px',
        });
        
        topbar.append(saveButton);


        /*save button dialog code*/
        //// Overlay to darken out main UI
        //dialogOverlay.attr('id', 'dialogOverlay');
        //dialogOverlay.css({
        //    display: 'none',
        //    position: 'absolute',
        //    top: 0,
        //    left: 0,
        //    width: '100%',
        //    height: '100%',
        //    'background-color': 'rgba(0,0,0,0.6)',
        //    'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex,
        //});

        //// Actual dialog container
        //var saveDialog = $(document.createElement('div'));
        //saveDialog.attr('id', 'saveDialog');

        //var saveDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
        //   {
        //       center_h: true,
        //       center_v: true,
        //       width: 0.5,
        //       height: 0.35,
        //       max_width: 560,
        //       max_height: 200,
        //   });
        //saveDialog.css({
        //    position: 'absolute',
        //    left: saveDialogSpecs.x + 'px',
        //    top: saveDialogSpecs.y + 'px',
        //    width: saveDialogSpecs.width + 'px',
        //    height: saveDialogSpecs.height + 'px',
        //    border: '3px double white',
        //    'background-color': 'black',
        //});
        //dialogOverlay.append(saveDialog);
        //var dialogTitle = $(document.createElement('div'));
        //dialogTitle.attr('id', 'dialogTitle');
        ////var fontsize = TAG.Util.getMaxFontSizeEM('Entering authoring mode, please enter password.', 0.8, 0.8 * loginDialog.width(), 0.2 * loginDialog.height(), 0.05);
        //dialogTitle.css({
        //    color: 'white',
        //    'width': '80%',
        //    'height': '15%',
        //    'left': '10%',
        //    'top': '12.5%',
        //    'font-size': '1.25em',
        //    'position': 'relative',
        //    'text-align': 'center',
        //    //'overflow': 'hidden',
        //    'word-wrap': 'break-word',
        //});

        //saveDialog.append(dialogTitle);
        //saveDialog.append(document.createElement('br'));

        //// Container for "save / cancel" buttons
        //var buttonRow = $(document.createElement('div'));
        //buttonRow.css({
        //    'position': 'relative',
        //    'display': 'block',
        //    'width': '80%',
        //    'left': '10%',
        //    'top': '40%'
        //});
        //saveDialog.append(buttonRow);

        //// TODO: Hook in save-to-server functionality here!
        //var submitButton = $(document.createElement('button'));
        //submitButton.css({
        //    'padding': '1%',
        //    'border': '1px solid white',
        //    'width': 'auto',
        //    'position': 'relative',
        //    'margin-top': '1%',
        //});
        //submitButton.text('Save');
        //submitButton.click(function () { save(true); });

        //buttonRow.append(submitButton);

        //var cancelButton = $(document.createElement('button'));
        //cancelButton.css({
        //    'padding': '1%',
        //    'border': '1px solid white',
        //    'width': 'auto',
        //    'position': 'relative',
        //    'margin-top': '1%',
        //    'float': 'right'
        //});
        //cancelButton.text('Cancel');
        //cancelButton.click(function () { dialogOverlay.fadeOut(500); });
        //buttonRow.append(cancelButton);
        
        //save button click event handler
        saveButton.click(function () {
            $('.rightClickMenu').hide();//shuts the menu that appears on right clicking on a track
            //dialogOverlay.fadeIn(500);
            if (textArea.val().length === 0) {
                textArea.val('Untitled Tour');
            }
            //var saveDialog = TAG.Util.UI.PopUpConfirmation(function () {
                //$("#popupConfirmButton").text('Saving...').attr('disabled', true).css({ 'border': '1px solid gray', 'color': 'gray', 'cursor': 'default' });
            save(true);
            saveButton.prop('disabled', true);
            saveButton.css('opacity', '0.4');

            //}, 'Save changes to ' + textArea.val() + '?', "Save", false);
            //root.append(saveDialog);
            //$(saveDialog).css('z-index', 1000000);
            //$(saveDialog).show();
        });

        //topbar.append(buttonPanel);

        // Tour Options dropdown
        var tourOptions = TAG.TourAuthoring.TourOptions({
            timeManager: timeManager,
            timeline: timeline,
            root: root,
            undoManager: undoManager,
            playbackControls: playbackControls,
            tour: tourobj
        });
        tourOptions.addToDOM(topbar);
        var tourOptionsSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            center_v: true,
            width: 0.13,
            height: 0.8,
        });
        var tourOptionsFontSize = TAG.Util.getMaxFontSizeEM('Options', 0.5, tourOptionsSpecs.width * 0.8, tourOptionsSpecs.height * 0.7, 0.01);
        var optionsLabelSpecs = TAG.Util.constrainAndPosition(tourOptionsSpecs.width, tourOptionsSpecs.height, {
            center_v: true,
            width: 0.8,
            height: 0.8,
        });

        tourOptions.applyCSS(
            {
                "height": tourOptionsSpecs.height + "px",
                "width": tourOptionsSpecs.width + 'px',
                "left": "60%",
                'top': tourOptionsSpecs.y + 'px',
                "position": 'absolute',
            });

        tourOptions.applyLabelCSS(
            {
                'height': optionsLabelSpecs.height + 'px',
                'width': optionsLabelSpecs.width + 'px',
                'left': 0 + 'px',
                'top': optionsLabelSpecs.y + 'px',
                "position": 'absolute',
                'font-size': tourOptionsFontSize,
            });

        // Page header (not user's tour title)
        var topBarLabel = $(document.createElement('div'));
        var topBarLabelSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            width: 0.4,
            height: 0.9,
        });
        topBarLabel.css({
            'margin-right': '2%',
            'margin-top': 8 * 0.04 + '%',
            'color': 'white',
            'position': 'absolute',
            'text-align': 'right',
            'right': '0px',
            'top': '0px',
            'height': topBarLabelSpecs.height + 'px',
            'width': topBarLabelSpecs.width + 'px',
        });

        var fontsizeTop = TAG.Util.getMaxFontSizeEM('Tour Authoring', 0.5, topBarLabelSpecs.width, topBarLabelSpecs.height * 0.85);
        topBarLabel.css({ 'font-size': fontsizeTop });

        topBarLabel.text('Tour Authoring');

        topbar.append(topBarLabel);

        //topbar.append(tourLabel);
    })();

    function addToDOM(container) {
        container.append(topbar).append(dialogOverlay).append(backDialogOverlay);
    }
    that.addToDOM = addToDOM;

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.TourOptions');

/**
 * Control for additional tour options
 *@param spec:    timeManager attr, url (url of tour if loading existing tour for editing)

 */
TAG.TourAuthoring.TourOptions = function (spec) {
    "use strict";

    var functionsPanel = $(document.createElement('div')),
        addTourOptionsLabel,
        dropMain,
        dropdownIcon,
        that = {},
        tour = spec.tour,
        playbackControls = spec.playbackControls,
        timeManager = spec.timeManager,
        timeline = spec.timeline,
        root = spec.root,
        undoManager = spec.undoManager,
        //dialogOverlay = $(document.createElement('div')), // NOTE: TODO: figure out how to place dialogOverlay inside of topbar to maintain modularity?

        dialogOverlay = $(TAG.Util.UI.blockInteractionOverlay()),


        thumbnailcaptured = $(document.createElement('div')),
        optionsBuffer = {};

    (function _createHTML() {
        functionsPanel.attr('id', 'tour-options');
        // Had to do tops and heights as CSS to prevent overlap on small screens
        functionsPanel.css({
            "height": "48px",
            "width": "13%",
            "left": "25%",
            "top": "27%",
            "position": "relative",
            "float": "left"
        });

        /**
         * Drop Down icon
         * Modified By: Hak
         */
        var addDropDownIconTourOptions = $(document.createElement('img'));
        addDropDownIconTourOptions.addClass("tourOptionDropDownIcon");
        addDropDownIconTourOptions.attr('src', tagPath + 'images/icons/Down.png');
        addDropDownIconTourOptions.css({
            'top': '-5%', 'width': '7.5%', 'height': 'auto', 'margin-left': '5%', 'margin-bottom': '3%',
        });
        dropdownIcon = addDropDownIconTourOptions;

        // Additional options will go here once they exist
        addTourOptionsLabel = $(document.createElement('label'));
        addTourOptionsLabel.attr('id', 'addTourOptionsLabel');
        addTourOptionsLabel.text("Options");
        addTourOptionsLabel.css({
            "font-size": TAG.Util.getFontSize(190),
            "color": "rgb(256, 256, 256)"
        });
        addTourOptionsLabel.append(addDropDownIconTourOptions);
        functionsPanel.append(addTourOptionsLabel);

        // Dropdown menus:
        // Main section
        dropMain = $(document.createElement('div'));
        dropMain.css({
            "position": "absolute",
            "color": "rgb(256, 256, 256)",
            'background-color': 'rgba(0,0,0,0.85)',
            'left': '0',
            'width': '100%',
            'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex
        });
        functionsPanel.append(dropMain);
        dropMain.hide();

        // create the buttons to add various components
        var thumbnailButton = _addMenuItem('Capture Thumbnail', dropMain, 'thumbnailButton');
        var lengthButton = _addMenuItem('Change Tour Length', dropMain, 'tourLengthButton');
        var exportButton = _addMenuItem('Export Tour Data', dropMain, 'exportButton');

        /**
         * Creates component menu buttons
         * @param title         Name of button
         * @param component     DOM element to add button to
         * @param id            id to the element
         */
        function _addMenuItem(title, component, id) {
            var item = $(document.createElement('label'));
            item.addClass('optionItem');
            item.attr('id', id);
            item.text(title);
            item.css({
                "left": "0%",
                "position": "relative",
                "font-size": '.8em',//TAG.Util.getFontSize(170),
                "color": "rgb(256, 256, 256)",
                "display": "block",
                'padding': '4% 0 5% 0',
                'text-indent': '4%',
                'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex + 5
            });

            //Highlighting
            item.on('mousedown', function (evt) {
                evt.stopImmediatePropagation();
                item.css({ "background-color": "white", "color": "black" });
            });

            item.on('mouseup', function (evt) {
                evt.stopImmediatePropagation();
                item.css({ "background-color": "transparent", "color": "white" });
            });

            item.on('mouseout', function (evt) {
                evt.stopImmediatePropagation();
                item.css({ "background-color": "transparent", "color": "white" });
            });

            component.append(item);
            return item;
        }

        var menuVisible = false;
        //have the dropMain menu show/hide when clicked
        addTourOptionsLabel.click(function (event) {
            var close = timeline.getCloseMenu();
            if (close && close !== hideMenu) {
                close();
            }

            event.stopImmediatePropagation();

            menuVisible = !menuVisible;
            if (menuVisible) {
                timeline.setisMenuOpen(true);
                timeline.setCloseMenu(hideMenu);
                root.on('mousedown.topMenu', function (event) {
                    hideMenu();
                });

                $(dropdownIcon).css({
                    'transform': 'scaleY(-1)',
                    'margin-bottom': '3%'
                });
            }
            else {
                timeline.setisMenuOpen(false);
                timeline.setCloseMenu(hideMenu);
                root.off('mousedown.topMenu');

                $(dropdownIcon).css({
                    'transform': 'scaleY(1)',
                    'margin-bottom': '3%'
                });
            }
            dropMain.css('top', parseInt(addTourOptionsLabel.css('top'),10) + addTourOptionsLabel.height());
            dropMain.toggle();
        });
        addTourOptionsLabel.on('mousedown', function (evt) {
            evt.stopImmediatePropagation();
        });

        //the capture thumbnail confirmation
        var capturedmsg = $(document.createElement('label'));
        $(capturedmsg).text("Capturing Thumbnail...");
        capturedmsg.css({
            'text-align': 'center',
            'width': '100%',
            'font-size': '1em',
            'color': 'white'
        });
        thumbnailcaptured.append(capturedmsg);
        thumbnailcaptured.addClass("thumbnailcaptured");
        thumbnailcaptured.css({
            'background-color': 'black',
            'position': 'absolute',
            'left': '52%',
            'z-index': '1000',
            'display': 'none',
            'opacity': '0.8',
            'border': '2.8px double white'
        });

        /*capture the current viewer's thumbnail*/
        thumbnailButton.on('click', function () {
            var uiHeight = $('#resizableArea').height() + $('#topbar').height();
            thumbnailcaptured.css({ 'top': 0.53 * uiHeight + 'px' });

            //hide menu
            hideMenu();
            thumbnailcaptured.fadeIn('fast');
            //capture the thumbnail and upload it.
            var rinplayer = $('#rinplayer');
            html2canvas([rinplayer[0]], {
                onrendered: function (canvas) {
                    // no need for cropping anymore, since the rinplayer is always 16:9
                    //gets dataurl from tmpcanvas, ready to send to server!
                    var dataurl = canvas.toDataURL();
                    TAG.Worktop.Database.uploadImage(dataurl, function (imageURL) {
                        TAG.Worktop.Database.changeTour(tour.Identifier, { Thumbnail: imageURL }, function () {
                            setTimeout(function () {
                                thumbnailcaptured.fadeOut();//alert msg disappear
                            }, 1000);
                        }, unauth, conflict, error);
                    }, unauth, error);
                    //optionsBuffer.thumbnail = imageURL;
                },
                allowTaint: true, // allow imageES images in thumbnails, etc
            });
        });

        function unauth() {
            dialogOverlay.hide();
            var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  You must log in to save changes.");
            $('body').append(popup);
            $(popup).show();
            setTimeout(function () {
                thumbnailcaptured.fadeOut();//alert msg disappear
            }, 1000);
        }

        function conflict(jqXHR, ajaxCall) {
            ajaxCall.force();
        }

        function error() {
            dialogOverlay.hide();
            var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  There was an error contacting the server.");
            $('body').append(popup);
            $(popup).show();
            setTimeout(function () {
                thumbnailcaptured.fadeOut();//alert msg disappear
            }, 1000);
        }

        /*click function for inputtin new tour length*/
        lengthButton.on('click', function () {
            //hide menu
            hideMenu();

            dialogOverlay.fadeIn(500);
            // Set timeInput to the current length
            timeInput.val(timeManager.formatTime(timeManager.getDuration().end));

            timeInput.select();
            messageRow.text('');
        });

        // Tour Length Dialog
        // Overlay to darken out main UI

        // Actual dialog container
        var lengthDialog = $(document.createElement('div'));
        lengthDialog.attr('id', 'lengthDialog');

        ///
        dialogOverlay.css('z-index', '100000');


        var lengthDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width:$('body').width()*0.35,
               max_height: $('body').height() * 0.25,
           });

        lengthDialog.css({
            position: 'absolute',
            left: lengthDialogSpecs.x + 'px',
            top: lengthDialogSpecs.y + 'px',
            width: lengthDialogSpecs.width + 'px',
            height: lengthDialogSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',
        });

        dialogOverlay.append(lengthDialog);
        
        // Create a form to capture enter keypress
        var dialogForm = $(document.createElement('form'));
        dialogForm.attr('id', 'dialogForm');
        dialogForm.css({
            'margin-top': '4.5%',
        });
        lengthDialog.append(dialogForm);

        // updates the timeManager/timeinput related stats
        // when the length of tour is changed/submit button is clicked.
        dialogForm.on('submit', function () {
            var split = timeInput.val().split(':');
            var min = parseInt(split[0],10), sec = parseInt(split[1],10);
            var oldTime;
            var command;
            if (split.length == 1 && (min || min === 0) && min >= 0) { // In this case 'min' is actually seconds
                if (min > TAG.TourAuthoring.Constants.maxTourLength) {
                    messageRow.text('Tour length is too long. Maximum length of tour must be 15 minutes.');
                    messageRow.css({
                        color: 'white',
                        'width': '80%',
                        'left': '10%',
                        'font-size': '0.7em',
                        'position': 'absolute',
                        'text-align': 'center',
                        'margin-top': '3%',
                    });
                    timeInput.select();
                }
                else {
                    if (min < timeline.getLastDisplayTime()) { //check if new time is shorter than last display length, and limit it to that
                        min = timeline.getLastDisplayTime();
                    }
                    oldTime = timeManager.getDuration().end;
                    command = TAG.TourAuthoring.Command({
                        execute: function () {
                            timeManager.setEnd(min);

                        },
                        unexecute: function () {
                            timeManager.setEnd(oldTime);
                        }
                    });
                    command.execute();
                    undoManager.logCommand(command);
                    dialogOverlay.fadeOut(500);
                }
            } else if (split.length === 2 && (min || min === 0) && (sec || sec === 0) && min >= 0 && (typeof sec === "number") && sec >= 0 && sec <= 59) { // good format
                var newTime = min * 60 + sec;
                if (newTime > TAG.TourAuthoring.Constants.maxTourLength) {
                    messageRow.text('Tour length is too long. Maximum length of tour is 15 minutes.');
                    timeInput.select();
                }
                else {
                    if (newTime < timeline.getLastDisplayTime()) { //check if new time is shorter than last display length, and limit it to that
                        newTime = timeline.getLastDisplayTime();
                    }
                    oldTime = timeManager.getDuration().end;
                    command = TAG.TourAuthoring.Command({
                        execute: function () {
                            timeManager.setEnd(newTime);

                        },
                        unexecute: function () {
                            timeManager.setEnd(oldTime);
                        }
                    });
                    command.execute();
                    undoManager.logCommand(command);
                    dialogOverlay.fadeOut(500);
                }
            }
            else {
                messageRow.text('Please enter a valid length (MM:SS or seconds).');
                timeInput.select();
            }

            timeline.faderUpdate();// update the fader pposition in sliderBox
            return false;
        });

        var dialogTitle = $(document.createElement('div'));
        dialogTitle.attr('id', 'dialogTitle');
        dialogTitle.css({
            color: 'white',
            'width': '80%',
            'height': '15%',
            'left': '10%',
            'font-size': '0.7em',
            'position': 'relative',
            'text-align': 'center',
            'word-wrap': 'break-word'
        });
        var msg = 'Enter New Length (MM:SS): ';
        dialogTitle.text(msg);
        //var fontsize = TAG.Util.getMaxFontSizeEM(msg,0.7,lengthDialog.width(),lengthDialog.height());
        //dialogTitle.css('font-size', fontsize);
        dialogForm.append(dialogTitle);

        var timeInput = $(document.createElement('input'));
        timeInput.attr('id', 'timeInput');
        timeInput.css({
            'position': 'relative',
        });
        dialogTitle.append(timeInput);
        dialogForm.append(document.createElement('br'));

        timeInput.on('keydown', function (ev) {
            ev.stopImmediatePropagation();
        });
        timeInput.on('keypress', function (ev) {
            ev.stopImmediatePropagation();
        });
        timeInput.on('keyup', function (ev) {
            ev.stopImmediatePropagation();
        });

        // Div for bad format message
        var messageRow = $(document.createElement('div'));
        messageRow.css({
            'color': 'white',
            'width': '80%',
            'left': '10%',
            'font-size': '0.7em',
            'position': 'absolute',
            'text-align': 'center',
            'margin-top': '1%'
        });
        dialogForm.append(messageRow);

        // Container for "save / cancel" buttons
        var buttonRow = $(document.createElement('div'));
        buttonRow.css({
            //'margin-top': '10px',
            //'text-align': 'left',

            'position': 'absolute',
            'display': 'block',
            'width': '80%',
            'left': '10%',
            'top': '60%'
        });
        dialogForm.append(buttonRow);


        //////////

        var buttonDiv = $(document.createElement("div"));
        buttonDiv.css('text-align', 'right');
        var emptyDiv = $(document.createElement("div"));
        emptyDiv.css('clear', 'both');
        var submitButton = $(document.createElement("button"));
        submitButton.text("Apply");
        submitButton.css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'absolute',
            'float': "left",
            'margin-top': '7%'


        });
        var cancelButton = $(document.createElement('button')).css('border-radius', '3.5px');
        cancelButton.attr('type', 'button');
        cancelButton.text("Cancel");
        cancelButton.css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "right",
            'margin-top': '7%',
            'bottom': '1%'
        });
        buttonRow.append(cancelButton);
        buttonRow.append(submitButton);
        buttonRow.append(emptyDiv);
        //renameDialog.append(buttonDiv);
        dialogForm.append(buttonRow);


        ////////////

        //creates all buttons and adds them to panel
        //var submitButton = $(document.createElement('button'));
        //submitButton.css({
        //    width: 'auto',
        //    border: '1px solid white',
        //    padding: '1%',
        //    'float':'right'
        //});
        //submitButton.text('Apply');
        //buttonRow.append(submitButton);

        //var cancelButton = $(document.createElement('button'));
        //cancelButton.attr('type', 'button');
        //cancelButton.css({
        //    width: 'auto',
        //    border: '1px solid white',
        //    padding: '1%',
        //});
        //cancelButton.text('Cancel');
        cancelButton.click(function () { dialogOverlay.fadeOut(500); });
        buttonRow.append(cancelButton);

        // export tour json to file



        exportButton.on("click", exportJSON);

        function exportJSON() {
            var date = Date.now();
            var json = timeline.toRIN(true);
            var json_str = JSON.stringify(json);
            var messageBox;

            var html_content = '';
            html_content += '<!DOCTYPE html>\n';
            html_content += '    <html>\n';
            html_content += '    <head>\n';
            html_content += '        <title>TAG Tour Embedding</title>\n';
            html_content += '        <script src="TAG-min.js"></script>\n';
            html_content += '        <script>\n';
            html_content += '            window.onload = load;\n';
            html_content += '            function load() {\n';
            html_content += '                TAG({\n';
            html_content += '                    path: "",\n';
            html_content += '                    containerId: "tagContainer",\n';
            html_content += '                    serverIp: "' + localStorage.ip + '",\n';
            html_content += '                    width: "1000px",\n';
            html_content += '                    height: "500px",\n';
            html_content += '                    pageToLoad: "#tagpagename=tour&tagguid=' + spec.tour.Identifier + '&tagtouronly=false&tagserver=' + localStorage.ip + '"\n';
            html_content += '                });\n';
            html_content += '            }\n';
            html_content += '        </script>\n';
            html_content += '    </head>\n';
            html_content += '    <body style="height:1000px;width:1100px;">\n';
            html_content += '        <div id="tagContainer" style="margin-left:50px;margin-top:50px"></div>\n';
            html_content += '    </body>\n';
            html_content += '</html>';

            hideMenu();

            messageBox = popupTextareaDialog("Copy the text below into an HTML file and place this file in the top-level 'TAG' directory of the TAG web app source code. Please see our website (cs.brown.edu/research/ptc/tag) for more details.", html_content);
            $('body').append(messageBox);
            messageBox.fadeIn(500);
            //Windows.Storage.KnownFolders.picturesLibrary.createFileAsync("TourPlayer" + date + ".html").then(
            //    function (file) {
            //        Windows.Storage.FileIO.writeTextAsync(file, html_content).done(function () {
            //            messageBox = TAG.Util.UI.popUpMessage(null, "Tour player file created in your Pictures Library.", null);
            //            $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
            //            $('body').append(messageBox);
            //            $(messageBox).fadeIn(500);
            //        });
            //    }
            //);
        }
        function popupTextareaDialog(description, text) {
            var overlay = $(TAG.Util.UI.blockInteractionOverlay()),
                messageDiv = $(document.createElement('div')),
                textarea = $(document.createElement('textarea')),
                closeButton = $(document.createElement('button')).css('border-radius', '3.5px'),
                optionButtonDiv = $(document.createElement('div')),
                confirmBox = $(document.createElement('div')),
                confirmBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(), { // TODO is window right for the web app?
                    center_h: true,
                    center_v: true,
                    width: 0.5,
                    height: 0.6,
                    max_width: 1200,
                    max_height: 1200,
                });

            overlay.on('click', removeAll);

            confirmBox.css({
                position: 'absolute',
                left: confirmBoxSpecs.x + 'px',
                top: confirmBoxSpecs.y + 'px',
                width: confirmBoxSpecs.width + 'px',
                height: confirmBoxSpecs.height + 'px',
                border: '3px double white',
                'background-color': 'black'
            });
            confirmBox.on('click', function (evt) {
                evt.stopPropagation();
            });

            messageDiv.addClass('popupTextareaMessage');
            messageDiv.css({
                'font-size': '1.2em',
                'height': '60px',
                'left': '5%',
                'position': 'relative',
                'margin-top': '10px',
                'width': '90%'
            });
            messageDiv.text(description);

            textarea.css({
                left: '4%',
                position: 'relative',
                'margin-top': '12px',
                width: '90%'
            });
            textarea.attr({
                value: text
            });

            optionButtonDiv.addClass('optionButtonDiv');
            optionButtonDiv.css({
                'height': '30px',
                'width': '90%',
                'position': 'relative',
                'left': '5%',
                'margin-top': '10px'
            });

            closeButton.css({
                'border': '1px solid white',
                'display': 'inline-block',
                'float': 'right',
                'position': 'relative'
            });
            closeButton.text('Close');
            closeButton.on('click', removeAll);

            function removeAll() {
                overlay.fadeOut(500, function () { overlay.remove(); });
            }

            optionButtonDiv.append(closeButton);
            confirmBox.append(messageDiv);
            confirmBox.append(textarea);
            confirmBox.append(optionButtonDiv);
            overlay.append(confirmBox);
            textarea.css('height', (confirmBox.height() - optionButtonDiv.height() - messageDiv.height() - 60) + 'px');

            return overlay;
        }
        /*the helper function to hide menus when an option is clicked*/
        function hideMenu() {
            $('.tourOptionDropDownIcon').css({ 'transform': 'scaleY(1)', 'margin-bottom': '0%' });
            menuVisible = false;
            dropMain.hide();
        }

    })();
    function applyCSS(css) {
        functionsPanel.css(css);
    }
    that.applyCSS = applyCSS;

    function applyLabelCSS(css) {
        addTourOptionsLabel.css(css);
    }
    that.applyLabelCSS = applyLabelCSS;

    function addToDOM(container) {
        container.append(functionsPanel).append(dialogOverlay);
        container.append(functionsPanel).append(thumbnailcaptured);
    }
    that.addToDOM = addToDOM;

    function getBufferedData() {
        var returndata = optionsBuffer;
        optionsBuffer = {};
        return returndata;
    }
    that.getBufferedData = getBufferedData;

    return that;
};

;
TAG.Util.makeNamespace('TAG.TourAuthoring.Track');
TAG.Util.makeNamespace('TAG.TourAuthoring.TrackType');


// Enum defining track types
TAG.TourAuthoring.TrackType = {
    audio: 1,
    video: 2,
    artwork: 3,
    ink: 4,
    image: 5,
};

/**
 * Represents all the displays and keyframes of a piece of media over the duration of a tour
 * Maps to Experience Stream in RIN
 * @param spec.type         one of TAG.TourAuthoring.TrackType
 * @param spec.media        URI of resource
 * @param spec.title        Name to display
 * @param spec.id           Unique id (number)
 * @param spec.guid         Worktop GUID, artworks only
 * @param spec.timeManager  Reference to time object storing current length and scale of timeline
 * @param my                Object that will hold keyframes and displays (for accessing by subclasses w/o making public)
 *                          Will be returned w/ 'displays', 'resource', 'type', 'timeManager', 'undoManager', 'track', 'svg' parameters
 *                          Also used to track currentDisplay, currentKeyframe on mousedown, selectedKeyframe for keyframe capture (set in displays and keyframes)
 */
TAG.TourAuthoring.Track = function (spec, my) {
    "use strict";

    var that = {},
        media = spec.media,
        storageContainer,
        dataHolder = spec.dataHolder,
        id = ('Track-' + spec.id),
        arrayPos = spec.id,//stores the position of the selected track in the 'trackarray' array
        guid = spec.guid,
        playbackControls = spec.playbackControls,
        titlediv, // for track minimization
        titleDivManip = false,//variable used to determine when a track has been selected for vertical movement/swapping with another track 
        prevTrack = {},
        trackBody,
        prevTitleDiv = {},
        renameOverlay = $(TAG.Util.UI.blockInteractionOverlay()), //overlay for when 'rename' component option is selected
        deleteOverlay = $(TAG.Util.UI.blockInteractionOverlay()),
        editInkOverlay = $(TAG.Util.UI.blockInteractionOverlay()), //overlay for when 'edit ink' component option is selected while playhead is not over the art track
        beforeTitle = null,
        spaceBefore = false,
        fadeHidden = true,
        lastScale,
        isMinimized = false,
        released = true,
        //attachedInks = [],
        mygroup; // group that contains svg lines for audio tracks only - used by track minimization

    var iconDiv = $(document.createElement('div'));

    my = my || {};
    my.title = decodeURI(spec.title);
    my.resource = 'R-' + arrayPos;
    my.root = spec.root;
    my.type = spec.type || TAG.TourAuthoring.TrackType.artwork;
    my.timeManager = spec.timeManager;
    my.undoManager = spec.undoManager;
    my.update = spec.update; // Call this function every time a change affecting RIN data is made
    my.timeline = spec.timeline;
    my.dirtyKeyframe = false;//keeps track of when a new keyframe has been added to a track
    my.that = that;
    my.selectedTrack = spec.selectedTrack;
    my.mediaLength = spec.mediaLength;
    my.isVisible = true;
    my.attachedInks = [];
    my.converted = spec.converted;                                                                  // boolean to check if a video track is converted or not
    my.toConvert = spec.toConvert;                                                                  // boolean to check if the user want to convert a video track right after uploading

    lastScale = my.timeManager.getDuration().scale;

    // private variables
    my.displays = [];
    // A variable to store all the keyframes for the audio track : Hak
    my.allKeyframes = [];

    // HTML creation
    var convertbtn;                                                                                 //convert video button for video tracks
    var chkIntervalVal;
    var titleConversionMsg
    // Title for header
    var titledivPlaceholder,
        titleText,
        movingIndicator,//variable to keep track of when the white bar indicating if a track can be swapped with a selected track should appear on the titledivs
        compOpsOpen = false,//keeps track of when the 'component options' menu which appears on right clicking on  track is open or not
        eventsPaused = false;
    that.compOpsOpen = compOpsOpen;
    function checkVideoConverted() {
        var retstring;
        if (my.converted === false && my.toConvert === true) {
            var videotag = $(document.createElement('video'));
            videotag.attr('preload', 'metadata');
            var filename = media.slice(8, media.length);//get rid of /Images/ before the filename
            var basefilename = filename.substr(0, filename.lastIndexOf('.'));
            var fileExt = filename.substr(filename.lastIndexOf('.'));
            TAG.Worktop.Database.getConvertedCheck(
                (function (videotag) {
                    return function (output) {
                        retstring = output;
                        if (output !== "False" && output !== "Error") {
                            console.log("converted: ");
                            var mp4filepath = "/Images/" + basefilename + ".mp4";
                            var mp4file = TAG.Worktop.Database.fixPath(mp4filepath);
                            videotag.attr('src', mp4file);
                            videotag.on('loadedmetadata', function () {
                                //remove from the video array and add display with the right duration
                                changeTrackColor('white');
                                my.converted = true;
                                my.toConvert = true;
                                my.mediaLength = this.duration
                                if (fileExt !== ".mp4") {
                                    addDisplay(0, this.duration);
                                }
                                //convertbtn.remove();
                                titleConversionMsg.text("");
                                titleText.css('font-style', 'normal');
                                titlediv.css("opacity", "1");
                                clearInterval(chkIntervalVal);

                            });
                        } if (output === "Error") {
                            my.converted = false;
                            titleText.css('font-style', 'italic');
                            titleConversionMsg.text("Conversion Error");
                            titlediv.css('opacity', '0.7');
                            //pop up message 
                            //if (first!==0) {
                            var popup = TAG.Util.UI.popUpMessage(null, "An error occurred when converting video " + my.title + ". Please try to import it again.", "OK", null, null, null, true);
                            $('body').append(popup);
                            $(popup).css('z-index', 1000000);
                            $(popup).show();
                            //}
                            clearInterval(chkIntervalVal);
                            console.log("Error ocurred when converting");
                        }
                        else {
                            console.log("not converted: ");
                        }
                    }
                })(videotag), null, filename, basefilename);
        }
        return retstring;
    }
    chkIntervalVal = setInterval(checkVideoConverted, 5000);

    (function _initTitle() {
        titlediv = $(document.createElement('div'));
        titlediv.attr('id', id + '-title');
        titlediv.addClass('titlediv');
        titlediv.css({
            "height": TAG.TourAuthoring.Constants.trackHeight+'px',
            "width": 0.127 * $(window).width() + 'px',
            'margin-left': '20px',
            'left': '0%',
            'position': 'relative',
            "background-color": "rgb(105,89,89)", 
            'border-bottom-style': 'solid',
            'border': '1px solid #888',
            'top': '0px',
            'overflow': 'hidden',
            'z-index': 0,
        });

        titleText = $(document.createElement('div'));
        titleText.addClass('track-title');
        titleText.text(my.title);
        titleText.css({
            'font-size': '.75em',
            'color': 'white',
            'top': '8%', 'left': '3%',
            'position': 'relative',
            'overflow': 'hidden',
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap',
            'display': 'block',
            'width': 0.115*$(window).width() + 'px',
        });
        titleConversionMsg = $(document.createElement('div'));
        titleConversionMsg.addClass("track-conversion");
        titleConversionMsg.css({
            'font-size': '0.5em',
            'color': 'white',
            'top': '16%',
            'left': '3%',
            'position': 'relative',
            'overflow': 'hidden',
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap',
            'display': 'block',
            'width': 0.115 * $(window).width() + 'px',
        });
        //        if (my.toConvert === true && my.converted !== true) {
        //            titleText.css('font-style', 'italic');
        //            titleConversionMsg.text("Converting video...");
        //            titlediv.css('opacity','0.7');
        //        }
        if (!spec.firstupload) {
            var status = checkVideoConverted();
            if (status === "Error") {
                titleText.css('font-style', 'italic');
                titleConversionMsg.text("Conversion Error");
                titlediv.css('opacity', '0.7');
            }
            if (status === "False") {
                titleText.css('font-style', 'italic');
                titleConversionMsg.text("Converting video...");
                titlediv.css('opacity', '0.7');
            }
        } else {
            titleText.css('font-style', 'italic');
            titleConversionMsg.text("Converting video...");
            titlediv.css('opacity', '0.7');
        }
        
        titlediv.append(titleText);
        titlediv.append(titleConversionMsg);

        //call add icon function here
        addIconToTitle(my.type);
    })();
    
    function initVisuals() {
        // Track container
        my.track = $(document.createElement('div'));
        my.track.attr('id', id);
        my.track.addClass('track');
        my.track.css({
            "height": TAG.TourAuthoring.Constants.trackHeight + 'px', // changed 25%
            'position': 'relative',
            'top': '0%',
            'left': '0%',
            "background-color": "rgb(255, 255, 255)",
            'border': '1px solid #888',
            "box-shadow": "5px 0px 10px -2px #888 inset",
            "overflow":"hidden"
        });
        if (!my.mediaLength && my.converted === false) {
            my.track.css({ "background-color": "gray", });
        }
        // SVG
        my.svg = d3.select(my.track[0])
            .append("svg")
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('overflow', 'hidden')
            .attr('style', 'position: absolute');

        // HK: Where the lines will be drawn
        my.svgLines = my.svg.append("svg:g")
            .classed("connectionLines", true);

        // HK: Draws the initial line for the audio track to distinguish it as an audio track
        if (my.type == TAG.TourAuthoring.TrackType.audio) {
            mygroup = my.svgLines.append("svg:g")
                .attr("id", "keyframeLines");
            var myLine = mygroup.append("svg:line")
                .attr("x1", 0)
                .attr("y1", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                .attr("x2", '100%')
                .attr("y2", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                .style('pointer-events', 'none')
                .style("stroke", "green")
                .style("stroke-width", 4);
        }

        var _trackSizing = function (ev) {
            var displays = (dataHolder.getDisplays(arrayPos) && dataHolder.getDisplays(arrayPos).getContents()) || [];
            var i, j, keyframes;
            my.track.css('width', my.timeManager.timeToPx(ev.end) + 'px');
            for (i = 0; i < displays.length; i++) {
                displays[i].display.resetVisuals();
                keyframes = dataHolder.getKeyframes(displays[i]).getContents();
                for (j = 0; j < keyframes.length; j++) {
                    keyframes[j].resetVisuals();
                }
            }
            
        };
        _trackSizing(my.timeManager.getDuration());
        my.timeManager.onSizing(_trackSizing);
    }
    initVisuals();

    function _initTrack() {
        // Track container
        my.track = $(document.createElement('div'));
        my.track.attr('id', id);
        my.track.addClass('track');
        my.track.css({
            "height": TAG.TourAuthoring.Constants.trackHeight + 'px', // changed 25%
            'position': 'relative',
            'top': '0%',
            'left': '0%',
            "background-color": "rgb(255, 255, 255)",
            'border': '1px solid #888',
            "box-shadow": "5px 0px 10px -2px #888 inset"
        });

        var _trackSizing = function (ev) {
            my.track.css('width', my.timeManager.timeToPx(ev.end) + 'px');
        };
        _trackSizing(my.timeManager.getDuration());
        my.timeManager.onSizing(_trackSizing);

        // SVG
        my.svg = d3.select(my.track[0])
            .append("svg")
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('overflow', 'hidden')
            .attr('style', 'position: absolute');

        // Gradient definitions
        var defs = my.svg.append('defs');
        defs.append('linearGradient')
            .attr('id', 'fade-in')
            .attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%')
            .call(
                function (gradient) {
                    gradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgb(256,256,256)').attr('stop-opacity', '0.75');
                    gradient.append('stop').attr('offset', '85%').attr('stop-color', TAG.TourAuthoring.Constants.displayColor).attr('stop-opacity', '0.75');
                });
        defs.append('linearGradient')
            .attr('id', 'fade-out')
            .attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%')
            .call(
                function (gradient) {
                    gradient.append('stop').attr('offset', '15%').attr('stop-color', TAG.TourAuthoring.Constants.displayColor).attr('stop-opacity', '0.75');
                    gradient.append('stop').attr('offset', '100%').attr('stop-color', 'rgb(256,256,256)').attr('stop-opacity', '0.75');
                });
        defs.append('linearGradient')
            .attr('id', 'fade-in-ink')
            .attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%')
            .call(
                function (gradient) {
                    gradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgb(256,256,256)').attr('stop-opacity', '0.75');
                    gradient.append('stop').attr('offset', '85%').attr('stop-color', TAG.TourAuthoring.Constants.inkDisplayColor).attr('stop-opacity', '0.75');
                });
        defs.append('linearGradient')
            .attr('id', 'fade-out-ink')
            .attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%')
            .call(
                function (gradient) {
                    gradient.append('stop').attr('offset', '15%').attr('stop-color', TAG.TourAuthoring.Constants.inkDisplayColor).attr('stop-opacity', '0.75');
                    gradient.append('stop').attr('offset', '100%').attr('stop-color', 'rgb(256,256,256)').attr('stop-opacity', '0.75');
                });


        // HK: Where the displays will be drawn
        my.svgDisplays = my.svg.append("svg:g")
            .classed("displayDrawing", true);

        // HK: Where the lines will be drawn
        my.svgLines = my.svg.append("svg:g")
            .classed("connectionLines", true);

        // HK: Draws the initial line for the audio track to distinguish it as an audio track
        if (my.type == TAG.TourAuthoring.TrackType.audio) {
            mygroup = my.svgLines.append("svg:g")
                .attr("id", "keyframeLines");
            var myLine = mygroup.append("svg:line")
                .attr("x1", 0)
                .attr("y1", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                .attr("x2", '100%')
                .attr("y2", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                .style('pointer-events', 'none')
                .style("stroke", "green")
                .style("stroke-width", 4);
        }
    }

    var menu = TAG.TourAuthoring.EditorMenu({
        type: TAG.TourAuthoring.MenuType.track,
        parent: that
    }, my);
    (function _initMenu() {
        menu.addTitle('Track Options');
        var renameButton = menu.addButton('Rename', 'left', componentOptionRename);
        if (my.type === TAG.TourAuthoring.TrackType.ink) {
            menu.addButton('Edit Annotation', 'left', componentOptionEditInk);
        }
        if (my.type === TAG.TourAuthoring.TrackType.video && !my.toConvert) {
            convertbtn = menu.addButton('Convert', 'left', componentOptionConvertVideo);

            //if (my.toConvert === true) {
            //    convertbtn.text("Converting");
            //    convertbtn.css({
            //        'color': 'gray' 
            //    })
            //    convertbtn.data('disabled', true);
            //}
        }
        var duplicateButton = menu.addButton('Duplicate', 'left', componentOptionDuplicate);
        var deleteButton = menu.addButton('Delete', 'left', componentOptionDelete);
        var cancelButton = menu.addButton('Cancel', 'left', componentOptionCancel);

        //Rename button highlighting
        renameButton.on('mousedown', function () {
            renameButton.css({ "background-color": "white", "color": "black" });
        });

        renameButton.on('mouseup', function () {
            renameButton.css({ "background-color": "transparent","color":"white" });
        });

        renameButton.on('mouseout', function () {
            renameButton.css({ "background-color": "transparent", "color": "white" });
        });

        //Duplicate button highlighting
        duplicateButton.on('mousedown', function () {
            duplicateButton.css({ "background-color": "white", "color": "black" });
        });

       duplicateButton.on('mouseup', function () {
            duplicateButton.css({ "background-color": "transparent", "color": "white" });
        });

        duplicateButton.on('mouseout', function () {
            duplicateButton.css({ "background-color": "transparent", "color": "white" });
        });

        //Delete button highlighting
        deleteButton.on('mousedown', function () {
            deleteButton.css({ "background-color": "white", "color": "black" });
        });

        deleteButton.on('mouseup', function () {
            deleteButton.css({ "background-color": "transparent", "color": "white" });
        });

        deleteButton.on('mouseout', function () {
            deleteButton.css({ "background-color": "transparent", "color": "white" });
        });

        //Cancel button highlighting
        cancelButton.on('mousedown', function () {
            cancelButton.css({ "background-color": "white", "color": "black" });
        });

        cancelButton.on('mouseup', function () {
            cancelButton.css({ "background-color": "transparent", "color": "white" });
        });

        cancelButton.on('mouseout', function () {
            cancelButton.css({ "background-color": "transparent", "color": "white" });
        });

    })();

    function close() {
        menu.forceClose();
    }

    function displayError(displayString) {
        close();
        var messageBox = TAG.Util.UI.popUpMessage(null, displayString, null);
        $(messageBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
        $('body').append(messageBox);
        $(messageBox).fadeIn(500);

        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection) {
            currSelection.setDeselected();
        }
    }
    function componentOptionConvertVideo(evt) {
        var curtrack = that;
        var newFileName = media.slice(8, media.length);
        var index = newFileName.lastIndexOf(".");
        var fileExtension = newFileName.slice(index);
        var baseFileName = newFileName.slice(0, index);
        TAG.Worktop.Database.convertVideo(function () {
        }, null, newFileName, fileExtension, baseFileName, null, "True");
        my.toConvert = true;
        //disable the button
        convertbtn.remove();

        titleConversionMsg.text("Converting...");
        titlediv.css('opacity', '0.7');
        titleText.css('font-style', 'italic');
        //convertbtn.text("Converting");
        //convertbtn.css({
        //    'color': 'gray'
        //})
        //convertbtn.data('disabled', true);
        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection) {
            currSelection.setDeselected();
        }
        close();
    }
    //method for manipulating ink canvas
    function componentOptionEditInk(evt) {
        var i;
        var displays = that.getStorageContainer().displays.getContents();
        if ($("#inkDrawControls").css("display") == "block" || $("#inkTransparencyControls").css("display") == "block" || $("#inkTextControls").css("display") == "block" || $("#inkEditDraw").css("display") == "block" || $("#inkEditTransparency").css("display") == "block" || $("#inkEditText").css("display") == "block") {
            displayError("An annotation is already being edited.");
            return;
        }

        if (!displays.length) {
            displayError("The annotation must be visible in the preview window in order to edit it.");
            return;
        }

        var inArtDisplay = true; //keeps track of if playhead is in art display
        var currTime = my.timeManager.getCurrentTime();

        if (getInkEnabled()) {
            var currTrack = getInkLink(),
                trackdisplays = currTrack.getDisplays();
            for (i = 0; i < trackdisplays.length; i++) {
                if ((trackdisplays[i].getStart() <= currTime) && (currTime <= trackdisplays[i].getOutStart() + trackdisplays[i].getFadeOut())) {
                    inArtDisplay = true;
                    break;
                }
                inArtDisplay = false;
            }
        }

        var inInkDisplay = false;//keeps track of if playhead is in ink display
        var closestTime = -1000000;

        // ******************************************************************
        // TODO: convert array to a tree for easy search between time ranges
        // ******************************************************************

        for (i = 0; i < displays.length; i++) {
            if (displays[i].display.getStart() <= currTime && currTime <= displays[i].display.getOutStart() + displays[i].display.getFadeOut()) {
                //inside the end of the fade-out and the start of the fade-in
                inInkDisplay = true;
                break;
            }
        }

        //ensures warning message appears if user tries to edit an ink without the playhead being inside artwork and ink, ink or artwork
        if ((!inInkDisplay) || (!inArtDisplay)) {
            displayError("The annotation must be visible in the preview window in order to edit it.");
            return;
        }

        my.timeManager.stop();
        var old_datastring = that.getInkPath();
        var inkType = old_datastring.split("::")[0].toLowerCase();
        close();

        if (!old_datastring || !inkType) {
            displayError("This annotation track has become corrupted, please remove and create a new ink.");
            return;
        }


        var ES = $("[ES_ID='" + my.title + "']");
        if (!ES[0]) {
            displayError("The annotation must be visible in the preview window in order to edit it.");
            return;
        }

        //that.setInkPath("");
        my.isVisible = false;

        if (inkType === "path" || inkType == "bezier") { //edit draw ink
            my.timeline.showEditDraw(that, old_datastring);
        }
        else if (inkType === "trans") { //edit transparency
            var transType = old_datastring.split("[mode]")[1].split("[")[0];
            my.timeline.showEditTransparency(that, old_datastring, transType);
        }
        else if (inkType === "text") { //edit text
            var text_elt = ES.find('text');
            var viewBox = text_elt[0] ? ES.find('svg')[0].getAttribute('viewBox') : null;
            if (!text_elt[0] || (getInkEnabled() && !viewBox)) {
                my.isVisible = true;
                displayError("The annotation must be loaded and on screen in order to edit it.");
                return;
            }
            var rinplayer = $('#rinplayer');
            var dims = {
                x: text_elt.offset().left - rinplayer.offset().left,
                y: text_elt.offset().top - rinplayer.offset().top,
                w: text_elt[0].getBBox().width,
                h: text_elt[0].getBBox().height,
                fontsize: getInkEnabled() ? parseFloat(text_elt.attr("font-size")) * (rinplayer.height() / parseFloat(viewBox.split(" ")[3])) : null
            };
            my.timeline.showEditText(that, old_datastring, dims);
        } else {
            my.isVisible = true;
            displayError("This annotation track is in a deprecated format, please remove and create a new ink.");
            return;
        }

        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection) {
            currSelection.setDeselected();
        }
        
        //show overlay to make all tracks non-clickable when edit ink
        if (my.isVisible === true)
            return;
        my.timeline.showEditorOverlay();
    }
    
    //method for handling rename
    function componentOptionRename(evt) {
        menu.close();
        var renameDialog = $(document.createElement("div"));
        renameDialog.attr("id", "renameDialog");


        ///new css
        var renameDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width: 560,
               max_height: 200,
           });
        renameDialog.css({
            position: 'absolute',
            left: renameDialogSpecs.x + 'px',
            top: renameDialogSpecs.y + 'px',
            width: renameDialogSpecs.width + 'px',
            height: renameDialogSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',
        });

        renameOverlay.append(renameDialog);
        var renameDialogTitle = $(document.createElement('div'));
        renameDialogTitle.attr('id', 'renameDialogTitle');
        renameDialogTitle.css({
            color: 'white',
            'width': '80%',
            'height': '15%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '1.25em',
            'position': 'relative',
            'text-align': 'center',
            'word-wrap': 'break-word',
        });


        //renameDialog.css({
        //    'height': '30%',
        //    'width': '45%',
        //    'position': 'fixed',
        //    'top': '50%',
        //    'left': '50%',
        //    'margin-top': '-15%',
        //    'margin-left': '-22.5%',
        //    'background-color': 'black',
        //    'z-index': TAG.TourAuthoring.aboveRinZIndex+5,
        //    'border': '3px double white',
        //});
         
        //renameOverlay.append(renameDialog);
        $("body").append(renameOverlay);
        my.timeManager.stop();
        renameOverlay.fadeIn(500);
        var form = $(document.createElement("form"));
        var newName = $(document.createElement("input"));
        /*newName.on('keyup', function () {
            var txt = (newName && newName[0] && newName[0].value) ? newName[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (newName && newName[0] && newName[0].value && newName[0].value != txt) {
                newName[0].value = txt;
            }
        });*/
        form.css("text-align", 'left').attr("maxlength","100");
        newName.attr("type", "text");
        newName.css("margin", '4% 4%');
        newName.css("width", '100%'); 
        newName.attr("id","newNameInput"); 
        newName.val(my.title); // default text is existing title
        var text = $(document.createElement("div"));
        newName.attr('maxlength', '50');
        text.text("Rename track to: ");
        text.css({
            //'top': '5%',
            //'height': '20%',
            //'width': '90%',
            //'color': 'white',
            //'margin': '5%',
            //'font-size': '200%'

            color: 'white',
            'width': '80%',
            //'height': '15%',
            'left': '10%',
            //'top': '12.5%',
            'font-size': '1.25em',
            'position': 'absolute',
            'text-align': 'center',
            //'overflow': 'hidden',
            'margin-top': '3%',
        });
        form.append(text);

        form.append(newName);
        renameDialog.append(form);
        newName.css({
            'width': '80%',
            'margin-left': '10%',
            'margin-right': '10%',
            'margin-top':'10%',//'10%',
            'box-sizing': 'border-box',
            'position':'relative',
            //width: 92%; margin-left: 4%; box-sizing: border-box;

        });
        var buttonDiv = $(document.createElement("div"));
        buttonDiv.css('text-align', 'right');
        var emptyDiv = $(document.createElement("div"));
        emptyDiv.css('clear', 'both');
        var buttonRow = $(document.createElement('div'));
        buttonRow.css({
            //'margin-top': '10px',
            //'text-align': 'center',

            'position': 'relative',
            'display': 'block',
            'width': '80%',
            'left': '10%',


        });
        buttonDiv.append(buttonRow);
        var ok = $(document.createElement("button"));
        ok.text("Apply");
        ok.css({
            //'left': '4%',
            //'bottom': '10%',
            //'font-size': '140%',
            //'position': 'absolute',
            //'box-sizing': 'border-box',

            'padding': '1%',
            'border': '1px solid white',
            'border-radius':'3.5px',
            'width': 'auto',
            'position': 'relative',
            //'margin-top': '1%',
            'float': "right",
            'margin-right': '7%',
            'margin-top': '5%',
                        

        });
        buttonRow.append(ok);
        var cancel = $(document.createElement('button'));
        cancel.attr('type', 'button');
        cancel.text("Cancel");
        cancel.css({
         

            //'right': '4%',
            //'bottom': '10%',
            //'font-size': '140%',
            //'position': 'absolute',
            //'box-sizing': 'border-box',

            'padding': '1%',
            'border-radius': '3.5px',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            //'margin-top': '1%',
            'margin-left': '7%',
            'float': "left",
            'margin-top': '5%',
        });
        //buttonDiv.append(cancel);
        //buttonDiv.append(ok);
        buttonDiv.append(emptyDiv);
        buttonRow.append(cancel);
        //renameDialog.append(buttonDiv);
        renameDialog.append(buttonRow);
        renameDialog.show();
        close();

        ok.click(okTap);
        cancel.click(function () {
            renameOverlay.fadeOut(500);
            $(renameOverlay).remove();
        });
        
        $(document).keypress(function (e) {
            if (e.which == 13) {
                okTap(e);
            }
        });

        function okTap(evt) {
            $(renameOverlay).fadeOut(500);
            var tmpTitle = that.getTitle();
            that.setTitle(newName.val().replace(/\'/g, '').replace(/\"/g, ''));
            //renameDialog.remove();
            $(renameOverlay).remove();
            //bleveque: if we change the title of an artwork or image  track, update the links of any attached inks
            if (my.type == TAG.TourAuthoring.TrackType.artwork || my.type == TAG.TourAuthoring.TrackType.image) {
                dataHolder.mapTracks(function (currentTrack) {
                    if (currentTrack.track.getType() == TAG.TourAuthoring.TrackType.ink && currentTrack.track.getInkEnabled() && currentTrack.track.getInkLink().getTitle() == that.getTitle()) {
                        currentTrack.setInkLink(that);
                    }
                });
            }
            
        }
        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection) {
            currSelection.setDeselected();
        }
    }

    function componentOptionDuplicate(evt) { // creates a duplicate track underneath
        menu.close();
        var currTrack = that;
        var undoStackSize = my.undoManager.undoStackSize();
        //var displays = currTrack.getDisplays(); // each has access to its keyframes
        var media = currTrack.getMedia();
        var pos = currTrack.getPos();
        
        var name = currTrack.getTitle();
        var keyframes, e, inFade, outFade, key; // e is the new track
        switch (currTrack.getType()) {
            case TAG.TourAuthoring.TrackType.audio:
                e = my.timeline.addAudioTrack(media, name, null, my.mediaLength);
                addTracksDisplays(e);
                currTrack.insert(e);
                break;

            case TAG.TourAuthoring.TrackType.video:
                e = my.timeline.addVideoTrack(media, name, null, my.mediaLength);
                addTracksDisplays(e);
                currTrack.insert(e);
                break;

            case TAG.TourAuthoring.TrackType.image:
                e = my.timeline.addImageTrack(media, name, null);
                addTracksDisplays(e);
                currTrack.insert(e);
                break;

            case TAG.TourAuthoring.TrackType.ink:
                var expID = currTrack.getInkLink();
                e = my.timeline.addInkTrack(expID, name, currTrack.getMedia(), currTrack.getInkSpec(), null);
                if (expID) {//if it is an attached ink
                    expID.addAttachedInkTrack(e);
                    e.setInkLink(expID);
                }
                addTracksDisplays(e);
                currTrack.insert(e);
                e.setInkEnabled(currTrack.getInkEnabled());
                e.setInkPath(currTrack.getInkPath());
                e.setInkProps({}); // not used
                e.setInkInitKeyframe(currTrack.getInkInitKeyframe());
                e.setInkRelativeArtPos(currTrack.getInkRelativeArtPos());
                
                e.addInkTypeToTitle(currTrack.getInkPath().split('::')[0].toLowerCase());
                break;

            case TAG.TourAuthoring.TrackType.artwork:
                e = my.timeline.addArtworkTrack(media, name, currTrack.getGUID(), null);
                addTracksDisplays(e);
                currTrack.insert(e);
                break;
        }

        function addTracksDisplays(e) {
            var trackNum = e.getPos();
            var displayContent = that.getStorageContainer().displays.getContents();
            for (var i = 0; i < displayContent.length; i++) {
                addEachTrackDisplay(i);
            }

            function addEachTrackDisplay(i) {
                var dispLength, dispStart, currDisp = displayContent[i].display;
                if (currTrack.getType() !== TAG.TourAuthoring.TrackType.audio) {
                    dispLength = currDisp.getMain() + 2 * TAG.TourAuthoring.Constants.defaultFade;
                    dispStart = currDisp.getMainStart() - TAG.TourAuthoring.Constants.defaultFade;
                }
                else {
                    dispLength = currDisp.getMain();
                    dispStart = currDisp.getMainStart();
                }

                var sourceDisp = displayContent[i];
                var newDisp = e.addDisplay(my.timeManager.timeToPx(dispStart), dispLength);

                var parentDisp = sourceDisp.display.getParentDisplay();

                if (parentDisp) {
                    parentDisp.addChildDisplay(newDisp);
                    newDisp.setParentDisplay(parentDisp);
                }

                //newDisp.setFadeInFromMenu(currDisp.getFadeIn());
                //newDisp.setFadeOutFromMenu(currDisp.getFadeOut());
                newDisp.basicSetTimes(sourceDisp.display.getTimes()); // we know exactly what the times should be for each display; no need to do bounds checking

                var sourcekf = currDisp.getStorageContainer().keyframes.getContents();//reset for current display
                for (var j = 0; j < sourcekf.length; j++) {
                    var currkf = sourcekf[j];
                    if (currTrack.getType() === TAG.TourAuthoring.TrackType.audio) {//need y value for volume keyframes
                        var newkf = newDisp.addKeyframe(my.timeManager.timeToPx(currkf.getTime()), currkf.getVolumePx());//adds keyframe and stores it
                        e.addKeyframeToLines(newkf);//adds it to audio lines
                        newkf.restoreHandlers();
                    }
                    else {
                        var newkf = newDisp.addKeyframe(my.timeManager.timeToPx(currkf.getTime()));
                        newkf.loadRIN(currkf.getCaptureData());
                        my.dirtyKeyframe = true;
                        newkf.restoreHandlers();
                    }
                }
            }
            my.timeManager.setScale(my.timeManager.getScale()); // bleveque: TODO hacky fix before SAM release -- figure out why displays were showing up strangely otherwise
            console.log("combining " + (my.undoManager.undoStackSize() - undoStackSize));
            my.undoManager.combineLast(my.undoManager.undoStackSize() - undoStackSize);
        }

    }

   


    //event handling for delete button
    function componentOptionDelete(evt) {

        menu.close();
        //

        var deleteDialog = $(document.createElement("div"));
        deleteDialog.attr("id", "deleteDialog");


        ///new css
        var deleteDialogSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width: 560,
               max_height: 200,
           });
        deleteDialog.css({
            position: 'absolute',
            left: deleteDialogSpecs.x + 'px',
            top: deleteDialogSpecs.y + 'px',
            width: deleteDialogSpecs.width + 'px',
            height: deleteDialogSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',
        });
     
        //deleteOverlay.append(deleteDialog);
        var deleteDialogTitle = $(document.createElement('div'));
        deleteDialogTitle.attr('id', 'deleteDialogTitle');
        deleteDialogTitle.css({
            color: 'white',
            'width': '80%',
            'height': '15%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '1.25em',
            'position': 'relative',
            'text-align': 'center',
            // 'overflow': 'hidden',
            'word-wrap': 'break-word',
        });

        $("body").append(deleteOverlay);
        deleteOverlay.append(deleteDialog);

        my.timeManager.stop();
        deleteOverlay.fadeIn(500);
        close();

        var mssge = $(document.createElement('div'));
        mssge.attr('id', 'mssge');
        var text = "Are you sure you want to delete " + my.title;
         mssge.text(text);
        mssge.css({
            //color: 'white',
            //'width': '80%',
            //'height': '15%',
            //'left': '10%',
            //'top': '12.5%',
            //'font-size': '1.25em',
            //'position': 'relative',
            //'text-align': 'center',
            ////'overflow': 'hidden',
            //'word-wrap': 'break-word',
            color: 'white',
            'width': '80%',
            'height': '50%',
            'left': '10%',
            'top': '12.5%',
            'font-size': '0.8em',
            //'overflow': 'hidden',
            'position': 'relative',
            'text-align': 'center',
            'text-overflow': 'ellipsis',
            'word-wrap': 'break-word',
            'maxlength':'200'
        });
        var fontsize = TAG.Util.getMaxFontSizeEM(text, 1, mssge.width(), mssge.height());
        mssge.css('font-size', fontsize);
        deleteDialog.append(mssge);

        //var mssge = "Are you sure you want to delete " + my.title;
        var hasAttachedInks = false;
        var trackArray = dataHolder.getTracks();
        //for (var jj = 0; jj < trackArray.length; jj++) {
        //    if (trackArray[jj].getType() === TAG.TourAuthoring.TrackType.ink && trackArray[jj].getInkEnabled() && trackArray[jj].getInkLink().getTitle() === that.getTitle()) {
        //        hasAttachedInks = true;
        //        break;
        //    }
        //}
        dataHolder.mapTracks(function (i) {
            if (i.track.getType() === TAG.TourAuthoring.TrackType.ink && i.track.getInkEnabled() && i.track.getInkLink().getTitle() === that.getTitle()) {
                hasAttachedInks = true;
                return;
            }
        });

        text += ((hasAttachedInks && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) ? " and any attached annotation tracks?" : "?");
        mssge.text(text);

        //var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
        //    yesTap();
        //}, mssge, "Delete");
        //$(confirmationBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 7);
        //$('body').append(confirmationBox);
        //my.timeManager.stop();

        //$(confirmationBox).fadeIn(500);
        //close();


        var buttonRow = $(document.createElement('div'));
        buttonRow.css({
            //'margin-top': '10px',
            //'text-align': 'center',

            'height': '20%',
            'width': '80%',
            'position': 'absolute',
            'color': 'white',
            'bottom': '5%',
            'right': '10%',


        });
        deleteDialog.append(buttonRow);

        // TODO: Hook in save-to-server functionality here!
        var deleteButton = $(document.createElement('button'));
        deleteButton.css({
            'padding': '1%',
            'border-radius': '3.5px',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',
          
        });
        deleteButton.text('Delete');
        $(deleteButton).click(function () {
            yesTap();
            deleteOverlay.fadeOut(500);
            $(deleteOverlay).remove();
        });

        buttonRow.append(deleteButton);

        var cancelButton = $(document.createElement('button'));
        cancelButton.css({

            'padding': '1%',
            'border-radius': '3.5px',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'margin-top': '1%',

            'float': 'right'
        });
        cancelButton.text('Cancel');
        cancelButton.click(function () { deleteOverlay.fadeOut(500); });
        buttonRow.append(cancelButton);
        TAG.Util.multiLineEllipsis(mssge);


        function yesTap() {
            close();
            var displayData = that.getStorageContainer().displays;
            var command = TAG.TourAuthoring.Command({
                execute: function () {
                    remove();

                    //if artwork is removed, also check if ink functionality should be removed
                    if (!my.timeline.checkForArtworks(0)) {
                        my.timeline.disableInk();
                    }

                    //code to snap down track list such that the track list is always full if it can be
                    if (dataHolder.numTracks() > 0) {
                        var last = $('#Track-' + (dataHolder.numTracks() - 1) + '-title');
                        var trackBottom = ($(document.getElementById('playback-controls')).offset().top);
                        var lastDivBottom = ($(last).offset().top + TAG.TourAuthoring.Constants.trackHeight);

                        //need to check if the first div is on the screen -- then no need to scroll
                        var first = dataHolder._trackArray[0].track.getTitleDiv();
                        var firstTop = first.offset().top;
                        var trackTop = $(timeline).offset().top;
                        if (firstTop < trackTop) {
                            if ((lastDivBottom + TAG.TourAuthoring.Constants.trackHeight) < trackBottom) {
                                //var t = $('.track').css('top');
                                //$('.track').css({
                                //   //'top': parseInt(t, 10) + TAG.TourAuthoring.Constants.trackHeight + "px"
                                //});
                                //$('.titlediv').css({
                                //    //'top': parseInt(t, 10) + TAG.TourAuthoring.Constants.trackHeight + "px"
                                //});
                            }
                        }
                    }
                    my.update();
                },
                unexecute: function () {
                    var replaceTrack = dataHolder.insertTrack(that, that.getPos());
                    replaceTrack.displays = displayData;
                    reloadTrack();
                }
            });
            my.undoManager.logCommand(command);
            command.execute();

            my.timeline.removeInkSession();
            var counter = 1;//one track removed so far
            //this block of code handles the case when an art piece with attached inks is deleted
            for (var k = my.attachedInks.length-1; k >= 0; k--) {
                deleteAttachedInks(k);
            }

            function deleteAttachedInks(j) {
                var track = my.attachedInks[j];
                var inkDisplayData = track.getStorageContainer().displays;
                counter++;
                var command = TAG.TourAuthoring.Command({
                    execute: function () {
                        removeAttachedInkTrack(track);
                        track.remove();
                        //my.update();
                    },
                    unexecute: function () {
                        var replaceTrack = dataHolder.insertTrack(track, track.getPos());
                        replaceTrack.displays = inkDisplayData;
                        track.reloadTrack();
                    }
                });
                my.undoManager.logCommand(command);
                command.execute();
            }

            if (counter > 1) {
                my.undoManager.combineLast(counter);
            }

            updateTrackArray();

            my.update();
        }



        //
        //var mssge = "Are you sure you want to delete " + my.title;
        //var hasAttachedInks = false;
        //for (var jj = 0; jj < trackarray.length; jj++) {
        //    if (trackarray[jj].getType() === TAG.TourAuthoring.TrackType.ink && trackarray[jj].getInkEnabled() && trackarray[jj].getInkLink().getTitle() === that.getTitle()) {
        //        hasAttachedInks = true;
        //        break;
        //    }
        //}
        //mssge += ((hasAttachedInks && (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image)) ? " and any attached ink tracks?" : "?");
        //var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
        //    yesTap();
        //}, mssge, "Delete");
        //$(confirmationBox).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 7);
        //$('body').append(confirmationBox);
        //my.timeManager.stop();

        //$(confirmationBox).fadeIn(500);
        //close();
        //function yesTap() {
        //    close();
        //    var command = TAG.TourAuthoring.Command({
        //        execute: function () {
        //            my.timeline.removeTrack(that);

        //            //if artwork is removed, also check if ink functionality should be removed
        //            if (!my.timeline.checkForArtworks(0)) {
        //                my.timeline.disableInk();
        //            }

        //            //code to snap down track list such that the track list is always full if it can be
        //            if (trackarray.length>0) {
        //                var last = $('#Track-' + (trackarray.length - 1) + '-title');
        //                var trackBottom = ($(document.getElementById('playback-controls')).offset().top);
        //                var lastDivBottom = ($(last).offset().top + TAG.TourAuthoring.Constants.trackHeight);

        //                //need to check if the first div is on the screen -- then no need to scroll
        //                var first = $('#Track-' + 0 + '-title');
        //                var firstTop = $(first).offset().top;
        //                var trackTop = $(timeline).offset().top;
        //                if (firstTop < trackTop) {
        //                    if ((lastDivBottom + TAG.TourAuthoring.Constants.trackHeight) < trackBottom) {
        //                        //var t = $('.track').css('top');
        //                        //$('.track').css({
        //                        //   //'top': parseInt(t, 10) + TAG.TourAuthoring.Constants.trackHeight + "px"
        //                        //});
        //                        //$('.titlediv').css({
        //                        //    //'top': parseInt(t, 10) + TAG.TourAuthoring.Constants.trackHeight + "px"
        //                        //});
        //                    }
        //                }
        //            }

        //        },
        //        unexecute: function () {
        //            reloadTrack();
        //        }
        //    });
        //    my.undoManager.logCommand(command);
        //    command.execute();

        //    my.timeline.removeInkSession();
        //    var counter = 1;//one track removed so far
        //    //this block of code handles the case when an art piece with attached inks is deleted
        //    for (var ii = 0; ii < trackarray.length; ii++) {
        //        if (trackarray[ii].getType() === TAG.TourAuthoring.TrackType.ink && trackarray[ii].getInkEnabled() && trackarray[ii].getInkLink().getTitle() === that.getTitle()) {
        //            (function (j) {
        //                var track = trackarray[j];

        //                counter++;
        //                var command = TAG.TourAuthoring.Command({
        //                    execute: function () {
        //                        my.timeline.removeTrack(track);
        //                    },
        //                    unexecute: function () {
        //                        track.reloadTrack();
        //                    }
        //                });
        //                my.undoManager.logCommand(command);
        //                command.execute();
                        
        //            })(ii);
        //            ii--;
        //        }
        //    }
        //    my.undoManager.combineLast(counter);
        //}    
    }
    //event handling for cancel button
    function componentOptionCancel(evt) {
        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection) {
            currSelection.setDeselected();
        }
        close();
    }
    
    //function to pause events
    function updateTracksEventsPaused(fb) {
        dataHolder.mapTracks(function (i) {
            i.track.setEventsPaused(fb);
        });
        //$.each(trackarray, function () {
        //    this.setEventsPaused(fb);
        //});
    }
    that.updateTracksEventsPaused = updateTracksEventsPaused;

    /**Xiaoyi & Libby
    *set a display selected when in multi select mode
    */
    function setSelected() {
        dataHolder.selectTrack(that);
        titlediv.css({
            "background-color": "#000"
        });
    }
    that.setSelected = setSelected;

    /**Xiaoyi & Libby
    *set a display deselected in multi select mode
    */
    function setDeselected() {
        dataHolder.selectTrack(null);
        titlediv.css({
            "background-color": "rgb(105,89,89)"
        });
    }
    that.setDeselected = setDeselected;

    // PUBLIC METHODS -- Getters and setters for type and media
    function getType () {
        return my.type;
    }
    that.getType = getType;

    function getMedia () {
        return media;
    }
    that.getMedia = getMedia;

    function getPos() {
        return arrayPos;
    }
    that.getPos = getPos;

    function getTitle () {
        return my.title;
    }
    that.getTitle = getTitle;

    function setTitle(newTitle) {
        newTitle = my.timeline.fixTrackTitle(newTitle, getID());
        my.title = newTitle;
        titleText.text(my.title);
    }
    that.setTitle = setTitle;

    function getSharedMy() {
        return my;
    }
    that.getSharedMy = getSharedMy;

    function getEventsPaused() {
        return eventsPaused;
    }
    that.getEventsPaused = getEventsPaused;

    function setEventsPaused(fB) {
        eventsPaused = fB;
    }
    that.setEventsPaused = setEventsPaused;

    function getCurrentDisplay() {
        return my.currentDisplay;
    }
    that.getCurrentDisplay = getCurrentDisplay;
    
    function setCurrentDisplay(currDisplay) {
        my.currentDisplay = currDisplay;
    }
    that.setCurrentDisplay = setCurrentDisplay;

    function setIsVisible(visibility) {
        my.isVisible = visibility;
    }
    that.setIsVisible = setIsVisible;

    function getCurrentKeyframe() {
        return my.currentKeyframe;
    }
    that.getCurrentKeyframe = getCurrentKeyframe;

    function getGUID() {
        return guid;
    }
    that.getGUID = getGUID;

    function setStorageContainer(storeContain) {
        storageContainer = storeContain;
    }
    that.setStorageContainer = setStorageContainer;

    function getStorageContainer() {
        return storageContainer;
    }
    that.getStorageContainer = getStorageContainer;

    /**
     * Functions for track ID
     * Corresponds to ordering of tracks in timeline array
     * Maps to z-layering in RIN
     * Each track ID should be unique, but might change on track switch
     * Use updatePos to update id
     */

    function getID() {
        return id.split('-')[1];
    }
    that.getID = getID;

    //function to update tracks in array to their current positions.
    function updateTrackArray() {
        dataHolder.mapTracks(function (container, i) {
            container.track.updatePos(i);
        });
    }

    //handles update of location in track array
    function updatePos(pos) {
        arrayPos = pos;
        id = ('Track-' + pos);
        titlediv.attr('id', id + '-title');       
        my.track.attr('id', id);
        my.resource = 'R-' + arrayPos;
        //prevTrack = my.track.prev(".track");
        //prevTitleDiv = titlediv.prev(".titlediv");
        //console.log("new position assigned: " + pos);
    }
    that.updatePos = updatePos;

    /*function checks that given value is within range of top and bottom of titlediv
    * @ param switchOffSet keeps track of the the height of each div
    */
    function checkWithinTitleDiv(switchOffset) {
        var t = titlediv.offset().top;     
        if (that.getPos() == 0 && spaceBefore)
            t -= TAG.TourAuthoring.Constants.trackHeight;       
        var h = parseInt(titlediv.css("height"),10);

        if (switchOffset >= t && switchOffset <= t + h) {
            return true;
        }
        else
            return false;
    }
    that.checkWithinTitleDiv = checkWithinTitleDiv;

    function getTitleDiv() {
        return titlediv;
    }
    that.getTitleDiv = getTitleDiv;

    /* 
    * function to move a current track to the location next to this track
    * if the track to be inserted is below this track, then it is inserted before this track
    * otherwise, it is inserted after
    */
    function insert(track) {
        if (track == that) {
            return;
        }
        var samePosition=false;
        if (arrayPos < track.getPos()) {
            samePosition = track.insertHelper(arrayPos);
        } else {
            samePosition = track.insertHelper(arrayPos);
        }
        updateTrackArray();
        my.update();
        // for resetting the tracks graphically when this is called
        //var t = $('.track').css('top');
        //$('.titlediv').css('top', parseFloat(t) + 'px');
    }
    that.insert = insert;

    /*function called when this track is moved and inserted next to another track
    * @ param prTrack is previous track within calling class
    * @ param prTitle is previous title within calling class 
    * @ param pos is array position within calling class
    */
    function insertHelper(pos) {
        var scrollTop = $('#trackTitleWrapper').scrollTop();
        that.detach();
        var trackToMove = that.getStorageContainer();
        //dataHolder.removeTrack(that);
        dataHolder._trackArray.splice(that.getPos(), 1);
        dataHolder._trackArray.splice(pos, 0, that.getStorageContainer());
        updateTrackArray();
        //prevTrack = prTrack;
        //prevTitleDiv = prTitle;
        my.track.detach();
        reloadTrack();
        titlediv.css('top', '0px');
        my.track.css('display', '');
        $('#trackTitleWrapper').scrollTop(scrollTop);
        offset = 0;
        return false;
    }
    that.insertHelper = insertHelper;

    function debugTrackArray() {
        for (var i = 0; i < dataHolder._trackArray.length; i++) {
            console.log(i + " - " + dataHolder._trackArray[i].track.getTitle());
        }
    }

    function getTrackDomElement() {
        return my.track;
    }
    that.getTrackDomElement = getTrackDomElement;

    //restores track and title to original position after moving title
    function restoreMovedTrack() {
        titlediv.css("top", "0px");
        titlediv.css("left", "0px");
    }

    //reloads track after deletion for undo redo. Assumes track was removed first.
    //Also gets called every time a track is added??
    function reloadTrack() {
        //var t = $('.track').css('top');
        //titlediv.css('top', parseFloat(t) + 'px');
        //my.track.css('top', parseFloat(t) + 'px');
        if (arrayPos === 0) {
            my.timeline.prependAddToDom(my.track, titlediv);
        }
        else {
            var previousTrack = dataHolder._trackArray[arrayPos - 1].track;
            previousTrack.getTitleDiv().after(titlediv);
            previousTrack.getTrackDomElement().after(my.track);
            
            //prevTitleDiv.after(titlediv);
            //prevTrack.after(my.track);
        }
        //dataHolder._trackArray.splice(arrayPos, 0, that.getStorageContainer());
        //updateTrackArray();
        
        my.update();
        restoreHandlers();
        if (my.that.getType() === TAG.TourAuthoring.TrackType.ink && my.that.getInkEnabled(my.that)) {
            my.that.getInkLink(my.that).addAttachedInkTrack(my.that);
        }
    }
    that.reloadTrack = reloadTrack;

    function restoreHandlers() {
        var disps = dataHolder.getDisplays(arrayPos)
        if (disps && disps._root) {
            disps._root.traverse(function (disp) {
                disp._value.display.restoreHandlers();
                var keyfs = dataHolder.getKeyframes(disp._value);
                if (keyfs && keyfs._root) {
                    keyfs._root.traverse(function (keyf) {
                        keyf._value.restoreHandlers();
                    });
                }
            });
        }
    }

    that.restoreHandlers = restoreHandlers;

    // Interaction code

    // Track title manipulations
    TAG.Util.makeManipulatable(titlediv[0], {
        onManipulate: onManipTrackTitleWrapper,
        onTapped: tappedTitle,
        onTappedRight: tapRightTitle,
        onRelease: trackTitleReleased,
        onScroll: scrollTitleWrapper,
        onDoubleTapped: toggleMinimized,
    }, false, true);

    // handles long press on the title
    my.inRightTap = false;
    function tapRightTitle(evt) {
        my.inRightTap = true;
        menu.open(evt);
    }
    this.tapRightTitle = tapRightTitle;

    //handles events when track title is tapped
    function tappedTitle(evt) {
        if (eventsPaused || my.inRightTap)
            return;

        var currSelection = dataHolder.getSelectedTrack();
        if (currSelection === that) {
            setDeselected();
        }
        else {
            if (currSelection) {
                currSelection.setDeselected();
            }
            setSelected();
        }
    }
    that.tappedTitle = tappedTitle;

    //inits track title to be dragged
    var prevZIndex = 0;
    // handles the case when the track title wrapper is dragged, if titledivmanip is true, instead allows for div to be dragged
    var firstEvent = true;

    //variables used by the onManipTrackTitleWrapper class to keep track of the top, bottom and total movement along the y axis of the tracks
    var moveTop = 0;
    var moveBottom = 0;   
    var totalYMoved = 0;
    var offset = 0;
    var dir = 0;
    function scrollTitleWrapper(delta) {
        var close = my.timeline.getCloseMenu();
        if (close) {
            close();
        }
        
        if (delta === 1.1) {
            $('#trackTitleWrapper').scrollTop($('#trackTitleWrapper').scrollTop() - 30);
        } else {
            $('#trackTitleWrapper').scrollTop($('#trackTitleWrapper').scrollTop() + 30);
        }
    }

    var vertLock = false, sideLock = false, xMoved = 0, yMoved = 0, dragEvents = 0;
function trackTitleReleased(evt) {
        my.inRightTap = false;
        if (released) {     // stops double-triggering of release
            released = false;
            return;
        }
        released = true;
        titleDivMouseUp();
    }

    function onManipTrackTitleWrapper(res, evt) {
        var currSelection = dataHolder.getSelectedTrack();
        evt.stopPropagation();

        if (eventsPaused || my.inRightTap) {
            return;
        }
        released = false;

        if (currSelection) {
            currSelection.setDeselected();
        }
        setSelected();

        //checks if a track has been selected for manipulation/movement
        if (titleDivManip) {
            titleDivTranslateY(res);
        } else {
            if (firstEvent) {
                firstEvent = false;
            }
            //these two 'if' conditions determine how much a track needs to be pulled along the x axis for it to become maniputable 
            if (totalYMoved < 30 && Math.abs(res.translation.y) < Math.abs(res.translation.x) * 2) {
                titleDivTranslateX(res.translation.x);
            } else {
                titleDivTranslateX(200);
            }
            if (Math.abs(res.translation.y) > Math.abs(res.translation.x))
                totalYMoved = totalYMoved + Math.abs(res.translation.y);
            if (parseInt(titlediv.css('left'),10) < -20) { //used to be -10
                titleDivManip = true;
                offset = 0;
                titledivPlaceholder = $(document.createElement('div'));
                titledivPlaceholder.css({
                    "width": 0.127 * $(window).width() + 'px',
                    'margin-left': '20px',
                    height: titlediv.height() + 'px',
                    float: 'left',
                    border: '1px solid black',
                    'box-shadow': 'inset 4px -4px 8px #888',
                    position: 'absolute',
                    'z-index': 0,
                    background: 'rgb(219, 218, 199)',
                    top: titlediv.position().top + $('#trackTitleWrapper').scrollTop() + 'px',
                });
                titlediv.before(titledivPlaceholder);
                prevZIndex = titlediv.css('z-index');
                titlediv.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);
                titlediv.css('left', '-20px');
                moveTop = titlediv.offset().top;
                moveBottom = moveTop + TAG.TourAuthoring.Constants.trackHeight;
            }
            upAndDown(res);
        }
    }

    /**Moves title div in the vertical direction with cursor
     * @method titleDivTranslateY
     * @param res
     */
    function titleDivTranslateY(res) {
        var t = parseInt(titlediv.css('top'),10);
        var topp = t + res.translation.y;
        var tr = null;                                                      // keeps track of the div/track that needs to be moved when moving a selected track
        var index = 0;
        var oldScroll;
        var scroll;
        var trackArrayHeight = 0;
        var i;

        if (topp < t) {                                                     // Moving up
            moveUp();
        } else if (topp > t) {                                              // Moving down
            moveDown();
        } else {
            if (titlediv.position().top < 15) {
                oldScroll = $('#trackTitleWrapper').scrollTop();
                $('#trackTitleWrapper').scrollTop(oldScroll - 25);
                topp = topp - Math.min(10, oldScroll);
                moveUp();
            }
            if (titlediv.position().top + 2 +titlediv.height() > $('#trackScrollVeil').height() - 15) {
                oldScroll = $('#trackTitleWrapper').scrollTop();
                scroll = oldScroll + 25;
                for (i = 0; i < dataHolder._trackArray.length; i++) {
                    trackArrayHeight = trackArrayHeight + dataHolder._trackArray[i].track.getTitleDiv().height() + 2;
                }
                if (scroll > trackArrayHeight - $('#trackTitleWrapper').height()) scroll = trackArrayHeight - $('#trackTitleWrapper').height();
                $('#trackTitleWrapper').scrollTop(scroll);
                topp = topp + scroll - oldScroll;
                moveDown();
            }
        }
        titlediv.css('top', topp);

        /**Moves the title div up
         * @method moveUp
         */
        function moveUp() {
            var i = arrayPos + offset - 1;
            var nextTrack;
            var nextTitleDiv;

            if (i >= arrayPos) { i++; }
            if (i >= 0) {
                nextTrack = dataHolder._trackArray[i].track;
                nextTitleDiv = nextTrack.getTitleDiv();
                if (nextTitleDiv.position().top > titlediv.position().top) {
                    nextTitleDiv.css('top', parseFloat(nextTitleDiv.css('top')) + 2 + titlediv.height() + 'px');
                    titledivPlaceholder.css('top', parseFloat(titledivPlaceholder.css('top')) - 2 - nextTitleDiv.height() + 'px');
                    offset--;
                }
            }
        }

        /**Moves the title div down
         * @method moveDown
         */
        function moveDown() {
            var i = arrayPos + offset + 1;
            var nextTrack;
            var nextTitleDiv;

            if (i <= arrayPos) { i--; }
            if (i < dataHolder._trackArray.length) {
                nextTrack = dataHolder._trackArray[i].track;
                nextTitleDiv = nextTrack.getTitleDiv();
                if (nextTitleDiv.position().top < titlediv.position().top) {
                    titledivPlaceholder.css('top', parseFloat(titledivPlaceholder.css('top')) + 2 + nextTitleDiv.height() + 'px');
                    nextTitleDiv.css('top', parseFloat(nextTitleDiv.css('top')) - 2 - titledivPlaceholder.height() + 'px');
                    offset++;
                }
            }
        }
    }

    /**Moves title div in the horizontal direction
     * @method titleDivTranslateX
     * @param {Number} x
     */
    function titleDivTranslateX(x) {
        var l = parseInt(titlediv.css('left'),10);
        var left = Math.min(l + x, 0);
        titlediv.css('left', left);
    }

    /**Handles events when a selected track is released
     * @method titleDivMouseUp
     */
    function titleDivMouseUp() {
        var tr = dataHolder._trackArray[arrayPos + offset]
        if (!tr){
            return;
        }
        tr = tr.track;
        var prev;
        var command;
        totalYMoved = 0;
        $('.titlediv').css('top', '0px');
        $('.titlediv').css('left', '0px');
        if (titledivPlaceholder) {
            titledivPlaceholder.detach();
        }
        if (offset !== 0 && titleDivManip && tr) {
            if (that.getPos() > tr.getPos()) {                  // that is below tr
                prev = dataHolder._trackArray[that.getPos() - 1].track;
            } else if (that.getPos() < tr.getPos()) {           // that is above tr
                prev = dataHolder._trackArray[that.getPos() + 1].track;
            } else {
                prev = dataHolder._trackArray[that.getPos()].track;
            }
            command = TAG.TourAuthoring.Command({
                execute: function () { tr.insert(that); },
                unexecute: function () {
                    prev.insert(that);
                }
            });
            command.execute();
            my.undoManager.logCommand(command);
        }
        titlediv.css('z-index', prevZIndex);
        //firstBlock = true;
        titleDivManip = false;
        firstEvent = true;
    }
    var grTrack;
    // makes the track manipulatable 
    if (IS_WINDOWS) {
        grTrack = TAG.Util.makeManipulatable(my.track[0], {
            onManipulate: onManipTrack,
            onTappedRight: tapRight,
            onScroll: scrollTitle,
            onTapped: trackTapped,
            onDoubleTapped: doubleTapped,
            onRelease: function () {
                my.inRightTap = false;
                vertLock = false;
                sideLock = false;
                xMoved = 0;
                yMoved = 0;
                dragEvents = 0;
            }
        });
    } else {
        grTrack = TAG.Util.makeManipulatable(my.track[0], {
            onManipulate: onManipTrack,
            onTappedRight: tapRight,
            onScroll: scrollTitle,
            onTapped: trackTapped,
            onDoubleTapped: doubleTapped,
            onRelease: function () {
                my.inRightTap = false;
                vertLock = false;
                sideLock = false;
                xMoved = 0;
                yMoved = 0;
                dragEvents = 0;
            }
        });
    }

    function released(evt) {
        if (eventsPaused || isMinimized) {
            return;
        }

        my.inRightTap = false;

        if (that.getCurrentKeyframe() !== null) {
            that.getCurrentKeyframe().released(evt);
        } else if (that.getCurrentDisplay() !== null) {
            that.getCurrentDisplay().released(evt);
        } else {
            console.log("skipping release");



        }
    }

    function tapRight(evt) {
        if (eventsPaused || isMinimized) {
            return;
        }

        my.inRightTap = true;

        if (that.getCurrentKeyframe()) {
            that.getCurrentKeyframe().rightTapped(evt);
        }
        else if (that.getCurrentDisplay()) {
            that.getCurrentDisplay().rightTapped(evt);
        }
    }
    that.tapRight = tapRight;
    
    function doubleTapped(evt) {
        if (isMinimized) {
            return;
        }
        if (my.currentDisplay) {
            var loc = my.currentDisplay.getLoc();
            if (loc === TAG.TourAuthoring.DisplayParts['fade-out'] || loc === TAG.TourAuthoring.DisplayParts['fade-in']) {
                return;
            }
        }
        addKeyorDisplay(evt);
    }

    //track tapped
    var multiSelection;
    function trackTapped(evt) {
        // cancel tap event on right click or if track is minimized
        if (evt.button === 2 || evt.gesture.srcEvent.buttons === 2) {
            return;
        }
        vertLock = false;
        sideLock = false;
        xMoved = 0;
        yMoved = 0;
        dragEvents = 0;
        multiSelection = my.timeline.getMultiSelection();
        //if not in the multi selection mode and the selection array is not empty, clear the array by deselecting them
        if (!multiSelection) {
            var selectednumber = my.timeline.getMultiSelectionArray().length;
            if (!that.getCurrentDisplay() && selectednumber > 0) {
                for (var i = 0;  i<selectednumber;i++){
                    my.timeline.allDeselected();
                }
            }
            else if (that.getCurrentKeyframe()) {
                if (isMinimized) {
                    return;
                }
                that.getCurrentKeyframe().tapped(evt);
            }
        }
        else if (that.getCurrentDisplay()) {//if in the multi selection mode, and user clicks on a display
            if (my.timeline.getMultiSelectionArray().indexOf(that.getCurrentDisplay()) < 0) {//if it is not selected, have it selected
                setDisplaySelected(that.getCurrentDisplay());
            }
            else {//if it is selected, have it deselected
                setDisplayDeselected(that.getCurrentDisplay(), false);
            }
        }
        else if (my.currentKeyframe) {//if the user clicks on a keyframe, select/deselect the display that contains current keyframe
            if (isMinimized) {
                return;
            }
            if (my.timeline.getMultiSelectionArray().indexOf(my.currentKeyframe.getContainingDisplay())< 0) {
                setDisplaySelected(my.currentKeyframe.getContainingDisplay());
            }
            else {
                setDisplayDeselected(my.currentKeyframe.getContainingDisplay(),false);
            }
        }
    }

    /**Xiaoyi & Libby
    *set current display deselected when user clicks it again
    */
    function setDisplaySelected(currentDisplay) {
        //add selected display to the array, and change the filling color
        my.timeline.getMultiSelectionArray().push(currentDisplay);
        //change it to the selected colors according to their types
        //the grey color (selectedInkDisplayColor) is used on videos and inks
        if (currentDisplay.getType() === 4 || currentDisplay.getType() === 2) {
            currentDisplay.getMainD().css('background-color', TAG.TourAuthoring.Constants.selectedInkDisplayColor);
        } else {
            currentDisplay.getMainD().css('background-color', TAG.TourAuthoring.Constants.selectedDisplayColor);
        }
    }
    that.setDisplaySelected = setDisplaySelected;

    /**Xiaoyi & Libby
    *set the current display deselected
    *@param: currentDisplay: the display is been clicking on
    *@keepDisplays:if we want to keep the displays
    */
    function setDisplayDeselected(currentDisplay, keepDisplays) {
        //remove the display from the array
        if (!keepDisplays) {
            my.timeline.getMultiSelectionArray().splice(my.timeline.getMultiSelectionArray().indexOf(currentDisplay), 1);
        }

        var valuation = function (a) {
            return a.source;
        }
        //remove this display's boundaries from the binheaps
        dataHolder._leftExternal.remove(
            dataHolder._leftExternal.findValue(currentDisplay, valuation));
        dataHolder._leftInternal.remove(
           dataHolder._leftInternal.findValue(currentDisplay, valuation));
        dataHolder._rightExternal.remove(
           dataHolder._rightExternal.findValue(currentDisplay, valuation));
        dataHolder._rightInternal.remove(
           dataHolder._rightInternal.findValue(currentDisplay, valuation));

        //ink/video displays change back to gray, others to green
        if (currentDisplay.getType() === 4 || currentDisplay.getType() === 2) {
            currentDisplay.getMainD().css('background-color', TAG.TourAuthoring.Constants.inkDisplayColor);
        } else if (currentDisplay.getType() === 1) {
            currentDisplay.getMainD().css('background-color', 'rgba(129, 173, 98, 0.8)');
        } else {
            currentDisplay.getMainD().css('background-color', TAG.TourAuthoring.Constants.displayColor);
        }
    }
    that.setDisplayDeselected = setDisplayDeselected;

    /**
     * Handles drag on track
     * Pan timeline view
     * If a display or keyframe is selected, move that
     */
    function onManipTrack(res, evt) {
        var i, leftbound, rightbound, keydisplay, allKeys;
        if (eventsPaused || my.inRightTap) {
            evt.stopImmediatePropagation();
            return;
        }
        // move display
        if (my.currentDisplay) {
            // hacky fix to keep handles minimized
            my.currentDisplay.suppressHandles();
            if (evt)
                evt.stopPropagation();
            if (vertLock || (!sideLock &&
                dragEvents > 3 && 
                Math.abs(yMoved) > Math.abs(xMoved))) {
                vertLock = true;
                upAndDown(res);
                return;
            } else if (dragEvents > 3) {
                sideLock = true;
            } else {
                xMoved += res.translation.x;
                yMoved += res.translation.y;
                dragEvents++;
                return;
            }
            // update bounds if no multi-select
            if (my.timeline.getMultiSelectionArray().length === 0) {
                leftbound = my.timeManager.getDuration().start;
                rightbound = my.timeManager.getDuration().end;
                var displays = that.getStorageContainer().displays.getContents();
                for (i = 0; i < displays.length; i++) {
                    // update bounds once current display is located in array
                    if (displays[i].display === my.currentDisplay) {
                        if ((i - 1) >= 0) {
                            leftbound = displays[i - 1].display.getEnd() + TAG.TourAuthoring.Constants.esOffset;
                        }
                        if ((i + 1) < displays.length) {
                            rightbound = displays[i + 1].display.getStart() - TAG.TourAuthoring.Constants.esOffset;
                        }
                    }
                } 
                my.currentDisplay.move(res, leftbound, rightbound);
            }
            else {//Xiaoyi/Libby
                //move all selected tracks
                if (my.timeline.getMultiSelectionArray().indexOf(my.currentDisplay) >= 0) {
                    my.timeline.moveSelect(res, my.currentDisplay);
                }
            }
        }
    
        // move keyframe
        else if (my.currentKeyframe) {
            if (isMinimized) {
                return;
            }
            if (evt)
                evt.stopPropagation();

            // Note that the bounds for the keyframe are just the beginning and end of the containing display
            keydisplay = my.currentKeyframe.getContainingDisplay();
            //allKeys = keydisplay.getStorageContainer().keyframes;
            // get bounds
            leftbound = keydisplay.getStart();
            rightbound = keydisplay.getEnd();
            //for (i = 0; i < allKeys.length; i++) {
            //    // update bounds once current keyframe is located in array
            //    if (allKeys[i] === my.currentKeyframe) {
            //        if ((i - 1) >= 0) {
            //            //if (allKeys[i - 1].getTime() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize) > allKeys[i].getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize)) {
            //            //    leftbound = allKeys[i].getTime();
            //            //}
            //            //else {
            //                leftbound = allKeys[i - 1].getTime() + TAG.TourAuthoring.Constants.esOffset;
            //            //}
            //        }
            //        if ((i + 1) < allKeys.length) {
            //            //if (allKeys[i + 1].getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize) < allKeys[i].getTime() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize)) {
            //            //    rightbound = allKeys[i].getTime();
            //            //}
            //            //else {
            //                rightbound = allKeys[i + 1].getTime() - TAG.TourAuthoring.Constants.esOffset;
            //            //}
            //        }
            //    }
            //}
            var prevKF = dataHolder.findPrevKeyframe(keydisplay, my.currentKeyframe),
                nextKF = dataHolder.findNextKeyframe(keydisplay, my.currentKeyframe);
            if (prevKF) {
                leftbound = prevKF.getTime() + TAG.TourAuthoring.Constants.esOffset;
            }
            if (nextKF) {
                rightbound = nextKF.getTime() - TAG.TourAuthoring.Constants.esOffset;
            }

            if (!my.timeline.getMultiSelection()) {
                my.currentKeyframe.move(res, leftbound, rightbound);
            }
        }
    }
    that.onManipTrack = onManipTrack;

    /*Xiaoyi & Libby
    *helper function returning the left/right bounds of the track during multi-select
    * @param currDisplay: display that the bounds are being found for
    * @returns the bound for each display separately that are multi-selected
    */
    function boundHelper(currDisplay, hasZeroFadeout) { // deal with fixing bounds for ink dragging here
        /**REWRITTEN TO HANDLE MINHEAPS**/
        var leftbound = my.timeManager.getDuration().start,
            rightbound = my.timeManager.getDuration().end,
            currkeyframes = currDisplay.getStorageContainer().keyframes, //now handles minheap
            //this is the internal right bound for the fade in
            //it is calculated by taking the smallest time when comparing the time at which the fadeout begins and the start time of the first keyframe (if any)
            fadeInRight = Math.min(currDisplay.getOutStart() - currDisplay.getFadeIn(),
                                        ((!currkeyframes.isEmpty() && (currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || Infinity)),
            //this is the internal left bound for the fade out
            //it is calculated by taking the largest time when comparing the time at which the fadein ends and the start time of the last keyframe (if any)
            fadeOutLeft = Math.max(currDisplay.getStart() + currDisplay.getFadeIn(),
                             ((!currkeyframes.isEmpty() && (currkeyframes.max().getTime() - currDisplay.getFadeOut() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || -Infinity)),
            currLeft = currDisplay.getStart(),
            loc = currDisplay.getLoc();
        var currRight = currDisplay.getEnd();
        
        //if the display the user is dragging has zero fadeout, update the currRight (for some reason, currDisplay.getEnd() doesn't work)
        if (hasZeroFadeout) {
            currRight = currDisplay.getOutStart();
        }

        //in the case where both the fadein and fadeout are both (such as with audio tracks), then the fadeinright and the fadeoutleft need to be calculated using either the first/last keyframe 
        //position or the edge of the fadein/fadeout handle, which prevents the display from being compressed so far that it is just a handle with no display at all
        if (currDisplay.getFadeIn() === 0 || currDisplay.getFadeOut() === 0) {
            fadeInRight = Math.min(my.timeManager.pxToTime(currDisplay.getFioHandle().attr('cx') - 2 * TAG.TourAuthoring.Constants.fadeBtnSize),
                                            ((!currkeyframes.isEmpty() && (currkeyframes.min().getTime() - my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || Infinity));
            fadeOutLeft = Math.max(my.timeManager.pxToTime(currDisplay.getFinHandle().attr('cx')) + my.timeManager.pxToTime(2 * TAG.TourAuthoring.Constants.fadeBtnSize),
                ((!currkeyframes.isEmpty() && (currkeyframes.max().getTime() - currDisplay.getFadeOut() + my.timeManager.pxToTime(TAG.TourAuthoring.Constants.keyframeSize + TAG.TourAuthoring.Constants.keyframeStrokeW + TAG.TourAuthoring.Constants.fadeBtnSize))) || -Infinity));
        }
        var boundArray = [];
        if (fadeInRight < currDisplay.getStart()) {
            fadeInRight = currDisplay.getStart();
        }
        if (fadeOutLeft > currDisplay.getOutStart()) {
            fadeOutLeft = currDisplay.getOutStart();
        }

        //use data holder to acquire this, reduces for loops being needed
        var prevDisp = dataHolder.findPreviousDisplay(arrayPos, currDisplay);
        var nextDisp = dataHolder.findNextDisplay(arrayPos, currDisplay);

        //if dragging the main section of the display
        var parentArtDisplay;
        if (loc === TAG.TourAuthoring.DisplayParts.main) {
            //for (var i = 0; i < my.displays.length; i++) {
            //    // update bounds once current display is located in array
            //    if (my.displays[i] === currDisplay) {
            //        if ((i - 1) >= 0 && my.timeline.getMultiSelectionArray().indexOf(my.displays[i - 1]) < 0) {
            //            leftbound = my.displays[i - 1].getEnd() + TAG.TourAuthoring.Constants.esOffset;
            //        }
            //        if ((i + 1) < my.displays.length && my.timeline.getMultiSelectionArray().indexOf(my.displays[i + 1]) < 0) {
            //            rightbound = my.displays[i + 1].getStart() - TAG.TourAuthoring.Constants.esOffset;//my.displays[i + 1] === dataHolder.findNextDisplay(arrayPos, currDisplay)
            //        }
            //        if (my.type === TAG.TourAuthoring.TrackType.ink && my.
            //) {
            //            parentArtDisplay = getParentArtDisplay(my.displays[i]);
            //            if (my.timeline.getMultiSelectionArray().indexOf(parentArtDisplay) === -1) {
            //                leftbound = Math.max(leftbound, parentArtDisplay.getStart());
            //                rightbound = Math.min(rightbound, parentArtDisplay.getEnd());
            //            }
            //        }
            //    }
            //}

            //instead of looping through the array we can use the dataholder to find the previous/next displays
            if (prevDisp && my.timeline.getMultiSelectionArray().indexOf(prevDisp.display) < 0) {
                leftbound = prevDisp.display.getEnd() + TAG.TourAuthoring.Constants.esOffset;
            }
            if (nextDisp && my.timeline.getMultiSelectionArray().indexOf(nextDisp.display) < 0) {
                rightbound = nextDisp.display.getStart() - TAG.TourAuthoring.Constants.esOffset;
            }
            if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
                parentArtDisplay = currDisplay.getParentDisplay();
                if (my.timeline.getMultiSelectionArray().indexOf(parentArtDisplay) === -1) {
                    leftbound = Math.max(leftbound, parentArtDisplay.getStart());
                    rightbound = Math.min(rightbound, parentArtDisplay.getEnd());
                }
            }

        } //if dragging the fadein/fadeout sections of the display
        else if (loc === TAG.TourAuthoring.DisplayParts['fade-out'] || loc === TAG.TourAuthoring.DisplayParts['fade-in']) {
            //for (var j = 0; j < my.displays.length; j++) {
            //    // update bounds once current display is located in array
            //    if (my.displays[j] === currDisplay) {
            //        if ((j - 1) >= 0) {
            //            leftbound = my.displays[j - 1].getEnd() + TAG.TourAuthoring.Constants.esOffset;
            //        }
            //        if ((j + 1) < my.displays.length) {
            //            rightbound = my.displays[j + 1].getStart() - TAG.TourAuthoring.Constants.esOffset;
            //        }
            //        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            //            parentArtDisplay = getParentArtDisplay(my.displays[j]);
            //            if (my.timeline.getMultiSelectionArray().indexOf(parentArtDisplay) === -1) {
            //                leftbound = Math.max(leftbound, parentArtDisplay.getStart());
            //                rightbound = Math.min(rightbound, parentArtDisplay.getEnd());
            //            }
            //        }
            //        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image || !my.inkEnabled) {
            //            var attachedDisplays = my.displays[j].getChildDisplays();
            //            var totalDispLength = my.displays[j].getLongestSubgroup(attachedDisplays);
            //            fadeOutLeft = Math.max(fadeOutLeft, my.displays[j].getStart() + totalDispLength);
            //            fadeInRight = Math.min(fadeInRight, my.displays[j].getEnd() - totalDispLength);
            //        }
            //        if (my.type === TAG.TourAuthoring.TrackType.video || my.type === TAG.TourAuthoring.TrackType.audio) {
            //            if (my.displays[j].getMediaLength()) {
            //                var maxlength = parseFloat(currDisplay.getMediaLength());
            //                leftbound = Math.max(leftbound, currDisplay.getEnd() - maxlength);
            //                rightbound = Math.min(rightbound, currDisplay.getStart() + maxlength);
            //            }
            //        }
            //    }
            //}

            //instead of looping through the array we can use the dataholder to find the previous/next displays
            if (prevDisp) {
                leftbound = prevDisp.display.getEnd() + TAG.TourAuthoring.Constants.esOffset;
            }
            if (nextDisp) {
                rightbound = nextDisp.display.getStart() - TAG.TourAuthoring.Constants.esOffset;
            }
            if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
                parentArtDisplay = getParentArtDisplay(currDisplay);
                if (my.timeline.getMultiSelectionArray().indexOf(parentArtDisplay) === -1) {
                    leftbound = Math.max(leftbound, parentArtDisplay.getStart());
                    rightbound = Math.min(rightbound, parentArtDisplay.getEnd());
                }
            }
            else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.image || !my.inkEnabled) {
                var attachedDisplays = currDisplay.getChildDisplays();
                var totalDispLength = currDisplay.getLongestSubgroup(attachedDisplays);
                fadeOutLeft = Math.max(fadeOutLeft, currDisplay.getStart() + totalDispLength);
                fadeInRight = Math.min(fadeInRight, currDisplay.getEnd() - totalDispLength);
            }
            if (my.type === TAG.TourAuthoring.TrackType.video || my.type === TAG.TourAuthoring.TrackType.audio) {
                if (currDisplay.getMediaLength()) {
                    var maxlength = parseFloat(currDisplay.getMediaLength());
                    leftbound = Math.max(leftbound, currDisplay.getEnd() - maxlength);
                    rightbound = Math.min(rightbound, currDisplay.getStart() + maxlength);
                }
            }
        }
       
        //boundArray[0] = currLeft - leftbound;//fadeinleft distance (in seconds)
        //boundArray[1] = rightbound - currRight;//fadeoutright distance (in seconds)
        //boundArray[2] = fadeInRight - currLeft;//fadeinright distance (in seconds)
        //boundArray[3] = currRight - currDisplay.getFadeOut() - fadeOutLeft;//fadeoutleft distance (in seconds)
        //return boundArray;
        
        //don't need boundArray anymore, using binheaps
        var leftExtBound = {
            bound: currLeft - leftbound, //distance in seconds
            source: currDisplay,
        }
        var leftIntBound = {
            bound: fadeInRight - currLeft, //distance in seconds
            source: currDisplay,
        }
        var rightExtBound = {
            bound: rightbound - currRight, //distance in seconds
            source: currDisplay,
        }
        var rightIntBound = {
            bound: currRight - currDisplay.getFadeOut() - fadeOutLeft, //distance in seconds
            source: currDisplay,
        }
        //push all bounds to respective heaps
        dataHolder._leftExternal.push(leftExtBound);
        dataHolder._leftInternal.push(leftIntBound);
        dataHolder._rightExternal.push(rightExtBound);
        dataHolder._rightInternal.push(rightIntBound);

    }
    that.boundHelper = boundHelper;


    /**
     * Gets the art display enclosing an attached ink track display.
     */
    function getParentArtDisplay(disp) {
        //var parentArtTrack = my.experienceId,
        //    parentDisplays = parentArtTrack.getDisplays(),
        //    parentArtDisplay = null;
        //for (var i = 0; i < parentDisplays.length; i++) {
        //    var currDisp = parentDisplays[i];
        //    if ((currDisp.getStart() <= disp.getOutStart()) && (disp.getOutStart() <= currDisp.getOutStart() + currDisp.getFadeOut())) { // use outStart to test if display is in the art display
        //        parentArtDisplay = currDisp;
        //        break;
        //    }
        //}
        //return parentArtDisplay;
        return disp.getParentDisplay();
    }
    function scale() {
        var displays = that.getStorageContainer().displays.getContents(); //array of displays, from tree of displays
        var i;
        for (i = 0; i < displays.length; i++) {
            displays[i].display.scale();
        }
    }
    that.scale = scale;
    my.timeManager.onSizing(scale);

    /**
     * helper function that loops through the array of displays 
     * returns the start of a display if there's a display nearby
     * returns 1 fadein, 0 fadeout and -1 otherwise
     * @ param  currentDisplayPosition is the position of the current display
     * @ param displays is an array of displays
     */
    function findDisplay(currentDisplayPosition, displays) {
        var i = 0;
        while (i < displays.length) {
            if (Math.abs(displays[i].getEnd() - currentDisplayPosition) <= 0.5 && displays[i].getEnd() !== currentDisplayPosition) {
                return displays[i].getEnd();
            }
            if (Math.abs(displays[i].getStart() - currentDisplayPosition) <= 0.5 && displays[i].getStart() !== currentDisplayPosition) {
                return displays[i].getStart();
            }
            i++;
        }
        return -1;
    }

    /**
     * helper function for finding a certain track using it's id
     * param trackNum - the track's id
     * returns the track
     */
    function getTrackByID(trackNum) {
        var tracks = my.timeline.getTracks();
        var i;
        for (i = 0; i < tracks.length; i++) {
            if (trackNum === parseInt(tracks[i].getID(),10)) {
                return tracks[i];
            }
        }
        return null;
    }

    /**
     * moves the track and the left and right
     */
    function leftAndRight(res, isRuler) {
        if (!trackBody)
            trackBody = my.timeline.getTrackBody();
        trackBody.scrollLeft(trackBody.scrollLeft() - res.translation.x);
    }
    that.leftAndRight = leftAndRight;

    /**
     * moves the track up and down
     */

    function upAndDown(res) {
        if (!trackBody)
            trackBody = $('#trackBody');
        trackBody.scrollTop(trackBody.scrollTop() - res.translation.y);
    }
    that.upAndDown = upAndDown;

    //scrolling function similar to upanddown
    //hacky fix, needs to be reworked like the entire class

    function scrollTitle(evt) {
        var close = my.timeline.getCloseMenu();
        if (close) {
            close();
        }

        if (!trackBody)
            trackBody = my.timeline.getTrackBody();
        var t = trackBody.scrollTop();
        //check if scrolling up or down
        var topp;
        if (evt === 1.1) { //scrolling up
            topp = t - 30;
        }
        else { //scrolling down
            topp = t + 30;
        }
        trackBody.scrollTop(topp);
    }


     //adds a key frame or display    
    function addKeyorDisplay(evt) {
        var positionX = evt.position.x,
            newTime = my.timeManager.pxToTime(positionX),
            positionY = evt.position.y,
            enoughSpace = true,
            displayLength = 5, // assumes display length to be 5 seconds
            i, keyframe, newDisplay,
            currDisplay, artDisplay,
            fromEnd;

        // double-click snap toggle bypass code goes here


        if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
            var artDisplays = getInkLink().getStorageContainer().displays.getContents();
            var indisp = false;
            //for (i = 0; i < artDisplays.length; i++) {
            //    if (newTime <= artDisplays[i].display.getEnd() && newTime >= artDisplays[i].display.getStart()) {
            //        indisp = true;
            //        artDisplay = artDisplays[i].display;

            //        break;
            //    }
            //}
            var artDisplays = getInkLink().getStorageContainer().displays.nearestNeighbors(newTime);
            for (i = 0; i < artDisplays.length; i++) { //will only be up to 2 elements in artDisplays -- the 2 closest ones
                if (artDisplays[i] && newTime <= artDisplays[i].display.getEnd() && newTime >= artDisplays[i].display.getStart()){//check to make sure display is not null
                    indisp = true;
                    artDisplay = artDisplays[i].display;
                    break;
                }
            }
        }
        if (indisp === false) {
            // TO-DO put in a warning here that the user should create the track over an artwork/image display
            return;
        }
        // Add display - MODIFY TO CHECK DATAHOLDER
        if (!my.currentDisplay) {
            // check if current display is going to conflict with other displays
            var minSpace = Infinity;
            var displays = that.getStorageContainer().displays.getContents();
            for (i = 0; i < displays.length; i++) {
                currDisplay = displays[i].display;

                // if newtime is after display we don't care
                if (newTime <= currDisplay.getEnd()) {
                    // check if tap location is on display
                    
                    if (newTime >= currDisplay.getStart()) {
                        enoughSpace = false;
                        break; // short circuit
                    }
                    // check if newTime is w/i displayLength seconds of start of current display
                    else if (newTime + displayLength >= currDisplay.getStart()) {
                        displayLength = currDisplay.getStart() - newTime - TAG.TourAuthoring.Constants.esOffset;
                    }
                    minSpace = Math.min(minSpace, currDisplay.getStart() - newTime);
                }
            }
            var fromEnd = my.timeManager.getDuration().end - newTime;
            if (enoughSpace) {
                my.timeline.allDeselected();
                //if (artDisplay.getEnd() - newTime >= 0.5) {
                    if (my.type === TAG.TourAuthoring.TrackType.ink && my.inkEnabled) {
                        newDisplay = addDisplay(positionX, Math.min(displayLength, artDisplay.getEnd() - newTime));
                        newDisplay.setParentDisplay(artDisplay);
                        artDisplay.addChildDisplay(newDisplay);
                        if (artDisplay.getEnd() - newTime < 1.5 || minSpace < 1.5) { // if less than 1.5 seconds available...
                            var smallestSpace = Math.min(minSpace, artDisplay.getEnd() - newTime);
                            newDisplay.setIn(0);
                            newDisplay.setOut(0);
                            newDisplay.setMain(smallestSpace);
                        }
                    }
                    else {
                        var smallestSpace = Math.min(displayLength, fromEnd);
                        newDisplay = addDisplay(positionX, smallestSpace);
                        if (fromEnd < 1.5) {
                            newDisplay.setIn(0);
                            newDisplay.setOut(0);
                            newDisplay.setMain(smallestSpace);
                        }
                    }
                //}
            }
        }

        // Add keyframe
        else if (my.type === TAG.TourAuthoring.TrackType.artwork || my.type === TAG.TourAuthoring.TrackType.audio || my.type === TAG.TourAuthoring.TrackType.image) {

            // enabled and disabled via custom event framework - see Viewer's event listener for playerReady event
            if (my.timeline.getViewer().isKeyframingDisabled()) {
                return;
            }

            // check to make sure we are adding keyframe to valid position
            if (newTime >= my.currentDisplay.getStart() && newTime <= my.currentDisplay.getEnd()) {
                // seek before creating new keyframe to unload and update with currently selected keyframe
                if (my.type !== TAG.TourAuthoring.TrackType.audio) {
                    my.timeManager.seek(newTime);
                }

                keyframe = my.currentDisplay.addKeyframe(positionX, positionY, true);
                
                if (keyframe) {
                    my.timeline.allDeselected();
                    if (my.type == TAG.TourAuthoring.TrackType.audio) {
                        my.allKeyframes.push(keyframe);
                        that.drawLines();
                        //my.update();
                    }
                    else { // initialize keyframe and select it for further movements
                        keyframe.loadRIN(my.timeline.captureKeyframe(my.title)); // send in my.title to specify which keyframe should be captured (works for images and artworks)
                        keyframe.setSelected(true); // delay logging of edits
                        my.dirtyKeyframe = true; // dirty b/c it's new
                        //TAG.Util.makeManipulatable
                    }
                    my.update();
                }
            }
        } 
    }

    //Deselects any active keyframes
    function deselectKeyframe() {
        if (my.selectedKeyframe) my.selectedKeyframe.setDeselected();
        my.dirtyKeyframe = false;
    }
    that.deselectKeyframe = deselectKeyframe;

    /**
    * Because loadRIN calls display.addKeyframe directly,
    * we need to pass it back into the track's list of allKeyframes manually for lines to draw
    */
    function addKeyframeToLines(keyframe) {
        my.allKeyframes.push(keyframe);
        that.drawLines();
    }
    that.addKeyframeToLines = addKeyframeToLines;

    //Draw volume line for audio tracks
    function drawLines() {
        if (isMinimized) {
            return;
        }
        if (my.type === TAG.TourAuthoring.TrackType.audio) {
            var keyframes = my.allKeyframes, end = keyframes.length-1;
            keyframes.sort(function (a, b) {
                if (a.isRemoved())
                    return 1;
                else if (b.isRemoved())
                    return -1;
                else
                    return a.getTime() - b.getTime();
            });

            while (end > 0 && keyframes[end].isRemoved()) {
                end--;
            }

            var lines = my.svgLines.selectAll('#keyframeLines');
            lines.remove();

            mygroup = my.svgLines.append("svg:g")
                .attr("id", "keyframeLines");

            var color = "green";
            var myLine;
            if (keyframes.length > 0) {
                myLine = mygroup.append("svg:line")
                    .attr("x1", 0)
                    .attr("y1", keyframes[0].getVolumePx())
                    .attr("x2", my.timeManager.timeToPx(keyframes[0].getTime()))
                    .attr("y2", keyframes[0].getVolumePx())
                    .style('pointer-events', 'none')
                    .style("stroke", color)
                    .style("stroke-width", 4);

                for (var counter = 0; counter < end; counter++) {
                    myLine = mygroup.append("svg:line")
                    .attr("x1", my.timeManager.timeToPx(keyframes[counter].getTime()))
                    .attr("y1", keyframes[counter].getVolumePx())
                    .attr("x2", my.timeManager.timeToPx(keyframes[counter + 1].getTime()))
                    .attr("y2", keyframes[counter + 1].getVolumePx())
                    .style('pointer-events', 'none')
                    .style("stroke", color)
                    .style("stroke-width", 4);
                }

                myLine = mygroup.append("svg:line")
                    .attr("x1", my.timeManager.timeToPx(keyframes[end].getTime()))
                    .attr("y1", keyframes[end].getVolumePx())
                    .attr("x2", '100%')
                    .attr("y2", keyframes[end].getVolumePx())
                    .style('pointer-events', 'none')
                    .style("stroke", color)
                    .style("stroke-width", 4);
            }
            else {
                myLine = mygroup.append("svg:line")
                    .attr("x1", 0)
                    .attr("y1", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                    .attr("x2", '100%')
                    .attr("y2", (100 - TAG.TourAuthoring.Constants.defaultVolume * 100) + "%")
                    .style('pointer-events', 'none')
                    .style("stroke", color)
                    .style("stroke-width", 4);
            }
        }
    }
    that.drawLines = drawLines;

    // Methods to add outline and track HTML to DOM
    // Expects to be passed containers as JQuery object

    /**
     * @param domElems  Object w/ two properties: 'title', the title container, and 'track', the track container
     */
    function addAllToDOM (domElems) {
        domElems.title.append(titlediv);
        domElems.track.append(my.track);
    }
    that.addAllToDOM = addAllToDOM;

    function prependAllToDOM(domElems) {
        domElems.title.prepend(titlediv);
        domElems.track.prepend(my.track);
    }
    that.prependAllToDOM = prependAllToDOM;



    /**Adds an identifying icon to the track div
    * @method addIconToTitle
    * @param {Type} type       type of track
    */
    function addIconToTitle(type) {
        var iconPath;
        var iconImg;
        iconDiv.attr('id', 'icon');
        iconDiv.css({
            "bottom": "3px", "position": "absolute", "right": "8px",
            "width": "30px", "height": '30px',
        });
        switch (type) {
            case TAG.TourAuthoring.TrackType.audio:
                iconPath = tagPath + 'images/icons/audio_icon_2.svg';
                break;
            case TAG.TourAuthoring.TrackType.video:
                iconPath = tagPath + 'images/icons/video_icon_2.svg';
                break;
            case TAG.TourAuthoring.TrackType.artwork:
                iconPath = tagPath + 'images/icons/image_icon_2.svg';
                break;
            case TAG.TourAuthoring.TrackType.ink:
                iconPath = tagPath + 'images/icons/text_icon_2.svg';
                break;
            case TAG.TourAuthoring.TrackType.image:
                iconPath = tagPath + 'images/icons/image_icon_2.svg';
                break;
        }
        iconImg = $(document.createElement('img'));
        iconImg.attr({
            'src': iconPath,
            'height': '30px',
            'width': '30px'
        });
        iconDiv.append(iconImg);
        titlediv.append(iconDiv);
    }



    function addInkTypeToTitle(type) {

        var inkType = $(document.createElement('div'));
        inkType.attr('id', 'inkType');
        inkType.css({
            "top": "48px", "position": "absolute", "left" : "5px",
            "font-size": "1em", "color": "white", "width":"80%", "height" : '20px',
        });
        //parse

        if (type === "trans") {

            //old_datastring.split("[mode]")[1].split("[")[0];
            var transType =  that.getInkPath().split("[mode]")[1].split("[")[0];

            if (transType === "block") {
                inkType.text("Block");
            }
            else {
                inkType.text("Isolate");
            }
        }
        else if (type == "text") {
            inkType.text("Text");
        }
        else if (type == "path" || type=="bezier") {
            inkType.text("Draw");
        }
        //inkType.text(type);
        


        titlediv.append(inkType);
    }
    that.addInkTypeToTitle = addInkTypeToTitle;

    // Add only title
    function addTitleToDOM(container) {
        if (arrayPos > 0) {
            container.children().eq(arrayPos - 1).after(titlediv);
        } else {
            container.prepend(titlediv);
        }
        prevTitleDiv = titlediv.prev(".titlediv");
    }
    that.addTitleToDOM = addTitleToDOM;

    // Add only track
    function addEditorToDOM(container) {
        if (arrayPos > 0) {
            container.children().eq(arrayPos - 1).after(my.track);
        } else {
            container.prepend(my.track);
        }
        //prevTrack = my.track.prev(".track");
    }
    that.addEditorToDOM = addEditorToDOM;

    function remove() {
        dataHolder.removeTrack(that);
        titlediv.remove();
        my.track.remove();
    }
    that.remove = remove;

    function detach() {
        //dataHolder.removeTrack(that);
        titlediv.detach();
        my.track.detach();
    }
    that.detach = detach;

    // DISPLAY WORK
   
    var displayCount = 0; // used for ids
    my.currentDisplay = null; // Manipulation handling
    my.currentKeyframe = null;

    /**
     * Public fn for adding visibility to track
     * @param x         x value (px) for display
     * @param length    length of display in seconds (set to 5 if not given) (only used in testing)
     * @returns     command for adding/undoing addition
     */
    function addDisplay(x, length) {
        //x = (my.timeManager.pxToTime(x) < 0.5) ? 0 : x - my.timeManager.timeToPx(0.5); //should use a constant for fade-in length rather than .5
        var index, i, parentDisplays, parentDisp,
            newDisplay = TAG.TourAuthoring.Display({
                start: my.timeManager.pxToTime(x),
                length: length,
                dataHolder: dataHolder,
                canKeyframe: (my.type !== TAG.TourAuthoring.TrackType.ink && my.type !== TAG.TourAuthoring.TrackType.video),
                canFade: (my.type !== TAG.TourAuthoring.TrackType.audio)
            }, my),

            command = TAG.TourAuthoring.Command({
                execute: function () {
                    //dataHolder.addDisplay(arrayPos, newDisplay);
                    newDisplay.reloadDisplay();
                    newDisplay.restoreHandlers();
                    my.update();
                },
                unexecute: function () {
                    newDisplay.removeDisplay(false);
                    my.update();
                }
            });
        dataHolder.addDisplay(arrayPos, newDisplay);
        //displayCount++;
        
        // update rest of displays
        //for (i = index+1; i < my.displays.length; i++) {
        //    my.displays[i].setID(i);
        //}
        my.update();
        my.undoManager.logCommand(command);
        return newDisplay; // for testing
    }
    that.addDisplay = addDisplay;

    //Function to remove display passed in as an argument.

    /**
     * Helper function for inserting display into array
     * Keeps displays sorted by start
     */
    function _displaycomp(a, b) {
        return a.getStart() > b.getStart();
    }
    that.displayComp = _displaycomp;

    /**
     * For testing purposes only!!!
     */
    function getDisplays() {
        return my.displays;
    }
    that.getDisplays = getDisplays;

    function clearDisplays() {
        //my.displays = [];
        that.getStorageContainer().displays.clear();
    }

    /**
     * Updates track w/ new keyframe data at current location
     * @param capture   keyframe data in RIN format
     * @param select    whether the keyframe receiving data should be selected
     */
    function receiveKeyframe(capture, select) {
        var i, display, keyframe, current = my.timeManager.getCurrentTime();
        var activeDisplay;// = that.getStorageContainer().displays.nearestNeighbors(current, 1)[0];
        if (my.selectedKeyframe || (activeDisplay = that.getStorageContainer().displays.nearestNeighbors(current, 1)[0])) {
            var activeKeyframe;
            if (my.selectedKeyframe) {
                activeKeyframe = my.selectedKeyframe;
            } else {
                activeKeyframe = activeDisplay.keyframes.nearestNeighbors(current, 1)[0];
            }
            if (activeKeyframe && ((Math.twoDecPlaces(activeKeyframe.getTime()) <= Math.twoDecPlaces(current + 0.05)) && (Math.twoDecPlaces(activeKeyframe.getTime()) >= Math.twoDecPlaces(current - 0.05))) && !activeKeyframe.removed) { // the current check fixes a bug
                activeKeyframe.loadRIN(capture);
                my.dirtyKeyframe = true;
                if (select && my.selectedKeyframe !== activeKeyframe) {
                    activeKeyframe.setSelected();
                }
            }
            else { // find active display and add keyframe to it
                if (!activeDisplay) {
                    activeDisplay = that.getStorageContainer().displays.nearestNeighbors(current, 1)[0];
                }
                if (activeDisplay) {
                    if (current >= activeDisplay.display.getStart() && current <= activeDisplay.display.getEnd()) {
                        keyframe = activeDisplay.display.addKeyframe(my.timeManager.timeToPx(current));
                        if (keyframe) {
                            keyframe.loadRIN(capture);
                            my.dirtyKeyframe = true;
                            keyframe.setSelected(false, true);
                        }
                    }
                }
                //var displays = that.getStorageContainer().displays.getContents();
                //for (i = 0; i < displays.length; i++) {
                //    display = displays[i].display;
                //    if (display.getStart() < current && current < display.getEnd()) {
                //        keyframe = display.addKeyframe(my.timeManager.timeToPx(current));
                //        if (keyframe) {
                //            keyframe.loadRIN(capture);
                //            my.dirtyKeyframe = true;
                //            if (select) keyframe.setSelected();
                //        }
                //        return;
                //    }
                //}
            }
        }
    }
    that.receiveKeyframe = receiveKeyframe;

    function _unselectKeyframe() {
        if (my.selectedKeyframe) {
            my.selectedKeyframe.setDeselected();
        }
        my.currentKeyframe = null;
        my.dirtyKeyframe = false;
    }
    my.timeManager.onMove(function () {
        if (my.dirtyKeyframe) {
            my.update(true);
        }
        _unselectKeyframe();
    });

    // Ink params
    my.inkSpec = {};
    my.inkPath = "";
    my.currentInkPath = "";
    my.inkProps = {};
    my.inkEnabled = null; //(bleveque) unattached ink tracks by default
    my.inkInitKeyframe = {};
    my.inkRelativeArtPos = {};
  
    // add initialization
    //color, font, opacity, size, mode
    // param getters
    function getInkSpec() {
        return my.inkSpec;
    }
    function getInkColor() {
        return my.inkSpec.penColor;
    }
    function getInkFont() {
        return my.inkSpec.font;
    }
    function getInkOpacity() {
        return my.inkSpec.opacity;
    }
    function getInkSize() {
        return my.inkSpec.size;
    }
    function getInkMode() {
        return my.inkSpec.mode;
    }
    function getInkPath() {
        return my.inkPath;
    }
    function getInkLink() {//returns parent/associated artwork track
        return my.experienceId;
    }
    function getInkProps() {
        return my.inkProps;
    }
    function getInkEnabled() {
        return my.inkEnabled;
    }
    function getInkInitKeyframe() {
        return my.inkInitKeyframe;
    }
    function getInkRelativeArtPos() {
        return my.inkRelativeArtPos;
    }
    function getInkType() {
        return my.inkType;
    }
    that.getInkType = getInkType;

    that.getInkSpec = getInkSpec;
    that.getInkColor = getInkColor;
    that.getInkFont = getInkFont;
    that.getInkOpacity = getInkOpacity;
    that.getInkSize = getInkSize;
    that.getInkMode = getInkMode;
    that.getInkPath = getInkPath;
    that.getInkLink = getInkLink;
    that.getInkProps = getInkProps;
    that.getInkEnabled = getInkEnabled;
    that.getInkInitKeyframe = getInkInitKeyframe;
    that.getInkRelativeArtPos = getInkRelativeArtPos;

    // param setters
    function setInkType() {
        return my.inkType;
    }

    function setInkSpec(spec) {
        my.inkSpec = spec;
    }
    function setInkColor(color) {
        my.inkSpec.color = color;
    }
    function setInkFont(font) {
        my.inkSpec.font = font;
    }
    function setInkOpacity(opacity) {
        my.inkSpec.opacity = opacity;
    }
    function setInkSize(size) {
        my.inkSpec.size = size;
    }
    function setInkMode(mode) {
        my.inkSpec.mode = mode;
    }
    function setInkPath(path) {
        my.inkPath = path;
    }
    function setInkLink(id) {
        my.experienceId = id;
    }
    function setInkProps(props) {
        my.inkProps = props;
    }
    function setInkEnabled(enabled) {
        my.inkEnabled = enabled;
    }
    function setInkInitKeyframe(kf) {
        my.inkInitKeyframe = kf;
    }
    function setInkRelativeArtPos(ar) {
        my.inkRelativeArtPos = ar;
    }
    function addAttachedInkTrack(tr) {
        if (my.attachedInks.indexOf(tr) < 0) {
            my.attachedInks.push(tr);
        } else {
            console.log("duplicate added");
        }
    }
    function removeAttachedInkTrack(tr) {
        my.attachedInks.splice(my.attachedInks.indexOf(tr), 1);
    }
    function changeTrackColor(color) {
        my.track.css('background-color', color);
    }

    function videoConverted(converted) {
        my.converted = converted;
    }
    that.setInkSpec = setInkSpec;
    that.setInkType = setInkType;
    that.setInkColor = setInkColor;
    that.setInkFont = setInkFont;
    that.setInkOpacity = setInkOpacity;
    that.setInkSize = setInkSize;
    that.setInkMode = setInkMode;
    that.setInkPath = setInkPath;
    that.setInkLink = setInkLink;
    that.setInkProps = setInkProps;
    that.setInkEnabled = setInkEnabled;
    that.setInkInitKeyframe = setInkInitKeyframe;
    that.setInkRelativeArtPos = setInkRelativeArtPos;
    that.addAttachedInkTrack = addAttachedInkTrack;
    that.removeAttachedInkTrack = removeAttachedInkTrack;
    that.changeTrackColor = changeTrackColor;
    that.videoConverted = videoConverted;
    // RIN conversions

    /**
     * Add track resource to RIN resource table
     * @param table     RIN resource table object to add entry to
     */
    function addResource(table) {
        table[my.resource] = {
            uriReference: media
        };
    }
    that.addResource = addResource;

    /**
     * Generates RIN data for Experience Stream from track
     * @param data      "ExperienceStreams" object to add named track ES object to
     */
    function addES(data) {
        var i, passthrough, inkLink = null,
            param = my.title,
            count = 0,
            exp = {},
            prevState = null;

        exp.data = {
            zIndex: dataHolder.numTracks() - that.getPos(),
        };

        // type
        switch (my.type) {
            case TAG.TourAuthoring.TrackType.artwork:
                exp.providerId = 'ZMES';
                exp.data.guid = guid;
                break;

            case TAG.TourAuthoring.TrackType.image:
                exp.providerId = 'ImageES';
                break;

            case TAG.TourAuthoring.TrackType.audio:
                exp.providerId = 'AES';
                exp.data.mediaLength = my.mediaLength;
                break;

            case TAG.TourAuthoring.TrackType.video:
                exp.providerId = 'VideoES';
                exp.data.mediaLength = my.mediaLength;
                exp.data.converted = my.converted;
                exp.data.toConvert = my.toConvert;
                break;

            case TAG.TourAuthoring.TrackType.ink:
                exp.providerId = 'InkES';
                exp.data.linkToExperience = {};
                inkLink = (my.experienceId) ? my.experienceId.getTitle() : '';
                exp.data.linkToExperience.embedding = {
                    element: {
                        datastring: {
                            type: "datastring",
                            str: my.inkPath,
                        },
                        props: my.inkProps,
                    },
                    enabled: my.inkEnabled,
                    //inkType: my.inkType,
                    initKeyframe: my.inkInitKeyframe,
                    experienceId: inkLink,
                    initproxy: my.inkRelativeArtPos,
                };
                //hard coded for now
                exp.data.markers = {
                    beginAt: 0,
                    endAt: 5,
                };
                exp.data.transition = {
                    inDuration: 0.000001, //was 0.5 (bleveque)
                    outDuration: 0.000001, //was 0.5 (bleveque)
                    providerId: "FadeInOutTransitionService",
                };
                exp.experienceStreams = { "defaultStream": { "duration": 16.891999999999999 } };
                exp.resourceReferences = [];
                break;
            default:
                console.log('Track type not yet implemented in RIN');
        }

        // don't pass through if track is currently selected or there is no selection
        if (!dataHolder.getSelectedTrack() || dataHolder.getSelectedTrack() === that) {
            passthrough = false;
        } else {
            passthrough = true;
        }
        
        if (my.type !== TAG.TourAuthoring.TrackType.ink) {
            exp.resourceReferences = [
                {
                    resourceId: my.resource,
                    required: 'true'
                }
            ];
        } else {
            exp.resourceReferences = [];
        }
        exp.experienceStreams = {};

        var trackDisplays = that.getStorageContainer().displays.getContents();
        for (var idx = 0; idx < trackDisplays.length; idx++) {
            trackDisplays[idx].display.toES(exp, passthrough, prevState, idx);
            prevState = dataHolder.lastKeyframe(trackDisplays[idx].display);
        }

        //dataHolder.mapDisplays(that.getStorageContainer(), function (currentDisplay) {
        //    currentDisplay.display.toES(exp, passthrough, prevState);
        //    prevState = dataHolder.lastKeyframe(currentDisplay.display);
        //});

        //for (i = 0; i < my.displays.length; i++) {
        //    my.displays[i].toES(exp, passthrough, prevState);
        //    prevState = my.displays[i].getLastKeyframe();
        //}

        while (data.hasOwnProperty(param)) {
            param = param + '-0';
        }
        data[param] = exp;
    }
    that.addES = addES;

    /**
     * --- DEPRECATED --- 
     * Helper function for generating Experience Streams
     * Gathers Keyframe Sequence data from displays
     * @returns     "keyframeSequences" object
     */
    function _getKeyframeSequences() {
        var i, sequences = {};
        for (i = 0; i < my.displays.length; i++) {
            my.displays[i].toKeyframeSequence(sequences);
        }
        return sequences;
    }

    /**
     * Gathers screenplay entries from displays
     * Don't forget to sort these things afterwards
     * @param screenplay        Array to add screenplay entries to
     * @param needFull          If true, output screenplay entries regardless of internal settings
     */
    function addScreenPlayEntries(screenplay, needFull) {
        if (needFull || my.isVisible) {
            var trackDisplays = dataHolder.getDisplays(that.getPos()).getContents();
            for (var i = 0; i < trackDisplays.length; i++) {
                var currentDisplay = trackDisplays[i];
                screenplay.push(currentDisplay.display.toScreenPlayEntry(i));
            };
            //for (i = 0; i < my.displays.length; i++) {
            //    screenplay.push(my.displays[i].toScreenPlayEntry());
            //}
        }
    }
    that.addScreenPlayEntries = addScreenPlayEntries;
    
    // updates the position of the zoom box
    function zoomBoxUpdate() {
        var zoomfader = $(document.getElementById('zoomPoint'));
        var currScale = my.timeManager.getDuration().scale;

        var minScale = $(timeline).width() / my.timeManager.getDuration().end;
        var percent = (currScale - minScale) / (TAG.TourAuthoring.Constants.maxZoom - minScale);
        var newLeft = ((zoomfader.offsetParent().width() - zoomfader.width()) * percent);
        zoomfader.css('left', newLeft);
    }

    // set minimized boolean flag to specified value
    function setMinimizedState(state) {
        isMinimized = state;
    }
    that.setMinimizedState = setMinimizedState;

    // return value of boolean flag representing minimized state
    function  getMinimizedState() {
        return isMinimized;
    }
    that.getMinimizedState = getMinimizedState;

    // toggle track minimization
    function toggleMinimized() {
        isMinimized = !isMinimized;
        if (Math.ceil(titlediv.height()) === TAG.TourAuthoring.Constants.trackHeight) {
            titlediv.height(TAG.TourAuthoring.Constants.minimizedTrackHeight);
            my.track.height(TAG.TourAuthoring.Constants.minimizedTrackHeight);
            iconDiv.hide();
            titleConversionMsg.hide();
            if (mygroup) {
                mygroup.style('display', 'none');
            }
        } else {
            titlediv.height(TAG.TourAuthoring.Constants.trackHeight);
            my.track.height(TAG.TourAuthoring.Constants.trackHeight);
            iconDiv.show();
            titleConversionMsg.show();
            if (mygroup) {
                mygroup.style('display', null);
            }
        }
        dataHolder.mapDisplays(that.getStorageContainer(), function (display) {
            display.display.toggleCircles();
        });

        drawLines();
        my.timeline.updateVerticalScroller();
        my.timeline.enableDisableDrag();
    }

    return that;
};
;
TAG.Util.makeNamespace('TAG.TourAuthoring.VideoTrack');

/**
 * Creates a Video track
 * @param spec  Specifications (see Track class for details);
 * @param my    After superclass is called, will contain displays and keyframes arrays
 *              Don't pass in unless you are subclassing this
 */
TAG.TourAuthoring.VideoTrack = function (spec, my) {
    "use strict";

    // Call super-constructor
    spec.type = TAG.TourAuthoring.TrackType.video;
    my = my || {};
    var that = TAG.TourAuthoring.Track(spec, my);

    my.track.addClass('video');
    //my.svg.classed('video', true);

    // Video-specific functions

    // Keyframes

    // Export to RIN format

    // Associated Inks
    //TAG.TourAuthoring.InkablePart(that, my);

    return that;
};
;
TAG.Util.makeNamespace("TAG.Authoring.SettingsView");

/*  Creates a SettingsView, which is the first UI in authoring mode.  
 *  @class TAG.Authoring.SettingsView
 *  @constructor
    TODO- change parameters to options object
 *  @param startView sets the starting setting.  This can be "Exhibitions", "Artworks", "Tours", 
 *       or "General Settings".  Undefined/null, etc. goes to General Settings.
 *       TODO: Use constants instead of strings
 *   @param {Function} callback  called after the UI is done being created.
 *   @param {Function} backPage is a function to create the page to go back to (null/undefined goes
 *      back to the main page).  This function, when called with no arguments,
 *      should return a dom element that can be provided as an argument to 
 *      slidePageRight.
 *   @param startLabelID selects a middle label automatically if it matches that id.
 *      The label will be scrolled to if it is off screen
 *   @return {Object} public methods and variables
 */
TAG.Authoring.SettingsView = function (startView, callback, backPage, startLabelID) {
    "use strict";
    //$(document).off();
     
    var root = TAG.Util.getHtmlAjax('../tagcore/html/SettingsView.html'), //Get html from html file

        //get all of the ui elements from the root and save them in variables
        middleLoading = root.find('#setViewLoadingCircle'),
        settingsContainer = root.find('#setViewSettingsContainer'),
        searchContainer = root.find('#setViewSearchContainer'),
        navBar = root.find('#setViewNavBar'),
        searchbar = root.find('#setViewSearchBar'),
        newButton = root.find('#setViewNewButton'),
        secondaryButton = root.find('#setViewSecondaryButton'),
        middlebar = root.find('#setViewMiddleBar'),
        middleLabelContainer = root.find('#setViewMiddleLabelContainer'),
        rightbar = root.find('#setViewRightBar'),
        viewer = root.find('#setViewViewer'),
        buttonContainer = root.find('#setViewButtonContainer'),
        settings = root.find('#setViewSettingsBar'),
        label = root.find('#setViewLoadingLabel'),
        circle = root.find('#setViewLoadingCircle'), 
        rootContainer = root.find('#setViewRoot'),
        iframeAssetCreateButton = root.find('#iframeAssetCreateButton'),
        primaryColorPicker,
        secondaryColorPicker,

        // Constants
        VIEWER_ASPECTRATIO = $(window).width() / $(window).height(),
        //Should probably get rid of any hard-coded values here:
        RIGHT_WIDTH = '54',
        CONTENT_HEIGHT = '92',
        HIGHLIGHT = 'white',
        BUTTON_HEIGHT = '40',
        DEFAULT_SEARCH_TEXT = '',
        PICKER_SEARCH_TEXT = 'Search by Name, Artist, or Year...',

        // Text for Navagation labels
        NAV_TEXT = {
            general: {
                text: 'General Settings',
                subtext: 'Customize TAG experience'
            },
            exhib: {
                text: 'Collections',
                subtext: 'Create and edit collections'
            },
            art: {
                text: 'Artworks',
                subtext: 'Import and manage artworks'
            },
            media: {
                text: 'Associated Media',
                subtext: 'Manage associated media'
            },
            tour: {
                text: 'Tours',
                subtext: 'Build interactive tours'
            },
            feedback: {
                text: 'Feedback',
                subtext: 'View comments and reports'
            },
        },

        that = {
            getRoot: getRoot,
        },

        //AUTOSAVING HAS BEEN REMOVED - SAVE BUTTONS ARE BACK!
        //global vars for automatic saving
        //currentMetadataHandler,                     //the save function for the current item (collection/artwork/assocmedia/tour); added to the queue when navigation occurs
        //saveQueue = TAG.Util.createQueue(),         //async queue that handles save operations (when multiple items have been edited in a short amount of time)
        previousIdentifier,                         //refers to the current middle label selected to prevent redundant save operations
        //changesHaveBeenMade = false,                //keeps track of whether the current collection/artwork/assocmedia/tour has been edited to prevent redundant save operations
        //autosaveData = {},                          //Used to refresh the display before the database has actually been updated
        //backButtonClicked = false,
        backButton,
        /*saveArray = [],
        pCL = null, 
        pCircle2 = null,
        backButtonClicked = false,
        generalIsLoading = false,
        collectionsIsLoading = false,
        artworksIsLoading = false,
        associatedMediaIsLoading = false,
        toursIsLoading = false,
        generalProgressCircle = null,*/
        labelOne,
        labelTwo,
        sortOptionsCount = 0,
        sortOptionsObj = {},
        settingsViewKeyHandler = {
            13: enterKeyHandlerSettingsView,
            46: deleteKeyHandlerSettingsView,
            40: downKeyHandlerSettingsView,
            38: upKeyHandlerSettingsView,
        },

        prevSelectedSetting,
        prevSelectedMiddleLabel,
        // These are 'asynchronous' queues to perform tasks. These queues will process events in order, but asynchronously so
        // they can be completed in the 'background'. Calling .add(fn) adds a function to the queue while .clear() clears the queue.  
        //Note that an in progress function will not be canceled by .clear().
        middleQueue = TAG.Util.createQueue(),  //used to add things to the middle label container
        rightQueue = TAG.Util.createQueue(), //used to add things to the right panel
        cancelLastSetting,
        cancelLastView,
        artPickerOpen = false,
        nav = [],
        artworks = [],
        assetUploader,
        mediaMetadata = [],
        numFiles = 0,
        isUploading = false,
        isCreatingMedia = false,
        artworkAssociations = [], // entry i contains the artwork info for the ith associated media
        artworkList = [], // save artworks retrieved from the database
        mediaCheckedIDs = [], // artworks checked in associated media uploading
        mediaUncheckedIDs = [], // artworks unchecked in associated media uploading
        editArt, // enter artwork editor button
        artmodeList, // list of all artworks in a collection
        infoSource = [], // array to hold sorting/searching information
        currDoq,//current selected artwork/associated media id
        // key handling stuff
        deleteType,
        toDelete,
        currentList,
        currentIndex = 0,
        currentSelected,
		currentSelectedSetting,
		leftButton,
        popUpBoxVisible = false,
        changesMade = false,
        pickerOpen = false,

        // booleans
		inGeneralView = false,
        inCollectionsView = false,
        inArtworkView = false,
        inAssociatedView = false,
        inToursView = false,
        inFeedbackView = false,

        //dropdown associated media menu
        menuLabel = createDropdownAssocMediaMenu(),
        showDropdown = false;

        //window.addEventListener('keydown', keyHandler),
        TAG.Util.UI.initKeyHandler();
        TAG.Util.UI.getStack()[0] = settingsViewKeyHandler;
        var timelineShown;
        newButton.on("mousedown", function () {
            newButton.css({"background-color":"white"});
        });
        var checkConTimerId;
        var cancelArtworkLoad = null;
    loadHelper();
    if (callback) {
        callback(that);
    }

    //an array to store video guids that need to be converted
    //var conversionVideos = [];
    /*function checkConversion() {
        for (var i = 0; i < conversionVideos.length; i++) {
            var artwork = conversionVideos[i];
            LADS.Worktop.Database.getConvertedVideoCheck(
                (function (i, artwork) {
                    return function (output) {
                        if (output !== "" || output !== "False") {
                            console.log("converted: ");
                            var element = $(document.getElementById("videoInPreview"));
                            if (element && element.attr("identifier") === output) {
                                reloadVideo(element);
                                conversionVideos.remove(artwork);
                            }
                        } else {
                            console.log("not converted: ");
                        }
                    }
                })(i, artwork), null, conversionVideos[i]);
        }
    }*/
    function checkConversion(doq) { //WIN8 AUG 15 RELEASE ONLY
        //if(
        LADS.Worktop.Database.getConvertedVideoCheck(
            function (output) {
                if (output === "True") {
                    console.log("converted: ");
                    clearInterval(checkConTimerId);
                    var source = doq.Metadata.Source;
                    var ext = source.substr(source.lastIndexOf('.'));
                    if (currDoq === doq.Identifier) {
                        if (ext === ".mp4") {
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                        } else {
                            reloadVideo(doq);
                        }
                    }
                } else if (output === "Error") {
                    clearInterval(checkConTimerId);
                    if (currDoq === doq.Identifier) {
                        $("#videoErrorMsg").remove();
                        $("#leftLoading").remove();
                        var msg = "An error occured when converting this video. Please try to upload again";
                        if (doq.Extension === '.mp4') {
                            viewer.append(TAG.Util.createConversionLoading(msg, true, true))
                        } else {
                            viewer.append(TAG.Util.createConversionLoading(msg, true));
                        }
                    }
                
                }else {
                    console.log("not converted: ");
                }
            }, null, doq.Identifier);
    }

    //setInterval(checkConversion, 1000 * 60);
    function reloadVideo(doq) {
        var mediaElement = $(document.createElement('video'));
        mediaElement.attr('id', 'videoInPreview');
        fixVolumeBar(mediaElement);
        mediaElement.attr('poster', (doq.Metadata.Thumbnail && !doq.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(doq.Metadata.Thumbnail) : '');
        mediaElement.attr('identifier', doq.Identifier);
        mediaElement.attr("preload", "none");
        mediaElement.attr("controls", "");
        mediaElement.css({ "width": "100%", "max-width": "100%", "max-height": "100%" });
        var source = TAG.Worktop.Database.fixPath(doq.Metadata.Source);
        var sourceWithoutExtension = source.substring(0, source.lastIndexOf('.'));
        var sourceExt = source.substring(source.lastIndexOf('.'));
        var videoErrorDiv = $(document.createElement('div'));
        videoErrorDiv.addClass("videoErrorDiv");

        mediaElement.attr("fileName", doq.Metadata.Source.substring(0, source.lastIndexOf('.')));
        var sourceMP4 = sourceWithoutExtension + ".mp4";
        var sourceWEBM = sourceWithoutExtension + ".webm";
        var sourceOGV = sourceWithoutExtension + ".ogv";

        addSourceToVideo(mediaElement, sourceMP4, 'video/mp4');
        addSourceToVideo(mediaElement, sourceWEBM, 'video/webm');
        addSourceToVideo(mediaElement, sourceOGV, 'video/ogv');
        mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer);
        viewer.append(mediaElement);

        $("#middleLoading").remove();
        $("#leftLoading").remove();
        $("#videoErrorMsg").remove();
    }
    
    
    //an array to store video guids that need to be converted
    var conversionVideos = [];
    /**
    * check for conversion in interval
    */
    //function checkConversion() {
    //    for (var i = 0; i < conversionVideos.length; i++) {
    //        var artwork = conversionVideos[i];
    //        TAG.Worktop.Database.getConvertedVideoCheck(
    //            (function (i, artwork) {
    //                return function (output) {
    //                    if (output !== "" && output !== "False" && output !== "Error") {
    //                        //console.log("converted: ");
    //                        var element = $(document.getElementById("videoInPreview"));
    //                        if (element && element.attr("identifier") === output) {
    //                            reloadVideo(element);
    //                            conversionVideos.remove(artwork);
    //                        }
    //                    } else if (output === "Error") {
    //                        $("#videoErrorMsg").remove();
    //                        $("#leftLoading").remove();
    //                        var msg = "An error occured when converting this video. Please try again";
    //                        viewer.append(TAG.Util.createConversionLoading(msg));
    //                        conversionVideos.remove(artwork);
    //                    }
    //                    else {
    //                        //console.log("not converted: ");
    //                    }
    //                }
    //            })(i, artwork), null, conversionVideos[i]);
    //    }
    //}
    //setInterval(checkConversion, 1000 * 60);

    /** Reload the video when conversion is done
    * @ param: videoInPreview element
    */

    //function reloadVideo(element) {
    //    var source = element.attr("src");
    //    if (element[0].children.length < 3) {
    //        element.removeAttr("src");
    //        var sourceWithoutExtension = source.substring(0, source.lastIndexOf('.'));
    //        var sourceMP4 = sourceWithoutExtension + ".mp4";
    //        var sourceWEBM = sourceWithoutExtension + ".webm";
    //        var sourceOGV = sourceWithoutExtension + ".ogv";

    //        addSourceToVideo(element, sourceMP4, 'video/mp4');
    //        addSourceToVideo(element, sourceWEBM, 'video/webm');
    //        addSourceToVideo(element, sourceOGV, 'video/ogv');
    //    }
    //    $(document.getElementById("leftLoading")).remove();
    //    $(function () {
    //        $("#leftLoading").remove();
    //    })
    //    if ($("#videoErrorMsg")) {
    //        $("#videoErrorMsg").remove();
    //    }
    //    element.show();
    //    var video = document.getElementById("videoInPreview");
    //    video.load();
    //    video.play();
    //}

    /**Handles enter key press on the SettingsView page
     * @ method enterKeyHandlerSettingsView
     * @param event
     */
    function enterKeyHandlerSettingsView(event) {
        if (event.target.className == "metadataPickerSearchbar") {
            console.log('searching metadata');
            event.stopPropagation();
            event.preventDefault();
        }
        if ($('.searchBar').is(':focus')) {
            event.stopPropagation();
            event.preventDefault();
        }
        else if (searchbar.is(':focus')) {
            if (!searchbar.val()) {
                resetView();
                searchbar.css({ 'background-image': 'none' });
            } else {
                doSearch();
                searchbar.css({ 'background-image': 'none' });
            }
            event.stopPropagation();
            event.preventDefault();
        }
        else if (!$("input, textarea, select").is(":focus")) {
            event.stopPropagation();
            event.preventDefault();
            if (inCollectionsView) {
                manageCollection(currentList[currentIndex]);
            }
            if (inArtworkView) {
                if ($(document.getElementById('artworkEditorButton')).length) {
                    editArtwork(currentList[currentIndex]);
                }
                if ($(document.getElementById('thumbnailButton')).length) {
                    saveThumbnail(currentList[currentIndex], false);
                }
             }
            if (inAssociatedView) {
                if (!$('.pickerOverlay').length) {
                    assocToArtworks(currentList[currentIndex]);
                }                
            }
            if (inToursView) { editTour(currentList[currentIndex]); }
            if (inFeedbackView) { deleteFeedback(currentList[currentIndex]); }
        }
        
    }

    /**Handles delete key press on the SettingsView page
     * @ method deleteKeyHandlerSettingsView
     */
    function deleteKeyHandlerSettingsView() {
        if (!$("input, textarea").is(":focus")) {
            deleteType(toDelete);
        }
    }

    /**Handles up key press on the SettingsView page
     * @ method upKeyHandlerSettingsView
     */
    function upKeyHandlerSettingsView() {
        if (!$("input, textarea").is(":focus")) {
            if (prevSelectedMiddleLabel && prevSelectedMiddleLabel === currentSelected) {
                if (currentSelected.prev()) {
                    if (currentIndex > 0) {
                        resetLabels('.middleLabel');
                        selectLabel(currentSelected.prev());
                        currentSelected = currentSelected.prev();
                        prevSelectedMiddleLabel = currentSelected;
                        currentIndex--;
                        

                        if (inCollectionsView) { 
                            loadExhibition(currentList[currentIndex]); 
                        }
                        if (inArtworkView) { 
                            loadArtwork(currentList[currentIndex]); 
                        }
                        if (inAssociatedView) { 
                            loadAssocMedia(currentList[currentIndex]); 
                        }
                        if (inToursView) { 
                            loadTour(currentList[currentIndex]); 
                        }
                        if (inFeedbackView) {
                            loadFeedback(currentList[currentIndex]); 
                        }
                    }
                }
            }
			
        }
        if (inGeneralView) {
            if (currentSelected === labelTwo) {
                resetLabels('.leftLabel');
                selectLabel(labelOne);
                currentSelected = labelOne;
                loadSplashScreen();
            } else if (currentSelected === labelOne) {
                resetLabels('.leftLabel');
                selectLabel(labelTwo);
                currentSelected = labelTwo;
                loadPasswordScreen();
            }
        }
    }

    /**Handles the down arrow key press on the SettingsViewPage
     * @method downKeyHandlerSettingsView
     */
    function downKeyHandlerSettingsView() {
        
        if (!$("input, textarea").is(":focus") && !inGeneralView) {
            if (prevSelectedMiddleLabel && prevSelectedMiddleLabel === currentSelected) {
                if (currentSelected.next()) {
                    if (currentIndex < (currentList.length - 1)) {
                        resetLabels('.middleLabel');
                        selectLabel(currentSelected.next());
                        currentSelected = currentSelected.next();
                        prevSelectedMiddleLabel = currentSelected;
                        currentIndex++;

                        if (inCollectionsView) {
                            loadExhibition(currentList[currentIndex]);
                        }
                        if (inArtworkView) {
                            loadArtwork(currentList[currentIndex]);
                        }
                        if (inAssociatedView) {
                            loadAssocMedia(currentList[currentIndex]);
                        }
                        if (inToursView) {
                            loadTour(currentList[currentIndex]);
                        }
                        if (inFeedbackView) {
                            loadFeedback(currentList[currentIndex]);
                        }
                    }
                }
            }
        }
        if (inGeneralView) {
            if (currentSelected === labelOne) {
                resetLabels('.leftLabel');
                selectLabel(labelTwo);
                currentSelected = labelTwo;
                loadPasswordScreen();
            } else if (currentSelected === labelTwo) {
                resetLabels('.leftLabel');
                selectLabel(labelOne);
                currentSelected = labelOne;
                loadSplashScreen();
            }
        }
    }

 /**
  * Function to reset current view and reload original labels
  * @method resetView
  */
    function resetView() {
        if (inArtworkView) {
            loadArtView();
        } else if (inAssociatedView) {
            loadAssocMediaView();
        } else if (inCollectionsView) {
            loadExhibitionsView();
        } else if (inFeedbackView) {
            loadFeedbackView();
        } else if (inToursView) {
            loadTourView();
        }
    }

    /**
     * Helper function to set up UI elements and switch to first view
     * @method loadHelper
     * @param {Object} main  
     */
    function loadHelper(main){

        //Setting up UI:
        backButton = root.find('#setViewBackButton');
        backButton.attr('src', tagPath + 'images/icons/Back.svg');

        backButton.mousedown(function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, false);
        });

        backButton.mouseleave(function () {
            TAG.Util.UI.cgBackColor("backButton", backButton, true);
        });

        backButton.click(function () {
            //if (!changesHaveBeenMade) {
            TAG.Util.removeYoutubeVideo();
                TAG.Auth.clearToken();
                rightQueue.clear();
                middleQueue.clear();
                backButton.off('click');
                if (backPage) {
                    var bpage = backPage();
                    TAG.Util.UI.slidePageRight(bpage);
                } else {
                    TAG.Layout.StartPage(null, function (page) {
                        TAG.Util.UI.slidePageRight(page);
                    });
                }
                TAG.Util.UI.getStack()[0] = null;
            //} else {

            //    changesHaveBeenMade && currentMetadataHandler && saveQueue.add(currentMetadataHandler());
            //    changesHaveBeenMade = false;

            //    backButtonClicked = true;

            //    settingsContainer.css({ visibility: 'hidden' });
            //    settings.css({ overflow: 'hidden' });
            //    buttonContainer.css({ visibility: 'hidden' });
            //    var changeLabel = createLabel('Changes are being saved...');
            //    changeLabel.attr('id', 'changeLabel');
            //    changeLabel.css({
            //        'position': 'absolute',
            //        'top': '30%',
            //        'left': '10%',
            //        'z-index': '50',
            //        'height': 'auto',
            //        'width': '33%',
            //        'color': 'black',
            //        'font-size': '80%'
            //    });
            //    var progressCircCSS = {
            //        'position': 'absolute',
            //        'left': '50%',
            //        'top': '30%',
            //        'z-index': '50',
            //        'height': 'auto',
            //        'width': '10%'
            //    };
            //    var progressCL = TAG.Util.showProgressCircle(settings, progressCircCSS, '0px', '0px', true);
            //    settings.append(changeLabel);
            //}
            
        });

        var topBarLabel = root.find('#setViewTopBarLabel');
        var topBarLabelSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            width: 0.4,
            height: 0.9,
        });
        topBarLabel.css({
            'height': topBarLabelSpecs.height + 'px',
            'width': topBarLabelSpecs.width + 'px',
        });
        var fontsize = TAG.Util.getMaxFontSizeEM('Tour Authoring', 0.5, topBarLabelSpecs.width, topBarLabelSpecs.height * 0.8, 0.1);
        topBarLabel.css({ 'font-size': fontsize });
        topBarLabel.text('Authoring Mode');

        //Add text to navigation bar:

        navBar.append(nav[NAV_TEXT.general.text] = createNavLabel(NAV_TEXT.general, loadGeneralView));
        navBar.append(nav[NAV_TEXT.exhib.text] = createNavLabel(NAV_TEXT.exhib, loadExhibitionsView));
        navBar.append(nav[NAV_TEXT.art.text] = createNavLabel(NAV_TEXT.art, loadArtView));
        navBar.append(nav[NAV_TEXT.media.text] = createNavLabel(NAV_TEXT.media, loadAssocMediaView)); // COMMENT!!!!!!!!
        navBar.append(nav[NAV_TEXT.tour.text] = createNavLabel(NAV_TEXT.tour, loadTourView));
        //navBar.append(nav[NAV_TEXT.feedback.text] = createNavLabel(NAV_TEXT.feedback, loadFeedbackView));

        searchbar.css({
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size': 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position': '12px center'
        });

        searchbar.on('click focus', function () {
            searchbar.css({ 'background-image': 'none' });
        });
        searchbar.on('focusout', function () {
            if (!searchbar.val()) {
                searchbar.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });
            }
        });
        
        searchbar.keyup(function (e) {

            if (!searchbar.val()) {
                resetView();
                searchbar.css({ 'background-image': 'none' });
            }
        });

       // rootContainer.keydown(keyHandler);
        //searchbar.attr('placeholder', 'Search...');
        newButton.text('New').css('border-radius', '3.5px');
        secondaryButton.text('Video');
        label.text('Loading...');
        circle.attr('src', tagPath + 'images/icons/progress-circle.gif');

        viewer.css({
            'height': $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + 'px',
        });

        buttonContainer.css({
            'top': $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + 'px',
        });
        settings.css({
            'height': getSettingsHeight() + 'px',
        });
        switchView(startView, startLabelID);
    }
    
    /**Switches the view based on selected navigation label
     * @method switchView
     * @param {String} view         the view to switch to
     * @param {Object} id           the id of the middle label to start on
     */
    function switchView(view, id) {
        resetLabels('.navContainer');
        switch (view) {
            case "Exhibitions":
                selectLabel(nav[NAV_TEXT.exhib.text]);
                prevSelectedSetting = nav[NAV_TEXT.exhib.text];
                loadExhibitionsView(id);
                break;
            case "Artworks":
                selectLabel(nav[NAV_TEXT.art.text]);
                prevSelectedSetting = nav[NAV_TEXT.art.text];
                loadArtView(id);
                break;
            case "Associated Media": 
                selectLabel(nav[NAV_TEXT.media.text]);
                prevSelectedSetting = nav[NAV_TEXT.media.text];
                loadAssocMediaView(id);
                break;
            case "Tours":
                
                selectLabel(nav[NAV_TEXT.tour.text]);
                prevSelectedSetting = nav[NAV_TEXT.tour.text];
                loadTourView(id);
                break;
            case "Feedback":
                selectLabel(nav[NAV_TEXT.feedback.text]);
                prevSelectedSetting = nav[NAV_TEXT.feedback.text];
                loadFeedbackView(id);
                break;
            case "General Settings":
            default:
                selectLabel(nav[NAV_TEXT.general.text]);
                prevSelectedSetting = nav[NAV_TEXT.general.text];
                loadGeneralView();
                break;
        }
    }

    /**Returns root
     * @method getRoot
     * @return {Object} root 
     */
    function getRoot() {
        return root;
    }

    // Navigation Bar Functions:

     /**Create a navigation label
     * @method createNavLabel
     * @param {String} text         text for label
     * @param {Function} onclick    onclick function for label
     * @return {Object} container   container containing new label
     */
    function createNavLabel(text, onclick) {
        var container = $(document.createElement('div'));
        container.attr('class', 'navContainer');
        container.attr('id', 'nav-' + text.text);
        container.mousedown(function () {
            container.css({
                'background': HIGHLIGHT
            });
        });
        container.mouseup(function () {
            container.css({
                'background': 'transparent'
            });
        });
        container.mouseleave(function () {
            container.css({
                'background': 'transparent'
            });
        });
        container.click(function () {
            // If a label is clicked return if its already selected.
            //if (prevSelectedSetting === container) {
            //    return;
            //} else {
            //    changesHaveBeenMade && currentMetadataHandler && saveQueue.add(currentMetadataHandler());
            //    changesHaveBeenMade = false;
            //}
            // Reset all labels and then select this one
            TAG.Util.removeYoutubeVideo();
            searchbar[0].value = "";

            resetLabels('.navContainer');
            selectLabel(container);
            // Do the onclick function
            if (onclick) {
                onclick();
            }
            prevSelectedSetting = container;
        });

        // vertical centering groundwork for 2.2
        //var navTextHolder;

        var navtext = $(document.createElement('label'));
        navtext.attr('class','navtext');
        navtext.text(text.text);

        var navsubtext = $(document.createElement('label'));
        navsubtext.attr('class','navsubtext');
        navsubtext.text(text.subtext);

        container.append(navtext);
        container.append(navsubtext);
        return container;
    }

    // General Settings Functions:

    /**Loads the General Settings view
     * @method loadGeneralView
     */
    function loadGeneralView() {

        inGeneralView = true;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;

        changesMade = false;

        prepareNextView(false);

        // Add this to our queue so the UI doesn't lock up
        middleQueue.add(function () {
            var label;
            // Add the Splash Screen label and set it as previously selected because its our default
            middleLoading.before(label = selectLabel(createMiddleLabel('Splash Screen', null, loadSplashScreen), true));
            labelOne = label;
            labelOne.addClass('leftLabel');
            prevSelectedMiddleLabel = label;
            // Default to loading the splash screen
            loadSplashScreen();
            // Add the Password Settings label
            labelTwo = createMiddleLabel('Password Settings', null, loadPasswordScreen).attr('id', 'password');
            labelTwo.addClass('leftLabel');
            middleLoading.before(labelTwo);
            middleLoading.hide();
        });
        cancelLastSetting = null;
    }

    // Fixes volume far for video/audio
    function fixVolumeBar(mediaElement) {
        var media = mediaElement[0];
        var lastVolume = media.volume;
        var muted = false;
        media.addEventListener('volumechange', function () {
            if (media.muted) {
                media.volume = 0;
                muted = true;
            }
            else {
                if (muted) {
                    media.volume = lastVolume;
                    muted = false;
                }
                lastVolume = media.volume;
            }
        }, false);
    }

    /**Sets up the right side of the UI for the splash screen
     * including the viewer, buttons, and settings container.
     * @method loadSplashScreen
     */
    function loadSplashScreen() {
        //$(document).off();
        prepareViewer(true);
        clearRight();

        // Load the start page, the callback will add it to the viewer when its done
		//if (generalIsLoading) {
        //    generalProgressCircle = displayLoadingSettings();
        //} else {
        //    generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        //}

        // Get DB Values
        /*var alpha = TAG.Worktop.Database.getMuseumOverlayTransparency();
        var overlayColor = TAG.Worktop.Database.getMuseumOverlayColor();
        var name = TAG.Worktop.Database.getMuseumName();
        var loc = TAG.Worktop.Database.getMuseumLoc();
        var info = TAG.Worktop.Database.getMuseumInfo();
        if (name === undefined) {
            name = "";
        }
        if (loc === undefined) {
            loc = "";
        }
        if (info === undefined) {
            info = "";
        }
        var logoColor = TAG.Worktop.Database.getLogoBackgroundColor();
        var backgroundColor = TAG.Worktop.Database.getBackgroundColor();
        var backgroundOpacity = TAG.Worktop.Database.getBackgroundOpacity();*/
        var primaryFontColor = TAG.Worktop.Database.getPrimaryFontColor();
        var secondaryFontColor = TAG.Worktop.Database.getSecondaryFontColor();
        var fontFamily = TAG.Worktop.Database.getFontFamily();
        var idleTimerDuration = TAG.Worktop.Database.getIdleTimerDuration()/60000;

        // Create inputs
        //var alphaInput = createTextInput(Math.floor(alpha * 100), true);
        var bgImgInput = createButton('Change Image', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
			uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                bgImgInput.val(url);
                $('#innerContainer').css({
                    'background-image': 'url("' + TAG.Worktop.Database.fixPath(url) + '")',
                    'background-size': 'cover',
                });
            });
        });
        bgImgInput.css('height', '35px');
        /*var logoInput = createButton('Change Logo', function () {
            changesHaveBeenMade = true;
			uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                logoInput.val(url);
                $('#logo')[0].src = TAG.Worktop.Database.fixPath(url);
            });
        });*/
        /*var overlayColorInput = createBGColorInput(overlayColor, '.infoDiv', null, function () { return alphaInput.val(); });
        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(name), true, 40);
        var locInput = createTextInput(TAG.Util.htmlEntityDecode(loc), true, 45);
        var infoInput = createTextAreaInput(TAG.Util.htmlEntityDecode(info), true);
        var logoColorInput = createBGColorInput(logoColor, '.logoContainer', null, function () { return 100; });
        var backgroundColorInput = createBGColorInput(backgroundColor, '.background', null, function() { return backgroundOpacityInput.val(); });
        var backgroundOpacityInput = createTextInput(backgroundOpacity, true);*/
        var primaryFontColorInput = createBGColorInput(primaryFontColor, null, '.primaryFont', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
            return 100;
        });

        primaryFontColorInput.on('keyup', function (event) {
            if (event.which === 13) {
                event.preventDefault();
                event.stopPropagation();
                saveButton.click();
            } else {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            }
            
        });

        primaryFontColorInput.on('change', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });

        var secondaryFontColorInput = createBGColorInput(secondaryFontColor, null, '.secondaryFont', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
            return 100;
        });

        secondaryFontColorInput.on('keyup', function (event) {
            if (event.which === 13) {
                event.preventDefault();
                event.stopPropagation();
                saveButton.click();
            } else {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            }
        });

        secondaryFontColorInput.on('change', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });


        //var fontFamilyInput = createSelectInput(['Arial', 'Calibri', 'Comic Sans MS', 'Courier New', 'Franklin Gothic', 'Raavi', 'Segoe Print', 'Segoe UI Light', 'Source Sans Pro', 'Times New Roman', 'Trebuchet MS', 'Verdana'], TAG.Worktop.Database.getFontFamily());
        var idleTimerDurationInput = createTextInput(idleTimerDuration, "", 3, false, false, true);
        idleTimerDurationInput.on('keyup', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });
        var startPage = previewStartPage(primaryFontColorInput, secondaryFontColorInput);

        //var font = fontFamilyInput.find(":selected").text();
        //$('.primaryFont').css('font-family', fontFamily);
        //$('.secondaryFont').css('font-family', fontFamily);
        
        // Handle changes
        primaryFontColorInput.focus(function () {
            $('#tagContainer').off().unbind();
        });
        secondaryFontColorInput.focus(function () {
            $('#tagContainer').off().unbind();
        });
        // Handle changes for autosaving
        //primaryFontColorInput.on('change', function () { changesHaveBeenMade = true; });
        //secondaryFontColorInput.on('change', function () { changesHaveBeenMade = true; });
        //fontFamilyInput.on('change', function () { changesHaveBeenMade = true; });
        //idleTimerDurationInput.on('change', function () { changesHaveBeenMade = true; });

        /*onChangeUpdateNum(alphaInput, 0, 100, function (num) {
            updateBGColor('.infoDiv', overlayColorInput.val(), num);
        });
        onChangeUpdateText(nameInput, '#museumName', 40);
        nameInput.keyup(function () {
            startPage.fixText();
        });
        nameInput.keydown(function () {
            startPage.fixText();
        });var museumLoc
        nameInput.change(function () {
            startPage.fixText();
        });
        onChangeUpdateText(locInput, '#subheading', 33);
        onChangeUpdateText(infoInput, '#museumInfo', 300);
        onChangeUpdateNum(backgroundOpacityInput, 0, 100, function(num) {
            updateBGColor('.background', backgroundColorInput.val(), num);
        })*/



        var bgImage = createSetting('Background Image', bgImgInput);
        /*var overlayAlpha = createSetting('Overlay Transparency (0-100)', alphaInput);
        var overlayColorSetting = createSetting('Overlay Color', overlayColorInput);
        var museumName = createSetting('Museum Name', nameInput);
        var museumLoc = createSetting('Museum Location', locInput);
        var museumInfo = createSetting('Museum Info', infoInput);
        var museumLogo = createSetting('Museum Logo', logoInput);
        var logoColorSetting = createSetting('Museum Logo Background Color', logoColorInput);
        var backgroundColorSetting = createSetting('Background Color', backgroundColorInput);
        var backgroundOpacitySetting = createSetting('Background Opacity (0-100)', backgroundOpacityInput);*/
        var primaryFontColorSetting = createSetting('Primary Font Color', primaryFontColorInput);
        var secondaryFontColorSetting = createSetting('Secondary Font Color', secondaryFontColorInput);
        //var fontFamilySetting = createSetting('Font Family', fontFamilyInput);
        var idleTimerDurationSetting = createSetting('Idle Timer Duration (in minutes)', idleTimerDurationInput);

        settingsContainer.append(bgImage);
        /*settingsContainer.append(overlayColorSetting);
        settingsContainer.append(overlayAlpha);
        settingsContainer.append(museumName);
        settingsContainer.append(museumLoc);
        settingsContainer.append(museumInfo);
        settingsContainer.append(museumLogo);
        settingsContainer.append(logoColorSetting);
        settingsContainer.append(backgroundColorSetting);
        settingsContainer.append(backgroundOpacitySetting);*/
        settingsContainer.append(primaryFontColorSetting);
        settingsContainer.append(secondaryFontColorSetting);
        //settingsContainer.append(fontFamilySetting);
        settingsContainer.append(idleTimerDurationSetting);
		//automatically save General Settings - Customization
        onChangeUpdateText(idleTimerDurationInput, null, 3);
        //TAG.Util.IdleTimer.TwoStageTimer().s1d = idleTimerDurationInput.val();
        settings.scroll(function () {
            secondaryFontColorInput.trigger("blur");
            primaryFontColorInput.trigger("blur");
        });

        //currentMetadataHandler = function () {
        //    /*if (locInput === undefined) {
        //        locInput = "";
        //    }
        //    if (infoInput === undefined) {
        //        infoInput = "";
        //    }*/
        //    saveSplashScreen({
        //        /*alphaInput: alphaInput,                             //Overlay Transparency
        //        overlayColorInput: overlayColorInput,               //Overlay Color
        //        nameInput: nameInput,                               //Museum Name
        //        locInput: locInput,                                 //Museum Location
        //        infoInput: infoInput,                               //Museum Info
        //        logoColorInput: logoColorInput, */                    //Logo background color
        //        bgImgInput: bgImgInput,                             //Background image
        //        /*logoInput: logoInput,                               //Logo image
        //        backgroundColorInput: backgroundColorInput,         //Background Color
        //        backgroundOpacityInput: backgroundOpacityInput, */    //Background Opacity
        //        primaryFontColorInput: primaryFontColorInput,       //Primary Font Color
        //        secondaryFontColorInput: secondaryFontColorInput,   //Secondary Font Color
        //        fontFamilyInput: fontFamilyInput,
        //        //idleTimerDurationInput: idleTimerDurationInput
        //    });
        //};

        // Save button

        var saveButton = createButton('Save', function () {
           /* if (locInput === undefined) {
                locInput = "";
            }
            if (infoInput === undefined) {
                infoInput = "";
            }*/
            //save Splash screen and pass in inputs with following keys:
            //idleTimerDurationInput.text(idleTimerDurationInput.val());
            saveIdleTimerDuration(idleTimerDurationInput);
            //idleTimerDurationInput.text(idleDuration);
            saveSplashScreen({
                //alphaInput: alphaInput,                             //Overlay Transparency
                //overlayColorInput: overlayColorInput,               //Overlay Color
                //nameInput: nameInput,                               //Museum Name
                //locInput: locInput,                                 //Museum Location
                //infoInput: infoInput,                               //Museum Info
                //logoColorInput: logoColorInput,                     //Logo background color
                bgImgInput: bgImgInput,                             //Background image
                //logoInput: logoInput,                               //Logo image
                //backgroundColorInput: backgroundColorInput,         //Background Color
                //backgroundOpacityInput: backgroundOpacityInput,    //Background Opacity
                primaryFontColorInput: primaryFontColorInput,       //Primary Font Color
                secondaryFontColorInput: secondaryFontColorInput,   //Secondary Font Color
                //fontFamilyInput: fontFamilyInput,
                idleTimerDurationInput: idleTimerDurationInput
            });
        }, {
            'margin-right': '3%',
            'margin-top': '1%',
            'margin-bottom': '1%',
            'margin-left': '.5%',
            'float': 'right'
        }, true);

        // preview buttons
        var previewStartPageButton = createButton('Splash Screen', function () {
            previewStartPage(primaryFontColorInput, secondaryFontColorInput);
            primaryColorPicker.hidePicker();
            secondaryColorPicker.hidePicker();
        }, {
            'margin-left': '2%',
            'margin-top': '1%',
            'margin-right': '0%',
            'margin-bottom': '3%',
        });

        var previewCollectionsPageButton = createButton('Collections Page', function () {
                previewCollectionsPage(primaryFontColorInput, secondaryFontColorInput);
                primaryColorPicker.hidePicker();
                secondaryColorPicker.hidePicker();
            },
            {
            'margin-left': '2%',
            'margin-top': '1%',
            'margin-right': '0%',
            'margin-bottom': '3%',
        });

        var previewArtworkViewerButton = createButton('Artwork Viewer', function () {
            previewArtworkViewer(primaryFontColorInput, secondaryFontColorInput);
            primaryColorPicker.hidePicker();
            secondaryColorPicker.hidePicker();
        }, {
            'margin-left': '2%',
            'margin-top': '1%',
            'margin-right': '0%',
            'margin-bottom': '3%',
        });

        buttonContainer.append(saveButton);
        buttonContainer.append(previewStartPageButton);
        buttonContainer.append(previewCollectionsPageButton);
        buttonContainer.append(previewArtworkViewerButton);


        saveButton.on("mousedown", function () {
            if (!saveButton.attr("disabled")) {
                saveButton.css({ "background-color": "white" });
            }
        });
        previewStartPageButton.on("mousedown", function () {
            previewStartPageButton.css({ "background-color": "white" });
        });
        previewCollectionsPageButton.on("mousedown", function () {
            previewCollectionsPageButton.css({ "background-color": "white" });
        });
        previewArtworkViewerButton.on("mousedown", function () {
            previewArtworkViewerButton.css({ "background-color": "white" });
        });
        bgImgInput.on("mousedown", function () {
            bgImgInput.css({ "background-color": "white" });
        });
        saveButton.on("mouseleave", function () {
            saveButton.css({ "background-color": "transparent" });
        });
        previewStartPageButton.on("mouseleave", function () {
            previewStartPageButton.css({ "background-color": "transparent" });
        });
        previewCollectionsPageButton.on("mouseleave", function () {
            previewCollectionsPageButton.css({ "background-color": "transparent" });
        });
        previewArtworkViewerButton.on("mouseleave", function () {
            previewArtworkViewerButton.css({ "background-color": "transparent" });
        });
        bgImgInput.on("mouseleave", function () {
            bgImgInput.css({ "background-color": "transparent" });
        });
        newButton.on("mouseleave", function () {
            newButton.css({ "background-color": "transparent" });
        });
        
        TAG.Telemetry.register(saveButton,'click','general_set_save',function(tobj){
            tobj.mode = 'settingsView'
        });
        
        TAG.Telemetry.register(previewStartPageButton,'click','startpage_preview',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(previewCollectionsPageButton,'click','collectionspage_preview',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(previewArtworkViewerButton,'click','artworkviewer_preview',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#nav-General Settings'),'click','settings_general',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#nav-Collections'),'click','settings_collections',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#nav-Artworks'),'click','settings_artworks',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#nav-Associated Media'),'click','settings_asscmedia',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#nav-Tours'),'click','settings_tours',function(tobj){
            tobj.mode = 'settingsView'
        });

        TAG.Telemetry.register(root.find('#artworkEditorButtont'),'click','settings_to_artworkeditor',function(tobj){
            tobj.mode = 'settingsView'
        });

    }

    /**Changes idle timer stageOne duration from the customization settings
     * input.val() is in minutes, and idleDuration needs to be set in milliseconds
     * hence the conversion factor of 60000
     * @method saveIdleTimerDuration
     * @param {HTML Element} input      
     */
    function saveIdleTimerDuration(input) {
        idleDuration = parseInt(input.val())*60000;
    }

    /**Saves the splash screen settings
     * @method saveSplashScreen
     * @param {Object} inputs       information from setting inputs
     */
    function saveSplashScreen(inputs) {
        //pCL = displayLoadingSettings();
        //backButtonClicked && prepareNextView(false, null, null, "Saving...");
		//generalIsLoading = true;
        clearRight();
        prepareViewer(true);
        prepareNextView(false, null, null, "Saving...");

        /*var alpha = inputs.alphaInput.val()/100;
        var overlayColor = inputs.overlayColorInput.val();
        var name = inputs.nameInput.val();
        var loc = inputs.locInput.val();
        var info = inputs.infoInput.val().replace('/\n\r?/g', '<br />');
        var logoColor = inputs.logoColorInput.val();*/
        var bgImg = inputs.bgImgInput.val();
        /*var logo = inputs.logoInput.val();
        var backgroundColor = inputs.backgroundColorInput.val();
        var backgroundOpacity = inputs.backgroundOpacityInput.val();*/
        var primaryFontColor = inputs.primaryFontColorInput.val();
        var secondaryFontColor = inputs.secondaryFontColorInput.val();
        //var fontFamily = inputs.fontFamilyInput.val();
        //var baseFontSize = LADS.Util.getMaxFontSize('Test', 2, 100000000, 30, 0.1);
        var idleTimerDuration = inputs.idleTimerDurationInput.val() * 1000 * 60;
        
        //inputs.idleTimerDurationInput.val(idleTimerDuration);
        //TAG.Util.IdleTimer.TwoStageTimer().s1d = parseInt(idleTimerDuration);
        var options = {
            //Name: name,
            //OverlayColor: overlayColor,
            //OverlayTrans: alpha,
            //Location: loc,
            //Info: info,
            //IconColor: logoColor,
            //BackgroundColor: backgroundColor,
            //BackgroundOpacity: backgroundOpacity,
            PrimaryFontColor: primaryFontColor,
            SecondaryFontColor: secondaryFontColor,
            //FontFamily: fontFamily,
            //BaseFontSize: baseFontSize,
            IdleTimerDuration: idleTimerDuration
        };
        if (bgImg) { options.Background = bgImg; }
        //if (logo) options.Icon = logo;

        //Change the settings in the database
        TAG.Worktop.Database.changeMain(options, function () {
            //refreshSplashScreen();
            //generalIsLoading = false;
            //if (!(generalIsLoading || collectionsIsLoading ||
            //    artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don't continue if more sections are still loading - wait for them to finish
            //    backButtonClicked && backButtonClickHandler();
            //};
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.general.text]) {
                LADS.Worktop.Database.getMain();
                return;
            };
            LADS.Worktop.Database.getMain(function () {
                if (!(prevSelectedMiddleLabel && (prevSelectedMiddleLabel.text() === "Password Settings"))) {
                    loadGeneralView();
                };
            }, error(loadGeneralView), null);
            //hideLoading();
            //hideLoadingSettings(pCL);
        }, authError, conflict({ Name: 'Main' }, 'Update', loadGeneralView), error(loadGeneralView));
    }

    /**Set up the right side of the UI for the  password changer
     * @method loadPasswordScreen
     */
    function loadPasswordScreen() {
        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        prepareViewer(false, null, false);
        clearRight();

        var loading = createLabel('Loading...');
        var loadingSetting = createSetting('', loading);
        settingsContainer.append(loadingSetting);

        TAG.Worktop.Database.checkSetting('AllowChangePassword', function (val) {
            loadingSetting.remove();
            if (val.toLowerCase() === 'true') {
                var oldInput = createTextInput('', false);
                var newInput1 = createTextInput('', false);
                var newInput2 = createTextInput('', false);
                var msgLabel = createLabel('');

                newInput1.on('keyup', function () {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                });

                oldInput.attr('type', 'password');
                newInput1.attr('type', 'password');
                newInput2.attr('type', 'password');

                var old = createSetting('Current Password', oldInput);
                var new1 = createSetting('New Password', newInput1);
                var new2 = createSetting('Confirm New Password', newInput2);
                var msg = createSetting('', msgLabel);

                settingsContainer.append(old);
                settingsContainer.append(new1);
                settingsContainer.append(new2);
               

                //Hide or else unused div covers 'Old Password' line
                buttonContainer.css('display', 'none');

                var saveButton = createButton('Update Password', function () {
                    savePassword({
                        old: oldInput,         // Old password
                        new1: newInput1,       // New password
                        new2: newInput2,       // New password confirmation
                        msg: msgLabel,         // Message area
                    });
                });
                // Make the save button respond to enter
                saveButton.removeAttr('type');
                var save = createSetting('', saveButton);
                settingsContainer.append(save);
                settingsContainer.append(msg);
            } else {
                passwordChangeNotSupported();
            }
        });
    }

    /**Display label if password change not supported by server
     *@method passwordChangeNotSupported
     */
    function passwordChangeNotSupported() {
        var label = createLabel('');
        var setting = createSetting('Changing the password has been disabled by the server.  Contact the server administrator for more information', label);
        settingsContainer.append(setting);
    }

    /**Updates the new password
     * @method savePassword
     * @param {Object} inputs    keys for password change
     */
    function savePassword(inputs) {
        inputs.msg.text('Processing...');
        if (inputs.new1.val() !== inputs.new2.val()) {
            inputs.msg.text('New passwords do not match.');
        } else {
            TAG.Auth.changePassword(inputs.old.val(), inputs.new1.val(),
                function () {
                    inputs.msg.text('Password Saved.');
                    inputs.old.val('');
                    inputs.new1.val('');
                    inputs.new2.val('');
                },
                function (msg) {
                    if (msg) {
                        inputs.msg.html(msg);
                    } else {
                        inputs.msg.text('Incorrect Password.');
                    }
                },
                function () {
                    inputs.msg.text('There was an error contacting the server.');
                });
        }
    }

    // PREVIEWS OF SPLASH SCREEN, COLLECTIONS PAGE, ARTOWRK VIEWER FOR CUSTOMIZATION

    /**Preview splash screen
     * @method previewStartPage
     */
    function previewStartPage(primaryFontInput, secondaryFontInput) {
        // Load the start page, the callback adds it to the viewer when it's done loading
        var startPage = TAG.Layout.StartPage({ primaryFontColor: primaryFontInput.val(), secondaryFontColor: secondaryFontInput.val(), isPreview:true}, function (startPage) {
            if(prevSelectedSetting && prevSelectedSetting != nav[NAV_TEXT.general.text]) {
                return;
            }
            viewer.empty();
            viewer.append(startPage);
            preventClickthrough(viewer);
        });
        return startPage;
    }

    /**Preview collections page
     * @method previewCollectionsPage
     */
    function previewCollectionsPage(primaryFontInput, secondaryFontInput) {
    	var collectionsPage,
    		options,
    		croot;
    	options = {
    	    primaryFontColor: primaryFontInput.val(),
    	    secondaryFontColor: secondaryFontInput.val(),
    		previewing:true
    	}
    	collectionsPage = TAG.Layout.CollectionsPage(options);
    	$(collectionsPage).find("*").off();;
        croot = collectionsPage.getRoot();
        $(croot).css({ 'z-index': '1' });

        if(prevSelectedSetting && prevSelectedSetting != nav[NAV_TEXT.general.text]) {
            return;
        }
        viewer.empty();
        viewer.append(croot);
        preventClickthrough(viewer);
    }

    /**Preview artwork viewer
     * @method previewArtworkViewer
     */
    function previewArtworkViewer(primaryFontInput, secondaryFontInput) {
        var doq,
        	options,
        	artworkViewer,
        	aroot;

        TAG.Worktop.Database.getArtworks(function(result){
        	doq=result[0];
        	var i;
     		for (i=0;i<result.length;i++){
     			//set the preview doq to the first artwork (not video or tour)
     			if (!(result[i].Metadata.Medium === "Video")&& !(result[i].Type === "Empty")){
     				doq = result[i];
     				break;
     			}
     		}
        	options = { 
        		catalogState: {}, 
        		doq: doq, 
        		split: 'L', 
        		primaryFontColor: primaryFontInput.val(),
        		secondaryFontColor: secondaryFontInput.val(),
        		previewing: true,
        	}
        	artworkViewer = TAG.Layout.ArtworkViewer(options, viewer);
        	aroot = artworkViewer.getRoot();
        	$(aroot).css('z-index', '-1');
        	if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.general.text]) {
            	return;
        	}
        	viewer.empty();
        	
        	viewer.append(aroot);
        	// Don't allow the viewer to be clicked
        	preventClickthrough(viewer);
        	
        });      
    }

    // Collection Functions:

    /**Loads the collections view
     * @method loadExhibitionsView
     * @param {Object} id       id of middle label to start on
     */
    function loadExhibitionsView(id, matches) {

        inGeneralView = false;
        inCollectionsView = true;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;

        changesMade = false;

        var list;
        var cancel = false;
        currentIndex = 0;

        // Set the new button text to "New"
        prepareNextView(true, "New", createExhibition);
        clearRight();
        prepareViewer(true);

        //if (generalIsLoading || collectionsIsLoading ||
        //         artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
        //    hideLoading();
        //    hideLoadingSettings(pCL);
        //};

        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        //collectionsIsLoading && showLoading();
        //(saveArray.indexOf(previousIdentifier) < 0) && function () { hideLoading(); hideLoadingSettings(pCL); };

        if (typeof matches !== "undefined") {
            list = matches;
            displayLabels();
        } else {
            // Make an async call to get the list of exhibitions
            TAG.Worktop.Database.getExhibitions(function (result) {
                if (cancel) return;
                sortAZ(result);
                currentList = result;
                initSearch();
                list = result;
                displayLabels();
            });
        }
        

        function displayLabels() {
            $.each(list, function (i, val) {
                if (cancel) {
                    return;
                }
                // Add each label as a separate function in the queue so they don't lock up the UI
                middleQueue.add(function () {
                    if (cancel) {
                        return;
                    }
                    if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedMiddleLabel &&
                        ((id && val.Identifier === id) || (!id && i === 0))) {

                        // Select the first one or the specified id
                        middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, null, function () {
                            previousIdentifier = val.Identifier;
                            if (cancelLastView) cancelLastView();
                            loadExhibition(val);
                            currentIndex = i;
                        }, val.Identifier), true));

                        // Scroll to the selected label if the user hasn't already scrolled somewhere
                        if (middleLabelContainer.scrollTop() === 0 && label.offset().top - middleLabelContainer.height() > 0) {
                            middleLabelContainer.animate({
                                scrollTop: (label.offset().top - middleLabelContainer.height() / 2)
                            }, 1000);
                        }
                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        currentIndex = i;
                        if (cancelLastView) cancelLastView();
                        loadExhibition(val);
                    } else {
                        middleLoading.before(label = createMiddleLabel(val.Name, null, function () {
                            //if (changesHaveBeenMade) {
                            //    //saveArray.push(previousIdentifier);
                            //    //currentMetadataHandler && saveQueue.add(currentMetadataHandler());
                            //    //changesHaveBeenMade = false;
                            //}
                            if (cancelLastView) cancelLastView();
                            loadExhibition(val);
                            previousIdentifier = val.Identifier;
                            currentIndex = i;
                        }, val.Identifier));
                        //prevSelectedMiddleLabel = label;
                        //currentSelected = prevSelectedMiddleLabel;
                    }

                });
            });
            // Hide the loading label when we're done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        }

        cancelLastSetting = function () { cancel = true; };
    }

    //CLICK HANDLER FOR SORT OPTIONS
    function clickCallback(sortDiv) {
        return function () {
            var buttonId = sortDiv.text().toLowerCase() + "Button",
                sortButton;

            if (sortDiv.attr("setSort") === "true" || sortDiv.attr("setSort") === true) {
                if (sortOptionsCount>0){
                    sortOptionsCount--;
                }
                
                sortDiv.attr("setSort", false);
                sortDiv.css({
                    "background-color": "black",
                    "background": "transparent",
                    "color": "black"
                });
                sortOptionsObj[sortDiv.text()] = false;
                //TODO:set the sort tag to white in previewer

                $("[id='"+buttonId+"']").hide();

                if (sortDiv.text() === "Date") {
                    timelineShown = false;
                    $("#dateButton").hide();
                    $("#showTimelineBttn").css('background-color', '');
                    $("#hideTimelineBttn").css('background-color', 'white');
                    $("#showTimelineBttn").attr("disabled","true");
                }
            } else {
                if (sortOptionsCount < 4) {
                    sortOptionsCount++;
                    sortDiv.attr("setSort", true);
                    sortDiv.css({
                        "background-color": "white"
                    });

                    //if the button already exists
                    if ($("[id='" + buttonId + "']")[0]) {
                        $("[id='" + buttonId + "']").show()
                            .css({"color":TAG.Util.UI.dimColor( "#" + TAG.Worktop.Database.getSecondaryFontColor(), 1.7)})
                    } else { //or if you're making it (sort option was origionally deselected)
                        sortButton = $(document.createElement('div'));
                        //Because stored on server as "Tour" but should be displayed as "Tours"
                        //sortDiv.text()==="Tour" ? text = "Tours" : text = sortDiv.text();
                        sortButton.addClass('secondaryFont');
                        sortButton.addClass('rowButton')
                                    .text(sortDiv.text())
                                    .attr('id', buttonId)
                                    //TODO: make sortButton have the same class as the same ones that are created in the collections page
                                    .css({
                                        "cursor": "pointer",
                                        "float": "left",
                                        "font-size": "92.5%",
                                        "margin-top": "0.475%",
                                        "margin-right": "2%",
                                        "height": "100%",
                                        "color":TAG.Util.UI.dimColor( "#" + TAG.Worktop.Database.getSecondaryFontColor(), 1.7)
                                    });
                        $("#buttonRow").append(sortButton);
                    }

                    if (sortDiv.text() === "Date") {
                        $("#showTimelineBttn").removeAttr('disabled');
                        $("#dateButton").show();
                    }
                    sortOptionsObj[sortDiv.text()] = true;
                }
                
            }
        };
    };

    //CREATE SORT OPTIONS DIV
    function createSortOptions(sortOptionsObj) {
        sortOptionsCount = 0;
        var sortOptionsDiv = $(document.createElement("div"))
            .css({
                'width': "50%",
                "height": "auto",
                'float': 'right',
                'margin-right': '3%',
                "overflow": "hidden",
                "overflow-x": "hidden"
            });

        var sortObj, sortDiv;
        for (sortObj in sortOptionsObj) {
            if ((sortOptionsObj.hasOwnProperty(sortObj)) && !(sortObj === '')) {
                /*if (sortObj === "Date" && sortOptionsObj[sortObj] === false) {
                    timelineShown = false;

                    $("#showTimelineBttn").css('background-color', '');
                    $("#hideTimelineBttn").css('background-color', 'white');

                    $("#showTimelineBttn").attr("disabled","true");
                }*/
                var sortDiv = $(document.createElement("div"))
                    .text(sortObj)
                    .addClass("sortOptionDiv");
                var setSort = sortOptionsObj[sortObj];
                sortDiv.attr("setSort", setSort);
                if (setSort === true) {
                    sortOptionsCount++;
                    sortDiv.css({
                        "background-color": "white",
                        "border": "1px solid black"
                    });
                }
                sortDiv.click(clickCallback(sortDiv));
                sortOptionsDiv.append(sortDiv);
            }
        }
        
        return sortOptionsDiv;
    }    

    /**Editing collections by adding/removing artworks
     * @method manageCollection
     * @param {doq} exhibition      the current collection to be edited
     */
    function manageCollection(exhibition) {
        if (!exhibition) {
            return;
        }
        TAG.Util.UI.createAssociationPicker(root, "Add and Remove Artworks in this Collection",
                { comp: exhibition, type: 'exhib' },
                'exhib', [{
                    name: 'All Artworks',
                    getObjs: TAG.Worktop.Database.getArtworksAndTours,
                }, {
                    name: 'Artworks in this Collection',
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }], {
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }, function () {
                    prepareNextView(true, "New", createExhibition);
                    clearRight();
                    prepareViewer(true);
                    loadExhibitionsView(exhibition.Identifier);
                });
     }



    /**Set up the right side for a collection
     * @method loadExhibition
     * @param {Object} exhibition   exhibition to load
     */
    function loadExhibition(exhibition) {
        //$(document).off();
        deleteType = deleteExhibition;
        toDelete = exhibition;
        var cancelView = false;
        clearRight();
        viewer.empty();
        viewer.css('background', 'black');
        var progressCircCSS = {
            'position': 'absolute',
            'left': '5%',
            'z-index': '50',
            'height': 'auto',
            'width': '10%',
            'top': '20%',
        };
        var vert = viewer.height() / 2;
        var horz = viewer.width() / 2;

        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, horz, vert, true);

        // Create inputs
        var privateState;
        if (exhibition.Metadata.Private) {
            privateState = (/^true$/i).test(exhibition.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton('Unpublish', function () {
            //(!privateState) && function () { changesHaveBeenMade = true;}();
            privateState = true;
            privateInput.css('background-color', 'white');
            publicInput.css('background-color', '');
        }, {
            'min-height': '0px',
            'margin-right': '4%',
            'width': '48%',
            'height':'35px'
        });
        privateInput.attr('class', 'settingButton');
        var publicInput = createButton('Publish', function () {
            //(privateState) && function () { changesHaveBeenMade = true; }();
            privateState = false;
            publicInput.css('background-color', 'white');
            privateInput.css('background-color', '');
        }, {
            'min-height': '0px',
            'width': '48%',
            'height':'35px'
        });
        publicInput.attr('class', 'settingButton');
        if (privateState) {
            privateInput.css('background-color', 'white');
        } else {
            publicInput.css('background-color', 'white');
        }
        /*var pubPrivDiv = $(document.createElement('div'));
        pubPrivDiv.append(privateInput).append(publicInput);*/

        // local visibility
        var localVisibility = LADS.Util.localVisibility(exhibition.Identifier);
        var invisibilityInput = createButton('Hide on This Machine', function () {
            //if (localVisibility) { changesHaveBeenMade = true; };
            localVisibility = false;
            invisibilityInput.css('background-color', 'white');
            visibilityInput.css('background-color', '');
        }, {
            'min-height': '0px',
            'margin-right': '4%',
            'width': '48%',
            'height':'35px'
        });
        var visibilityInput = createButton('Show on This Machine', function () {
            //if (!localVisibility) { changesHaveBeenMade = true; };
            localVisibility = true;
            visibilityInput.css('background-color', 'white');
            invisibilityInput.css('background-color', '');
        }, {
            'min-height': '0px',
            'width': '48%',
            'height': '35px'
        });
        if (localVisibility) {
            visibilityInput.css('background-color', 'white');
        } else {
            invisibilityInput.css('background-color', 'white');
        }
        /*var visDiv = $(document.createElement('div'));
        visDiv.append(invisibilityInput).append(visibilityInput);*/

        //TO-DO: add in on server side from TAG.Worktop.Database.js changeExhibition() 
        var assocMediaShown;
        if (exhibition.Metadata.AssocMediaView === "true" || exhibition.Metadata.AssocMediaView === "false") {
            exhibition.Metadata.AssocMediaView === "true" ? assocMediaShown = true: assocMediaShown = false;
        } else {
            //backwards compatibility
            assocMediaShown = false;
        }
        var showAssocMedia = createButton('Show', function () {
            //(!assocMediaShown) && function () { changesHaveBeenMade = true; }();
            assocMediaShown = true;
            showAssocMedia.css({'background-color':'white'});
            hideAssocMedia.css({'background-color':''});
            $('#toggleRow').css('display','block');
        }, {
            'min-height': '0px',
            'margin-right': '4%',
            'width': '48%',
            'height':'35px'
        });
        showAssocMedia.attr('class','settingButton');
        var hideAssocMedia = createButton('Hide', function () {
            //(assocMediaShown) && function () { changesHaveBeenMade = true; }();
            assocMediaShown = false;
            hideAssocMedia.css('background-color','white');
            showAssocMedia.css('background-color','');
            $('#toggleRow').css('display','none');
            }, {
            'min-height': '0px',
            'width': '48%',
             'height': '35px'
        });
        hideAssocMedia.attr('class','settingButton');
        if (assocMediaShown){
            showAssocMedia.css('background-color','white');
        }else{
            hideAssocMedia.css('background-color','white');
        }
        /*var timelineOptionsDiv = $(document.createElement('div'));
        timelineOptionsDiv.append(showTimeline).append(hideTimeline);*/

        
        if (exhibition.Metadata.Timeline === "true" || exhibition.Metadata.Timeline === "false") {
            exhibition.Metadata.Timeline === "true" ? timelineShown = true: timelineShown = false;
        } else {
            //backwards compatibility
            timelineShown = true;
        }
        // use #toggleRow
        /*
        $('#toggleRow').css({
            'display': 'none',
            'min-height': '0px',
            'width': '48%',
             'height': '35px'
        });
        */
        var showTimeline = createButton('Show', function () {
            //(!timelineShown) && function () { changesHaveBeenMade = true; }();
            timelineShown = true;
            showTimeline.css('background-color', 'white');
            hideTimeline.css('background-color','');
            if ($('#timelineArea').children().length > 0) {
                $('#timelineArea').css('display', 'block');
                $('#bottomContainer').css({
                    'height': '69%',
                    'top': '25%'
                });
            }
            //$('#dateButton') &&
            //$('#yearButton') &&
        }, {
            'min-height': '0px',
            'margin-right': '4%',
            'width':'48%',
            'padding-left': '10px',
            'padding-right': '10px',
            'height': '35px'
        });
        showTimeline.attr("id","showTimelineBttn");
        showTimeline.attr('class','settingButton');
        var hideTimeline = createButton('Hide', function () {
            //(timelineShown) && function () { changesHaveBeenMade = true; }();
            timelineShown = false;
            hideTimeline.css('background-color','white');
            showTimeline.css('background-color','');
            $('#timelineArea').css('display','none');
            $('#bottomContainer').css({
                'height': '85%',
                'top':'15%'
               });
            //$('#dateButton') &&
            //$('#yearButton') &&
            }, {
                'min-height': '0px',
                'width': '48%',
                'height': '35px'
            });

        hideTimeline.attr("id","hideTimelineBttn");
        hideTimeline.attr('class','settingButton');
        if (timelineShown){
            showTimeline.css('background-color','white');
        }else{
            hideTimeline.css('background-color','white');
        }



        var privateSetting;
        var localVisibilitySetting;
        var name;
        var desc;
        var bg;
        var sortDropDown = null;
        var idLabel;
        var timeline;
        var nameInput;
        var descInput;
        var bgInput;
        var assocMedia;
        var sortOptions = null;
        var curSortOptions = JSON.parse(exhibition.Metadata.SortOptions || "{}" );
        var key;
        sortOptionsObj = {};
        if (curSortOptions.Title === false) {
            sortOptionsObj.Title = false;
        } else {
            sortOptionsObj.Title = true;
        }
        if (curSortOptions.Date === false) {
            sortOptionsObj.Date = false;
        } else {
            sortOptionsObj.Date = true;
        }
        if (curSortOptions.Artist === false) {
            sortOptionsObj.Artist = false;
        } else {
            sortOptionsObj.Artist = true;
        }


        TAG.Worktop.Database.getArtworksIn(exhibition.Identifier, function (artworks) {
            if (cancelView) return;
            for (var i = 0; i < artworks.length; i++) {
                if (artworks[i].Extension === "tour" || (artworks[i].Type === "Empty" && artworks[i].Metadata.ContentType !== "Artwork" && artworks[i].Metadata.Type !== "Image" && artworks[i].Metadata.ContentType !== "VideoArtwork" && artworks[i].Metadata.ContentType !== "iframe")) {
                    sortOptionsObj["Tours"] = curSortOptions["Tours"] || false;
                } else {
                    var infoFields = artworks[i].Metadata.InfoFields;
                    for (key in infoFields) {
                        var val = curSortOptions[key];
                        if (val===null) {
                            sortOptionsObj[key] = false;
                        } else {
                            sortOptionsObj[key] = val;
                        }
                    }
                }
            }
            if (sortOptionsObj && sortOptionsObj != {}) {
                sortDropDown = createSortOptions(sortOptionsObj);
            }
            createCollectionSettings();
        }, authError, conflict(exhibition, "Update", loadExhibitionsView), error(loadExhibitionsView));

        function createCollectionSettings() {
            if (cancelView) return;
            prepareViewer(true);
            clearRight();
            // Set the viewer to exhibition view (see function below)
            exhibitionView(exhibition);
            var pubPrivDiv = $(document.createElement('div'));
            pubPrivDiv.append(privateInput).append(publicInput);
            privateInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            publicInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            var visDiv = $(document.createElement('div'));
            visDiv.append(invisibilityInput).append(visibilityInput);

            invisibilityInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            visibilityInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            var timelineOptionsDiv = $(document.createElement('div'));
            timelineOptionsDiv.append(showTimeline).append(hideTimeline);

            showTimeline.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            hideTimeline.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            var assocMediaOptionsDiv = $(document.createElement('div'));
            assocMediaOptionsDiv.append(showAssocMedia).append(hideAssocMedia);

            showAssocMedia.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            hideAssocMedia.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            nameInput = createTextInput(TAG.Util.htmlEntityDecode(exhibition.Name), 'Title', 40);
            descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(exhibition.Metadata.Description), false, 2000);
            bgInput = createButton('Select...', function () {
                //changesHaveBeenMade = true;                                                   
                uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                    var url = urls[0];
                    bgInput.val(url);
                    $('#bgimage').css({
                        'background-image': 'url("' + TAG.Worktop.Database.fixPath(url) + '")',
                        'background-size': 'cover',
                    });
                });
            });

            nameInput.focus(function () {
                if (nameInput.val() === 'Collection')
                    nameInput.select();
            });
            nameInput.keyup(function (event) {
                event.preventDefault();
                event.stopPropagation();
                if (event.which === 13) {                   
                    saveButton.click();
                } else {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                }
                $('.collection-title').text(nameInput.val());
                
            });
            descInput.focus(function () {
                if (descInput.val() === 'Description')
                    descInput.select();
            });
            descInput.keyup(function () {
                $("#collectionDescription").text(descInput.val());
                var infoDiv = $("#infoDiv"),
                    titleDiv = $("#tileDiv");
                if (descInput.val() === "") {
                    infoDiv.css("width", "0%");
                    titleDiv.css({ 'margin-left': '2%' });
                } else {
                    infoDiv.css("width", "25%");
                    titleDiv.css({ 'margin-left': '0%' });
                }
                titleDiv.css({ 'left': infoDiv.width() });
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });
            // Handle Changes
            onChangeUpdateText(nameInput, '#exhibition-title', 40);
            onChangeUpdateText(descInput, '#description-text', 1790);

            localVisibilitySetting = createSetting('Visibility on Machine', visDiv);
            privateSetting = createSetting('Publish Setting', pubPrivDiv);
            name = createSetting('Title', nameInput);
            desc = createSetting('Description', descInput);
            bg = createSetting('Background Image', bgInput);
            timeline = createSetting('Timeline Setting', timelineOptionsDiv);
            assocMedia = createSetting('Associated Media Timeline Setting', assocMediaOptionsDiv);

            if (sortDropDown) {
                sortOptions = createSetting('Sort Options', sortDropDown);
                sortDropDown.click(function () {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                });
            }

            //$('.settingsViewTextarea').css({
            //    'resize': 'vertical',
            //    'height':'60px'
            //});

            settingsContainer.append(privateSetting);
            settingsContainer.append(localVisibilitySetting);
            settingsContainer.append(name);
            settingsContainer.append(desc);
            settingsContainer.append(bg);
            settingsContainer.append(timeline);
            settingsContainer.append(assocMedia);
            if (sortOptions) {
                settingsContainer.append(sortOptions);
            }

            //Automatically save changes
            //currentMetadataHandler = function () {
            //    if (nameInput.val() === undefined || nameInput.val() === "") {
            //        nameInput.val("Untitled Collection");
            //    }
            //    LADS.Util.localVisibility(exhibition.Identifier, { visible: localVisibility });
            //    saveExhibition(exhibition, {
            //        privateInput: privateState,
            //        nameInput: nameInput,
            //        descInput: descInput,
            //        bgInput: bgInput,
            //        sortOptions: sortDropDown,
            //        timelineInput: timelineShown
            //    });
            //};

            // Buttons
            var saveButton = createButton('Save', function () {
                if (nameInput.val() === undefined || nameInput.val() === "") {
                    nameInput.val("Untitled Collection");
                }
                LADS.Util.localVisibility(exhibition.Identifier, { visible: localVisibility });
                saveExhibition(exhibition, {
                    privateInput: privateState,  //default set unpublished
                    nameInput: nameInput,        //Collection name
                    descInput: descInput,        //Collection description
                    bgInput: bgInput,            //Collection background image
                    sortOptions: sortDropDown,
                    timelineInput: timelineShown,
                    assocMediaInput: assocMediaShown
                });
            }, {
                'margin-right': '3%',
                'margin-top': '1%',
                'margin-bottom': '1%',
                'margin-left': '.5%',
                'float': 'right',
            }, true);

            var deleteButton = createButton('Delete', function () {
                deleteExhibition(exhibition);
            }, {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0',
                'margin-bottom': '3%',
            });

            var catalogNext = true;
            // Creates the button to toggle between views
            var switchViewButton = createButton('Preview Catalog', function () {
                viewer.empty();
                if (catalogNext) {
                    // If there is no art the program crashes when entering catalog mode
                    // Show a message and return if thats the case (would prefer not having
                    // to request all the artwork)
                    LADS.Worktop.Database.getArtworksIn(exhibition.Identifier, function (artworks) {
                        if (cancelView) return;
                        if (!artworks || !artworks[0]) {
                            var messageBox = LADS.Util.UI.popUpMessage(null, "Cannot view in catalog mode because there is no artwork in this exhibit.", null, true);
                            root.append(messageBox);
                            $(messageBox).show();
                            exhibitionView();
                        } else {
                            switchViewButton.text('Preview Collection');
                            catalogView();
                            catalogNext = !catalogNext;
                        }
                    });

                    return;
                } else {
                    switchViewButton.text('Preview Catalog');
                    exhibitionView();
                }
                catalogNext = !catalogNext;
            }, {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });

            var artPickerButton = createButton('Manage', function () {
                TAG.Util.UI.createAssociationPicker(root, "Add and Remove Artworks in this Collection",
                    { comp: exhibition, type: 'exhib' },
                    'exhib', [{
                        name: 'All Artworks',
                        getObjs: TAG.Worktop.Database.getArtworksAndTours,
                    }, {
                        name: 'Artworks in this Collection',
                        getObjs: TAG.Worktop.Database.getArtworksIn,
                        args: [exhibition.Identifier]
                    }], {
                        getObjs: TAG.Worktop.Database.getArtworksIn,
                        args: [exhibition.Identifier]
                    }, function () {
                        prepareNextView(true, "New", createExhibition);
                        clearRight();
                        prepareViewer(true);
                        loadExhibitionsView(exhibition.Identifier);
                    });

            }, {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });

            artPickerButton.on("mousedown", function () {
                artPickerButton.css({ "background-color": "white"});
            });

            leftButton = artPickerButton;

            saveButton.on("mousedown", function () {
                if (!saveButton.attr("disabled")) {
                    saveButton.css({ "background-color": "white" });
                }
            });
            artPickerButton.on("mousedown", function () {
                artPickerButton.css({ "background-color": "white" });
            });
            deleteButton.on("mousedown", function () {
                deleteButton.css({ "background-color": "white" });
            });
            saveButton.on("mouseleave", function () {
                if (!saveButton.attr("disabled")) {
                    saveButton.css({ "background-color": "transparent" });
                }
            });
            artPickerButton.on("mouseleave", function () {
                artPickerButton.css({ "background-color": "transparent" });
            });
            deleteButton.on("mouseleave", function () {
                deleteButton.css({ "background-color": "transparent" });
            });
            newButton.on("mouseleave", function () {
                newButton.css({ "background-color": "transparent" });
            });
            

            // Sets the viewer to catalog view
            function catalogView() {
                rightQueue.add(function () {
                    if (cancelView) return;
                    var catalog;
                    if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                        return;
                    }
                    LADS.Layout.Catalog(exhibition, null, function (catalog) {
                        viewer.append(catalog.getRoot());
                        catalog.loadInteraction();
                        preventClickthrough(viewer);

                    });
                });
            }

            /**Helper method to set the viewer to exhibition view
             * @method exhibitionView
             * @param {Object} exhibition    exhibition to load
             */
            function exhibitionView(exhibition) {
                rightQueue.add(function () {
                    if (cancelView) return;
                    var options = {
                        backCollection: exhibition,
                        previewing: true
                    };
                    var exhibView = new TAG.Layout.CollectionsPage(options);
                    var exroot = exhibView.getRoot();
                    $(exroot).css('z-index', '-1'); // otherwise, you can use the search box and sorting tabs!
                    viewer.append(exroot);
                    preventClickthrough(viewer);
                });
            }

            

            buttonContainer.append(artPickerButton).append(deleteButton).append(saveButton);
            TAG.Telemetry.register(artPickerButton,'click','art-selected_collections',function(tobj){
                tobj.mode = 'settingsView';
            });

            TAG.Telemetry.register(deleteButton,'click','art-deleted_collections',function(tobj){
                tobj.mode = 'settingsView';
            });

             TAG.Telemetry.register(saveButton,'click','art-saved_collections',function(tobj){
                 tobj.mode = 'settingsView';
            });
        }
        cancelLastView = function () {
            cancelView = true;
        };
    }

    /**Create an exhibition
     * @method createExhibition
     */
    function createExhibition() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createExhibition(null, function (newDoq) {
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                return;
            }
            if (!newDoq) { // Shouldn't happen!
                // TODO: Error Message
                loadExhibitionsView();
                return;
            }
            loadExhibitionsView(newDoq.Identifier);
        }, authError, error(loadExhibitionsView), true);
    }

    /** Save a collection
     * @method saveExhibition
     * @param {Object} exhibition   collection to save
     * @inputs {Object} inputs      keys from input fields
     */
    function saveExhibition(exhibition, inputs) {
        //pCL = displayLoadingSettings();
        //prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);
        prepareNextView(false, null, null, "Saving...");

        //To-Do add in encoding here:
        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();
        var bg = inputs.bgInput.val();
        var priv = inputs.privateInput;
        var timeline = inputs.timelineInput;
        var assocMedia = inputs.assocMediaInput;

        /*var sortOptionChanges = {};
        if (inputs.sortOptions) {
            for (var i = 0; i < inputs.sortOptions[0].children.length; i++) {
                var option = $(inputs.sortOptions[0].children[i]);
                var setSort = option.attr("setSort");
                if (i > 2) {
                    if (option.text() === "Tour" && i == 3) {
                        sortOptionChanges[option.text()] = setSort;
                    } else {
                        sortOptionChanges["?" + option.text()] = setSort;
                    }
                } else {
                    sortOptionChanges[option.text()] = setSort;
                }
            }
        }*/
        var options = {
            Name: name,
            Private: priv,
            Description: desc,
            SortOptions: JSON.stringify(sortOptionsObj),
            Timeline: timeline,
            AssocMediaView: assocMedia
        }

        if (bg){
            options.Background = bg;
        }

        TAG.Worktop.Database.changeExhibition(exhibition.Identifier, options, function () {
            //refreshExhibition(exhibition);
            //collectionsIsLoading = false;
            //if (backButtonClicked && !(generalIsLoading || collectionsIsLoading ||
            //    artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don't continue if more sections are still loading - wait for them to finish
            //    backButtonClickHandler();
            //};
            //if (!backButtonClicked && (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.exhib.text])) {
            //    loadExhibitionsView(exhibition.Identifier); //eventually don't want this here? - reloads everything
            //};
            //hideLoading();
            //hideLoadingSettings(pCL);
            //saveArray.splice(saveArray.indexOf(exhibition.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                LADS.Worktop.Database.getExhibitions();
                return;
            }
            if (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.exhib.text]) {
                loadExhibitionsView(exhibition.Identifier);
                return;
            }
        }, authError, conflict(exhibition, "Update", loadExhibitionsView), error(loadExhibitionsView));
    }

    /**Delete a collection
     * @method deleteExhibition
     * @param {Object} exhibition     collection to delete
     */
    function deleteExhibition(exhibition) {

        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the exhibition
            TAG.Worktop.Database.deleteDoq(exhibition.Identifier, function () {
                if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                    return;
                }
                loadExhibitionsView();
            }, authError, conflict(exhibition, "Delete", loadExhibitionsView), error(loadExhibitionsView));
        }, "Are you sure you want to delete " + exhibition.Name + "?", "Delete", true, function() { $(confirmationBox).hide(); });
        root.append(confirmationBox);
        $(confirmationBox).show();
        TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
    }


    // Tour Functions:

    /**Load the tour view
     * @method loadTourView
     * @param {Object} id   id of middle label to start on
     */
    function loadTourView(id, matches) {

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = true;
        inFeedbackView = false;

        changesMade = false;

        var list;
        currentIndex = 0;

        prepareNextView(true, "New", createTour);
        clearRight();
        prepareViewer(true);
        var cancel = false;

        //if (generalIsLoading || collectionsIsLoading ||
        //        artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
        //    hideLoading();
        //    hideLoadingSettings(pCL);
        //};
        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        //toursIsLoading && showLoading();
        //(saveArray.indexOf(previousIdentifier) < 0) && function () { hideLoading(); hideLoadingSettings(pCL); };


        if (typeof matches !== "undefined") {
            list = matches;
            displayLabels();
        } else {
            // Make an async call to get tours
            TAG.Worktop.Database.getTours(function (result) {
                if (cancel) return;
                sortAZ(result);
                currentList = result;
                initSearch();
                list = result;
                displayLabels();

            });
        }

        function displayLabels() {
            $.each(list, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn't lock up
                middleQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedMiddleLabel &&
                        ((id && val.Identifier === id) || (!id && i === 0))) {
                        // Select the first one
                        middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, null, function () {
                            previousIdentifier = val.Identifier;
                            loadTour(val);
                            currentIndex = i;
                        }, val.Identifier, false, function () {
                            editTour(val);
                        }), true));

                        // Scroll to the selected label if the user hasn't already scrolled somewhere
                        if (middleLabelContainer.scrollTop() === 0 && label.offset().top - middleLabelContainer.height() > 0) {
                            middleLabelContainer.animate({
                                scrollTop: (label.offset().top - middleLabelContainer.height() / 2)
                            }, 1000);
                        }

                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        currentIndex = i;
                        loadTour(val);
                    } else {

                        middleLoading.before(label = createMiddleLabel(val.Name, null, function () {
                            //if (changesHaveBeenMade) {
                            //    //saveArray.push(previousIdentifier);
                            //    //currentMetadataHandler && saveQueue.add(currentMetadataHandler());
                            //    //changesHaveBeenMade = false;
                            //}
                            loadTour(val);
                            previousIdentifier = val.Identifier;
                            currentIndex = i;
                        }, val.Identifier, false, function () {
                            editTour(val);

                        }));
                        //prevSelectedMiddleLabel = label;
                        //currentSelected = prevSelectedMiddleLabel;
                    }

                });
            });
            // Hide the loading label when we're done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        }

        cancelLastSetting = function () { cancel = true; };
    }

    /**Load a tour to the right side
     * @method loadTour
     * @param {Object} tour     tour to load
     */
    function loadTour(tour) {
        //$(document).off();
        prepareViewer(true);
        clearRight();
        deleteType = deleteTour;
        toDelete = tour;

        // Create an img element just to load the image
        var img = $(document.createElement('img'));
        img.attr('src', TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail));

        // Create a progress circle
        var progressCircCSS = {
            'position': 'absolute',
            'left': '30%',
            'top': '22%',
            'z-index': '50',
            'height': viewer.height() / 2 + 'px',
            'width': 'auto'
        };

        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, '0px', '0px', false);
        var selectedLabel = prevSelectedMiddleLabel;
        img.load(function () {
            // If the selection has changed since we started loading return
            if (prevSelectedMiddleLabel && prevSelectedMiddleLabel.text() !== TAG.Util.htmlEntityDecode(tour.Name)) {
                TAG.Util.removeProgressCircle(circle);
                return;
            }
            TAG.Util.removeProgressCircle(circle);
            // Set the image as a background image, centered and contained
            viewer.css('background', 'black url(' + TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail) + ') no-repeat center / contain');
        });

        if (tour.Metadata.Thumbnail === "/Images/default.jpg") {
            TAG.Util.removeProgressCircle(circle);
        }
        // Create inputs
        // inputs
        var privateState;
        if (tour.Metadata.Private) {
            privateState = (/^true$/i).test(tour.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton('Unpublish', function () {
            //(!privateState) && function () { changesHaveBeenMade = true;}();
            privateState = true;
            privateInput.css('background-color', 'white');
            publicInput.css('background-color', '');
        }, {
            //'min-height': '0px',
            'margin-right': '4%',
            'width': '48%',
            'height':'35px'
        });
        privateInput.attr('class', 'settingButton');
        
        privateInput.click(function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });

        var publicInput = createButton('Publish', function () {
            //(privateState) && function () { changesHaveBeenMade = true; }();
            privateState = false;
            publicInput.css('background-color', 'white');
            privateInput.css('background-color', '');
        }, {
            //'min-height': '0px',
            'width': '48%',
            'height':'35px'
        });

        publicInput.click(function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });

        publicInput.attr('class','settingButton');
        if (privateState) {
            privateInput.css('background-color', 'white');
        } else {
            publicInput.css('background-color', 'white');
        }
        var pubPrivDiv = $(document.createElement('div'));
        pubPrivDiv.append(privateInput).append(publicInput);

        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(tour.Name), "Tour Title", 120);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(tour.Metadata.Description).replace(/\n/g,'<br />') || "", false, 2000);
        var tourIdInput = createTextInput(tour.Identifier, 'Tour ID (read-only)', 80, false, true);
        nameInput.focus(function () {
            if (nameInput.val() === 'Untitled Tour')
                nameInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === 'Tour Description')
                descInput.select();
        });

        // on change behavior
        onChangeUpdateText(descInput, null, 1500); // What should max length be?
        onChangeUpdateText(nameInput, null, 1500);

        var privateSetting = createSetting('Publish Setting', pubPrivDiv);
        var name = createSetting('Name', nameInput);
        var desc = createSetting('Description', descInput);
        var tourIdLabel = createSetting('ID (read-only)', tourIdInput);

        settingsContainer.append(privateSetting);
        settingsContainer.append(name);
        settingsContainer.append(desc);
        settingsContainer.append(tourIdLabel);

        nameInput.on('keyup', function (event) {
            if (event.which === 13) {
                saveButton.click();
            } else {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            }
        });

        descInput.on('keyup', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });

        //Automatically save changes
        //currentMetadataHandler = function () {
        //    if (nameInput.val() === undefined || nameInput.val() === "") {
        //        nameInput.val("Untitled Tour");
        //    }
        //    saveTour(tour, {
        //        privateInput: privateState,
        //        nameInput: nameInput,
        //        descInput: descInput,
        //    });
        //};

        // Create buttons
        var editButton = createButton('Edit',
            function () { editTour(tour); },
            {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });
        var deleteButton = createButton('Delete',
            function () { deleteTour(tour); },
            {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });
        var duplicateButton = createButton('Duplicate',
            function () {
                duplicateTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            },
            {
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });
        var saveButton = createButton('Save',
            function () {
                if (nameInput.val() === undefined || nameInput.val() === "") {
                    nameInput.val("Untitled Tour");
                }
                saveTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            }, {
                'margin-right': '3%',
                'margin-top': '1%',
                'margin-bottom': '1%',
                'margin-left': '.5%',
                'float': 'right'
            }, true);

        buttonContainer.append(editButton).append(duplicateButton).append(deleteButton).append(saveButton);

        saveButton.on("mousedown", function () {
            if (!saveButton.attr("disabled")) {
                saveButton.css({ "background-color": "white" });
            }
        });
        duplicateButton.on("mousedown", function () {
            duplicateButton.css({ "background-color": "white" });
        });
        deleteButton.on("mousedown", function () {
            deleteButton.css({ "background-color": "white" });
        });
        editButton.on("mousedown", function () {
            editButton.css({ "background-color": "white" });
        });
        saveButton.on("mouseleave", function () {
            if (!saveButton.attr("disabled")) {
                saveButton.css({ "background-color": "transparent" });
            }
        });
        duplicateButton.on("mouseleave", function () {
            duplicateButton.css({ "background-color": "transparent" });
        });
        deleteButton.on("mouseleave", function () {
            deleteButton.css({ "background-color": "transparent" });
        });
        editButton.on("mouseleave", function () {
            editButton.css({ "background-color": "transparent" });
        });
        newButton.on("mouseleave", function () {
            newButton.css({ "background-color": "transparent" });
        });
        

         TAG.Telemetry.register(editButton,'click','tour_edit',function(tobj){
             tobj.mode = 'settingsView';
            });

          TAG.Telemetry.register(duplicateButton,'click','tour_duplicate',function(tobj){
              tobj.mode = 'settingsView';
            });

           TAG.Telemetry.register(deleteButton,'click','tour_delete',function(tobj){
                tobj.mode = 'settingsView';
            });

            TAG.Telemetry.register(saveButton,'click','tour_save',function(tobj){
                tobj.mode = 'settingsView';
            });
    }

    /** Create a tour
     * @method createTour
     */
    function createTour() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createTour(null, function (newDoq) {
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            if (!newDoq) {
                // TODO: ERROR
                loadTourView();
                return;
            }
            loadTourView(newDoq.Identifier);
        }, authError, error(loadTourView), true);
    }

    /**Edit a tour
     * @method editTour
     * @param {Object} tour     tour to edit
     */
    function editTour(tour) {
        if (!tour) {
            return;
        }
        // Overlay doesn't spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay('Loading Tour...', 1);
        middleQueue.clear();
        rightQueue.clear();
        setTimeout(function () {
            var toureditor = new TAG.Layout.TourAuthoringNew(tour, function () {
                TAG.Util.UI.slidePageLeft(toureditor.getRoot());
            });
        }, 1);
    }

    /**Delete a tour
     * @method deleteTour
     * @param {Object} tour     tour to delete
     */
    function deleteTour(tour) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the tour
            TAG.Worktop.Database.deleteDoq(tour.Identifier, function () {
                if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                    return;
                }
                loadTourView();
            }, authError, conflict(tour, "Delete", loadTourView), error(loadTourView));
        }, "Are you sure you want to delete " + tour.Name + "?", "Delete", true, function () { 
            $(confirmationBox).hide(); 
        });
        root.append(confirmationBox);
        $(confirmationBox).show();
        TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
    }

    /**Duplicate a tour
     * @method duplicateTour
     * @param {Object} tour     tour to duplicate
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function duplicateTour(tour, inputs) {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);
        var options = {
            Name: "Copy: " + tour.Name,
            Description: tour.Metadata.Description,
            Content: tour.Metadata.Content,
            Thumbnail: tour.Metadata.Thumbnail,
            Private: "true", // always want to create duplicates as unpublished
        };

        TAG.Worktop.Database.createTour(options, function (tewer) {
            console.log("success");
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            loadTourView(tewer.Identifier);
        }, function () {
            console.log("error");
        }, function () {
            console.log("cacheError");
        });
    }

    /**Save a tour
     * @method saveTour
     * @param {Object} tour     tour to save
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function saveTour(tour, inputs) {
        //pCL = displayLoadingSettings();
        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();

        if (name.indexOf(' ') === 0) {
            var messageBox = TAG.Util.UI.popUpMessage(null, "Tour Name cannot start with a space.", null, true);
            $(root).append(messageBox);
            $(messageBox).show();
            return;
        }

        prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.changeTour(tour.Identifier, {
            Name: name,
            Description: desc,
            Private: inputs.privateInput,
        }, function () {
            //refreshTour(tour);
            //toursIsLoading = false;
            //if (backButtonClicked && !(generalIsLoading || collectionsIsLoading ||
            //    artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don't continue if more sections are still loading - wait for them to finish
            //    backButtonClickHandler();
            //};
            //if (!backButtonClicked && (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.tour.text])) {
            //    loadTourView(previousIdentifier); //eventually don't want this here? - reloads everything
            //};
            //hideLoading();
            //hideLoadingSettings(pCL);
            //saveArray.splice(saveArray.indexOf(tour.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                LADS.Worktop.Database.getTours();
                return;
            }
            if (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.tour.text]) {
                loadTourView(previousIdentifier);
                return;
            }
        }, authError, conflict(tour, "Update", loadTourView), error(loadTourView));
    }

    // Associated Media functions:

    /**Load Associated Media view
     * @method load AssocMediaView
     * @param {Object} id   id of middle label to start on
     */
    function loadAssocMediaView(id, matches) {
        //$(document).off();
        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = true;
        inToursView = false;
        inFeedbackView = false;

        changesMade = false;

        var list;
        currentIndex = 0;
        menuLabel.on("mouseleave", function () {
            menuLabel.css({"background-color": "transparent"});
        });
        if (showDropdown) {
            menuLabel.click();
        }

        prepareNextView(true, "Add", createAsset);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        //if (generalIsLoading || collectionsIsLoading ||
        //  artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
        //    hideLoading();
        //    hideLoadingSettings(pCL);
        //};
        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        //associatedMediaIsLoading && showLoading();
        //(saveArray.indexOf(previousIdentifier) < 0) && function () { hideLoading(); hideLoadingSettings(pCL); };

        if (typeof matches !== "undefined") {       //If there are no search results to display
            list = matches;
            displayLabels();
        } else {
            // Make an async call to get artworks and then display
            TAG.Worktop.Database.getAssocMedia(function (result) {
                if (cancel) return;
                sortAZ(result);
                currentList = result;
                artworkList = result;
                initSearch();
                list = result;
                displayLabels();
            });
        }


        function displayLabels() {
            if (list[0] && list[0].Metadata) {
                $.each(list, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue so the UI doesn't lock up
                    middleQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.ContentType.toLowerCase()) {
                            case 'video':
                                imagesrc = (val.Metadata.Thumbnail && !val.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + 'images/video_icon.svg';
                                break;
                            case 'audio':
                                imagesrc = tagPath + '/images/audio_icon.svg';
                                break;
                            case 'iframe':
                                imagesrc = tagPath + '/images/video_icon.svg'; // TODO iframe replace icon
                                break;
                            case 'image':
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + 'images/image_icon.svg';
                                break;
                            default:
                                imagesrc = null;
                                break;
                        }
                        if (!prevSelectedMiddleLabel &&
                            ((id && val.Identifier === id) || (!id && i === 0))) {
                            // Select the first one
                            middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                previousIdentifier = val.identifier;
                                loadAssocMedia(val);
                                currentIndex = i;
                            }, val.Identifier, false), true));

                            // Scroll to the selected label if the user hasn't already scrolled somewhere
                            if (middleLabelContainer.scrollTop() === 0 && label.offset().top - middleLabelContainer.height() > 0) {
                                middleLabelContainer.animate({
                                    scrollTop: (label.offset().top - middleLabelContainer.height() / 2)
                                }, 1000);
                            }

                            prevSelectedMiddleLabel = label;
                            currentSelected = prevSelectedMiddleLabel;
                            loadAssocMedia(val);
                        } else {
                            middleLoading.before(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //if (changesHaveBeenMade) {
                                //    //saveArray.push(previousIdentifier);
                                //    //currentMetadataHandler && saveQueue.add(currentMetadataHandler());
                                //    //changesHaveBeenMade = false;
                                //}
                                loadAssocMedia(val);
                                previousIdentifier = val.Identifier;
                                currentIndex = i;
                            }, val.Identifier, false));
                        }

                    });
                });
                // Hide the loading label when we're done
                middleQueue.add(function () {
                    middleLoading.hide();
                });
            } else {
                middleLoading.hide();
            }
        }

        cancelLastSetting = function () { cancel = true; };
    }
    
    /**Loads associated media to the right side
     * @method loadAssocMedia
     * @param {Object} media    associated media to load
     */
    function loadAssocMedia(media) {
        
        prepareViewer(true);
        clearRight();
        deleteType = deleteAssociatedMedia;
        toDelete = media;
        currDoq = media.Identifier;
        clearTimeout(checkConTimerId);
        // Create an img element to load the image
        var type = media.Metadata.ContentType.toLowerCase();
        var holder;
        var sourceExt;
        var source = (type === 'iframe') ? media.Metadata.Source : TAG.Worktop.Database.fixPath(media.Metadata.Source);
        switch (type) {
            case "image":
                holder = $(document.createElement('img'));
                break;
            case "video":
                holder = $(document.createElement('video'));
                holder.attr('id', 'videoInPreview');
                holder.attr('poster', (media.Metadata.Thumbnail && !media.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(media.Metadata.Thumbnail) : '');
                holder.attr('identifier', media.Identifier);
                holder.attr("preload", "none");
                holder.attr("controls", "");
                holder.css({ "width": "100%", "max-width": "100%", "max-height": "100%" });
                holder.attr("src", source);
                var source = TAG.Worktop.Database.fixPath(media.Metadata.Source);
                var sourceWithoutExtension = source.substring(0, source.lastIndexOf('.'));
                sourceExt = source.substring(source.lastIndexOf('.'));
                TAG.Worktop.Database.getConvertedVideoCheck(
                function (output) {
                    if (output ==="True" || sourceExt === ".mp4") {
                        holder.removeAttr('src');
                        var sourceMP4 = sourceWithoutExtension + ".mp4";
                        var sourceWEBM = sourceWithoutExtension + ".webm";
                        var sourceOGV = sourceWithoutExtension + ".ogv";

                        addSourceToVideo(holder, sourceMP4, 'video/mp4');
                        addSourceToVideo(holder, sourceWEBM, 'video/webm');
                        addSourceToVideo(holder, sourceOGV, 'video/ogv');
                        holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer);
                        //$(document.getElementsByClassName("convertVideoBtn")[0]).hide().data('disabled', true);
                        viewer.append(holder);
                        if (sourceExt === '.mp4') {
                            if (output === "False") {
                                var msg = "This video is being converted to compatible formats for different browsers";
                                checkConTimerId = setInterval(function () { checkConversion(media) }, 2000);
                                viewer.append(TAG.Util.createConversionLoading(msg, null, true));
                            } else if (output === "Error") {
                                var msg = "An error occured when converting this video. Please try to upload again";
                                viewer.append(TAG.Util.createConversionLoading(msg, true, true));
                            }
                        }
                    } else {
                        //convertBtn.show();
                        if (output === "False") {
                            //$(document.getElementsByClassName("convertVideoBtn")[0]).hide().data('disabled', true);
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "This video is being converted to compatible formats for different browsers";
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            checkConTimerId = setInterval(function () { checkConversion(media) }, 2000);
                        } else if (output === "Error") {
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "An error occured when converting this video. Please try to upload again";
                            if (sourceExt === ".mp4") {
                                viewer.append(TAG.Util.createConversionLoading(msg, true, true));
                            } else {
                                viewer.append(TAG.Util.createConversionLoading(msg, true));
                            }
                        } else if(output ===null) {
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, source, sourceExt, sourceWithoutExtension, artwork.Identifier);
                        }
                        //holder.attr('src', source);
                    }
                }, null, media.Identifier);
                //if (conversionVideos.indexOf(media.Identifier) > -1) {
                //    var msg = "This video is being converted to compatible formats for different browsers";
                //    viewer.append(TAG.Util.createConversionLoading(msg));
                //} else {
                //    holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer, media.Metadata.Converted);
                //}
                break;
            case "audio":
                holder = $(document.createElement('audio'));
                holder.attr("preload", "none");
                holder.attr("controls", "");
                holder.css({ 'width': '80%' });
                fixVolumeBar(holder);
                break;
            case "iframe":
                holder = $(document.createElement('iframe'));
                holder.attr({
                    src: source + "?modestbranding=1&showinfo=0&fs=0",
                    frameborder: '0'
                });
                holder.css({
                    width: '100%',
                    height: '100%'
                });
                break;
            case "text":
            default:
                holder = $(document.createElement('div'));
                holder.css({
                    "font-size": "24px",
                    "top": "20%",
                    "width": "80%",
                    "text-align": "center",
                    "color": "white"
                });
                holder.html(media.Name + "<br /><br />" + media.Metadata.Description);
                holder.crossOrigin = "";
                break;
        }
        (source && type !== 'text' && type!== "iframe") && holder.attr('src', source);

        // Create a progress circle
        var progressCircCSS = {
            'position': 'absolute',
            'left': '40%',
            'top': '40%',
            'z-index': '50',
            'height': 'auto',
            'width': '20%'
        };
        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, '0px', '0px', false);
        var selectedLabel = prevSelectedMiddleLabel;

        switch (type) {
            case "image":
                holder.load(function () {
                    // If the selection has changed since we started loading then return
                    if (prevSelectedMiddleLabel && prevSelectedMiddleLabel.text() !== media.Name) {
                        TAG.Util.removeProgressCircle(circle);
                        return;
                    }
                    TAG.Util.removeProgressCircle(circle);
                    // Set the image as a background image
                    viewer.css('background', 'black url(' + source + ') no-repeat center / contain');
                });
                break;
            case "video":
                TAG.Util.removeProgressCircle(circle);
                viewer.css('background', 'black');
                //if(sourceExt===".mp4"){
                //    viewer.append(holder);
                //}
                break;
            case "audio":
                TAG.Util.removeProgressCircle(circle);
                viewer.css('background', 'black');
                //center the the audio element in the viewer
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + "px";
                var top = viewer.height() /2 - holder.height() /2 + "px";
                holder.css({ "position": "absolute", "left": left, "top" : top });
                break;
            case "iframe":
                TAG.Util.removeProgressCircle(circle);
                viewer.css('background', 'black');
                viewer.append(holder);
                break;
            case "text":
                TAG.Util.removeProgressCircle(circle);
                viewer.css({ 'background': 'black'});
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + "px";
                var top = viewer.height() / 2 - holder.height() / 2 + "px";
                holder.css({ "position": "absolute", "left": left, "top": top });
                break;
            default:
                TAG.Util.removeProgressCircle(circle);
                viewer.css('background', 'black');
                break;
        }

        // Create labels
        var titleInput = createTextInput(TAG.Util.htmlEntityDecode(media.Name) || "", "Title", 100);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(media.Metadata.Description).replace(/\n/g,'<br />') || "", true, 2000);

        titleInput.focus(function () {
            if (titleInput.val() === 'Title')
                titleInput.select();
        });

        titleInput.on('keyup', function (event) {
            if (event.which === 13) {
                saveButton.click();
            } else {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            }
            
        });

        descInput.focus(function () {
            if (descInput.val() === 'Description')
                descInput.select();
        });

        descInput.on('keyup', function () {
            changesMade = true;
            saveButton.prop("disabled", false);
            saveButton.css("opacity", 1);
        });

        onChangeUpdateText(titleInput, null, 100);
        onChangeUpdateText(descInput, null, 5000);

        var title = createSetting('Title', titleInput);
        var desc = createSetting('Description', descInput);
        var yearMetadataDivSpecs = createYearMetadataDiv(media, function (event) {            
            if (event && event.which === 13) {
                saveButton.click();
            } else {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            }
        });

        settingsContainer.append(title);
        settingsContainer.append(desc);
        if (type === 'iframe') {
            var rawSource = media.Metadata.Source;
            var visibleSource;
            if (rawSource.indexOf('youtube') > -1) {
                if (rawSource.indexOf('embed') > -1) {
                    visibleSource = rawSource.substring(rawSource.indexOf('embed') + 6);
                    visibleSource = "https://www.youtube.com/watch?v=" + visibleSource;
                }                
            }
            else if (rawSource.indexOf('vimeo')) {
                if (rawSource.indexOf('video') > -1) {
                    visibleSource = rawSource.substring(rawSource.indexOf('video') + 6, rawSource.indexOf("?"));
                    visibleSource = "https://www.vimeo.com/" + visibleSource;
                }    
            }
            var sourceInput = createTextInput(visibleSource);
            sourceInput.focus(function () {
                if (descInput.val() === 'Source')
                    descInput.select();
            });
            sourceInput.on('keyup', function (event) {
                if (event.which === 13) {
                    saveButton.click();
                } else {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                }
            });
            onChangeUpdateText(sourceInput, null, 5000);
            var source = createSetting('Source', sourceInput);
            settingsContainer.append(source);
        }
        settingsContainer.append(yearMetadataDivSpecs.yearMetadataDiv);

        //Automatically save changes
        //currentMetadataHandler = function () {
        //    if (titleInput.val() === undefined || titleInput.val() === "") {
        //        titleInput.val("Untitled Asset");
        //    }
        //    saveAssocMedia(media, {
        //        titleInput: titleInput,
        //        descInput: descInput,
        //        yearInput: yearMetadataDivSpecs.yearInput,
        //        monthInput: yearMetadataDivSpecs.monthInput,
        //        dayInput: yearMetadataDivSpecs.dayInput,
        //        timelineYearInput: yearMetadataDivSpecs.timelineYearInput,
        //        timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,
        //        timelineDayInput: yearMetadataDivSpecs.timelineDayInput
        //    });
        //};

        // Create buttons
        
        var assocButton = createButton('Manage Associations',
            function () {
                pickerOpen = true;
                assocToArtworks(media); /*changesHaveBeenMade = true;*/
            },
            {
                'float': 'left',
                'margin-left': '2%',
                'margin-top': '1%',
                'margin-right': '0%',
                'margin-bottom': '3%',
            });
        
        leftButton = assocButton;
        var deleteButton = createButton('Delete',
            function () { deleteAssociatedMedia(media); /*changesHaveBeenMade = true;*/ },
            {
                'margin-right': '0%',
                'margin-top': '1%',
                'margin-bottom': '3%',
                'margin-left': '2%',
                'float': 'left',
            });

        var generateAssocMediaThumbnailButton = createButton('Generate Thumbnail',
            function () {
                generateAssocMediaThumbnail(media);
                //changesHaveBeenMade = true;
            }, {
                'margin-right': '3%',
                'margin-top': '1%',
                'margin-bottom': '1%',
                'margin-left': '2%',
                'float': 'left'
            });

        var saveButton = createButton('Save',
            function () {
                if (titleInput.val() === undefined || titleInput.val() === "") {
                    titleInput.val("Untitled Asset");
                }
                var updatedMetadata = {
                    titleInput: titleInput,
                    descInput: descInput,
                    yearInput: yearMetadataDivSpecs.yearInput,
                    monthInput: yearMetadataDivSpecs.monthInput,
                    dayInput: yearMetadataDivSpecs.dayInput,
                    timelineYearInput: yearMetadataDivSpecs.timelineYearInput,
                    timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,
                    timelineDayInput: yearMetadataDivSpecs.timelineDayInput
                };


                if (type === 'iframe') {
                    var validURL = checkEmbeddedURL(sourceInput.val());
                    if (validURL) {
                        saveAssocMedia(media, updatedMetadata, validURL);
                    }
                } else {
                    saveAssocMedia(media, updatedMetadata);
                }
            }, {
                'margin-right': '3%',
                'margin-top': '1%',
                'margin-bottom': '1%',
                'margin-left': '.5%',
                'float': 'right'
            }, true);

        var thumbnailButton = createButton('Capture Thumbnail',
            function () {
                saveThumbnail(media, false);
                //changesHaveBeenMade = true;
            }, {
                'margin-right': '0%',
                'margin-top': '1%',
                'margin-bottom': '3%',
                'margin-left': '2%',
                'float': 'left'
            });

        thumbnailButton.attr('id', 'thumbnailButton');
        buttonContainer.append(assocButton);
        if (media.Metadata.ContentType.toLowerCase() === 'video') {
        //    var convertBtn = createButton('Convert Video',
        //            function () {
        //                var source = media.Metadata.Source;
        //                var newFileName = source.slice(8, source.length);
        //                var index = newFileName.lastIndexOf(".");
        //                var fileExtension = newFileName.slice(index);
        //                var baseFileName = newFileName.slice(0, index);
        //                if (media.Metadata.Converted !== "True") {
        //                    TAG.Worktop.Database.convertVideo(function () {
        //                    }, null, newFileName, fileExtension, baseFileName, media.Identifier);
        //                    conversionVideos.push(media.Identifier);
        //                    $("#videoErrorMsg").remove();
        //                    $("#leftLoading").remove();
        //                    var msg = "This video is being converted to compatible formats for different browsers";
        //                    viewer.append(TAG.Util.createConversionLoading(msg));
        //                    holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer, "False");
        //                    convertBtn.hide().data('disabled', true);
        //                }
        //            }, {
        //                'margin-right': '0%',
        //                'margin-top': '1%',
        //                'margin-bottom': '3%',
        //                'margin-left': '2%',
        //                'float': 'left'
        //            })
        //    convertBtn.attr('class', 'button convertVideoButton');
        //    convertBtn.attr("disabled", "");
        buttonContainer.append(thumbnailButton);//.append(convertBtn);
        } else if (media.Metadata.ContentType.toLowerCase() === 'image' && !media.Metadata.Thumbnail && media.Metadata.Source && media.Metadata.Source[0] === '/' && !source.match(/.mp3/)) {
            // hacky way to see if asset was imported recently enough to support thumbnailing (these are /Images/_____.__
            // rather than http:// _______/Images/_______.__
            buttonContainer.append(generateAssocMediaThumbnailButton);
        }
        buttonContainer.append(deleteButton).append(saveButton); //SAVE BUTTON//

        saveButton.on("mousedown", function () {
            if (!saveButton.attr("disabled")) {
                saveButton.css({ "background-color": "white" });
            }
        });
        thumbnailButton.on("mousedown", function () {
            thumbnailButton.css({ "background-color": "white" });
        });
        deleteButton.on("mousedown", function () {
            deleteButton.css({ "background-color": "white" });
        });
        assocButton.on("mousedown", function () {
            assocButton.css({ "background-color": "white" });
        });
        saveButton.on("mouseleave", function () {
            if (!saveButton.attr("disabled")) {
                saveButton.css({ "background-color": "transparent" });
            }
        });
        thumbnailButton.on("mouseleave", function () {
            thumbnailButton.css({ "background-color": "transparent" });
        });
        deleteButton.on("mouseleave", function () {
            deleteButton.css({ "background-color": "transparent" });
        });
        assocButton.on("mouseleave", function () {
            assocButton.css({ "background-color": "transparent" });
        });
        newButton.on("mouseleave", function () {
            newButton.css({ "background-color": "transparent" });
        });
    }


    /**Helper method to check URLs of videos to be embedded (standard YouTube or Vimeo URLs only) and return parsed URL for embed
     * @method checkEmbeddedURL
     * @param {String} url    URL to check and parse
     * @return {string} validURL   parsed URL if valid, empty string otherwise
     */
    function checkEmbeddedURL(url) {
        var modifiedURL = url,
                        popup,
                        id,
                        validURL = true;
        if (modifiedURL.toLowerCase().indexOf('youtube') > -1) {

            if (modifiedURL.indexOf("watch?v=") > -1) {
                id = modifiedURL.substring(modifiedURL.indexOf("watch?v=") + 8);

                if (id && !/^[a-zA-Z0-9_-]*$/.test(id)) {
                    validURL = false;
                }
            } else {
                validURL = false;
            }

            if (validURL && id) {
                if (modifiedURL.indexOf("https://") < 0 && modifiedURL.indexOf("http://") > -1) {
                    modifiedURL = modifiedURL.replace("http://", "https://");
                } else if (modifiedURL.indexOf("https://") < 0 && modifiedURL.indexOf("http://") < 0) {
                    modifiedURL = "https://" + modifiedURL;
                }
                modifiedURL = modifiedURL.replace("watch?v=", "embed/");
            } else {
                popup = TAG.Util.UI.popUpMessage(null, "There was a problem embedding the given YouTube URL. The URL should be in the format http://www.youtube.com/watch?v=JozMHAWq0TA");
                $('body').append(popup);
                $(popup).show();
            }

        } else if (modifiedURL.toLowerCase().indexOf('vimeo') > -1) {

            if (modifiedURL.indexOf("vimeo.com") > -1) {
                id = modifiedURL.substring(modifiedURL.indexOf("vimeo.com") + 10);
                if (id && !/^\d+$/.test(id)) {		//No special characters or characters
                    validURL = false;
                }
            } else {
                validURL = false;
            }

            if (validURL && id) {
                modifiedURL = "https://player.vimeo.com/video/" + id + "?title=0&amp;byline=0&amp;portrait=0";
            } else {
                popup = TAG.Util.UI.popUpMessage(null, "There was a problem embedding the given Vimeo URL. The URL should be in the format http://vimeo.com/11088764 ");
                $('body').append(popup);
                $(popup).show();
            }

        } else {
            popup = TAG.Util.UI.popUpMessage(null, "Please enter a valid YouTube or Vimeo URL.");
            $('body').append(popup);
            $(popup).show();
            validURL = false;
        }
        if (validURL) {
            return modifiedURL;
        } else {
            return "";
        }
    }


    /**Save an associated media
     * @method saveAssocMedia
     * @param {Object} media    associated media to save
     * @param {Object} inputs   keys for media title and description
     */
    function saveAssocMedia(media, inputs, embeddedURL) {
        var name = inputs.titleInput.val(),
            year = inputs.yearInput.val(),
            month = inputs.monthInput.val(),
            day = inputs.dayInput.val(),
            timelineYear = inputs.timelineYearInput.val(),
            timelineMonth = inputs.timelineMonthInput.val(),
            timelineDay = inputs.timelineDayInput.val(),
            desc = inputs.descInput.val(),
            source = embeddedURL || "";
            
        //pCL = displayLoadingSettings();
        clearRight();
        prepareViewer(true);
        prepareNextView(false, null, null, "Saving...");

        var name = inputs.titleInput.val();
        var desc = inputs.descInput.val();
        //prepareViewer(true);

        TAG.Worktop.Database.changeHotspot(media, {
            Name: name,
            Description: desc,
            Source: source,
            Year: year,
            Month: month,
            Day: day,
            TimelineYear: timelineYear,
            TimelineMonth: timelineMonth,
            TimelineDay: timelineDay,
        }, function () {
            //refreshAssocMedia(media);
            //associatedMediaIsLoading = false;
            //if (backButtonClicked && !(generalIsLoading || collectionsIsLoading ||
            //    artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don't continue if more sections are still loading - wait for them to finish
            //    backButtonClickHandler();
            //};
            //if (!backButtonClicked && (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.media.text])) {
            //    hideLoading();
            //    hideLoadingSettings(pCL);
            //    loadAssocMediaView(previousIdentifier); //eventually don't want this here? - reloads everything
            //};
            //hideLoading();
            //hideLoadingSettings(pCL);
            //saveArray.splice(saveArray.indexOf(media.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                LADS.Worktop.Database.getAssocMedia();
                return;
            }
            if (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.media.text]) {
                loadAssocMediaView(previousIdentifier);
                return;
            }
        }, authError, conflict(media, "Update", loadAssocMediaView), error(loadAssocMediaView));
    }

    /**Delete associated media
     * @method deleteAssociatedMedia
     * @param {Object} media    media to be deleted
     */
    function deleteAssociatedMedia(media) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // stupid way to force associated artworks to increment their linq counts and refresh their lists of media
            TAG.Worktop.Database.changeHotspot(media.Identifier, { Name: media.Name }, function () {
            // success handler
            TAG.Worktop.Database.deleteDoq(media.Identifier, function () {
                console.log("deleted");
                loadAssocMediaView();
            }, function () {
                console.log("noauth error");
            }, function () {
                console.log("conflict error");
            }, function () {
                console.log("general error");
            });
            }, function () {
            // unauth handler
            }, function () {
            // conflict handler
            }, function () {
            // error handler
            });
            }, "Are you sure you want to delete " + media.Name + "?", "Delete", true, function () { $(confirmationBox).hide(); });
            root.append(confirmationBox);
            $(confirmationBox).show();
            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));

    }

    /**Brings up an artwork chooser for a particular associated media
     * @method assocToArtworks
     * @param {Object} media    media to associate to artworks
     */
    function assocToArtworks(media) {
        if (!media) {
            return;
        }
        artworkAssociations = [[]];
        numFiles = 1;
        TAG.Util.UI.createAssociationPicker(root, "Choose artworks", { comp: media, type: 'media' }, "artwork", [{
            name: "All Artworks",
            getObjs: TAG.Worktop.Database.getArtworks
        }], {
            getObjs: TAG.Worktop.Database.getArtworksAssocTo,
            args: [media.Identifier]
        }, function () { });
    }

    /**Generate thumbnail for associated media
     * @method generateAssocMediaThumbnail
     * @param {Object} media        media to generate thumbnail for
     */
    function generateAssocMediaThumbnail(media) {
        prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.changeHotspot(media.Identifier, { Thumbnail: 'generate' }, function () {
            loadAssocMediaView(media.Identifier);
        }, unauth, conflict, error);
    }

    /**Generate iframe asset
     * @method createIframeAsset
     * @param {String} src        URL to embed
     */
    function createIframeAsset(src) { //TODO IFRAME ASSOC MEDIA: iframe asset creation would look something like this
        middleLabelContainer.empty();
        middleLabelContainer.append(middleLoading);
        middleLoading.show();
        clearRight();
        viewer.empty();
        viewer.css('background', 'black');
        var validURL = checkEmbeddedURL(src);
        if (validURL) {
            var options = {
                Source: validURL,
                Name: "Untitled Embedded Video"
            };
            TAG.Worktop.Database.createIframeAssocMedia(options, onSuccess);
        } else {
            loadAssocMediaView();
        }
        function onSuccess(doqData) {
            var newDoq = new Worktop.Doq(doqData.responseText);
            function done() {
                loadAssocMediaView(newDoq.Identifier);
            }
            TAG.Worktop.Database.changeHotspot(newDoq.Identifier, options, done, TAG.Util.multiFnHandler(authError, done), TAG.Util.multiFnHandler(conflict(newDoq, "Update", done)), error(done));

        };

    }

    /**
     * Create a dialog for inputting an iframe source for new associated media
     * @method createIframeSourceDialog
     */
    function createIframeSourceDialog() {
        var overlay = TAG.Util.UI.popupInputBox({
            confirmAction: createIframeAsset,
            container: root,
            message: 'Enter a YouTube or Vimeo URL',
            //placeholder: 'E.g., http://www.youtube.com/embed/g794oDdc1l0',
            confirmText: 'Save'
        });
        root.append(overlay);
        overlay.fadeIn(500);
    }

    /**
     * @method createAsset
     */
    function createAsset() {
        uploadFile(TAG.Authoring.FileUploadTypes.AssociatedMedia, function (urls, names, contentTypes, files) {
            var check, i, url, name, done = 0, total = urls.length, durations = [], toScroll, alphaName;
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            if(files.length > 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === 'Video') {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else if (contentTypes[j] === 'Audio') {
                    files[j].properties.getMusicPropertiesAsync().done(function (MusicProperties) {
                        durations.push(MusicProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (error) {
                        console.log(error);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }

            function incrDone() {
                done++;
                if (done >= total) {
                    loadAssocMediaView(toScroll.Identifier);
                } else {
                    durationHelper(done);
                }
            }

            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                    var options = { Name: names[j] };
                    if (durations[j]) {
                        options.Duration = durations[j];
                    }
                    TAG.Worktop.Database.changeHotspot(newDoq.Identifier, options, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, "Update", incrDone)), error(incrDone));
                    if (contentTypes[j] === "Video") {
                        var source = newDoq.Metadata.Source;
                        var newFileName = source.slice(8, source.length);
                        var index = newFileName.lastIndexOf(".");
                        var fileExtension = newFileName.slice(index);
                        var baseFileName = newFileName.slice(0, index);
                        TAG.Worktop.Database.convertVideo(function () {
                        }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                    }
                    /*if (contentTypes[j] === "Video") { //TODO: COMMENTING OUT FOR WIN8 AUG 15 RELEASE ONLY

                        //conversionVideos.push(newDoq.Identifier);
                        var source = newDoq.Metadata.Source;
                        var newFileName = source.slice(8, source.length);
                        var index = newFileName.lastIndexOf(".");
                        var fileExtension = newFileName.slice(index);
                        var baseFileName = newFileName.slice(0, index);
                        var confirmBox = TAG.Util.UI.PopUpConfirmation(function () {
                            //$(document.getElementById("leftLoading")).remove();
                            //viewer.append(LADS.Util.createConversionLoading("This video is being converted to compatible formats for different browsers"));
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                            conversionVideos.push(newDoq.Identifier);
                            var mediaElement = $(document.getElementById("videoInPreview"));
                            if (mediaElement[0]) {
                                $("#videoErrorMsg").remove();
                                $("#leftLoading").remove();
                                var msg = "This video is being converted to compatible formats for different browsers";
                                viewer.append(TAG.Util.createConversionLoading(msg));    
                            }
                        }, "Would you like to convert" + newFileName + "?", "Yes", true, function () {
                            if (fileExtension !== ".mp4") {
                                var msg = "This video format has not been converted to formats supported in multiple browsers.";
                                viewer.append(LADS.Util.createConversionLoading(msg, true));
                            }
                            $(".convertVideoBtn").show().data("disabled", false);
                        });

                        root.append(confirmBox);
                        $(confirmBox).show();
                    }*/
                } catch (error) {
                    done++;
                    console.log("error in uploading: " + error.message);
                    return;
                }
                if (!alphaName || names[j] < alphaName) {
                    toScroll = newDoq;                          //Alphabetical order
                    alphaName = names[j];
                }
            }
        }, true, ['.jpg', '.png', '.gif', '.tif', '.tiff', '.mp4', '.mp3', '.mp4', '.webm', '.ogv','.mov','.avi','.wmv']);
    }

    /**Create an associated media (import), possibly more than one
     * @method createMedia
     */
    function createMedia() {
        batchAssMedia();
    }

    /**
     * @method batchAssMedia
     */
    function batchAssMedia() {
        var uniqueUrls = []; // Used to make sure we don't override data for the wrong media (not actually airtight but w/e)
        mediaMetadata = [];
        artworkAssociations = [];
        numFiles = 0;
        isUploading = true;
        assetUploader = TAG.Authoring.FileUploader( // multi-file upload now
            root,
            TAG.Authoring.FileUploadTypes.AssociatedMedia,
            function (files, localURLs) { // localCallback
                var file, localURL, i;
                var img, video, audio;
                var contentType;
                numFiles = files.length;
                for (i = 0; i < files.length; i++) {
                    artworkAssociations.push([]);
                    file = files[i];
                    localURL = localURLs[i];
                    if (file.contentType.match(/image/)) {
                        contentType = 'Image';
                    } else if (file.contentType.match(/video/) || files[i].fileType.toLowerCase() === ".mp4" || files[i].fileType.toLowerCase() === ".webm" || files[i].fileType.toLowerCase() === ".ogv") {
                        contentType = 'Video';
                    } else if (file.contentType.match(/audio/)) {
                        contentType = 'Audio';
                    }
                    uniqueUrls.push(localURL);
                    mediaMetadata.push({
                        'title': file.displayName,
                        'contentType': contentType,
                        'localUrl': localURL,
                        'assetType': 'Asset',
                        'assetLinqID': undefined,
                        'assetDoqID': undefined
                    });
                }
            },
            function (dataReaderLoads) { // finished callback: set proper contentUrls, if not first, save it
                var i, dataReaderLoad;
                for (i = 0; i < dataReaderLoads.length; i++) {
                    dataReaderLoad = dataReaderLoads[i];
                    mediaMetadata[i].contentUrl = dataReaderLoad;
                }

                // chooseAssociatedArtworks(); // need to send in media objects here TODO
            },
            ['.jpg', '.png', '.gif', '.tif', '.tiff', '.mp4', '.mp3'], // filters
            false, // useThumbnail
            null, // errorCallback
            true // multiple file upload enabled?
        );
    }

    /**
     * @method saveAssMedia
     * @param i the index of the asset 
     */
    function saveAssMedia(i) {
        var len = artworkAssociations[i].length;
        uploadHotspotHelper(i, 0, len);
    }

    /**
     * Uploads hotspot i to artwork j in its list of artworks to associate to.
     * @method uploadHotspotHelper
     * @param i    the index of the asset we're uploading
     * @param j    each asset has a list of artworks it'll be associated with; j is the index in this list
     * @param len  the length of the list above
     */
    function uploadHotspotHelper(i, j, len) {
        // uploads hotspot hotspot i to artwork j in its list
        var activeMM = mediaMetadata[i];
        uploadHotspot(artworkAssociations[i][j], { // this info isn't changing, so maybe we can do this more easily in uploadHotspot
            title: TAG.Util.htmlEntityEncode(activeMM.title || 'Untitled media'),
            desc: TAG.Util.htmlEntityEncode(''),
            pos: null, // bogus entry for now -- should set it to {x: 0, y: 0} in uploadHotspot
            contentType: activeMM.contentType,
            contentUrl: activeMM.contentUrl,
            assetType: activeMM.assetType,
            metadata: {
                assetLinqID: activeMM.assetLinqID,
                assetDoqID: activeMM.assetDoqID
            }
        },
        i, j, len);
    }

    /**
     * @method uploadHotspot
     * @param artwork
     * @param info
     * @param i
     * @param j
     * @param len
     */
    function uploadHotspot(artwork, info, i, j, len) {
        var title = info.title,
            desc = info.desc,
            pixel = info.pos,
            contentType = info.contentType,
            contentUrl = info.contentUrl,
            assetType = info.assetType,
            worktopInfo = info.metadata || {},
            dzPos = pixel ? zoomimage.viewer.viewport.pointFromPixel(pixel) : { x: 0, y: 0 },
            rightbarLoadingSave;

        var options = {
            Name: title,
            ContentType: contentType,
            Duration: duration,
            Source: contentUrl,
            LinqTo: artwork.Identifier,
            X: dzPos.x,
            Y: dzPos.y,
            LinqType: assetType,
            Description: desc
        };

        TAG.Worktop.Database.createHotspot(artwork.CreatorID, artwork.Identifier, createHotspotHelper);

        /**
         * @method createHotspotHelper
         * @param isNewAsset
         * @param xmlHotspot
         */
        function createHotspotHelper(isNewAsset, xmlHotspot) { // currently for creating both hotspots and assoc media
            var $xmlHotspot,
                hotspotId,
                hotspotContentId,
                hotspotContentDoq,
                $hotspotContentDoq,
                titleField,
                metadata,
                descField,
                contentTypeField,
                sourceField,
                position;
            $xmlHotspot = $(xmlHotspot);
            hotspotId = $xmlHotspot.find("Identifier").text();
            hotspotContentId = $xmlHotspot.find("BubbleContentID:last").text();
            hotspotContentDoq = $.parseXML(TAG.Worktop.Database.getDoqXML(hotspotContentId));
            $hotspotContentDoq = $(hotspotContentDoq);
            // update doq info and send back to server
            titleField = $hotspotContentDoq.find('Name').text(title);
            metadata = $hotspotContentDoq.find('Metadata');
            descField = metadata.find("d3p1\\:Key:contains('Description') + d3p1\\:Value").text(desc);
            contentTypeField = metadata.find("d3p1\\:Key:contains('ContentType') + d3p1\\:Value").text(contentType);
            sourceField = metadata.find("d3p1\\:Key:contains('Source') + d3p1\\:Value").text(contentUrl);
            position = $xmlHotspot.find('Offset > d2p1\\:_x').text(dzPos.x); // why is position getting reset?
            position = $xmlHotspot.find('Offset > d2p1\\:_y').text(dzPos.y);
            //add linq type : Hotspot vs. Asset
            $xmlHotspot.find("d3p1\\:Key:contains('Type') + d3p1\\:Value").text(assetType);
            TAG.Worktop.Database.pushLinq(xmlHotspot, hotspotId);
            TAG.Worktop.Database.pushXML(hotspotContentDoq, hotspotContentId);
            if (j < len - 1) {
                uploadHotspotHelper(i, j + 1, len);
            }
            else if (j === len - 1 && i < numFiles - 1) {
                saveAssMedia(i + 1);
            }
            else {
                isUploading = false;
                isCreatingMedia = false;
                //$topProgressDiv.css("visibility", "hidden");
            }
        }
    }



    /**
     * Store the search strings for each artwork/tour
     * @method initSearch
     * @param {Array} contents    the contents of this collection (array of doqs)
     */
    function initSearch() {
        var info;

        searchbar[0].value = "";
        //$(searchbar).blur(); //////////
        infoSource = [];
        
        $.each(currentList, function (i, cts) {
            if (!cts) {
                return false;
            }
            info = ((cts.Name) ? cts.Name : "") + " " + ((cts.Metadata.Artist) ? cts.Metadata.Artist : "") + " " + ((cts.Metadata.Year) ? cts.Metadata.Year : "") + " " + ((cts.Metadata.TimelineYear) ? cts.Metadata.TimelineYear : "") + " " + ((cts.Metadata.Description) ? cts.Metadata.Description : "") + " " + ((cts.Metadata.Type) ? cts.Metadata.Type : "") + " " + ((cts.Metadata.Feedback) ? cts.Metadata.Feedback : "");
            if (cts.Metadata.InfoFields) {
                $.each(cts.Metadata.InfoFields, function (field, fieldText) {           //Adding custom metadata fields: both keys and values
                    info += " " + field;
                    info += " " + fieldText;
                });
            }            
            
            infoSource.push({
                "id": i,
                "keys": info.toLowerCase(),
                "identifier": info.Identifier
            });
           
        });
    }

    /**
     * Search collection using string in search input box
     * @method doSearch
     */
    function doSearch() {
        TAG.Util.removeYoutubeVideo();

        var content = searchbar.val().toLowerCase(),
            matches = [],
            i;

        if (!content) {
            loadArtView();
            return;
        }

        for (i = 0; i < infoSource.length; i++) {
            if (infoSource[i].keys.indexOf(content) > -1) {
                matches.push(currentList[i]);
            }
        }
        if (inArtworkView) {
            loadArtView(null, matches);
        } else if (inAssociatedView) {
            loadAssocMediaView(null, matches);
        } else if (inCollectionsView) {
            loadExhibitionsView(null, matches);
        } else if (inFeedbackView) {
            loadFeedbackView(null, matches);
        } else if (inToursView) {
            loadTourView(null, matches);
        } else {
            return;
        }

    }



    // Art Functions:

    /**Loads art view
     * @method loadArtView
     * @param {Object} id   id of middle label to start on
     */
    function loadArtView(id, matches) {

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = true;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;

        changesMade = false;

        var list;
        currentIndex = 0;
        prepareNextView(true, "Import", createArtwork);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        //if (generalIsLoading || collectionsIsLoading ||
        //  artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
        //    hideLoading();
        //    hideLoadingSettings(pCL);
        //};
        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
        //artworksIsLoading && showLoading();
        //(saveArray.indexOf(previousIdentifier) < 0) && function () { hideLoading(); hideLoadingSettings(pCL); };

        if (typeof matches !== "undefined") {       //If there are no search results to display
            list = matches;
            displayLabels();
        } else {
            // Make an async call to get artworks and then display
            TAG.Worktop.Database.getArtworks(function (result) {
                if (cancel) return;
                sortAZ(result);
                currentList = result;
                artworkList = result;
                initSearch();
                list = result;
                displayLabels();
            });
        }
        

        function displayLabels() {
            if (list[0] && list[0].Metadata) {
                $.each(list, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue
                    // so the UI doesn't lock up
                    val.Name = TAG.Util.htmlEntityDecode(val.Name);
                    middleQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.Type) {
                            case 'Artwork':
                                imagesrc = TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail);
                                break;
                            case 'VideoArtwork':
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + "images/video_icon.svg";
                                break
                            default:
                                imagesrc = null;
                        }
                        if (!prevSelectedMiddleLabel &&
                            ((id && val.Identifier === id) || (!id && i === 0))) {
                            // Select the first one
                            middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                previousIdentifier = val.identifier;
                                loadArtwork(val);
                                currentIndex = i;
                            }, val.Identifier, false, function () {
                                if (val.Metadata.Type === "Artwork") {
                                    editArtwork(val);
                                }
                            }, true, val.Extension), true));


                            // Scroll to the selected label if the user hasn't already scrolled somewhere
                            if (middleLabelContainer.scrollTop() === 0 && label.offset().top - middleLabelContainer.height() > 0) {
                                middleLabelContainer.animate({
                                    scrollTop: (label.offset().top - middleLabelContainer.height() / 2)
                                }, 1000);
                            }

                            prevSelectedMiddleLabel = label;
                            currentSelected = prevSelectedMiddleLabel;
                            currentIndex = i;
                            loadArtwork(val);
                        } else {
                            middleLoading.before(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                //if (changesHaveBeenMade) {
                                //    //saveArray.push(previousIdentifier);
                                //    //currentMetadataHandler && saveQueue.add(currentMetadataHandler());
                                //    //changesHaveBeenMade = false;
                                //}
                                loadArtwork(val);
                                previousIdentifier = val.Identifier;
                                currentIndex = i;
                            }, val.Identifier, false, function () {
                                if (val.Metadata.Type === "Artwork") {
                                    editArtwork(val);
                                }
                            }, true, val.Extension));
                        }

                    });
                });
                // Hide the loading label when we're done
                middleQueue.add(function () {
                    middleLoading.hide();
                });
            } else {
                middleLoading.hide();
            }
        }
            
        cancelLastSetting = function () { cancel = true; };
    }
    /*nest source tag inside video element*/
    function addSourceToVideo(element, src, type) {
        var source = document.createElement('source');

        source.src = src;
        source.type = type;

        element[0].appendChild(source);
    }
    /**Loads an artwork to the right side
     * @method loadArtwork
     * @param {Object} artwork  artwork to load
     */
    function loadArtwork(artwork) {
        //$(document).off();
        if (cancelArtworkLoad) cancelArtworkLoad();
        prepareViewer(true);
        clearRight();
        deleteType = deleteArtwork;
        toDelete = artwork;
        clearInterval(checkConTimerId);
        currDoq = artwork.Identifier;
        // Create an img element to load the image
        var mediaElement;
        var cancel = false;
        if (artwork.Metadata.Type !== 'VideoArtwork') {
            mediaElement = $(document.createElement('img'));
            mediaElement.attr('src', TAG.Worktop.Database.fixPath(artwork.URL));
        } else {
            /*
            mediaElement = $(document.createElement('video'));
            mediaElement.attr('id', 'videoInPreview');
            fixVolumeBar(mediaElement);
            mediaElement.attr('poster', (artwork.Metadata.Thumbnail && !artwork.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail) : '');
            mediaElement.attr('identifier', artwork.Identifier);
            mediaElement.attr("preload", "none");
            mediaElement.attr("controls", "");
            mediaElement.css({ "width": "100%", "max-width": "100%", "max-height": "100%" });
            var source = TAG.Worktop.Database.fixPath(artwork.Metadata.Source);

            TAG.Worktop.Database.getConvertedVideoCheck(
                function (output) {
                    if (output !== "" && output !== "False" && output !== "Error") {
                        var sourceWithoutExtension = source.substring(0, source.lastIndexOf('.'));
                        var sourceMP4 = sourceWithoutExtension + ".mp4";
                        var sourceWEBM = sourceWithoutExtension + ".webm";
                        var sourceOGV = sourceWithoutExtension + ".ogv";

                        addSourceToVideo(mediaElement, sourceMP4, 'video/mp4');
                        addSourceToVideo(mediaElement, sourceWEBM, 'video/webm');
                        addSourceToVideo(mediaElement, sourceOGV, 'video/ogv');
                        $(document.getElementsByClassName("convertVideoBtn")[0]).hide().data('disabled', true);
                    } else {
                        if (output === "False") {
                            $(document.getElementsByClassName("convertVideoBtn")[0]).hide().data('disabled', true);
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "This video is being converted to compatible formats for different browsers";
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            conversionVideos.push(artwork.Identifier);
                        } else if (output === "Error") {
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "An error occured when converting this video. Please try again";
                            viewer.append(TAG.Util.createConversionLoading(msg, true));
                        } else {
                            //if (artwork.Extension !== ".mp4") {
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "This video format has not been converted to formats supported in multiple browsers.";
                            viewer.append(TAG.Util.createConversionLoading(msg, true));
                            //}
                        }
                        mediaElement.attr('src', source);
                    }
                }, null, artwork.Identifier);
            if (conversionVideos.indexOf(artwork.Identifier) > -1) {
                $("#videoErrorMsg").remove();
                $("#leftLoading").remove();
                var msg = "This video is being converted to compatible formats for different browsers";
                viewer.append(TAG.Util.createConversionLoading(msg));
            } else {
                mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer, artwork.Metadata.Converted);
            }
            */
            mediaElement = $(document.createElement('video'));
            mediaElement.attr('id', 'videoInPreview');
            fixVolumeBar(mediaElement);
            mediaElement.attr('poster', (artwork.Metadata.Thumbnail && !artwork.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail) : '');
            mediaElement.attr('identifier', artwork.Identifier);
            mediaElement.attr("preload", "none");
            mediaElement.attr("controls", "");
            mediaElement.css({ "width": "100%", "max-width": "100%", "max-height": "100%" });
            var source = TAG.Worktop.Database.fixPath(artwork.Metadata.Source);
            var sourceWithoutExtension = source.substring(0, source.lastIndexOf('.'));
            var sourceExt = source.substring(source.lastIndexOf('.'));
            var videoErrorDiv = $(document.createElement('div'));
            videoErrorDiv.addClass("videoErrorDiv");

            mediaElement.attr("fileName", artwork.Metadata.Source.substring(0, source.lastIndexOf('.')));
            TAG.Worktop.Database.getConvertedVideoCheck(
                function (output) {
                    if (output === "True" || sourceExt === ".mp4" || output === "true") {
                        clearInterval(checkConTimerId);
                        var sourceMP4 = sourceWithoutExtension + ".mp4";
                        var sourceWEBM = sourceWithoutExtension + ".webm";
                        var sourceOGV = sourceWithoutExtension + ".ogv";

                        addSourceToVideo(mediaElement, sourceMP4, 'video/mp4');
                        addSourceToVideo(mediaElement, sourceWEBM, 'video/webm');
                        addSourceToVideo(mediaElement, sourceOGV, 'video/ogv');
                        mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer);
                        viewer.append(mediaElement);
                        if (sourceExt === '.mp4') {
                            if (output === "False") {
                                var msg = "This video is being converted to compatible formats for different browsers";
                                checkConTimerId = setInterval(function () { checkConversion(artwork) }, 2000);
                                viewer.append(TAG.Util.createConversionLoading(msg, null, true));
                            } else if (output === "Error") {
                                var msg = "An error occured when converting this video. Please try to upload again";
                                viewer.append(TAG.Util.createConversionLoading(msg, true, true));
                            }
                        }
                    } else {
                        if (output === "False") {
                            //$(document.getElementsByClassName("convertVideoBtn")[0]).hide();
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "This video is being converted to a compatible format";
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            checkConTimerId = setInterval(function () { checkConversion(artwork) }, 2000);
                        } else if (output === "Error") {
                            //$(document.getElementsByClassName("convertVideoBtn")[0]).show();
                            $("#videoErrorMsg").remove();
                            $("#leftLoading").remove();
                            var msg = "An error occured when converting this video. Please try to upload again";
                            if (sourceExt === ".mp4") {
                                viewer.append(TAG.Util.createConversionLoading(msg, true, true));
                            } else {
                                viewer.append(TAG.Util.createConversionLoading(msg, true));
                            }
                        } else if (output === null) {
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, source, sourceExt, sourceWithoutExtension, artwork.Identifier);
                        }
                    }
                }, null, artwork.Identifier);
        }
        mediaElement.crossOrigin = "";
        // Create a progress circle
        var progressCircCSS = {
            'position': 'absolute',
            'left': '40%',
            'top': '40%',
            'z-index': '50',
            'height': 'auto',
            'width': '20%'
        };
        var circle;
        if (artwork.Metadata.Type !== 'VideoArtwork') {
            circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, '0px', '0px', false);
        }
        var selectedLabel = prevSelectedMiddleLabel;

        if (artwork.Metadata.Type !== 'VideoArtwork') {
            mediaElement.load(function () {
                // If the selection has changed since we started loading then return
                if (prevSelectedMiddleLabel && prevSelectedMiddleLabel.text() !== artwork.Name) {
                    TAG.Util.removeProgressCircle(circle);
                    return;
                }
                TAG.Util.removeProgressCircle(circle);
                // Set the image as a background image
                viewer.css('background', 'black url(' + TAG.Worktop.Database.fixPath(artwork.URL) + ') no-repeat center / contain');
            });
        } else {

        }

        

        // Lock artwork setting: Only one artwork per server
        var isLocked;

        TAG.Worktop.Database.getMain(function () {
            var titleInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Name), "Artwork Title", 100);
            var artistInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Artist), "Artist", 100);
            var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Description).replace(/\n/g, '<br />') || "", "", false, 2000);

            titleInput.on('keyup', function (event) {
                if (event.which === 13) {
                    saveButton.click();
                } else {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                }

            });

            artistInput.on('keyup', function (event) {
                if (event.which === 13) {
                    saveButton.click();
                } else {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                }

            });

            descInput.on('keyup', function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            var customInputs = {};
            var customSettings = {};

            var saveButton;
            var yearMetadataDivSpecs = createYearMetadataDiv(artwork, function (event) {
                if (event && event.which === 13) {
                    saveButton.click();
                } else {
                    changesMade = true;
                    saveButton.prop("disabled", false);
                    saveButton.css("opacity", 1);
                }
            });


            titleInput.focus(function () {
                if (titleInput.val() === 'Title')
                    titleInput.select();
            });
            artistInput.focus(function () {
                if (artistInput.val() === 'Artist')
                    artistInput.select();
            });
            descInput.focus(function () {
                if (descInput.val() === 'Description')
                    descInput.select();
            });

            onChangeUpdateText(titleInput, null, 100);
            onChangeUpdateText(artistInput, null, 100);
            onChangeUpdateText(yearMetadataDivSpecs.yearInput, null, 100);
            onChangeUpdateText(descInput, null, 5000);

            var desc = createSetting('Description', descInput);
            var title = createSetting('Title', titleInput);
            var artist = createSetting('Artist', artistInput);

            if (artwork.Metadata.InfoFields) {
                $.each(artwork.Metadata.InfoFields, function (key, val) {
                    customInputs[key] = createTextInput(TAG.Util.htmlEntityDecode(val), "Metadata Field");
                    customSettings[key] = createSetting(key, customInputs[key]);
                });
            }


            settingsContainer.append(title);
            settingsContainer.append(artist);
            settingsContainer.append(desc);
            settingsContainer.append(yearMetadataDivSpecs.yearMetadataDiv);

            $.each(customSettings, function (key, val) {
                settingsContainer.append(val);
            });



            if (cancel) return;
            isLocked = TAG.Worktop.Database.getLocked();
            //Get locked artwork GUID
            var unlockedInput = createButton('Unlocked', function () {
                //if (localVisibility) { changesHaveBeenMade = true; };
                isLocked = "";
                unlockedInput.css('background-color', 'white');
                lockedInput.css('background-color', '');
            }, {
                'min-height': '0px',
                'margin-right': '4%',
                'width': '48%',
            });
            var lockedInput = createButton('Locked', function () {
                //if (!localVisibility) { changesHaveBeenMade = true; };
                isLocked = artwork.Identifier;
                lockedInput.css('background-color', 'white');
                unlockedInput.css('background-color', '');
            }, {
                'min-height': '0px',
                'width': '48%',
            });

            //Color the appropriate button
            if (isLocked === artwork.Identifier) {
                lockedInput.css('background-color', 'white');
            } else {
                unlockedInput.css('background-color', 'white');
            }

            var lockedDiv = $(document.createElement('div'));
            lockedDiv.append(lockedInput).append(unlockedInput);

            lockedInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });

            unlockedInput.click(function () {
                changesMade = true;
                saveButton.prop("disabled", false);
                saveButton.css("opacity", 1);
            });
            var lockedSetting = createSetting('Lock to this artwork', lockedDiv);
            settingsContainer.append(lockedSetting);


            //Automatically save changes
            //currentMetadataHandler = function () {
            //    if (titleInput.val() === undefined || titleInput.val() === "") {
            //        titleInput.val("Untitled Artwork");
            //    }
            //    saveArtwork(artwork, {
            //        artistInput: artistInput,                                      //Artwork artist
            //        nameInput: titleInput,                                         //Artwork title
            //        yearInput: $(yearMetadataDivSpecs.yearInput),                     //Artwork year or era
            //        monthInput: yearMetadataDivSpecs.monthInput,                   //Artwork month
            //        dayInput: yearMetadataDivSpecs.dayInput,                       //Artwork day
            //        timelineYearInput: yearMetadataDivSpecs.timelineYearInput,     //Artwork year on timeline
            //        timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,   //Artwork month on timeline 
            //        timelineDayInput: yearMetadataDivSpecs.timelineDayInput,       //Artwork day on timeline 
            //        descInput: descInput,                                          //Artwork description
            //        customInputs: customInputs                                    //Artwork custom info fields
            //    });
            //};

            // Create buttons
            editArt = createButton('Artwork Editor',
                function () { editArtwork(artwork); },
                {
                    'margin-left': '2%',
                    'margin-top': '1%',
                    'margin-right': '0%',
                    'margin-bottom': '3%',
                });
            leftButton = editArt;
            editArt.attr("id", "artworkEditorButton");
            var deleteArt = createButton('Delete',
                function () { deleteArtwork(artwork); },
                {
                    'margin-left': '2%',
                    'margin-top': '1%',
                    'margin-right': '0%',
                    'margin-bottom': '3%',
                });
            if (isLocked == artwork.Identifier) {
                deleteArt.prop("disabled", true);
                deleteArt.css({
                    "opacity": "0.5"
                });
            }
            var inputs = {
                artistInput: artistInput,                                      //Artwork artist
                nameInput: titleInput,                                         //Artwork title
                yearInput: $(yearMetadataDivSpecs.yearInput),                     //Artwork year or era
                monthInput: yearMetadataDivSpecs.monthInput,                   //Artwork month
                dayInput: yearMetadataDivSpecs.dayInput,                       //Artwork day
                timelineYearInput: yearMetadataDivSpecs.timelineYearInput,     //Artwork year on timeline
                timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,   //Artwork month on timeline 
                timelineDayInput: yearMetadataDivSpecs.timelineDayInput,       //Artwork day on timeline 
                descInput: descInput,                                          //Artwork description
                customInputs: customInputs                                    //Artwork custom info fields
            };
            saveButton = createButton('Save',
                function () {
                    if (titleInput.val() === undefined || titleInput.val() === "") {
                        titleInput.val("Untitled Artwork");
                    }
                    saveArtwork(artwork, {
                        artistInput: artistInput,                                      //Artwork artist
                        nameInput: titleInput,                                         //Artwork title
                        yearInput: $(yearMetadataDivSpecs.yearInput),                  //Artwork year or era
                        monthInput: yearMetadataDivSpecs.monthInput,                   //Artwork month
                        dayInput: yearMetadataDivSpecs.dayInput,                       //Artwork day
                        timelineYearInput: yearMetadataDivSpecs.timelineYearInput,     //Artwork year on timeline
                        timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,   //Artwork month on timeline 
                        timelineDayInput: yearMetadataDivSpecs.timelineDayInput,       //Artwork day on timeline 
                        descInput: descInput,                                          //Artwork description
                        locked: isLocked,                                                //Whether locked into artwork
                        customInputs: customInputs                                     //Artwork custom info fields
                    });
                }, {
                    'margin-right': '3%',
                    'margin-top': '1%',
                    'margin-bottom': '1%',
                    'margin-left': '.5%',
                    'float': 'right'
                }, true);

            var xmluploaderbtn = createButton('Upload XML',
                            function () {
                                uploadXML(artwork, inputs, settingsContainer);
                            },
                            {
                                'margin-left': '2%',
                                'margin-top': '1%',
                                'margin-right': '0%',
                                'margin-bottom': '3%',
                            });


            var thumbnailButton = createButton('Capture Thumbnail',
                function () {
                    saveThumbnail(artwork, true);
                }, {
                    'margin-right': '0%',
                    'margin-top': '1%',
                    'margin-bottom': '1%',
                    'margin-left': '2%',
                    'float': 'left'
                });
            thumbnailButton.attr('id', 'thumbnailButton');
            if (artwork.Metadata.Type !== 'VideoArtwork') {
                buttonContainer.append(editArt).append(deleteArt).append(saveButton).append(xmluploaderbtn); // for win8 aug 15 release only
            } else {
                buttonContainer.append(deleteArt).append(saveButton).append(xmluploaderbtn); // for win8 aug 15 release only
            }

            saveButton.on("mousedown", function () {
                if (!saveButton.attr("disabled")) {
                    saveButton.css({ "background-color": "white" });
                }
            });
            thumbnailButton.on("mousedown", function () {
                thumbnailButton.css({ "background-color": "white" });
            });
            xmluploaderbtn.on("mousedown", function () {
                xmluploaderbtn.css({ "background-color": "white" });
            });
            deleteArt.on("mousedown", function () {
                deleteArt.css({ "background-color": "white" });
            });
            editArt.on("mousedown", function () {
                editArt.css({ "background-color": "white" });
            });
            saveButton.on("mouseleave", function () {
                saveButton.css({ "background-color": "transparent" });
            });
            thumbnailButton.on("mouseleave", function () {
                thumbnailButton.css({ "background-color": "transparent" });
            });
            xmluploaderbtn.on("mouseleave", function () {
                xmluploaderbtn.css({ "background-color": "transparent" });
            });
            deleteArt.on("mouseleave", function () {
                deleteArt.css({ "background-color": "transparent" });
            });
            editArt.on("mouseleave", function () {
                editArt.css({ "background-color": "transparent" });
            });
            newButton.on("mouseleave", function () {
                newButton.css({ "background-color": "transparent" });
            });


            /*if (artwork.Metadata.Type !== 'VideoArtwork') {
                buttonContainer.append(editArt).append(deleteArt).append(saveButton).append(xmluploaderbtn); //SAVE BUTTON//
            } else {
                var convertBtn = createButton('Convert Video',
                        function () {
                            var source = artwork.Metadata.Source;
                            var newFileName = source.slice(8, source.length);
                            var index = newFileName.lastIndexOf(".");
                            var fileExtension = newFileName.slice(index);
                            var baseFileName = newFileName.slice(0, index);
                            if (artwork.Metadata.Converted !== "True") {
                                TAG.Worktop.Database.convertVideo(function () {
                                }, null, newFileName, fileExtension, baseFileName, artwork.Identifier);
                                conversionVideos.push(artwork.Identifier);
                                $("#videoErrorMsg").remove();
                                $("#leftLoading").remove();
                                var msg = "This video is being converted to compatible formats for different browsers";
                                viewer.append(TAG.Util.createConversionLoading(msg));
                                mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer, "False");
                                convertBtn.hide().data('disabled', true);
                            }
                        }, {
                            'margin-right': '0%',
                            'margin-top': '1%',
                            'margin-bottom': '3%',
                            'margin-left': '2%',
                            'float': 'left'
                        })
                convertBtn.attr('class', 'button convertVideoBtn');
                convertBtn.attr("disabled", "");
                if (artwork.Metadata.Converted !== "True" && conversionVideos.indexOf(artwork.Identifier) === -1) {
                    convertBtn.show().data('disabled', false);
                } else {
                    convertBtn.hide().data('disabled', true);
                }
                buttonContainer.append(thumbnailButton).append(saveButton).append(convertBtn).append(xmluploaderbtn).append(deleteArt); //SAVE BUTTON//
            }*/
        });
        cancelArtworkLoad = function () { cancel = true; };
    }

    /**Save Thumbnail image 
     * @method saveThumbnail
     * @param {Object} component
     * @param {Boolean} isArtwork
     */
    function saveThumbnail(component, isArtwork) {
        var id = $('#videoInPreview').attr('identifier');
        var pop = Popcorn('#videoInPreview');
        var time = $('#videoInPreview')[0].currentTime;
        var dataurl = pop.capture({ type: 'jpg' }); // modified popcorn.capture a bit to
        prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.uploadImage(dataurl, function (imageURL) {
            if (isArtwork) {
                TAG.Worktop.Database.changeArtwork(id, { Thumbnail: imageURL }, function () {
                    console.log("success?")
                    loadArtView(component.Identifier);
                }, unauth, conflict, error);
            
            } else { // here, it must be a video assoc media
                TAG.Worktop.Database.changeHotspot(id, { Thumbnail: imageURL }, function () {
                    console.log("success?");
                    loadAssocMediaView(component.Identifier);
                }, unauth, conflict, error);
            }
        }, unauth, error);
    }

    function unauth() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  You must log in to save changes.");
        $('body').append(popup);
        $(popup).show();
    }

    function conflict(jqXHR, ajaxCall) {
        ajaxCall.force();
    }

    function error() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, "Thumbnail not saved.  There was an error contacting the server.");
        $('body').append(popup);
        $(popup).show();
    }

    /**Create an artwork (import), possibly more than one
     * @method createArtwork
     */
    function createArtwork() {
        uploadFile(TAG.Authoring.FileUploadTypes.DeepZoom, function (urls, names, contentTypes, files) {
            var check, i, url, name, done=0, total=urls.length, durations=[], toScroll, alphaName;
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            function incrDone() {
                done++;
                if (done >= total) {
                    loadArtView(toScroll.Identifier);       //Scroll down to a newly-added artwork
                } else {
                    durationHelper(done);
                }
            }

            //////////
            if (files.length > 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === 'Video') {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }
            ///////////
            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                } catch (error) {
                    done++;
                    console.log("error in uploading: " + error.message);
                    return;
                }
                var ops = { Name: names[j] };
                if (durations[j]) {
                    ops.Duration = durations[j];
                }
                if (!alphaName || names[j] < alphaName) {
                    toScroll = newDoq;                          //Alphabetical order
                    alphaName = names[j];
                }
                TAG.Worktop.Database.changeArtwork(newDoq.Identifier, ops, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, "Update", incrDone)), error(incrDone));
                var source = newDoq.Metadata.Source;
                var newFileName = source.slice(8, source.length);
                var index = newFileName.lastIndexOf(".");
                var fileExtension = newFileName.slice(index);
                var baseFileName = newFileName.slice(0, index);
                if (contentTypes[j] === "Video") {
                    TAG.Worktop.Database.convertVideo(function () {
                    }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                }
                /*var source = newDoq.Metadata.Source;
                if (contentTypes[j] === "Video") {
                    var newFileName = source.slice(8, source.length);
                    var index = newFileName.lastIndexOf(".");
                    var fileExtension = newFileName.slice(index);
                    var baseFileName = newFileName.slice(0, index);
                    var confirmBox = TAG.Util.UI.PopUpConfirmation(function () {
                        TAG.Worktop.Database.convertVideo(function () {
                        }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                        conversionVideos.push(newDoq.Identifier);
                        var mediaElement = $(document.getElementById("videoInPreview"));
                        if (mediaElement[0]) {
                            var msg = "This video is being converted to compatible formats for different browsers";
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            $("#videoErrorMsg").remove();
                        }
                        $(".convertVideoBtn").hide().data("disabled", true);
                    }, "Would you like to convert " + newFileName + "?", "Yes", true, function () {
                        if (fileExtension !== ".mp4") {
                            var msg = "This video format has not been converted to formats supported in multiple browsers.";
                            viewer.append(LADS.Util.createConversionLoading(msg, true));
                        }
                        $(".convertVideoBtn").show().data("disabled", false);
                    });

                    root.append(confirmBox);
                    $(confirmBox).show();
                }*/
            }

        }, true, ['.jpg', '.png', '.gif', '.tif', '.tiff', '.mp4', '.webm', '.ogv','.avi','.mov','.wmv']);
    }
    /*upload xml for single artwork
   artwork
   inputs: all the input fields in the settingsContainer
   settingsContainer
   */
    function uploadXML(artwork, inputs, settingsContainer) {
        var parsingOverlay = $(TAG.Util.UI.blockInteractionOverlay()).addClass("parsingOverlay"),
            parsingOverlayText = $(document.createElement('label')).addClass("parsingOverlayText").text('Parsing Metadata file now. Please wait.'),
            parsingPicker = $(document.createElement('div')).addClass("parsingPicker"),
            parsingPickerHeader = $(document.createElement('div')).addClass("parsingPickerHeader").text("Please update the input fields below to match the input fields in your XML file."),
            parsingInfo = $(document.createElement('div')).addClass("parsingInfo"),
            parsingPickerConfirm = $(document.createElement('button')).attr("id", "parsingPickerConfirm").text("Confirm"),
            parsingPickerCancel = $(document.createElement('button')).attr("id", "parsingPickerCancel").text("Cancel"),
            curtitle = artwork.Name,
            curdata,
            isrightdata = false,
            customFields = [],
            mtinputs = {};
        parsingPickerConfirm.css('border-radius', '3.5px');
        parsingPickerCancel.css('border-radius', '3.5px');
        parsingOverlay.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);
        parsingOverlay.append(parsingOverlayText);
        parsingOverlayText.hide();

        parsingPicker.append(parsingPickerHeader);
        parsingPicker.append(parsingInfo);
        parsingPicker.append(parsingPickerCancel);
        parsingPicker.append(parsingPickerConfirm);

        parsingOverlay.append(parsingPicker);

        root.append(parsingOverlay);

        parsingOverlay.fadeIn();

        //Metadata input fields
        if (artwork.Metadata.InfoFields) {
            customFields = Object.keys(artwork.Metadata.InfoFields);
        };
        var metadataspec = {
            title: "title",
            description: "description",
            year: "year",
            artist: "artist",
            extra1: customFields[0] || "",
            extra2: customFields[1] || "",
            extra3: customFields[2] || "",
            extra4: customFields[3] || "",
        };
        $.each(metadataspec, function (key, val) {
            var input = createTextInput(val, "Metadata Field", null, false, false);
            var field = createSetting(key, input, null, '7px');
            field.addClass("metadataspec");
            $(field).css({
                'margin': '0px 0px 2px 0px',
                padding: '1% 7% 1% 1%',
                width:'92%',
            });
            $(field).children(":first").css({ color: 'white', 'font-style': 'normal', 'vertical-align': 'top' });
            $(field).children().eq(1).css({ margin: '0 auto', 'font-size':'60%'});
            mtinputs[key] = input;// { field: field, input: input };
            field.show().data('visible', true);
            parsingInfo.append(field);
        });

        //Confirm button
        parsingPickerConfirm.click(function () {
            //parsingPickerOverlay.fadeOut();
            $.each(metadataspec, function (key, val) {
                // update spec according to inputs val
                var newval = mtinputs[key].val();
                //if (newval !== val){// && newval!=="") {
                metadataspec[key] = newval;
                //}
            });
            parsingPicker.fadeOut();
            initFilepicker(metadataspec);
        });

        //Cancel button
        parsingPickerCancel.click(function () {
            parsingOverlay.fadeOut();
            parsingPickerCancel.disabled = true;
        });

        function initFilepicker(spec) {
            var filepicker = new Windows.Storage.Pickers.FileOpenPicker();
            filepicker.fileTypeFilter.replaceAll([".xml"]);
            filepicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.desktop;
            filepicker.pickSingleFileAsync().then(function (file) {
                if (!file) {
                    parsingOverlay.fadeOut();
                }
                if (file) {
                    parsingOverlayText.fadeIn();
                    var size;
                    var maxFileSize = 30 * 1024 * 1024;
                    var toparse;
                    file.getBasicPropertiesAsync().then(
                        function (basicProperties) {
                            size = basicProperties.size;
                            if (size < maxFileSize) {
                                toparse = true;
                                parsefile();
                            } else {
                                parsingOverlay.fadeOut();
                                var warningBox = TAG.Util.UI.PopUpConfirmation(function () {
                                    toparse = true;
                                    parsefile();
                                }, "The file is larger than 30MB. Parsing it might crash your computer. Are you sure you want to continue?", "Confirm", true, function () {
                                    toparse = false;
                                });
                                root.append(warningBox);
                                $(warningBox).show();
                                TAG.Util.multiLineEllipsis($($($(warningBox).children()[0]).children()[0]));
                            }

                            //picked the xml file and parse the strings
                            function parsefile() {
                                $.ajax({
                                    type: "GET",
                                    url: window.URL.createObjectURL(file),
                                    dataType: "xml",
                                    success: function (xml) {
                                        // Parse the xml file and get data
                                        var lists = [];
                                        var elements = xml.documentElement.childNodes;
                                        var i, curname;
                                        for (i = 0; i < elements.length; i++) {//each artwork
                                            if (isrightdata === false) {
                                                curname = elements[i].localName;
                                                if (curname !== null) {
                                                    var metadatas = elements[i].childNodes;
                                                    var list = {};
                                                    var j, name;
                                                    for (j = 0; j < metadatas.length; j++) {//each metadata field in the artwork
                                                        name = metadatas[j].localName;
                                                        if (name !== null) {
                                                            name = name.toLowerCase();
                                                            if (metadatas[j].childNodes[0]) {
                                                                list[name] = metadatas[j].childNodes[0].nodeValue;
                                                                if (name === spec.title && metadatas[j].childNodes[0].nodeValue === curtitle) {
                                                                    isrightdata = true;
                                                                }
                                                            } else {
                                                                list[name] = "";
                                                            }
                                                        }
                                                    }
                                                    lists.push(list);
                                                    if (isrightdata === true) {
                                                        curdata = list;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (isrightdata === true) {
                                            //find the match and update the artwork info using curdata
                                            //$(".parsingOverlay").fadeOut();
                                            updateArtwork(artwork, inputs, curdata, settingsContainer, spec);
                                            $(".parsingOverlay").remove();

                                        } else {//make a metadata picker for them to choose the metadata they want if no match found
                                            _metadatapicker(artwork, inputs, settingsContainer, lists, spec);
                                            $(".parsingOverlay").remove();

                                        }
                                    },
                                    error: function () {
                                        $(".parsingOverlay").remove();
                                        var popupmsg = TAG.Util.UI.popUpMessage(null, "Error occured when parsing xml. Please double check your file", "OK", null, null, null, true);
                                        $(popupmsg).show();
                                        root.append(popupmsg);
                                    }
                                });
                            }
                        });

                }
            });
            //$(".parsingOverlay").remove();
        }
    }
    /*update artwork inputs after parse xml file
    @param: artwork: the artwork you are going to update metadata for
        inputs: all the input fields on settingsContainer. 
        data: the metadata that is going to be updated for the artwork
    */
    function updateArtwork(artwork, inputs, data, settingsContainer, spec) {
        var counter = 0;//counter to keep track of customfields. now 4max
        var infoFields = {};
        var customSettings = {};

        var title = data[spec.title];
        var artist = data[spec.artist];
        var year = data[spec.year];
        var description = data[spec.description];
        var ele;
        var curval;
        if (!title)
            title = "";
        delete data[spec.title];
        delete spec.title;
        if (!year)
            year = "";
        delete data[spec.year];
        delete spec.year;
        if (!artist)
            artist = "";
        delete data[spec.artist];
        delete spec.artist;
        if (!description)
            description = "";
        delete data[spec.description];
        delete spec.description;
        $.each(spec, function (key, val) {
            if (val !== "") {
                infoFields[val] = "";
            }
        });
        if (Object.keys(data).length > 0) {//if there are more fields:
            $.each(infoFields, function (key, val) {
                curval = data[key];
                if (curval) {
                    delete data[key];
                    infoFields[key] = curval;
                }
                delete spec[key];
                counter++;
            });
            for (ele in data) {
                if (counter < 2) {
                    infoFields[ele] = data[ele];
                    // create input field for new cus field
                    inputs.customInputs[ele] = createTextInput(TAG.Util.htmlEntityDecode(data[ele]), "Metadata Field");
                    customSettings[ele] = createSetting(ele, inputs.customInputs[ele]);
                    counter++;
                }
            }

            $.each(customSettings, function (key, val) {
                settingsContainer.append(val);
            });

        }
        //$(".parsingOverlay").remove();
        prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.changeArtwork(artwork, {
            Name: title,
            Artist: artist,
            Year: year,
            Description: description,
            InfoFields: JSON.stringify(infoFields),
        }, function () {
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                return;
            }
            loadArtView(artwork.Identifier);
        }, authError, conflict(artwork, "Update", loadArtView), error(loadArtView));
    }
    /*a picker for user to choose metadata when nothing matches in the file
    @params: artwork: doq of artwork
            inputs: all the input fields in settingsContainer 
            settingsContainer: settingsContainer, passed in for adding new input later
            metadatalist: a list of metadata that parsed in xml file
    */
    function _metadatapicker(artwork, inputs, settingsContainer, metadatalist, spec) {
        var allTitles = {};
        var metadataPickerOverlay   = $(TAG.Util.UI.blockInteractionOverlay())  .addClass('metadataPickerOverlay');
        var metadataPicker          = $(document.createElement('div'))          .addClass("metadataPicker");
        var metadataPickerHeader    = $(document.createElement('div'))          .addClass('metadataPickerHeader')       .text("No match found. Please select the metadata you would like to import for '" + artwork.Name + "'.");
        var searchbar               = $(document.createElement('input'))        .addClass('metadataPickerSearchbar')    .attr('type', 'text');
        var metadataLists           = $(document.createElement('div'))          .addClass('metadataLists');
        var metadataInfos           = $(document.createElement('div'))          .addClass('metadataInfos');
        var metadataholder          = $(document.createElement('div'))          .addClass('metadataHolder');
        var fields = {};//fields to store all the metadata elements

        //get all metadata titles from metadatalist.
        var selectedmetadata;
        var i;
        var counter = 0;
        var curlast;
        var curlist = metadatalist;
        var infoSource = [];
        var info = "";
        init();
        metadataPickerOverlay.css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex);
        metadataPickerOverlay.append(metadataPicker);
        metadataPickerHeader.css({
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap',
            'overflow':'hidden'
        });
        TAG.Util.multiLineEllipsis(metadataPickerHeader);
        metadataPicker.append(metadataPickerHeader);

        //searchbar
        searchbar.css({
            'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")',
            'background-size': 'auto 50%',
            'background-repeat': 'no-repeat',
            'background-position': '8px center'
        });
        searchbar.on('click focus', function () { searchbar.css({ 'background-image': 'none' }); });
        searchbar.on('blur focusout', function () { (!searchbar.val()) && searchbar.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' }); });
        searchbar.on('keyup', function (event) {
            if (!searchbar.val()) {
                //init();
                metadataLists.empty();
                for (var i = 0; i < 30; i++) {
                    if (i < infoSource.length) {
                        var mtHolder = makemtholder(infoSource[i].title || "Untitled", i);
                    } else {
                        break;
                    }//set the first one selected once we firstly open the picker
                    if (i === 0) {
                        mtHolder.click();
                    }
                    counter++;
                }
            }
            if (event.which === 13) {
                doSearch();
            }
        });

        metadataPicker.append(searchbar);

        // creates a panel for all the metadata objects
        metadataPicker.append(metadataLists);
        metadataLists.bind('scroll', function () {
            if ($(this).scrollTop() + $(this).innerHeight() >= this.scrollHeight) {
                if (counter < curlist.length) {
                    var num = counter + 30 <= curlist.length ? 30 : curlist.length - counter;
                    for (var k = 0; k < num; k++) {
                        if (counter < curlist.length) {
                            makemtholder(allTitles[counter], counter);
                            counter++;
                        }
                    }
                }
            }
        })

        // creates a panel for all metadata's detailed info
        metadataPicker.append(metadataInfos);
        metadataInfos.append(metadataholder);
        

        //Method to display reset the metadata list and search information
        function init() {
            metadataLists.empty();
            infoSource = [];
            curlist = metadatalist;
            for (i = 0; i < metadatalist.length; i++) {
                info = "";
                $.each(metadatalist[i], function(index, element) {
                    info += element + " ";          //Put all the metadata in one string for searching purposes
                });
                var mt = metadatalist[i];
                var title = mt[spec["title"]];
                infoSource.push({
                    "id": i,
                    "keys": info.toLowerCase(),
                    "title": title||"Untitled",
                });
                if (!title)
                    title = "Untitled";
                allTitles[i] = title;                                          
                if (i < 30) {
                    var mtHolder = makemtholder(title, i);
                    //set the first one selected once we firstly open the picker
                    if (i === 0) {
                        mtHolder.click();
                    }
                    counter++;
                }
            };
        }
        
        //Actual search method
        function doSearch() {
            var content = searchbar.val();
            var searchResults = [];
            if(content){
                metadataLists.empty();
                counter = 0;
                content = content.toLowerCase();
                curlist = [];
                $.each(infoSource, function (index, element) {
                    if (element.keys.indexOf(content) > -1 || element.title.toLowerCase().indexOf(content) > -1) {
                        curlist.push(metadatalist[element.id])
                        if (counter < 30) {
                            var mtHolder = makemtholder(element.title, element.id);
                            if (counter === 0) {
                                mtHolder.click();
                            }
                            counter++
                        }
                    }
                });
            } else {
                //init();
                metadataLists.empty();
                counter = 0;
                curlist = metadatalist;
                for (var i = 0; i < 30; i++) {
                    if (i < infoSource.length) {
                        var mtHolder = makemtholder(infoSource[i].title || "Untitled", i);
                    } else {
                        break;
                    }//set the first one selected once we firstly open the picker
                    if (i === 0) {
                        mtHolder.click();
                    }
                    counter++;
                }
            }
            
        }
        function makemtholder(ttl, index) {
            var mtHolder = $(document.createElement('div')).addClass('mtHolder').attr('id', index).text(ttl)
                            .css({'white-space':'nowrap','overflow':'hidden','text-overflow':'ellipsis','font-size':'0.9em'});
            metadataLists.append(mtHolder);
            makemtClickable(mtHolder);
            return mtHolder;
        }

        //click function for each metadata element
        function makemtClickable(mtholder) {
            mtholder.click(function () {
                $(".mtHolder").css('background', 'black');
                mtholder.css('background', '#999');

                var selected = mtholder.attr('id');
                selectedmetadata = metadatalist[selected];
                if (selectedmetadata) {
                    $("#metadataPickerImport").attr('disabled', false);
                    for (var ele in fields) {//if there is already a field for that element, change the value and show it.
                        if (ele in selectedmetadata) {
                            fields[ele].input.val(selectedmetadata[ele]);
                            fields[ele].field.show().data('visible', true);
                        } else {
                            fields[ele].field.hide().data('visible', false);
                        }
                    }
                    for (var rest in selectedmetadata) {
                        //if there are extra fields, add them
                        if (!fields[rest]) {
                            var input = createTextInput(selectedmetadata[rest], "Metadata Field", null, false, true);
                            var field = createSetting(rest, input, null, '7px').addClass("metadataField").attr('title', rest);
                            field.css({
                                margin:  '0%',
                                padding: '1%',
                                width:   '98%'
                            });
                            $(field).children(":first").css({ color: 'white', 'font-style': 'normal', 'vertical-align': 'middle' });
                            fields[rest] = { field: field, input: input };
                            field.show().data('visible', true);
                            metadataholder.append(field);
                        }
                    }
                }
            });
        }



        var metadataPickerButtons = $(document.createElement('div')).attr("id", "metadataPickerButtons")
                                    .css({'height':'5%','bottom':'7%','width':'100%','position':'absolute'});
        var metadataPickerCancel = $(document.createElement('button')).attr("id", "metadataPickerCancel").css({ 'float': 'right', 'position': 'absolute', 'margin-right': '12%' }).css('border-radius', '3.5px');;
        metadataPickerCancel.text("Cancel");
        
        // cancel button click handler
        metadataPickerCancel.click(function () {
            metadataPickerOverlay.fadeOut();
            $('.metadataInfos').empty();
            metadataPickerCancel.disabled = true;
        });
        metadataPickerButtons.append(metadataPickerCancel);


        var metadataPickerImport = $(document.createElement('button')).attr("id", "metadataPickerImport").css({ 'float': 'right', 'position': 'absolute', 'margin-right': '2%' }).css('border-radius', '3.5px');;
        metadataPickerImport.attr('disabled', true);
        if (selectedmetadata)
            metadataPickerImport.attr('disabled', false);
        metadataPickerImport.text("Import");

        //import button click handler
        metadataPickerImport.click(function () {
            updateArtwork(artwork, inputs, selectedmetadata, settingsContainer, spec);
            $('.metadataInfos').empty();
            metadataPickerOverlay.fadeOut();
        });

        metadataPickerButtons.append(metadataPickerImport);
        metadataPicker.append(metadataPickerButtons);
        root.append(metadataPickerOverlay);
        $(".parsingOverlay").fadeOut();
        metadataPickerOverlay.fadeIn();
    }
    /**Edit an artwork
     * @method editArtwork
     * @param {Object} artwork   artwork to edit
     */
    function editArtwork(artwork) {
        if (!artwork) {
            return;
        }
        // Overlay doesn't spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay('Loading Artwork...', 1);
        middleQueue.clear();
        clearTimeout(checkConTimerId);
        rightQueue.clear();
        setTimeout(function () {
            TAG.Util.UI.slidePageLeft((TAG.Layout.ArtworkEditor(artwork)).getRoot());
        }, 1);
    }

    /**Delete an artwork
     * @method deleteArtwork
     * @param {Object} artwork      artwork to delete
     */
    function deleteArtwork(artwork) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the artwork
            TAG.Worktop.Database.deleteDoq(artwork.Identifier, function () {
                if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                    return;
                }
                loadArtView();
            }, authError, authError);
        }, "Are you sure you want to delete " + artwork.Name + "?", "Delete", true, function () { $(confirmationBox).hide() });
        root.append(confirmationBox);
        $(confirmationBox).show();
        TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
    }

    /**Save an artwork
     * @method saveArtwork
     * @param {Object} artwork      artwork to save
     * @param {Object} inputs       keys for artwork info from input fields
     */
    function saveArtwork(artwork, inputs) {
        var name = inputs.nameInput.val(),
            artist = inputs.artistInput.val(),
            year = inputs.yearInput.val(),
            month = inputs.monthInput.val(),
            day = inputs.dayInput.val(),
            timelineYear = inputs.timelineYearInput.val(),
            timelineMonth = inputs.timelineMonthInput.val(),
            timelineDay = inputs.timelineDayInput.val(),
            description = inputs.descInput.val(),
            isLocked = inputs.locked;

        var infoFields = {};
        $.each(inputs.customInputs, function (key, val) {
            infoFields[key] = val.val();
        });

        //pCL = displayLoadingSettings();
        //prepareNextView(false, null, null, "Saving...");
        clearRight();
        prepareViewer(true);
        prepareNextView(false, null, null, "Saving...");
        
        TAG.Worktop.Database.changeArtwork(artwork, {
            Name: name,
            Artist: artist,
            Year: year,
            Month: month,
            Day: day,
            TimelineYear: timelineYear,
            TimelineMonth: timelineMonth,
            TimelineDay: timelineDay,
            Description: description,
            Locked: isLocked,
            InfoFields: JSON.stringify(infoFields),
        }, function () {
            //refreshArtwork(artwork);
            //artworksIsLoading = false;
            //if (backButtonClicked && !(generalIsLoading || collectionsIsLoading ||
            //    artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don't continue if more sections are still loading - wait for them to finish
            //    backButtonClickHandler();
            //};
            //if (!backButtonClicked && (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.art.text])) {
            //    hideLoading();
            //    hideLoadingSettings(pCL);
            //    loadArtView(previousIdentifier); //eventually don't want this here? - reloads everything
            //};
            //hideLoading();
            //hideLoadingSettings(pCL);
            //saveArray.splice(saveArray.indexOf(artwork.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                LADS.Worktop.Database.getMain();
                return;
            }
            if (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.art.text]) {
                loadArtView(previousIdentifier);
                return;
            }
        }, authError, conflict(artwork, "Update", loadArtView), error(loadArtView)); 
    }

    // Feedback Functions:

    /**Loads Feedback view
     * @method loadFeedbackView
     * @param {Object} id   id of middle label to start on
     */
    function loadFeedbackView(id, matches) {

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = true;

        changesMade = false;

        var list;
        currentIndex = 0;

        prepareNextView(true, "");
        prepareViewer(false);
        clearRight();
        var cancel = false;

        //if (generalIsLoading || collectionsIsLoading ||
        //       artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
        //    hideLoading();
        //    hideLoadingSettings(pCL);
        //};
        //generalProgressCircle && hideLoadingSettings(generalProgressCircle);

        if (typeof matches !== "undefined") {
            list = matches;
            displayLabels();
        } else {
            // Make an async call to get feedback
            TAG.Worktop.Database.getFeedback(function (result) {
                if (cancel) return;
                sortDate(result);
                currentList = result;
                initSearch();
                list = result;
                displayLabels();
            });
        }

        function displayLabels() {
            $.each(list, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn't lock up
                middleQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                        return;
                    }
                    var label;
                    var text = $.datepicker.formatDate('(m/dd/yy) ', new Date(val.Metadata.Date * 1000)) + val.Metadata.Feedback;
                    if (!prevSelectedMiddleLabel &&
                        ((id && val.Identifier === id) || (!id && i === 0))) {
                        // Select the first one
                        middleLoading.before(selectLabel(label = createMiddleLabel(text, null, function () {
                            loadFeedback(val);
                            currentIndex = i;
                        }, val.Identifier, true)));

                        // Scroll to the selected label if the user hasn't already scrolled somewhere
                        if (middleLabelContainer.scrollTop() === 0 && label.offset().top - middleLabelContainer.height() > 0) {
                            middleLabelContainer.animate({
                                scrollTop: (label.offset().top - middleLabelContainer.height() / 2)
                            }, 1000);
                        }

                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        loadFeedback(val);
                    } else {
                        middleLoading.before(label = createMiddleLabel(text, null, function () {
                            loadFeedback(val);
                            currentIndex = i;
                        }, val.Identifier, true));
                    }

                });
            });
            // Hide the loading label when we're done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        }

        cancelLastSetting = function () { cancel = true; };
    }

    /** Loads feedback to right side of screen
     * @method loadFeedback
     * @param {Object} feedback     feedback to load
     */
    function loadFeedback(feedback) {
        clearRight();
        prepareViewer(true, feedback.Metadata.Feedback);
        deleteType = deleteFeedback;
        toDelete = feedback;

        var sourceLabel = createLabel('Loading...');
        var dateLabel = createLabel($.datepicker.formatDate('DD, MM d, yy ', new Date(feedback.Metadata.Date * 1000)));
        var source = createSetting('Submitted From', sourceLabel);
        var dateSetting = createSetting('Date', dateLabel);

        settingsContainer.append(source);
        var sourceType = feedback.Metadata.SourceType === "Exhibition" ? "Collection" : feedback.Metadata.SourceType;
        if (feedback.Metadata.SourceID) {
            getSourceName(feedback, function (sourceName) {
                sourceLabel.text(sourceName + ' (' + sourceType + ')');
                var sourceButton = createButton(sourceName + ' (' + sourceType + ')', function () {
                    followSource(feedback);
                });
                var sourceSetting = createSetting('Submitted From', sourceButton);
                source.remove();
                dateSetting.prepend(sourceSetting);
            }, function (sourceName) {
                sourceLabel.text(sourceName + ' (' + sourceType + ', Deleted)');
            }, function () {
                sourceLabel.text('Deleted');
            });
        } else {
            sourceLabel.text(sourceType + " Page (No " + sourceType + " Selected)");
        }
        settingsContainer.append(dateSetting);

        var deleteButton = createButton('Delete Feedback', function () {
            deleteFeedback(feedback);
        },
        {
            'margin-left': '2%',
            'margin-top': '1%',
            'margin-right': '0%',
            'margin-bottom': '3%',
        });
        leftButton = deleteButton;
        buttonContainer.append(deleteButton);
    }

    /**Get source of feedback
     * @method getSourceName
     * @param {Object} feedback     feedback to get source of
     * @param {Function} onSuccess  function called if source found
     * @param {Function} onDeleted  function called if source has been deleted
     * @param {Function} onError    function called if there is an error 
     */
    function getSourceName(feedback, onSuccess, onDeleted, onError) {
        TAG.Worktop.Database.getDoq(feedback.Metadata.SourceID,
            function (doq) {
                if (doq.Metadata.Deleted) {
                    onDeleted(doq.Name);
                } else {
                    onSuccess(doq.Name);
                }
            }, function () {
                onError();
            });
    }

    /**Switch view to source of feedback
     * @method followSource
     * @param {Object} feedback     feedback to follow source of
     */
    function followSource(feedback) {
        switch (feedback.Metadata.SourceType) {
            case "Exhibition":
            case "Exhibitions":
                switchView("Exhibitions", feedback.Metadata.SourceID);
                break;
            case "Tour":
            case "Tours":
                switchView("Tours", feedback.Metadata.SourceID);
                break;
            case "Art":
            case "Artwork":
            case "Artworks":
                switchView("Artworks", feedback.Metadata.SourceID);
                break;
        }
    }

    /**Delete a feedback
     * @method deleteFeedback
     * @param {Object} feedback     feedback to delete
     */
    function deleteFeedback(feedback) {
        prepareNextView(false);
        clearRight();

        // actually delete the feedback
        TAG.Worktop.Database.deleteDoq(feedback.Identifier, function () {
            if (prevSelectedSetting && prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                return;
            }
            loadFeedbackView();
        }, authError, conflict(feedback), error(loadFeedbackView));
    }

    //Middle Bar Functions:

    /**Create a middle label 
     * @method createMiddleLabel
     * @param  {String} text            the text of the label
     * @param imagesrc                  the source for the image. If not specified no image added
     * @param {Function} onclick        the onclick function for the label
     * @param {Object} id               id to set if specified
     * @param {Function} onDoubleClick  function for double click
     * @param {Boolean} inArtMode 
     * @param extension                 to check if is video or static art
     * @return {Object} container       the container of the new label
     */
    function createMiddleLabel(text, imagesrc, onclick, id, noexpand, onDoubleClick, inArtMode, extension) {
        var container = $(document.createElement('div'));
        text = TAG.Util.htmlEntityDecode(text);
        container.attr('class', 'middleLabel');
        if (id) {
            container.attr('id', id);
        }

        if (inArtMode) {
            if (extension.match(/mp4/) || extension.match(/ogv/) || extension.match(/webm/) || extension.match(/avi/) || extension.match(/mov/)) {
                container.data('isVideoArtwork', true);
            } else {
                container.data('isStaticArtwork', true);
            }
        }

        container.mousedown(function () {
            container.css({
                'background': HIGHLIGHT
            });
        });
        container.mouseup(function () {
           container.css({
                'background': 'transparent'
            });
        });
        container.mouseleave(function () {
            container.css({
                'background': 'transparent'
            });
        });
        container.click(function () {
            //if (prevSelectedMiddleLabel == container) {
            //    return;
            //} else {
            //    changesHaveBeenMade && currentMetadataHandler && saveQueue.add(currentMetadataHandler());
            //    changesHaveBeenMade = false;
            //}
            //autosave for general settings - switching between customization and password settings
            //if (inGeneralView && changesHaveBeenMade) {
            //    currentMetadataHandler && saveQueue.add(currentMetadataHandler());
            //    changesHaveBeenMade = false;
            //    //generalProgressCircle && hideLoadingSettings(generalProgressCircle);
            //}
            TAG.Util.removeYoutubeVideo();
            resetLabels('.middleLabel');
            selectLabel(container, !noexpand);
            if (onclick) {
                onclick();
            }
            prevSelectedMiddleLabel = container;
            currentSelected = container;
        });
        if (onDoubleClick) {
            container.dblclick(onDoubleClick);
        }
        var width;

        // BUILD VERTICAL CENTERING HELPER FUCK YEAH
        var helper = $(document.createElement('span'));
        helper.css({
            'display' : 'inline-block',
            'height': '100%',
            'vertical-align': 'middle'
        });
        container.append(helper);

        // build image if it exists WHICH WILL BE VERTICALLY CENTERED FUCK YEAH
        if (imagesrc) {
            var imageParent = $(document.createElement('div'))
            .css({
                'display': 'inline-block',
                'vertical-align': 'middle',
                'height': '100%',
                'width': '20%',
                'position': 'relative',
                'margin': 'auto 3% auto 1%'
            });
            container.append(imageParent);
            var image = $(document.createElement('img'));
            image.attr('src', imagesrc);
            image.css({
                'margin': 'auto auto auto',
                'height': 'auto',
                'max-width': '100%',
                'max-height': '100%',
                'display': 'block',
                'position': 'absolute',
                'width': 'auto',
                'left': '0',
                'right': '0',
                'top': '0',
                'bottom': '0'
            });
            imageParent.append(image);

            var progressCircCSS = {
                'position': 'absolute',
                'left': '5%',
                'z-index': '50',
                'height': 'auto',
                'width': '10%',
                'top': '20%'
            };
            var circle = TAG.Util.showProgressCircle(container, progressCircCSS, '0px', '0px', false);
            image.load(function () {
                TAG.Util.removeProgressCircle(circle);
            });
            width = '70%';
        } else {
            width = '90%';
        }

        // build text label WHICH WILL ALSO BE VERTICALLY CENTERED FUCK YEAH
        var label = $(document.createElement('div'));
        label.attr('class', 'labelText');
        label.css({
            'width': width,
            'vertical-align': 'middle'
        });

        if (!imagesrc) {
            label.css({
                'padding-left': '4%'
            });
        } else {
            label.css({
                'padding-left': '2%'
            });
        }

        label.text(text);

        container.append(label);

        return container;
    }

    /**Set up the middle bar for the next view
     * @method prepareNextView
     * @param {Boolean} showSearch      if true show search bar, otherwise hide
     * @param {String} newText          text for the 'New' button
     * @param {Function} newBehavior    onclick function for the 'New' button
     * @param {String} loadingText      Text to display while middle bar loading
     */
    function prepareNextView(showSearch, newText, newBehavior, loadingText) {
        TAG.Util.removeYoutubeVideo();
        clearInterval(checkConTimerId);
        middleQueue.clear();
        middleLabelContainer.empty();
        middleLabelContainer.append(middleLoading);
        middleLoading.show();
        secondaryButton.css("display", "none");

        if (showDropdown) {
            menuLabel.click();
        }

        if (!inAssociatedView) {
            menuLabel.hide();
            searchbar.css({ width: '53%' });
            newButton.text(newText);
            newButton.unbind('click').click(newBehavior);
            if (!newText) newButton.hide();
            else newButton.show();
        } else {
            newButton.hide();
            searchbar.css({width:'40%'});
            menuLabel.show();
        }

        prevSelectedMiddleLabel = null;
        if (cancelLastSetting) cancelLastSetting();

        if (loadingText) {
            middleLoading.children('label').text(loadingText);
        } else {
            middleLoading.children('label').text('Loading...');
        }

        if (showSearch) {
            searchContainer.show();
            searchContainer.css('display', 'inline-block');
            searchbar.css({ 'background-image': 'url("' + tagPath + '/images/icons/Lens.svg")' });
        } else {
            searchContainer.hide();
        }
    }

    /**Clears the right side
     * @method clearRight
     */
    function clearRight() {
        settingsContainer.empty();
        buttonContainer.empty();
        rightQueue.clear();
        $(".leftLoading").remove();
    }

    /**Prepares the viewer on the right side
     * @method prepareViewer
     * @param {Boolean} showViewer    whether the preview window is shown 
     * @param {String} text           text to add to the viewer (in a textbox)
     * @param {Boolean} showButtons   whether the buttonContainer is shown
     */
    function prepareViewer(showViewer, text, showButtons) {
        TAG.Util.removeYoutubeVideo();
        viewer.empty();
        viewer.css('background', 'black');
        if (showViewer) {
            viewer.show();
            buttonContainer.show();
            buttonContainer.css({
                'top': $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + 'px',
                'margin-top': '0.35%',
            });
            settings.css({
                'height': getSettingsHeight() + 'px',
            });
            if (text) {
                var textbox = $(document.createElement('textarea'));
                if (typeof text == 'string')
                    text = text.replace(/<br \/>/g, '\n').replace(/<br>/g, '\n').replace(/<br\/>/g, '\n');
                textbox.val(text);
                textbox.css({
                    'padding': '.5%',
                    'width': '100%',
                    'height': '100%',
                    'box-sizing': 'border-box',
                    'margin': '0px',
                });
                textbox.attr('readonly', 'true');
                viewer.append(textbox);
                viewer.css('background', 'transparent');
            } else {
                viewer.css('background', 'black');
            }
        } else {
            viewer.hide();
            settings.css({
                'height': ($(window).height() * CONTENT_HEIGHT / 100) -
                (BUTTON_HEIGHT * 1) + 'px',
            });
        }
        if (showButtons===false){
            buttonContainer.hide();
        }
    }

    //Helper methods for label interaction:

    /**Clicks an element determined by a jquery selector when it is added to the page
     * @method clickWhenReady
     * @param selector
     * @param maxtries
     * @param tries
     */
    function clickWhenReady(selector, maxtries, tries) {
        doWhenReady(selector, function (elem) { elem.click(); }, maxtries, tries);
    }

    /** Calls passed in function when the element determined by the selector
     *  is added to the page
     * @method doWhenReady
     * @param {Object} selector     class or id of object(s) on which fn is performed     
     * @param {Function} fn
     * @param maxtries
     * @param tries
     */
    function doWhenReady(selector, fn, maxtries, tries) {
        maxtries = maxtries || 100;
        tries = tries || 0;
        if (tries > maxtries) return;
        if ($.contains(document.documentElement, $(selector)[0])) {
            fn($(selector));
        } else {
            rightQueue.add(function () {
                doWhenReady(selector, fn, maxtries, tries + 1);
            });
        }
    }

    /**Reset mouse interaction for labels
     * @method resetLabels
     * @param {Object} selector     class of labels to reset
     */
    function resetLabels(selector) {
        
        $(selector).css('background', 'transparent');
        $.each($(selector), function (i, current) {
            
            if ($(current).attr('disabled') === 'disabled') {
                return;
            }
            
            $(current).mousedown(function () {
                
                $(current).css({
                    'background': HIGHLIGHT
                });
            });
            $(current).mouseup(function () {
                
                $(current).css({
                    'background': 'transparent'
                });
            });
            $(current).mouseleave(function () {
                
                $(current).css({
                    'background': 'transparent'
                });
            });
        });
    }

    /**Select a label by unbinding mouse events and highlighting
     * @method selectLabel
     * @param {Object} label    label to select
     * @param {Boolean} expand  if label expands when selected 
     * @param {Integer} index   index of the selected label in it's relvant list.  
     * @return {Object} label   selected label   
     */
    function selectLabel(label, expand) {
        label.css('background', HIGHLIGHT);
        label.unbind('mousedown').unbind('mouseleave').unbind('mouseup');
        
        if (expand) {
            label.css('height', '');
            label.children('div').css('white-space', '');

            if (prevSelectedMiddleLabel) {
                prevSelectedMiddleLabel.children('div').css('white-space', 'nowrap');
            }
        }
        return label;
    }

    /**Disable a label, unbinding mouse events
     * @method disableLabel
     * @param {Object} label         label to disable
     * @return {Object} label        disabled label
     */
    function disableLabel(label) {
        label.css({
            'color': 'gray',
        });
        label.unbind('mousedown').unbind('mouseleave').unbind('mouseup').unbind('click').attr('disabled', true);
        return label;
    }

   
    //Settings functions:

    /**Gets the height of the settings section since the viewer has to be positioned absolutely,
     *the entire right bar needs to be position absolutely. Settings has bottom: 0, so the height needs to be correct
     * to not have this be under the buttons container.  If any of the heights of the right components changes it should be
     * updated here.
     * @method getSettingsHeight
     * @return height       appropriate height for settings
     */
    function getSettingsHeight() {
        var height =
        // Start with the entire height of the right side
        ($(window).height() * CONTENT_HEIGHT / 100) -
        // Subtract:
        (
            // Height of the viewer
            $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO +
            // Height of the button container
            BUTTON_HEIGHT * 1 +
            // Height of the padding of the button container
            $(window).width() * RIGHT_WIDTH / 100 * 0.0285
        );
        return height;
    }

    /**Creates a setting to be inserted into the settings container
     * @method createSetting
     * @param {String} text     text for the setting
     * @param {Object} input    the input for the setting
     * @param width             if not falsey then assumed to be number represengint percent, must be less than 95
     * @return container        container of new setting
     */
    function createSetting(text, input, width, labelLeft, timeline) {
        var container = $(document.createElement('div'));
        var mb = "4%";
        if (timeline){
            mb = "0%";
        }
        container.css({
            'width': '100%',
            'margin-bottom': mb
        });

        var label = $(document.createElement('div'));
        label.css({
            //'font-size': SETTING_FONTSIZE,
            'width': width ? 45 - (width - 50) + '%' : '45%',
            'overflow': 'hidden',
            'text-overflow': 'ellipsis',
            'font-style': 'italic',
            'display': 'inline-block',
            'margin-left': labelLeft,
        });
        label.text(text);

        if (width) {
            width = width + '%';
        } else {
            width = '50%';
        }
        input.css({
            'width': width,
            //'font-size': INPUT_FONTSIZE,
            'float': 'right',
            'margin-right': '3%',
            'box-sizing': 'border-box',
        });

        var clear = $(document.createElement('div'));
        clear.css('clear', 'both');

        container.append(label);
        container.append(input);
        container.append(clear);

        return container;
    }

    //Helper functions:


    /* Create a linked year metadata input div 
    * @method createYearMetadataDiv
    * @param {Object} work                      artwork or media you are editting
    * @param {Object} saveButton                jQuery DOM object representing the save button to be enabled when settings are changed
    * @return {Object} yearMetadataDivSpecs     div with year and timeline year options, list of input fields
    */
    function createYearMetadataDiv(work, callback){
        
        var yearInput,
            monthInput,
            dayInput,
            timelineInputText,
            timelineYearInput,
            timelineYearJustChanged = false,
            timelineMonthInput,
            timelineDayInput,
            timelineYearDiv = $(document.createElement('div')).addClass('timelineYearDiv'),
            yearDiv = $(document.createElement('div')).addClass('yearDiv'),
            year,
            month,
            day,
            timelineYear,
            timelineMonth,
            timelineDay,
            timelineYearAutofilled = false,
            timelineYearAllowed = true,
            yearMetadataDiv= $(document.createElement('div')).addClass('yearMetadataDiv'),
            yearMetadataDivSpecs;

        //Create input boxes: 
        yearInput = createTextInput(TAG.Util.htmlEntityDecode(work.Metadata.Year), "Enter valid year", 100);
        var yearDescriptionDiv = $(document.createElement('div'));
        monthInput = createSelectInput(getMonthOptions(yearInput.attr('value')), work.Metadata.Month);
        monthInput.css('margin-right', '0%');
        dayInput = createSelectInput(getDayOptions(monthInput.attr('value'),yearInput,monthInput), work.Metadata.Day);
        dayInput.css('margin-right', '0%');
        timelineInputText = work.Metadata.TimelineYear || getTimelineInputText(yearInput);
        timelineYearInput = createTextInput(timelineInputText, "Enter valid year", 100);

        timelineMonthInput = createSelectInput(getMonthOptions(timelineYearInput.attr('value')),work.Metadata.TimelineMonth);
        timelineMonthInput.css('margin-right','0%');
        timelineDayInput = createSelectInput(getDayOptions(timelineMonthInput.attr('value'),timelineYearInput,timelineMonthInput), work.Metadata.TimelineDay);
        timelineDayInput.css('margin-right', '0%');
        yearInput.attr('id', 'yearInput');
        //Add focus to inputs:
        yearInput.focus(function () {
            if (yearInput.val() === 'Year'){
                yearInput.select();
            }
        });
        monthInput.focus(function(){
            if (monthInput.val() === 'Month'){
                monthInput.select();
            }
        });
        dayInput.focus(function(){
            if (dayInput.val() === 'Day'){
                dayInput.select();
            }
        });
        timelineYearInput.focus(function(){
            if (timelineYearInput.val() === 'Date on Timeline'){
                timelineYearInput.select();
            }
        });
        timelineMonthInput.focus(function(){
            if (timelineMonthInput.val() === "Month"){
                timelineMonthInput.select();
            }
        });
        timelineDayInput.focus(function(){
            if (timelineDayInput.val() === "Day"){
                timelineDayInput.select();
            }
        });

        //Set up year div:
        //TO-DO: add (?) icon w/ pop-up
        yearDiv.css({
            width : '100%',
            height : '20px'
        });
        year = createSetting('Year', yearInput, 60, null, true);
        year.css({
            width: '32%',
            display: 'inline-block',
            position: 'relative',
            'float': 'left'
        });
        month = createSetting('Month', monthInput, 60, null, true);
        month.css({
            width: '32%',
            'padding-left': '1%',
            'position':'relative',
            display: 'inline-block',
            'float': 'left'
        });
        toggleAllow(monthInput);
        day = createSetting('Day', dayInput, 70, null, true);
        day.css({
            width: '30%',
            'padding-left': '2%',
            'position': 'relative',
            display: 'inline-block',
            'float': 'left'
        });
        toggleAllow(dayInput);
        yearDiv.append(year)
               .append(month)
               .append(day);

        //Set up timeline year div:
        //TO-DO add (?) icon w/ pop-up
        timelineYearDiv.css({
            width: '100%',
            height: '20px',
            'padding-top':'2%'
        });
        timelineYear = createSetting('Date on Timeline', timelineYearInput, 40);
        timelineYear.css({
            width: '44%',
            display: 'inline-block',
            position: 'relative',
            'float': 'left'
        });
        timelineMonth = createSetting('Month', timelineMonthInput, 50);
        timelineMonth.css({
            width: '25%',
            'padding-left': '1%',
            'position': 'relative',
            display: 'inline-block',
            'float': 'left'
        });
        toggleAllow(timelineMonthInput);
        timelineDay = createSetting('Day', timelineDayInput, 60);
        timelineDay.css({
            width: '25%',
            'padding-left': '2%',
            'position': 'relative',
            display: 'inline-block',
            'float': 'left'
        });
        toggleAllow(timelineDayInput);
        timelineYearDiv.append(timelineYear)
                       .append(timelineMonth)
                       .append(timelineDay);

        yearDescriptionDiv.css({
            'width': '60%',
            'height': '10%',
            'position': 'relative',
            'font-size': '70%',
            'font-style': 'italic',
            'top': '-10px',
            'white-space': 'nowrap',
            'display':'inline-block'
        });
        yearDescriptionDiv.text("Year Format Examples:  2013, 800 BC, 17th century, 1415-1450");
        yearInput.on('keyup', function (event) {
            callback(event)
        });
        timelineYearInput.on('keyup', function (event) {
            callback(event)
        });
        //Link input values of date fields to dynamically change/disable               
        yearInput.on('input', function (event) {
            callback(event);
            setOptions(monthInput, getMonthOptions(yearInput.attr('value')),'');
            toggleAllow(monthInput);
            setOptions(dayInput, getDayOptions(monthInput.attr('value'),yearInput,monthInput));
            toggleAllow(dayInput);
            if (!timelineYearJustChanged|| timelineYearInput.val()===''){
                timelineYearInput.val(getTimelineInputText(yearInput));

                timelineYearJustChanged = false;
                setOptions(timelineMonthInput, getMonthOptions(timelineYearInput.attr("value")));
                toggleAllow(timelineMonthInput);
                setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr("value"),timelineYearInput,timelineMonthInput));
                toggleAllow(timelineDayInput);
            }
            timelineYearAutofilled = false;
        });
        monthInput.change(function () {
            callback();
            setOptions(dayInput,getDayOptions(monthInput.attr("value"),yearInput,monthInput),dayInput.attr('value'));
            toggleAllow(dayInput);
            if (timelineMonthInput.attr("value") === "") {
                timelineMonthInput.attr("value",monthInput.attr("value"));
                setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr("value"),timelineYearInput,timelineMonthInput));
                toggleAllow(timelineDayInput);
            }
        });
        dayInput.change(function () {
            callback();           
            if (timelineDayInput.attr("value")=== "" && timelineDayInput.dropDownOptions.length>1){
                timelineDayInput.attr("value", dayInput.attr("value"));
            };
        });
        timelineYearInput.on('input', function (event) {
            callback(event);            
            if (timelineYearInput.attr('value').length===0 && !timelineYearAutofilled){
                timelineYearInput.val(getTimelineInputText(yearInput));
                timelineMonthInput.val(monthInput.attr("value"));
                timelineDayInput.val(dayInput.attr("value"));
                timelineYearAutofilled = true;
            } 
            timelineYearJustChanged = true;
            if ( timelineYearInput.attr('value').length>0 &&!isSingleYear(timelineYearInput.attr('value'))){
                timelineYearAllowed = false;
                timelineYearInput.css({
                    'border-color': 'red',
                    'border-width' : 'medium',
                    'opacity' : '0.7'
                });
            } else {
                timelineYearAllowed = true;
                timelineYearInput.css({
                    'border-color' : '#a7b4ae',
                    'border-width': 'thin',
                    'opacity': '1'
                });
            }
            setOptions(timelineMonthInput, getMonthOptions(timelineYearInput.attr('value')),'');
            toggleAllow(timelineMonthInput, timelineYearAllowed);
            setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr('value'),timelineYearInput,timelineMonthInput),'');
            toggleAllow(timelineDayInput, timelineYearAllowed);
        });
        timelineMonthInput.change(function () {
            callback();
            setOptions(timelineDayInput,getDayOptions(timelineMonthInput.attr("value"),timelineYearInput,timelineMonthInput),timelineDayInput.attr('value'));
            toggleAllow(timelineDayInput, true);
        });

        //Set up year metadatadiv
        yearMetadataDiv.css({
            'width' : '100%'
        });

        yearMetadataDiv.append(yearDiv)
                       .append(yearDescriptionDiv)
                       .append(timelineYearDiv);

        yearMetadataDivSpecs = {
            yearMetadataDiv : yearMetadataDiv,
            yearInput : yearInput,
            monthInput: monthInput,
            dayInput: dayInput,
            timelineYearInput: timelineYearInput,
            timelineMonthInput: timelineMonthInput,
            timelineDayInput: timelineDayInput
        }

        return yearMetadataDivSpecs;

        //Helper functions:

        /*Get month options based on year
         * @method getMonthOptions
         * @param {String} year         year used to determine month options
         * @return {Array}              list of options to use in month drop down
         */
        function getMonthOptions(year){
            if (!isSingleYear(year)){
                return [''];
            } else {
                return ['','January','February','March','April','May','June','July','August','September','October','November','December'];
            }
        }

        /*Get input text for timeline year input
         * @method getTimelineInputText
         * @param {Object} yearInput        year input field
         * @return {String} timelineInputText   text to display in timelineYearInput 
         */
        function getTimelineInputText(yearInput){
            var timelineInputText = TAG.Util.parseDateToYear({ year : yearInput.attr('value')});
            if (timelineInputText){
                if (timelineInputText<0){
                    return -timelineInputText + ' BCE';
                }
                else {
                    return timelineInputText;
                }
            } else{
                return '';
            }
        }

        /* returns whether a date input is a single year
         * @method isSingleYear
         * @param {String} dateString      string to parse
         * @return {Boolean}               whether input string represents single year
         */
        function isSingleYear(dateString){
            //remove characters that are okay and white space
            dateString = dateString.replace(/bce?/gi,'')
                                   .replace(/ce/gi, '')
                                   .replace(/ad/gi, '')
                                   .replace(/,/g,'')
                                   .replace(/\s/gi,'');
            //dateString now cannot have non-numeric characters, except '-' at index 0 (for negative numbers) 
            if (dateString.search(/[^0-9]/)>0 || dateString.length===0 || dateString[0].search(/[0-9||-]/)<0){
                return false;
            } else {
                return true;
            }
        }
        
        /*Get day options based on month using test date
         * @method getDayOptions
         * @param {String} month
         * @return {Array} dayArray     array of day drop down options
         */
        function getDayOptions(month, yearIn, monthIn){
            var dayArray = [''],
                testDate,
                daysInMonth,
                i;
            if (month === '') { 
                return dayArray;
            }
            testDate = new Date(TAG.Util.parseDateToYear({year: yearIn.attr('value')}), monthIn.dropDownOptions.indexOf(month), 0);
            daysInMonth = testDate.getDate();
            for (i=1;i<daysInMonth+1;i++){
                dayArray.push(i);
            }
            return dayArray;
        }
        
        /*Set drop down options of a select input
         * @method setOptions()
         * @param {Object} select       select input
         * @param {Object} options      options to add to drop down
         * @param {String} value        selected value
         */
        function setOptions(select, options, value){
            var option,
                i;
            select.empty();
            select.dropDownOptions = options;
            for (i=0; i<options.length; i++) {
                option = $(document.createElement('option'));
                option.text(options[i]);
                option.attr('value', options[i]);
                select.append(option);
                options[i].selected = true;
            }
            select.attr('value', value);
        }

        /*Set styling of a select input based on if its allowed
        * @param {Object} select        select input to style
        * @param {Boolean} allowed      whether its allowed (optional)
        * @return {Boolean}             whether its allowed
        */
        function toggleAllow(select, allowed){
            if (select.dropDownOptions.length === 1 || allowed === "false"){
                select.css({
                    'background-color': 'gray',
                    'opacity' : '0.3',
                });
                return false;
            }
            else {
                select.css({
                    'background-color': 'white',
                    'opacity' : '1'
                });
                return true;
            } 
        }
    }

    /** Create a button 
     * @method createButton
     * @param {String} text         button text
     * @param {Function} onclick    onclick function for button
     * @param css                   additional css to apply to button if specified
     * @return {Object} button      new button created
     */
    function createButton(text, onclick, css, isSaveButton) {
        var button = $(document.createElement('button')).text(text).css('border-radius','3.5px');
        button.attr('type', 'button');
        button.attr('class','button');
        if (css) {
            button.css(css);
        }
        button.click(onclick);
        if (isSaveButton) {
            button.prop("disabled", true);
            button.css("opacity", "0.4");
        }
        return button;
    }

    /**Create a label
     * @method createLabel
     * @param {String} text         label text
     * @return {Object} label       new label created
     */
    function createLabel(text) {
        var label = $(document.createElement('label')).text(text || "");
        return label;
    }

    /**Create a text input
     * @method createTextInput
     * @param {String} text         the default text for the input
     * @param {Boolean} defaultval  if true, reset to default text if empty and loses focus
     * @param maxlength             max length of the input in characters
     * @param hideOnClick
     * @param {Boolean} onlyNumbers only numeric characters are allowed
     * @return input                newly created input
     */
    function createTextInput(text, defaultval, maxlength, hideOnClick, readonly, onlyNumbers) {
        var input = $(document.createElement('input')).val(text);
        onlyNumbers = onlyNumbers || false;
        /*input.on('keyup', function () {
            var txt = (input && input[0] && input[0].value) ? input[0].value.replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (input && input[0] && input[0].value && input[0].value!=txt) {
                input[0].value = txt;
            }
        });*/
        if (onlyNumbers) {
            input.on('keypress', function (event) {
                return (event.charCode >= 48 && event.charCode <= 57);
            });
        }
        if (defaultval) {
            input.attr("placeholder", defaultval);
        }
        input.attr('autocomplete', 'off');
        input.attr('spellcheck', 'false');
        input.addClass("searchBar");
        input.attr({
            'type': 'text',
            'maxlength': maxlength,
            'readonly': !!readonly
        });
        //input.on('change', function () { changesHaveBeenMade = true; }); //for autosaving
        return input;
    }

    /**Create a text area input 
     * @method createTextAreaInput
     * @param {String} text     default text for area
     * @param defaultval
     * @param hideOnClick
     * @return {Object} input    newly creted text input
     */
    function createTextAreaInput(text, defaultval, hideOnClick, maxLength) {
        if (typeof text === 'string') {
            text = text.replace(/<br \/>/g, '\n').replace(/<br>/g, '\n').replace(/<br\/>/g, '\n');
        }
        text = text.substring(0, 2001);
        var input = $(document.createElement('textarea')).val(text).attr({ 'id': 'settingsViewTextarea', 'maxlength': maxLength});
         input.css({
             'overflow': 'hidden',
         });
         /*input.bind('copy paste', function (e) {
             e.preventDefault();
         });*/
        //input.autoSize();
        doWhenReady(input, function (elem) {
            if (input[0].scrollHeight<=(root.find('#setViewSettingsContainer').height() * 0.5)){
                var realHeight = input[0].scrollHeight;
            }
            else{
                var realHeight= root.find('#setViewSettingsContainer').height() * 0.5;
            }
            $(input).css('height', realHeight + 'px');
        });
        input.on('keyup', function () {
            //var txt = (input && input.text()) ? input.text().replace(/[^àáâãäçèéêëìíîïñòóôõöùúûüýÿÀÁÂÃÄÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝ\w\s~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '') : "";
            if (input[0].scrollHeight <= (root.find('#setViewSettingsContainer').height() * 0.5)) {
                var realHeight = input[0].scrollHeight;
            }
            else {
                var realHeight = root.find('#setViewSettingsContainer').height() * 0.5;
            }
            /*if (input && input.text() && input.text()!=txt) {
                input.text(txt);
            }*/
            $(input).css('height', realHeight + 'px');
        });
        //input.on('change', function () { changesHaveBeenMade = true; }); //for autosaving
        return input;
    }

    /**Create a drop-down input element with a list to add options to
     * @method createSelectInput
     * @param {Array} options               list of options in the drop-down
     * @param {Object} value                current value of select menu
     * @return {HTML element} selectElt     element of type 'select'
     */
    function createSelectInput(options, value) {
        var selectElt = $(document.createElement('select')),
            option,
            i;
        selectElt.css({ 'overflow': 'scroll' });
        selectElt.dropDownOptions = options;
        for (i=0; i<options.length; i++) {
            option = $(document.createElement('option'));
            option.text(options[i]);
            option.attr('value', options[i]);
            selectElt.append(option);
            options[i].selected = true;
        }
        selectElt.change(function () {
            //$('.primaryFont').css('font-family', selectElt.find(":selected").text());
            //$('.secondaryFont').css('font-family', selectElt.find(":selected").text());
        });
        selectElt.attr('value', value);
        //selectElt.on('change', function () { changesHaveBeenMade = true; }); //for autosaving
        return selectElt;
    }

    /**Create a color input which modifies the background color
     * of all elements matching the jquery selector 'selector'.
     * @method creatBGColorInput 
     * @param color 
     * @param selectorBackground            jQuery selector for elements background to be changed
     * @param selectorText                  jQuery selector for color of text in the element to be changed
     * @param {Function} getTransValue      returns a valid transparency value  
     * @return {Object} container           returns container holding new input
     */
    function createBGColorInput(color, selectorBackground, selectorText, getTransValue) {
        if (color.indexOf('#') !== -1) {
            color = color.substring(1, color.length);
        }
        var container = $(document.createElement('input'));
        container.attr('type', 'text');
        var picker = new jscolor.color(container[0], {});
        var hex = TAG.Util.UI.colorToHex(color);
        container.val(color);
        picker.fromString(color);
        if (selectorText === ".secondaryFont"){
            secondaryColorPicker = picker;
        } else {
            primaryColorPicker = picker;
        }
        picker.onImmediateChange = function () {
            if(selectorText) {
                updateTextColor(selectorText, container.val());
            } 
            if(selectorBackground) {
                updateBGColor(selectorBackground, container.val(), getTransValue());
            }
            if (selectorText != ".secondaryFont") {
                $('#serverInput').css('border-color', '#' + container.val());
                $('#passwordInput').css('border-color', '#' + container.val());
                $('#serverSubmit').css('border-color', '#' + container.val());
                $('#passwordSubmit').css('border-color', '#' + container.val());
            } 
        };
        //container.on('change', function () { changesHaveBeenMade = true; }); //for autosaving
        return container;
    }

    /**Set the bg color of elements maching jquery selector 'selector'
     * @method updateBGColor 
     * @param selector          jQuery selector of elements to be changed
     * @param hex               hex value of color
     * @param trans             transparency of color
     */
    function updateBGColor(selector, hex, trans) {
        $(selector).css('background-color', TAG.Util.UI.hexToRGB(hex) + trans / 100.0 + ')');

    }

    /**Sets the text color of text in the jQuery selector passed in
     * @method updateTextColor
     * @param {HTML element} selector          jQuery selector, the color of text inside the selector is changed
     * @param {Hex Value} color                color passed in as a hex value
     */
    function updateTextColor(selector, color) {
        $(selector).css({ 'color': '#' + color });
    }

    /**Prevent a container from being clicked on by added a div on top of it
     * @method preventClickthrough
     * @param {Object} container     container to prevent click through of
     */
    function preventClickthrough(container) {
        var cover = document.createElement('div');
        $(cover).css({
            'height': '100%',
            'width': '100%',
            'float': 'left',
            'position': 'absolute',
            'background-color': 'white',
            'opacity': '0',
            'top': '0px',
            'right': '0px',
            'z-index': '499',
        });
        $(cover).bind('click', function () { return false; });
        $(container).append(cover);
    }

    /**Sort a list with propery Name alphabetically, case insensitive
     * @method sortAZ
     * @param {Object} list
     * @return 
     */
    function sortAZ(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aLower = a.Name.toLowerCase();
                var bLower = b.Name.toLowerCase();
                return (aLower < bLower) ? -1 : 1;
            });
        }
    }

    /**Sort a list with date metadata by date with most recent date first
     * @method sortDate
     * @param {Object} list 
     * @return 
     */
    function sortDate(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aint = parseInt(a.Metadata.Date, 10);
                var bint = parseInt(b.Metadata.Date, 10);
                if (aint < bint) {
                    return 1;
                } else if (aint > bint) {
                    return -1;
                } else {
                    return 0;
                }
            });
        }
    }

    /**Perform a search 
     * @method search
     * @param val           value to search for
     * @param selector      jQuery selector of elements to search
     * @param childType     selector's type
     */
    function search(val, selector, childType) {
        $.each($(selector), function (i, child) {
            if ($(child).attr('id') === 'middleLoading')
                return;
            if (TAG.Util.searchString($(child).children(childType).text(), val)) {
                $(child).show();
            } else {
                $(child).hide();
            }
        });
    }

    /**Search data
     * @param val       value to search for
     * @param selector  jQuery selector for elements to be searched
     */
    function searchData(val, selector) {
        $.each($(selector), function (i, element) {
            var data = $(element).data();
            var show = false;
            $.each(data, function (k, v) {
                if (TAG.Util.searchString(v, val)) {
                    show = true;
                }
            });
            if (show) {
                $(element).show();
            } else {
                $(element).hide();
            }
        });
    }

    /**Update text on change
     * @method onChangeUpdateText
     * @param {Object} input    input to update
     * @param selector          jQuery selector of element to update
     * @param maxLength         maximum text length in characters
     * @return {Object}         updated input
     */
    function onChangeUpdateText(input, selector, maxlength) {
        input.keyup(function () {
            if (input.val().length > maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, '<br />'));
        });
        input.keydown(function () {
            if (input.val().length > maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, '<br />'));
        });
        input.change(function () {
            if (input.val().length > maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, '<br />'));
        });
        return input;
    }

    /**Update a text input that takes in a number
     * @method onChangeUpdateNum
     * @param {Object} input            input to update
     * @param min                       minimum value of inputted number
     * @param max                       maximum value of inputted number
     * @param {Function} doOnChange     performed if input value is number between min and max   
     */
    function onChangeUpdateNum(input, min, max, doOnChange) {
        input.keyup(function () {
            var replace = input.val().replace(/[^0-9]/g, '');
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + '') {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.keydown(function () {
            var replace = input.val().replace(/[^0-9]/g, '');
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + '') {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.change(function () {
            var replace = input.val().replace(/[^0-9]/g, '');
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + '') {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
    }


    /**from JavaScript: The Good Parts
     * @method is_array
     * @param value         value to check
     * @return {Boolean}    if value is an array
     */
    function is_array(value) {
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /** Upload a file then calls the callback with the url and name of the file.
     * @method uploadFIle
     * @param type                  See TAG.Authoring.FileUploader for 'type' values
     * @param {Function} callback   
     * @param multiple              for batch upload
     * @param filter    
     */
    function uploadFile(type, callback, multiple, filter) {
        var names = [], locals = [], contentTypes = [], fileArray, i;
        TAG.Authoring.FileUploader( // remember, this is a multi-file upload
            root,
            type,
            // local callback - get filename
            function (files, localURLs) {
                fileArray = files;
                for (i = 0; i < files.length; i++) {
                    names.push(files[i].displayName);
                    var ext=files[i].fileType.toLowerCase();
                    if (files[i].contentType.match(/image/)) {
                        contentTypes.push('Image');
                    } else if (files[i].contentType.match(/video/) || ext === ".avi" || ext === ".wmv" || ext === ".mov" || ext === ".mp4" || ext === ".webm" || ext === ".ogv") {
                        contentTypes.push('Video');
                    } else if (files[i].contentType.match(/audio/)) {
                        contentTypes.push('Audio');
                    } else if (files[i].name.match('\.woff')) {
                        contentTypes.push('Font');
                    }
                }
            },
            // remote callback - save correct name
            function (urls) {
                if (!is_array(urls)) { // check to see whether a single file was returned
                    urls = [urls];
                    names = [names];
                }
                for (i = 0; i < urls.length; i++) {
                    console.log("urls[" + i + "] = " + urls[i] + ", names[" + i + "] = " + names[i]);
                }
                callback(urls, names, contentTypes, fileArray);
            },
            filter || ['.jpg', '.png', '.gif', '.tif', '.tiff', '.woff'],
            false,
            function () {
                root.append(TAG.Util.UI.popUpMessage(null, "There was an error uploading the file.  Please try again later."));
            },
            !!multiple // batch upload disabled
            );
    }

    /**Create an overlay over the whole settings view with a spinning circle and centered text. This overlay is intended to be used 
     * only when the page is 'done'.  The overlay doesn't support being removed from the page, so only call this when the page will 
     * be changed!
     * @method loadingOverlay
     * @param {String} text     Text defaults to 'Loading...' if not specified. 
     */
    function loadingOverlay(text, opacity) {
        text = text || "Loading...";
        var overlay = $(document.createElement('div'));
        var opacity = opacity || 0.5;
        overlay.css({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '100%',
            'height': '100%',
            'background-color': 'rgba(0,0,0,' + opacity + ')',
            'z-index': '1000',
        });
        root.append(overlay);

        var circle = $(document.createElement('img'));
        circle.attr('src', tagPath + 'images/icons/progress-circle.gif');
        circle.css({
            'height': 'auto',
            'width': '10%',
            'position': 'absolute',
            'left': '45%',
            'top': ($(window).height() - $(window).width() * 0.1) / 2 + 'px',
        });
        overlay.append(circle);

        var widthFinder = $(document.createElement('div'));
        widthFinder.css({
            'position': 'absolute',
            'visibility': 'hidden',
            'height': 'auto',
            'width': 'auto',
            'font-size': '200%',
        });
        widthFinder.text(text);
        root.append(widthFinder);

        var label = $(document.createElement('label'));
        label.css({
            'position': 'absolute',
            'left': ($(window).width() - widthFinder.width()) / 2 + 'px',
            'top': ($(window).height() - $(window).width() * 0.1) / 2 + $(window).width() * 0.1 + 'px',
            'font-size': '200%',
            'color': 'white',
        });
        widthFinder.remove();
        label.text(text);
        overlay.append(label);
    }
    
    /** Authentication error function
     * @method authError
     */
    function authError() {
        var popup = TAG.Util.UI.popUpMessage(function () {
            TAG.Auth.clearToken();
            rightQueue.clear();
            middleQueue.clear();
            TAG.Layout.StartPage(null, function (page) {
                TAG.Util.UI.slidePageRight(page);
            });
        }, "Could not authenticate, returning to the splash page.", null, true);
        root.append(popup);
        $(popup).show();
    }

    /**Error function
     * @method error
     * @param {Function} fn     function called if specified
     */
    function error(fn) {
        return function () {
            var popup = TAG.Util.UI.popUpMessage(null, "An unknown error occured.", null, true);
            root.append(popup);
            $(popup).show();
            fn && fn();
        }
    }

    /**Conflict function
    * @method conflict
    * @param doq            doq for which there is a conflict
    * @param {String} text      
    * @param fail
    */
    function conflict(doq, text, fail) {
        return function (jqXHR, ajaxCall) {
            var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                ajaxCall.force();
                // TODO: Text for change/delete
            }, "Your version of " + doq.Name + " is not up to date.  Are you sure you want to change " + doq.Name + "?", text, true, fail);
            root.append(confirmationBox);
            $(confirmationBox).show();
            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
        }
    }

    //function displayLoadingSettings() {
    //    settingsContainer.css({ visibility: 'hidden' });
    //    settings.css({ overflow: 'hidden' });
    //    buttonContainer.css({ visibility: 'hidden' });
    //    var changeLabel = createLabel('Changes are being saved...');
    //    changeLabel.attr('id', 'changeLabel');
    //    changeLabel.css({
    //        'position': 'absolute',
    //        'top': '15%',
    //        'z-index': '50',
    //        'height': 'auto',
    //        'width': '33%',
    //        'color': 'black',
    //        'font-size': '140%'
    //    });
    //    var progressCircCSS = {
    //        'position': 'absolute',
    //        'left': '40%',
    //        'top': '20%',
    //        'z-index': '50',
    //        'height': 'auto',
    //        'width': '20%'
    //    };
    //    var progressCL = LADS.Util.showProgressCircle(settings, progressCircCSS, '0px', '0px', true);
    //    settings.append(changeLabel);
    //    return progressCL;
    //};

    //function hideLoadingSettings(circle) {
    //    $('#changeLabel').remove();
    //    settingsContainer.css({ visibility: 'visible' });
    //    settings.css({ overflow: 'auto' });
    //    buttonContainer.css({ visibility: 'visible' });
    //    circle && LADS.Util.removeProgressCircle(circle);
    //};

    //function showLoading() {
    //    leftLabelContainer.empty();
    //    leftLabelContainer.append(createLeftLoading());
    //    buttonContainer.css({ visibility: 'hidden' });
    //    prepareViewer(true);
    //    pCircle2 = displayLoadingSettings();
    //};

    //function hideLoading() {
    //    buttonContainer.css({ visibility: 'visible' });
    //    hideLoadingSettings(pCircle2);
    //};

    //function backButtonClickHandler() {
    //    LADS.Auth.clearToken();
    //    rightQueue.clear();
    //    leftQueue.clear();
    //    $('#backButton').off('click');
    //    if (backPage) {
    //        var bpage = backPage();
    //        LADS.Util.UI.slidePageRight(bpage);
    //    } else {
    //        LADS.Layout.StartPage(null, function (page) {
    //            LADS.Util.UI.slidePageRight(page);
    //        });
    //    }
    //};

    //function refreshSplashScreen() {
    //    //console.log('\nsaveSplashScreen has finished.');
    //    TAG.Worktop.Database.getMain(function () {
    //        //console.log('reloading... ' + (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.general.text]));
    //        if (prevSelectedSetting && prevSelectedSetting === nav[NAV_TEXT.general.text]) {
    //            if (!(prevSelectedMiddleLabel && (prevSelectedMiddleLabel.text() === "Password Settings"))) {
    //                loadGeneralView(); //refreshes the general settings
    //            };
    //        };
    //    });
    //    saveQueue.isEmpty() && backButtonClicked && handleBackButtonClick();
    //}

    //function refreshExhibition(exhibition) {
    //    //console.log('\nsaveExhibition has finished.');
    //    TAG.Worktop.Database.getDoq(exhibition.Identifier, function (doq) {
    //        exhibition.label.text(doq.Name);
    //    });
    //    saveQueue.isEmpty() && backButtonClicked && handleBackButtonClick();
    //}

    //function refreshTour(tour) {
    //    //console.log('\nsaveTour has finished.');
    //    TAG.Worktop.Database.getDoq(tour.Identifier, function (doq) {
    //        tour.label.text(doq.Name);
    //    });
    //    saveQueue.isEmpty() && backButtonClicked && handleBackButtonClick();
    //}

    //function refreshAssocMedia(media) {
    //    //console.log('\nsaveAssocMedia has finished.');
    //    //TAG.Worktop.Database.getDoq(media.Identifier, function (doq) {
    //    //    media.label.text(doq.Name);
    //    //});
    //    saveQueue.isEmpty() && backButtonClicked && handleBackButtonClick();
    //}

    //function refreshArtwork(artwork) {
    //    //console.log('\nsaveArtwork has finished.');
    //    //TAG.Worktop.Database.getDoq(artwork.Identifier, function (doq) {
    //    //    artwork.label.text(doq.Name);
    //    //});
    //    saveQueue.isEmpty() && backButtonClicked && handleBackButtonClick();
    //}

    //function handleBackButtonClick() {
    //    TAG.Worktop.Database.getMain(function () {
    //        TAG.Auth.clearToken();
    //        rightQueue.clear();
    //        middleQueue.clear();
    //        backButton.off('click');
    //        if (backPage) {
    //            var bpage = backPage();
    //            TAG.Util.UI.slidePageRight(bpage);
    //        } else {
    //            TAG.Layout.StartPage(null, function (page) {
    //                TAG.Util.UI.slidePageRight(page);
    //            });
    //        }
    //        TAG.Util.UI.getStack()[0] = null;
    //    });
    //}

    function createDropdownAssocMediaMenu() {
        var addMenuLabel = $(document.createElement('button'))
            .attr('id', 'addMenuLabel')
            .appendTo(searchContainer)
            .css({
                "color": "black",
                'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex,
                'float':'right',
                'font-size':'50%',
                'height':'40%',
                'margin-top':'2.8%',
                'padding-bottom':'1%',
                'width': '48%',
                'border': '1px solid black',
                //'padding': '1.5% 0px 0px 0px',
                'padding-top':'-10%',
                'display': 'block',
            }).css('border-radius', '3.5px');
        var addMenuArrowIcon = $(document.createElement('img'))
            .attr('id', 'addMenuArrowIcon')
            .attr('src', tagPath + 'images/icons/RightB.png')
            .css({
                width: '6%',
                height: '70%',
                display:'inline-block',
                'margin-right': '5%',
                '-webkit-transform': 'rotate(90deg)',
                '-moz-transform': 'rotate(90deg)',
                '-o-transform': 'rotate(90deg)',
                '-ms-transform': 'rotate(90deg)',
                'transform': 'rotate(90deg)',
                'padding-left': '7%',
                'padding-right':'0%'
            })
        var addMenuLabelDiv = $(document.createElement('div'))
            .css({
                width:'80%',
                height: '100%',
                'text-align': 'center',
                'vertical-align': 'middle',
                'padding':'0px 10% 0px 10%'
            })
            .append($(document.createElement('div')).text('Add').css({
                'display': 'inline-block',
                'margin-right': '5%',
            }))
            .append(addMenuArrowIcon)
            .appendTo(addMenuLabel);
        var dropDown = $(document.createElement('div'))
            .attr('id', 'dropDown')
            .appendTo(searchContainer)
            .css({
                "left": '52%',
                "display":"block",
                "position": "relative",
                "color": "rgb(256, 256, 256)",
                'width': '48%',
                'background-color': 'rgba(0,0,0,0.95)',
                'float': 'left',
                'clear': 'left',
                'z-index': TAG.TourAuthoring.Constants.aboveRinZIndex,
                'border': '1px solid white',
            });
        dropDown.hide();
        addMenuLabel.click(function () {
            if (showDropdown) {
                $("#setViewMiddleLabelContainer").css('overflow', 'auto');
                addMenuLabel.css({ "background-color": "transparent" });
                addMenuArrowIcon.css({
                    '-webkit-transform': 'rotate(90deg)',
                    '-moz-transform': 'rotate(90deg)',
                    '-o-transform': 'rotate(90deg)',
                    '-ms-transform': 'rotate(90deg)',
                    'transform': 'rotate(90deg)',
                    'padding-left': '7%',
                    'padding-right': '0%'
                });
                dropDown.hide();
            } else {
                addMenuLabel.css({ "background-color": "white" });
                $("#setViewMiddleLabelContainer").css('overflow', 'hidden');
                addMenuArrowIcon.css({
                    '-webkit-transform': 'rotate(270deg)',
                    '-moz-transform': 'rotate(270deg)',
                    '-o-transform': 'rotate(270deg)',
                    '-ms-transform': 'rotate(270deg)',
                    'transform': 'rotate(270deg)',
                    'padding-left': '0%',
                    'padding-right':'7%'
                });
                dropDown.show();
            }
            showDropdown = !showDropdown;
        });

        var fromFile = $(document.createElement('label'))
            .attr('id', 'fromFile')
            .text('From File')
            .css({
                "display": "block",
                'border-color': 'white',
                'color': 'white',
                'background-color': 'black',
                //'border-style': 'solid',
                'border-width': 'thin',
                'border-bottom-style': 'none',
                'padding-left': '15px',
                'padding-right': '15px',
                'font-size': '85%',
                'font-weight': '600',
                'padding-bottom':'5%',
                'padding-top':'5%',
            })
            .on('mouseenter', function () {
                fromFile.css({
                    'background-color': 'white',
                    'color': 'black',
                    'border-color': 'black',
                });
            })
            .on('mouseleave', function (e) {
                fromFile.css({
                    'background-color': 'black',
                    'color': 'white',
                    'border-color': 'white',
                });
            })
            .click(function () {
                addMenuLabel.click();
                createAsset();
            });
        var iFrameAsset = $(document.createElement('label'))
            .attr('id', 'Embed Video')
            .text('Embed Video')
            .css({
                "display": "block",
                'border-color': 'white',
                'color': 'white',
                'background-color': 'black',
                //'border-style': 'solid',
                'border-width': 'thin',
                'padding-left': '15px',
                'padding-right': '15px',
                'font-size': '85%',
                'font-weight': '600',
                'padding-bottom': '5%',
                'padding-top': '5%',
            })
            .on('mouseenter', function () {
                iFrameAsset.css({
                    'background-color': 'white',
                    'color': 'black',
                    'border-color': 'black',
                });
            })
            .on('mouseleave', function (e) {
                iFrameAsset.css({
                    'background-color': 'black',
                    'color': 'white',
                    'border-color': 'white',
                });
            })
            .click(function () {
                addMenuLabel.click();
                createIframeSourceDialog();
            });
        dropDown.append(fromFile);
        dropDown.append(iFrameAsset);
        addMenuLabel.on("mousedown", function () {
            if (!showDropdown) {
                addMenuLabel.css({ "background-color": "white" });
            }            
        });
        addMenuLabel.on("mouseleave", function () {
            if (!showDropdown) {
                addMenuLabel.css({ "background-color": "transparent" });
            }
        });
       
        
        return addMenuLabel;
    }

    return that;
};
;
TAG.Util.makeNamespace('TAG.Authoring.FileUploader');

/**
 * Enum of file upload types
 */
TAG.Authoring.FileUploadTypes = {
    Standard: 0,
    DeepZoom: 1,
    AssociatedMedia: 2,
    VideoArtwork: 3,
    Map: 4
};

/**
 * Helper class for performing file uploads
 * Also creates HTML overlay that displays progress / spinning wheel
 * Note: everything is handled internally, no external API, does its thing then removes itself and disappears
 * @param root              Root of HTML, upload overlay will be appended to this while upload is running and removed when finished automatically!
 * @param type              Type of file upload (defined by FileUploadTypes)
 * @param localCallback     Callback passed local file info (args: <WinJS.StorageFile> file, <String> localURL)
 * @param finishedCallback  Callback to execute once upload is finished (standard args: <String> url; deepzoom args: <String> xmlDoq)
 * @param filters           Array of file types selectable by user
 * @param useThumbs         Use thumbnail view mode?
 * @param progressFunc      Function to keep track of progress (e.g. for displaying a progress bar somewhere)
 */
TAG.Authoring.FileUploader = function (root, type, localCallback, finishedCallback, filters, useThumbs, errorCallback, multiple, innerProgBar) {
    "use strict";
    var that = {};
    filters = filters || ["*"];
    multiple = multiple || false;


    var uploadingOverlay = $(document.createElement('div')),
        innerProgressBar = $(document.createElement('div')); // HTML upload overlay
    var filesFinished = 0;
    var numFiles = 100000;
    var dataReaderLoads = [];
    var uploadQueue = TAG.Util.createQueue();
    var globalUriStrings = [], globalFiles = [], globalUpload = null;
    var percentLoaded = 0;
    var totalBytesToSend = {}; // an entry for each upload object, indexed by guid
    var totalBytesSent = {};
    var promises = [];
    var globalFilesObject;
    var uploadFilesObject;
    var maxDuration = Infinity;
    var minDuration = -1;
    var size;
    var largeFiles = "";
    var longFiles = [];
    var shortFiles = [];
    var fileUploadError;
    var maxFileSize = 50 * 1024 * 1024;
    var maxVideoArtworkSize = 80 * 1024 * 1024;
    var maxDeepZoomFileSize = 250 * 1024 * 1024;

    // Basic HTML initialization
    (function init() {
        var uploadOverlayText = $(document.createElement('label')),
            progressIcon = $(document.createElement('img')),
            progressBar = $(document.createElement('div'));

        // Progress / spinner wheel overlay to display while uploading
        uploadingOverlay.attr("id", "uploadingOverlay");
        uploadingOverlay.css({ 'position': 'absolute', 'left': '0%', 'top': '0%', 'background-color': 'rgba(0, 0, 0, .5)', 'width': '100%', 'height': '100%', 'z-index': 100000100 });

        uploadOverlayText.css({ 'color': 'white', 'width': '10%', 'height': '5%', 'top': '38%', 'left': '40%', 'position': 'relative', 'font-size': '100%' });
        uploadOverlayText.text('Uploading file(s). Please wait.');

        progressIcon.css({
            'position': 'relative', 'top': '50%', 'left': '14%'
        });
        progressIcon.attr('src', 'images/icons/progress-circle.gif');

        progressBar.css({
            'position': 'relative', 'top': '42%', 'left': '45%', 'border-style': 'solid', 'border-color': 'white', 'width': '10%', 'height': '2%'
        });

        innerProgressBar.css({
            'background-color': 'white', 'width': '0%', 'height': '100%'
        });

        progressBar.append(innerProgressBar);
        uploadingOverlay.append(uploadOverlayText);
        uploadingOverlay.append(progressBar);
        uploadingOverlay.hide();
        root.append(uploadingOverlay);
    })();

    /**
     * Starts the file upload
     */
    (function uploadFile() {
        // Opens file picker
        var currentState = Windows.UI.ViewManagement.ApplicationView.value;        
        var filePicker = new Windows.Storage.Pickers.FileOpenPicker();
        if (useThumbs) {
            filePicker.viewMode = Windows.Storage.Pickers.PickerViewMode.thumbnail;
        } else {
            filePicker.viewMode = Windows.Storage.Pickers.PickerViewMode.list;
        }
        filePicker.fileTypeFilter.replaceAll(filters);
        filePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.desktop;
        try {
            if (multiple) { // batch upload
                filePicker.pickMultipleFilesAsync().then(
                    uploadFilesObject = function (filesObject) { // Now file has been picked
                            var uriStrings = [],
                                upload = new UploadOp(),
                                localURLs = [],
                                k, files = [],
                                //largeFiles = [],
                                hashedDate, newHashedDate; // local URL
                            globalFilesObject = filesObject;
                            totalBytesToSend = {};
                            totalBytesSent = {};
                            largeFiles = "";
                            longFiles = [];
                            shortFiles = [];
                            var bar = innerProgBar || innerProgressBar; // reset the width of the uploading bar
                            bar.width("0%");
                            if (filesObject.length === 0) {
                                removeOverlay();
                                addLocalCallback([], [])();
                                return;
                            }
                            // create an actual array out of the windows files object -- filter out files that are too large/long

                            function fileLimitHelper(file, i) {
                                file.getBasicPropertiesAsync().then(
                                    function (basicProperties) {
                                        size = basicProperties.size;

                                        numFiles = files.length; // global
                                        var maxSize;
                                        switch (type) {
                                            case TAG.Authoring.FileUploadTypes.VideoArtwork:
                                            case TAG.Authoring.FileUploadTypes.AssociatedMedia:
                                            case TAG.Authoring.FileUploadTypes.Standard:
                                                maxSize = maxFileSize;
                                                break;
                                            case TAG.Authoring.FileUploadTypes.DeepZoom:
                                                if (file.fileType === ".mp4" ||
                                                    file.fileType === ".ogv" ||
                                                    file.fileType === ".webm" ||
                                                    file.fileType === ".mov" ||
                                                    file.fileType === ".avi" ||
                                                    file.fileType === ".wmv") {
                                                    maxSize = maxVideoArtworkSize;
                                                    break;
                                                }
                                            case TAG.Authoring.FileUploadTypes.Map:
                                                maxSize = maxDeepZoomFileSize;
                                                break;
                                        }
                                        if (size < maxSize) {
                                            files.push(file);
                                            localURLs.push(window.URL.createObjectURL(file, { oneTimeOnly: true }));
                                            var ext = file.fileType.toLowerCase();
                                            switch (type) {
                                                case TAG.Authoring.FileUploadTypes.VideoArtwork:
                                                    uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadVideoArtwork&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    break;
                                                case TAG.Authoring.FileUploadTypes.AssociatedMedia:
                                                    uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadAssociatedMedia&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    break;
                                                case TAG.Authoring.FileUploadTypes.Standard:
                                                    uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUpload&Client=Windows&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    break;
                                                case TAG.Authoring.FileUploadTypes.DeepZoom:
                                                    if (ext === ".mp4" || ext === ".webm" || ext === ".avi" || ext === ".mov" || ext === ".ogv" || ext === ".wmv" ) {
                                                        uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadVideoArtwork&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    } else {
                                                        uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadDeepzoom&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    }
                                                    break;
                                                case TAG.Authoring.FileUploadTypes.Map:
                                                    uriStrings.push(TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadMap&Client=Windows&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1));
                                                    break;

                                            }
                                        }
                                        else {                                            
                                            largeFiles += ("<br />" + file.name);
                                        }
                                        
                                        // if we haven't hit all the files, keep going
                                        if (i < filesObject.length - 1) {
                                            fileLimitHelper(filesObject[i + 1], i + 1);
                                        } else if (i === (filesObject.length - 1)) { // here we've reached the end
                                            checkDurations(files, function () {
                                                var mins, secs;
                                                removeOverlay();
                                                addLocalCallback([], [])();
                                                //if(file.fileType.substr(1)!==".mp4")
                                                if (files.length === 0 && largeFiles !== '') { //no > time-limit files
                                                    //alert that all files failed.
                                                    fileUploadError = uploadErrorAlert(null, "The selected file(s) could not be uploaded because they exceed the 50MB file limit.", null);
                                                    $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                    $('body').append(fileUploadError);
                                                    $(fileUploadError).fadeIn(500);
                                                    return;
                                                }
                                                else if (files.length === 0 && longFiles.length > 0 && file.fileType !== ".webm" && file.fileType !== ".ogv") { // no > 50MB files
                                                    mins = Math.floor(maxDuration / 60);
                                                    secs = maxDuration % 60;
                                                    if (secs === 0) secs = '00';
                                                    else if (secs <= 9) secs = '0' + secs;

                                                    fileUploadError = uploadErrorAlert(null, "The selected file(s) could not uploaded because they exceed " + mins + ":" + secs + " in length.", null);

                                                    $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                    $('body').append(fileUploadError);
                                                    $(fileUploadError).fadeIn(500);
                                                    return;
                                                }
                                                else if (files.length === 0 && shortFiles.length > 0 && file.fileType !== ".webm"&&file.fileType !== ".ogv") { // no > 50MB files
                                                    mins = Math.floor(minDuration / 60);
                                                    secs = minDuration % 60;
                                                    if (secs === 0) secs = '00';
                                                    else if (secs <= 9) secs = '0' + secs;

                                                    fileUploadError = uploadErrorAlert(null, "The selected file(s) could not uploaded because they are shorter than " + mins + ":" + secs + " in length.", null);

                                                    $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                    $('body').append(fileUploadError);
                                                    $(fileUploadError).fadeIn(500);
                                                    return;
                                                }
                                                else if (files.length === 0 && file.fileType !== ".webm" && file.fileType !== ".ogv") {
                                                    mins = Math.floor(maxDuration / 60);
                                                    secs = maxDuration % 60;
                                                    if (secs === 0) secs = '00';
                                                    else if (secs <= 9) secs = '0' + secs;

                                                    fileUploadError = uploadErrorAlert(null, "The selected file(s) could not be uploaded because they exceed the 50MB file limit or exceed the " + mins + ":" + secs + " duration limit.", null);
                                                    $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                    $('body').append(fileUploadError);
                                                    $(fileUploadError).fadeIn(500);
                                                    return;
                                                }
                                                globalFiles = files;
                                                numFiles = files.length; // global
                                                globalUriStrings = uriStrings;
                                                globalUpload = upload;
                                                var localResult = localCallback(files, localURLs,
                                                    uploadStart(0, upload),
                                                    function () {
                                                        fileUploadError = uploadErrorAlert(null, "uploading canceled due to the unsupported format", null);
                                                        $(fileUploadError).css('z-index', LADS.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                        $('body').append(fileUploadError);
                                                        $(fileUploadError).fadeIn(500);
                                                    });

                                                if (localResult !== 'uploading test!') {
                                                    uploadStart(0, upload)();
                                                }
                                            });
                                        }

                                    }
                                );
                            }

                            fileLimitHelper(filesObject[0], 0);
                    });
            }
            else { // single upload
                filePicker.pickSingleFileAsync().then(
                    function (file) { // Now file has been picked

                        // error check
                        if (!file) {
                            removeOverlay();
                            addLocalCallback([], [], [])();
                        }
                        else {
                            file.getBasicPropertiesAsync().then(
                                   function (basicProperties) {
                                       size = basicProperties.size;

                                       var maxSize;
                                       switch (type) {
                                           case TAG.Authoring.FileUploadTypes.VideoArtwork:
                                           case TAG.Authoring.FileUploadTypes.AssociatedMedia:
                                           case TAG.Authoring.FileUploadTypes.Standard:
                                               maxSize = maxFileSize;
                                               break;
                                           case TAG.Authoring.FileUploadTypes.DeepZoom:
                                           case TAG.Authoring.FileUploadTypes.Map:
                                               maxSize = maxDeepZoomFileSize;
                                               break;
                                       }
                                       //50 MB size limit for standard, 250 MB size limit for deep zoom images
                                       if (size < maxSize) {
                                           checkDuration(file, function () {
                                               var uriString,
                                                   upload = new UploadOp(),
                                                   localURL; // local URL

                                               globalFiles = [file];
                                               numFiles = 1;

                                               localURL = window.URL.createObjectURL(file, { oneTimeOnly: true });
                                               var ext = file.fileType.toLowerCase();
                                               // Set specifics of request by type
                                               switch (type) {
                                                   case TAG.Authoring.FileUploadTypes.VideoArtwork:
                                                       uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadVideoArtwork&Client=Windows&ReturnDoq=true&Token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       break;
                                                   case TAG.Authoring.FileUploadTypes.AssociatedMedia:
                                                       uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadAssociatedMedia&Client=Windows&ReturnDoq=true&Token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       break;
                                                   case TAG.Authoring.FileUploadTypes.Standard:
                                                       uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUpload&Client=Windows&Token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       break;
                                                   case TAG.Authoring.FileUploadTypes.DeepZoom:
                                                       if (ext === ".mp4" ||ext === ".webm" || ext === ".avi" || ext === ".mov" || ext === ".ogv"||ext === ".wmv") {
                                                           uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadVideoArtwork&Client=Windows&ReturnDoq=true&Token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       } else {
                                                           uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadDeepzoom&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       }
                                                       break;
                                                   case TAG.Authoring.FileUploadTypes.Map:
                                                       uriString = TAG.Worktop.Database.getSecureURL() + "/?Type=FileUploadMap&Client=Windows&ReturnDoq=true&token=" + TAG.Auth.getToken() + "&Extension=" + file.fileType.substr(1);
                                                       break;
                                               }

                                               globalUriStrings = [uriString];
                                               globalUpload = upload;

                                               // Set up the upload
                                               var msg;
                                               if (typeof (msg = localCallback([file], [localURL], [uriString])) === 'string') {
                                                   fileUploadError = uploadErrorAlert(null, msg, null);
                                                   $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                                   $('body').append(fileUploadError);
                                                   $(fileUploadError).fadeIn(500);
                                               } else {
                                                   upload.start(0);
                                               }
                                           }, function () { // longbad
                                               var mins = Math.floor(maxDuration / 60);
                                               var secs = maxDuration % 60;
                                               if (secs === 0) secs = '00';
                                               else if (secs <= 9) secs = '0' + secs;

                                               fileUploadError = uploadErrorAlert(null, "The selected file exceeded the " + mins + ":" + secs + " duration limit and could not be uploaded.", null);
                                               $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                               $('body').append(fileUploadError);
                                               $(fileUploadError).fadeIn(500);
                                           }, function () { // shortbad
                                               var mins = Math.floor(minDuration / 60);
                                               var secs = minDuration % 60;
                                               if (secs === 0) secs = '00';
                                               else if (secs <= 9) secs = '0' + secs;

                                               fileUploadError = uploadErrorAlert(null, "The selected file is shorter than the " + mins + ":" + secs + " lower duration limit and could not be uploaded.", null);
                                               $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                               $('body').append(fileUploadError);
                                               $(fileUploadError).fadeIn(500);
                                           });

                                       }


                                       else {
                                           fileUploadError = uploadErrorAlert(null, "The selected file exceeded the 50MB file limit and could not be uploaded.", null);
                                           $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                                           $('body').append(fileUploadError);
                                           $(fileUploadError).fadeIn(500);

                                       }

                                   });
                        }

                    });
            }
        } catch (e) {
            // file access failed
            console.log("file access failed: "+e.message);
            if (errorCallback)
                errorCallback();
        }
    })();

    function checkDuration(file, good, longbad, shortbad) {
        if (file.fileType === '.mp3') {
            // Get music properties
            file.properties.getMusicPropertiesAsync().done(function (musicProperties) {
                if (musicProperties.duration / 1000 > maxDuration) {
                    longbad();
                } else if (musicProperties.duration / 1000 < minDuration) {
                    shortbad();
                } else {
                    good();
                }
            },
            longbad); // error callback
        } else if (file.fileType.toLowerCase() === ".mp4") {
            file.properties.getVideoPropertiesAsync().done(function (videoProperties) {
                if (videoProperties.duration / 1000 > maxDuration) {
                    longbad();
                } else if (videoProperties.duration / 1000 < minDuration) {
                    shortbad();
                } else {
                    good();
                }
            },
            longbad); // error callback
        } else {
            good();
        }
    }

    function checkDurations(files, callback) {
        var removeVals = [];
        var done = 0;
        if (files.length === 0) {
            callback();
            return;
        }
        helper(0);

        function helper(j) {
            checkDuration(files[j], function () {
                done++;
                if (done === files.length) remove();
                else helper(j++);
            }, function () { // longbad
                removeVals.push(j);
                longFiles.push(files[j]);
                done++;
                if (done === files.length) remove();
                else helper(j++);
            }, function () { // shortbad
                removeVals.push(j);
                shortFiles.push(files[j]);
                done++;
                if (done === files.length) remove();
                else helper(j++);
            });
        }

        function remove() {
            removeVals.sort(function (a, b) { return b - a; });
            for (var i = 0; i < removeVals.length; i++) {
                files.splice(removeVals[i], 1);
            }
            callback();
        }
    }

    function uploadStart(i, upload) {
        return function () {
            upload.start(i);
        };
    }

    function addLocalCallback(files, localUrls, uriStrings) {
        return function () {
            localCallback(files, localUrls, uriStrings);
        };
    }

    // Helper functions

    /**
     * Appends overlay to root
     * (no idea if this will actually disable interactions too as is)
     */
    function addOverlay(elmt) {
        if ($("#uploadingOverlay").length === 0) {
            elmt.append(uploadingOverlay);
        }
    }

    /**
     * Totally remove the overlay from the DOM / destroy
     */
    function removeOverlay() {
        uploadingOverlay.remove();
    }

    /**
     * Inner class that performs actual upload operation
     * Partly taken from: http://msdn.microsoft.com/en-us/library/windows/apps/Hh700372.aspx
     */
    function UploadOp() {
        var upload = null,
            promise = null;

        /**
         * Starts upload of given file
         * @param uriString     Spec passed to server
         * @param file          File object representing file to be uploaded
         */
        this.start = function (i) {
            var uri, uploader;
            var uriString = globalUriStrings[i], file = globalFiles[i];
            try {
                addOverlay(root);
                uploadingOverlay.show();

                uri = new Windows.Foundation.Uri(uriString);
                uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();

                // Set a header, so the server can save the file (this is specific to the sample server).
                uploader.setRequestHeader("Filename", file.name);
                uploader.setRequestHeader("Content-Type", "multipart/form-data; boundary=----WebKitFormBoundaryqj1e7E6nvkEBR9N5");

                // Create a new upload operation.
                upload = uploader.createUpload(uri, file);
                var ind = upload.guid; // property name in the totalBytesSent object
                totalBytesSent[ind] = 0;
                file.getBasicPropertiesAsync().then(
                    function (basicProperties) {
                        size = basicProperties.size;

                            // Start the upload and persist the promise to be able to cancel the upload.
                            promise = upload.startAsync().then(interComplete(i), error, progress);
                            promises.push(promise);
                    }
                );
            } catch (err) {
                removeOverlay();
                console.log(err.message);
            }
        };

        // On application activation, reassign callbacks for an upload
        // operation persisted from previous application state.
        this.load = function (loadedUpload) {
            try {
                upload = loadedUpload;
                promise = upload.attachAsync().then(complete, error, progress(upload));
            } catch (err) {
                removeOverlay();
                if (errorCallback)
                    errorCallback();
            }
        };
    }

    function interComplete(i) {
        return function (uploadOperation) {
            complete(uploadOperation, i);
        };
    }

    /**
     * Called when upload is completed
     * @param uploadOperation       Finished upload passed by background uploader
     */
    function complete(uploadOperation, i) {
        var response = uploadOperation.getResponseInformation(),
            iInputStream = uploadOperation.getResultStreamAt(0),
            dataReader = new Windows.Storage.Streams.DataReader(iInputStream),
            loadop = dataReader.loadAsync(10000000);

        // Once response is read
        loadop.operation.completed = function () {
            var dataReaderLoad = dataReader.readString(dataReader.unconsumedBufferLength);
            dataReaderLoads.push($.trim(dataReaderLoad)); // DEBUGGING: this function mutates the data
            finishedUpload();
        };
        if(i<numFiles-1) {
            uploadStart(i + 1, globalUpload)();
        }
    }

    function finishedUpload() {
        filesFinished += 1;
        if (filesFinished === numFiles) {
            removeOverlay();
            finishedCallback(dataReaderLoads);
            var msg = "", str, mins, secs;
            var longFilesExist = false;
            var i;
            if (largeFiles !== "") {
                msg = "The following file(s) exceeded the 50MB file limit:" + largeFiles;
            }
            if (longFiles.length) {
                longFilesExist = true;
                mins = Math.floor(maxDuration / 60);
                secs = maxDuration % 60;
                if (secs === 0) {
                    secs = '00';
                }
                else if (secs <= 9) {
                    secs = '0' + secs;
                }
                str = "The following file(s) exceeded the " + mins + ":" + secs + " duration limit:<br />";
                for (i = 0; i < longFiles.length; i++) {
                    str = str + longFiles[i].name + "<br />";
                }
                msg = msg + str;
            }
            if (shortFiles.length) {
                if (longFilesExist) {
                    msg = msg + "<br />";
                }
                mins = Math.floor(minDuration / 60);
                secs = minDuration % 60;
                if (secs === 0) {
                    secs = '00';
                }
                else if (secs <= 9) {
                    secs = '0' + secs;
                }
                str = "The following file(s) are shorter than the " + mins + ":" + secs + " lower duration limit:<br />";
                for (i = 0; i < shortFiles.length; i++) {
                    str = str + shortFiles[i].name + "<br />";
                }
                msg = msg + str;
            }
            if (msg) {
                var fileUploadError = uploadErrorAlert(null, msg, null, false, true);
                $(fileUploadError).css('z-index', TAG.TourAuthoring.Constants.aboveRinZIndex + 1000);
                $('body').append(fileUploadError);
                $(fileUploadError).fadeIn(500);
            }
        }
    }

    /**
     * If file upload fails
     */
    function error(err) {
        var shouldContinue = false,
            popup;
        if (err.message.split(" ")[0] === "Unauthorized") {
            removeOverlay();
            console.log("unauthorized");
            TAG.Auth.authenticate(
                function () {
                    if (uploadFilesObject) {
                        uploadFilesObject(globalFilesObject); // need to deal with this for single file uploads, too, if this ever comes back...
                    }
                },
                function () {
                    shouldContinue = true;
                    popup = TAG.Util.UI.popUpMessage(null, "File(s) not uploaded. You must login to upload files.");
                    $('body').append(popup);
                    $(popup).show();
                }
            );
        } else {
            removeOverlay();
            console.log("internal server error: possibly not enough RAM on the server VM to handle this upload");
            popup = TAG.Util.UI.popUpMessage(null, "A server error occurred. This image may need to be uploaded into TAG directly through the server. Contact server administrator for more information.");
            $('body').append(popup);
            $(popup).show();
        }
        if (shouldContinue) {
            console.log('file upload error: ' + err.message);
            console.log(err.message);
            removeOverlay();
            
            if (errorCallback) {
                errorCallback();
            }
        }
    }

    /**
     * Called by uploader as upload progresses
     * @param upload        upload object / info
     */
    function progress(upload) {        
        var bar = innerProgBar || innerProgressBar;
        totalBytesToSend[upload.guid] = upload.progress.totalBytesToSend;
        var bytesSent = upload.progress.bytesSent;
        totalBytesSent[upload.guid] = bytesSent;
        var percentComplete = 0;
        for (var key in totalBytesSent) {
            if (totalBytesToSend[key]) {
                percentComplete += totalBytesSent[key] / (totalBytesToSend[key] * numFiles);

            }
        }        
        bar.width(percentComplete * 90 + "%");
    }

    function cancelPromises() {
        var i;
        for (i = 0; i < promises.length; i++) { // promise.cancel doesn't do anything for fulfilled promises
            promises[i].cancel();
        }
    }
    that.cancelPromises = cancelPromises;

    function setMaxDuration(seconds) {
        maxDuration = seconds;
    }
    that.setMaxDuration = setMaxDuration;

    function setMinDuration(seconds) {
        minDuration = seconds;
    }
    that.setMinDuration = setMinDuration;

    /**
    * copied from TAG.Util.UI because the boxes have crap CSS. tru fax.
    */
    function uploadErrorAlert(clickAction, message, buttonText, noFade, useHTML) {
        var overlay = TAG.Util.UI.blockInteractionOverlay();

        var confirmBox = document.createElement('div');
        var confirmBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width: 560,
               max_height: 200,
           });

        $(confirmBox).css({
            position: 'absolute',
            left: confirmBoxSpecs.x + 'px',
            top: confirmBoxSpecs.y + 'px',
            width: confirmBoxSpecs.width + 'px',
            height: confirmBoxSpecs.height + 'px',
            border: '3px double white',
            'background-color': 'black',
        });

        var messageLabel = document.createElement('div');
        $(messageLabel).css({
            'color': 'white',
            'width': '90%',
            'height': '57.5%',
            'left': '5%',
            'top': '12.5%',
            'font-size': '1.25em',
            'position': 'relative',
            'text-align': 'center',
            'word-wrap': 'break-word',
            'overflow-y': 'auto',
        });
        if (useHTML) {
            $(messageLabel).html(message);
        } else {
            $(messageLabel).text(message);
        }
        var optionButtonDiv = document.createElement('div');
        $(optionButtonDiv).addClass('optionButtonDiv');
        $(optionButtonDiv).css({
            'height': '30%',
            'width': '98%',
            'position': 'absolute',
            'bottom': '0%',
            'right': '2%',
        });

        var confirmButton = document.createElement('button');
        $(confirmButton).css({
            'padding': '1%',
            'border': '1px solid white',
            'width': 'auto',
            'position': 'relative',
            'float': "right",
            'margin-right': '3%',
            'margin-top': '0%',
        });
        buttonText = (!buttonText || buttonText === "") ? "OK" : buttonText;
        $(confirmButton).text(buttonText);
        confirmButton.onclick = function () {
            if (clickAction)
                clickAction();
            removeAll();
        };

        function removeAll() {
            if (noFade) {
                $(overlay).hide();
                $(overlay).remove();
            } else {
                $(overlay).fadeOut(500, function () { $(overlay).remove(); });
            }
        }

        $(optionButtonDiv).append(confirmButton);

        $(confirmBox).append(messageLabel);
        $(confirmBox).append(optionButtonDiv);

        $(overlay).append(confirmBox);
        return overlay;
    }

    return that;
};
;
/**
 * jscolor, JavaScript Color Picker
 *
 * @version 1.3.13
 * @license GNU Lesser General Public License, http://www.gnu.org/copyleft/lesser.html
 * @author  Jan Odvarko, http://odvarko.cz
 * @created 2008-06-15
 * @updated 2012-01-19
 * @link    http://jscolor.com
 */


var jscolor = {


	dir : '', // location of jscolor directory (leave empty to autodetect)
	bindClass : 'color', // class name
	binding : true, // automatic binding via <input class="...">
	preloading : true, // use image preloading?


	install : function() {
		//jscolor.addEvent(window, 'load', jscolor.init);
	},


	init : function() {
		if(jscolor.binding) {
			jscolor.bind();
		}
		if(jscolor.preloading) {
			jscolor.preload();
		}
	},


	getDir : function() {
		if(!jscolor.dir) {
			var detected = jscolor.detectDir();
			jscolor.dir = detected !== false ? detected : tagPath + 'js/TAG/authoring/jscolor/';
		}
		return jscolor.dir;
	},


	detectDir : function() {
		var base = location.href;

		var e = document.getElementsByTagName('base');
		for(var i=0; i<e.length; i+=1) {
			if(e[i].href) { base = e[i].href; }
		}

		var e = document.getElementsByTagName('script');
		for(var i=0; i<e.length; i+=1) {
			if(e[i].src && /(^|\/)jscolor\.js([?#].*)?$/i.test(e[i].src)) {
				var src = new jscolor.URI(e[i].src);
				var srcAbs = src.toAbsolute(base);
				srcAbs.path = srcAbs.path.replace(/[^\/]+$/, ''); // remove filename
				srcAbs.query = null;
				srcAbs.fragment = null;
				return srcAbs.toString();
			}
		}
		return false;
	},


	bind : function() {
		var matchClass = new RegExp('(^|\\s)('+jscolor.bindClass+')\\s*(\\{[^}]*\\})?', 'i');
		var e = document.getElementsByTagName('input');
		for(var i=0; i<e.length; i+=1) {
			var m;
			if(!e[i].color && e[i].className && (m = e[i].className.match(matchClass))) {
				var prop = {};
				if(m[3]) {
					try {
						eval('prop='+m[3]);
					} catch(eInvalidProp) {}
				}
				e[i].color = new jscolor.color(e[i], prop);
			}
		}
	},


	preload : function() {
		for(var fn in jscolor.imgRequire) {
			if(jscolor.imgRequire.hasOwnProperty(fn)) {
				jscolor.loadImage(fn);
			}
		}
	},


	images : {
		pad : [ 181, 101 ],
		sld : [ 16, 101 ],
		cross : [ 15, 15 ],
		arrow : [ 7, 11 ]
	},


	imgRequire : {},
	imgLoaded : {},


	requireImage : function(filename) {
		jscolor.imgRequire[filename] = true;
	},


	loadImage : function(filename) {
		if(!jscolor.imgLoaded[filename]) {
			jscolor.imgLoaded[filename] = new Image();
			jscolor.imgLoaded[filename].src = jscolor.getDir()+filename;
		}
	},


	fetchElement : function(mixed) {
		return typeof mixed === 'string' ? document.getElementById(mixed) : mixed;
	},


	addEvent : function(el, evnt, func) {
		if(el.addEventListener) {
			el.addEventListener(evnt, func, false);
		} else if(el.attachEvent) {
			el.attachEvent('on'+evnt, func);
		}
	},


	fireEvent : function(el, evnt) {
		if(!el) {
			return;
		}
		if(document.createEvent) {
			var ev = document.createEvent('HTMLEvents');
			ev.initEvent(evnt, true, true);
			el.dispatchEvent(ev);
		} else if(document.createEventObject) {
			var ev = document.createEventObject();
			el.fireEvent('on'+evnt, ev);
		} else if(el['on'+evnt]) { // alternatively use the traditional event model (IE5)
			el['on'+evnt]();
		}
	},


	getElementPos : function(e) {
		var e1=e, e2=e;
		var x=0, y=0;
		if(e1.offsetParent) {
			do {
				x += e1.offsetLeft;
				y += e1.offsetTop;
			} while(e1 = e1.offsetParent);
		}
		while((e2 = e2.parentNode) && e2.nodeName.toUpperCase() !== 'BODY') {
			x -= e2.scrollLeft;
			y -= e2.scrollTop;
		}
		return [x, y];
	},


	getElementSize : function(e) {
		return [e.offsetWidth, e.offsetHeight];
	},


	getRelMousePos : function(e) {
		var x = 0, y = 0;
		if (!e) { e = window.event; }
		if (typeof e.offsetX === 'number') {
			x = e.offsetX;
			y = e.offsetY;
		} else if (typeof e.layerX === 'number') {
			x = e.layerX;
			y = e.layerY;
		}
		return { x: x, y: y };
	},


	getViewPos : function() {
		if(typeof window.pageYOffset === 'number') {
			return [window.pageXOffset, window.pageYOffset];
		} else if(document.body && (document.body.scrollLeft || document.body.scrollTop)) {
			return [document.body.scrollLeft, document.body.scrollTop];
		} else if(document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
			return [document.documentElement.scrollLeft, document.documentElement.scrollTop];
		} else {
			return [0, 0];
		}
	},


	getViewSize : function() {
		if(typeof window.innerWidth === 'number') {
			return [window.innerWidth, window.innerHeight];
		} else if(document.body && (document.body.clientWidth || document.body.clientHeight)) {
			return [document.body.clientWidth, document.body.clientHeight];
		} else if(document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
			return [document.documentElement.clientWidth, document.documentElement.clientHeight];
		} else {
			return [0, 0];
		}
	},


	URI : function(uri) { // See RFC3986

		this.scheme = null;
		this.authority = null;
		this.path = '';
		this.query = null;
		this.fragment = null;

		this.parse = function(uri) {
			var m = uri.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\/\/)([^\/?#]*))?([^?#]*)((\?)([^#]*))?((#)(.*))?/);
			this.scheme = m[3] ? m[2] : null;
			this.authority = m[5] ? m[6] : null;
			this.path = m[7];
			this.query = m[9] ? m[10] : null;
			this.fragment = m[12] ? m[13] : null;
			return this;
		};

		this.toString = function() {
			var result = '';
			if(this.scheme !== null) { result = result + this.scheme + ':'; }
			if(this.authority !== null) { result = result + '//' + this.authority; }
			if(this.path !== null) { result = result + this.path; }
			if(this.query !== null) { result = result + '?' + this.query; }
			if(this.fragment !== null) { result = result + '#' + this.fragment; }
			return result;
		};

		this.toAbsolute = function(base) {
			var base = new jscolor.URI(base);
			var r = this;
			var t = new jscolor.URI;

			if(base.scheme === null) { return false; }

			if(r.scheme !== null && r.scheme.toLowerCase() === base.scheme.toLowerCase()) {
				r.scheme = null;
			}

			if(r.scheme !== null) {
				t.scheme = r.scheme;
				t.authority = r.authority;
				t.path = removeDotSegments(r.path);
				t.query = r.query;
			} else {
				if(r.authority !== null) {
					t.authority = r.authority;
					t.path = removeDotSegments(r.path);
					t.query = r.query;
				} else {
					if(r.path === '') { // TODO: == or === ?
						t.path = base.path;
						if(r.query !== null) {
							t.query = r.query;
						} else {
							t.query = base.query;
						}
					} else {
						if(r.path.substr(0,1) === '/') {
							t.path = removeDotSegments(r.path);
						} else {
							if(base.authority !== null && base.path === '') { // TODO: == or === ?
								t.path = '/'+r.path;
							} else {
								t.path = base.path.replace(/[^\/]+$/,'')+r.path;
							}
							t.path = removeDotSegments(t.path);
						}
						t.query = r.query;
					}
					t.authority = base.authority;
				}
				t.scheme = base.scheme;
			}
			t.fragment = r.fragment;

			return t;
		};

		function removeDotSegments(path) {
			var out = '';
			while(path) {
				if(path.substr(0,3)==='../' || path.substr(0,2)==='./') {
					path = path.replace(/^\.+/,'').substr(1);
				} else if(path.substr(0,3)==='/./' || path==='/.') {
					path = '/'+path.substr(3);
				} else if(path.substr(0,4)==='/../' || path==='/..') {
					path = '/'+path.substr(4);
					out = out.replace(/\/?[^\/]*$/, '');
				} else if(path==='.' || path==='..') {
					path = '';
				} else {
					var rm = path.match(/^\/?[^\/]*/)[0];
					path = path.substr(rm.length);
					out = out + rm;
				}
			}
			return out;
		}

		if(uri) {
			this.parse(uri);
		}

	},


	/*
	 * Usage example:
	 * var myColor = new jscolor.color(myInputElement)
	 */

	color : function(target, prop) {


		this.required = true; // refuse empty values?
		this.adjust = true; // adjust value to uniform notation?
		this.hash = false; // prefix color with # symbol?
		this.caps = true; // uppercase?
		this.slider = true; // show the value/saturation slider?
		this.valueElement = target; // value holder
		this.styleElement = target; // where to reflect current color
		this.onImmediateChange = null; // onchange callback (can be either string or function)
		this.hsv = [0, 0, 1]; // read-only  0-6, 0-1, 0-1
		this.rgb = [1, 1, 1]; // read-only  0-1, 0-1, 0-1

		this.pickerOnfocus = true; // display picker on focus?
		this.pickerMode = 'HSV'; // HSV | HVS
		this.pickerPosition = 'bottom'; // left | right | top | bottom
		this.pickerSmartPosition = true; // automatically adjust picker position when necessary
		this.pickerButtonHeight = 20; // px
		this.pickerClosable = false;
		this.pickerCloseText = 'Close';
		this.pickerButtonColor = 'ButtonText'; // px
		this.pickerFace = 10; // px
		this.pickerFaceColor = 'ThreeDFace'; // CSS color
		this.pickerBorder = 1; // px
		this.pickerBorderColor = 'ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight'; // CSS color
		this.pickerInset = 1; // px
		this.pickerInsetColor = 'ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow'; // CSS color
		this.pickerZIndex = 10000;


		for(var p in prop) {
			if(prop.hasOwnProperty(p)) {
				this[p] = prop[p];
			}
		}


		this.hidePicker = function() {
			if(isPickerOwner()) {
				removePicker();
			}
		};


		this.showPicker = function() {
			if(!isPickerOwner()) {
				var tp = jscolor.getElementPos(target); // target pos
				var ts = jscolor.getElementSize(target); // target size
				var vp = jscolor.getViewPos(); // view pos
				var vs = jscolor.getViewSize(); // view size
				var ps = getPickerDims(this); // picker size
				var a, b, c;
				switch(this.pickerPosition.toLowerCase()) {
					case 'left': a=1; b=0; c=-1; break;
					case 'right':a=1; b=0; c=1; break;
					case 'top':  a=0; b=1; c=-1; break;
					default:     a=0; b=1; c=1; break;
				}
				var l = (ts[b]+ps[b])/2;

				// picker pos
				if (!this.pickerSmartPosition) {
					var pp = [
						tp[a],
						tp[b]+ts[b]-l+l*c
					];
				} else {
					var pp = [
						-vp[a]+tp[a]+ps[a] > vs[a] ?
							(-vp[a]+tp[a]+ts[a]/2 > vs[a]/2 && tp[a]+ts[a]-ps[a] >= 0 ? tp[a]+ts[a]-ps[a] : tp[a]) :
							tp[a],
						-vp[b]+tp[b]+ts[b]+ps[b]-l+l*c > vs[b] ?
							(-vp[b]+tp[b]+ts[b]/2 > vs[b]/2 && tp[b]+ts[b]-l-l*c >= 0 ? tp[b]+ts[b]-l-l*c : tp[b]+ts[b]-l+l*c) :
							(tp[b]+ts[b]-l+l*c >= 0 ? tp[b]+ts[b]-l+l*c : tp[b]+ts[b]-l-l*c)
					];
				}
				drawPicker(pp[a], pp[b]);
			}
		};


		this.importColor = function() {
			if(!valueElement) {
				this.exportColor();
			} else {
				if(!this.adjust) {
					if(!this.fromString(valueElement.value, leaveValue)) {
						styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage;
						styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;
						styleElement.style.color = styleElement.jscStyle.color;
						this.exportColor(leaveValue | leaveStyle);
					}
				} else if(!this.required && /^\s*$/.test(valueElement.value)) {
					valueElement.value = '';
					styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage;
					styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;
					styleElement.style.color = styleElement.jscStyle.color;
					this.exportColor(leaveValue | leaveStyle);

				} else if(this.fromString(valueElement.value)) {
					// OK
				} else {
					this.exportColor();
				}
			}
		};


		this.exportColor = function(flags) {
			if(!(flags & leaveValue) && valueElement) {
				var value = this.toString();
				if(this.caps) { value = value.toUpperCase(); }
				if(this.hash) { value = '#'+value; }
				valueElement.value = value;
			}
			if(!(flags & leaveStyle) && styleElement) {
				styleElement.style.backgroundImage = "none";
				styleElement.style.backgroundColor =
					'#'+this.toString();
				styleElement.style.color =
					0.213 * this.rgb[0] +
					0.715 * this.rgb[1] +
					0.072 * this.rgb[2]
					< 0.5 ? '#FFF' : '#000';
			}
			if(!(flags & leavePad) && isPickerOwner()) {
				redrawPad();
			}
			if(!(flags & leaveSld) && isPickerOwner()) {
				redrawSld();
			}
		};


		this.fromHSV = function(h, s, v, flags) { // null = don't change
			h<0 && (h=0) || h>6 && (h=6);
			s<0 && (s=0) || s>1 && (s=1);
			v<0 && (v=0) || v>1 && (v=1);
			this.rgb = HSV_RGB(
				h===null ? this.hsv[0] : (this.hsv[0]=h),
				s===null ? this.hsv[1] : (this.hsv[1]=s),
				v===null ? this.hsv[2] : (this.hsv[2]=v)
			);
			this.exportColor(flags);
		};


		this.fromRGB = function(r, g, b, flags) { // null = don't change
			r<0 && (r=0) || r>1 && (r=1);
			g<0 && (g=0) || g>1 && (g=1);
			b<0 && (b=0) || b>1 && (b=1);
			var hsv = RGB_HSV(
				r===null ? this.rgb[0] : (this.rgb[0]=r),
				g===null ? this.rgb[1] : (this.rgb[1]=g),
				b===null ? this.rgb[2] : (this.rgb[2]=b)
			);
			if(hsv[0] !== null) {
				this.hsv[0] = hsv[0];
			}
			if(hsv[2] !== 0) {
				this.hsv[1] = hsv[1];
			}
			this.hsv[2] = hsv[2];
			this.exportColor(flags);
		};


		this.fromString = function(hex, flags) {
			var m = hex.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
			if(!m) {
				return false;
			} else {
				if(m[1].length === 6) { // 6-char notation
					this.fromRGB(
						parseInt(m[1].substr(0,2),16) / 255,
						parseInt(m[1].substr(2,2),16) / 255,
						parseInt(m[1].substr(4,2),16) / 255,
						flags
					);
				} else { // 3-char notation
					this.fromRGB(
						parseInt(m[1].charAt(0)+m[1].charAt(0),16) / 255,
						parseInt(m[1].charAt(1)+m[1].charAt(1),16) / 255,
						parseInt(m[1].charAt(2)+m[1].charAt(2),16) / 255,
						flags
					);
				}
				return true;
			}
		};


		this.toString = function() {
			return (
				(0x100 | Math.round(255*this.rgb[0])).toString(16).substr(1) +
				(0x100 | Math.round(255*this.rgb[1])).toString(16).substr(1) +
				(0x100 | Math.round(255*this.rgb[2])).toString(16).substr(1)
			);
		};


		function RGB_HSV(r, g, b) {
			var n = Math.min(Math.min(r,g),b);
			var v = Math.max(Math.max(r,g),b);
			var m = v - n;
			if(m === 0) { return [ null, 0, v ]; }
			var h = r===n ? 3+(b-g)/m : (g===n ? 5+(r-b)/m : 1+(g-r)/m);
			return [ h===6?0:h, m/v, v ];
		}


		function HSV_RGB(h, s, v) {
			if(h === null) { return [ v, v, v ]; }
			var i = Math.floor(h);
			var f = i%2 ? h-i : 1-(h-i);
			var m = v * (1 - s);
			var n = v * (1 - s*f);
			switch(i) {
				case 6:
				case 0: return [v,n,m];
				case 1: return [n,v,m];
				case 2: return [m,v,n];
				case 3: return [m,n,v];
				case 4: return [n,m,v];
				case 5: return [v,m,n];
			}
		}


		function removePicker() {
			delete jscolor.picker.owner;
			document.getElementsByTagName('body')[0].removeChild(jscolor.picker.boxB);
		}


		function drawPicker(x, y) {
			if(!jscolor.picker) {
				jscolor.picker = {
					box : document.createElement('div'),
					boxB : document.createElement('div'),
					pad : document.createElement('div'),
					padB : document.createElement('div'),
					padM : document.createElement('div'),
					sld : document.createElement('div'),
					sldB : document.createElement('div'),
					sldM : document.createElement('div'),
					btn : document.createElement('div'),
					btnS : document.createElement('span'),
					btnT : document.createTextNode(THIS.pickerCloseText)
				};
				for(var i=0,segSize=4; i<jscolor.images.sld[1]; i+=segSize) {
					var seg = document.createElement('div');
					seg.style.height = segSize+'px';
					seg.style.fontSize = '1px';
					seg.style.lineHeight = '0';
					jscolor.picker.sld.appendChild(seg);
				}
				jscolor.picker.sldB.appendChild(jscolor.picker.sld);
				jscolor.picker.box.appendChild(jscolor.picker.sldB);
				jscolor.picker.box.appendChild(jscolor.picker.sldM);
				jscolor.picker.padB.appendChild(jscolor.picker.pad);
				jscolor.picker.box.appendChild(jscolor.picker.padB);
				jscolor.picker.box.appendChild(jscolor.picker.padM);
				jscolor.picker.btnS.appendChild(jscolor.picker.btnT);
				jscolor.picker.btn.appendChild(jscolor.picker.btnS);
				jscolor.picker.box.appendChild(jscolor.picker.btn);
				jscolor.picker.boxB.appendChild(jscolor.picker.box);
			}

			var p = jscolor.picker;

			// controls interaction
			p.box.onmouseup =
			p.box.onmouseout = function() { target.focus(); };
			p.box.onmousedown = function() { abortBlur=true; };
			p.box.onmousemove = function(e) {
				if (holdPad || holdSld) {
					holdPad && setPad(e);
					holdSld && setSld(e);
					if (document.selection) {
						document.selection.empty();
					} else if (window.getSelection) {
						window.getSelection().removeAllRanges();
					}
					dispatchImmediateChange();
				}
			};
			p.padM.onmouseup =
			p.padM.onmouseout = function() { if(holdPad) { holdPad=false; jscolor.fireEvent(valueElement,'change'); } };
			p.padM.onmousedown = function(e) {
				// if the slider is at the bottom, move it up
				switch(modeID) {
					case 0: if (THIS.hsv[2] === 0) { THIS.fromHSV(null, null, 1.0); }; break;
					case 1: if (THIS.hsv[1] === 0) { THIS.fromHSV(null, 1.0, null); }; break;
				}
				holdPad=true;
				setPad(e);
				dispatchImmediateChange();
			};
			p.sldM.onmouseup =
			p.sldM.onmouseout = function() { if(holdSld) { holdSld=false; jscolor.fireEvent(valueElement,'change'); } };
			p.sldM.onmousedown = function(e) {
				holdSld=true;
				setSld(e);
				dispatchImmediateChange();
			};

			// picker
			var dims = getPickerDims(THIS);
			p.box.style.width = dims[0] + 'px';
			p.box.style.height = dims[1] + 'px';

			// picker border
			p.boxB.style.position = 'absolute';
			p.boxB.style.clear = 'both';
			p.boxB.style.left = x+'px';
			p.boxB.style.top = y+'px';
			p.boxB.style.zIndex = THIS.pickerZIndex;
			p.boxB.style.border = THIS.pickerBorder+'px solid';
			p.boxB.style.borderColor = THIS.pickerBorderColor;
			p.boxB.style.background = THIS.pickerFaceColor;

			// pad image
			p.pad.style.width = jscolor.images.pad[0]+'px';
			p.pad.style.height = jscolor.images.pad[1]+'px';

			// pad border
			p.padB.style.position = 'absolute';
			p.padB.style.left = THIS.pickerFace+'px';
			p.padB.style.top = THIS.pickerFace+'px';
			p.padB.style.border = THIS.pickerInset+'px solid';
			p.padB.style.borderColor = THIS.pickerInsetColor;

			// pad mouse area
			p.padM.style.position = 'absolute';
			p.padM.style.left = '0';
			p.padM.style.top = '0';
			p.padM.style.width = THIS.pickerFace + 2*THIS.pickerInset + jscolor.images.pad[0] + jscolor.images.arrow[0] + 'px';
			p.padM.style.height = p.box.style.height;
			p.padM.style.cursor = 'crosshair';

			// slider image
			p.sld.style.overflow = 'hidden';
			p.sld.style.width = jscolor.images.sld[0]+'px';
			p.sld.style.height = jscolor.images.sld[1]+'px';

			// slider border
			p.sldB.style.display = THIS.slider ? 'block' : 'none';
			p.sldB.style.position = 'absolute';
			p.sldB.style.right = THIS.pickerFace+'px';
			p.sldB.style.top = THIS.pickerFace+'px';
			p.sldB.style.border = THIS.pickerInset+'px solid';
			p.sldB.style.borderColor = THIS.pickerInsetColor;

			// slider mouse area
			p.sldM.style.display = THIS.slider ? 'block' : 'none';
			p.sldM.style.position = 'absolute';
			p.sldM.style.right = '0';
			p.sldM.style.top = '0';
			p.sldM.style.width = jscolor.images.sld[0] + jscolor.images.arrow[0] + THIS.pickerFace + 2*THIS.pickerInset + 'px';
			p.sldM.style.height = p.box.style.height;
			try {
				p.sldM.style.cursor = 'pointer';
			} catch(eOldIE) {
				p.sldM.style.cursor = 'hand';
			}

			// "close" button
			function setBtnBorder() {
				var insetColors = THIS.pickerInsetColor.split(/\s+/);
				var pickerOutsetColor = insetColors.length < 2 ? insetColors[0] : insetColors[1] + ' ' + insetColors[0] + ' ' + insetColors[0] + ' ' + insetColors[1];
				p.btn.style.borderColor = pickerOutsetColor;
			}
			p.btn.style.display = THIS.pickerClosable ? 'block' : 'none';
			p.btn.style.position = 'absolute';
			p.btn.style.left = THIS.pickerFace + 'px';
			p.btn.style.bottom = THIS.pickerFace + 'px';
			p.btn.style.padding = '0 15px';
			p.btn.style.height = '18px';
			p.btn.style.border = THIS.pickerInset + 'px solid';
			setBtnBorder();
			p.btn.style.color = THIS.pickerButtonColor;
			p.btn.style.font = '12px sans-serif';
			p.btn.style.textAlign = 'center';
			try {
				p.btn.style.cursor = 'pointer';
			} catch(eOldIE) {
				p.btn.style.cursor = 'hand';
			}
			p.btn.onmousedown = function () {
				THIS.hidePicker();
			};
			p.btnS.style.lineHeight = p.btn.style.height;

			// load images in optimal order
			switch(modeID) {
				case 0: var padImg = 'hs.png'; break;
				case 1: var padImg = 'hv.png'; break;
			}
			p.padM.style.backgroundImage = "url('"+jscolor.getDir()+"cross.gif')";
			p.padM.style.backgroundRepeat = "no-repeat";
			p.sldM.style.backgroundImage = "url('"+jscolor.getDir()+"arrow.gif')";
			p.sldM.style.backgroundRepeat = "no-repeat";
			p.pad.style.backgroundImage = "url('"+jscolor.getDir()+padImg+"')";
			p.pad.style.backgroundRepeat = "no-repeat";
			p.pad.style.backgroundPosition = "0 0";

			// place pointers
			redrawPad();
			redrawSld();

			jscolor.picker.owner = THIS;
			document.getElementsByTagName('body')[0].appendChild(p.boxB);
		}


		function getPickerDims(o) {
			var dims = [
				2*o.pickerInset + 2*o.pickerFace + jscolor.images.pad[0] +
					(o.slider ? 2*o.pickerInset + 2*jscolor.images.arrow[0] + jscolor.images.sld[0] : 0),
				o.pickerClosable ?
					4*o.pickerInset + 3*o.pickerFace + jscolor.images.pad[1] + o.pickerButtonHeight :
					2*o.pickerInset + 2*o.pickerFace + jscolor.images.pad[1]
			];
			return dims;
		}


		function redrawPad() {
			// redraw the pad pointer
			switch(modeID) {
				case 0: var yComponent = 1; break;
				case 1: var yComponent = 2; break;
			}
			var x = Math.round((THIS.hsv[0]/6) * (jscolor.images.pad[0]-1));
			var y = Math.round((1-THIS.hsv[yComponent]) * (jscolor.images.pad[1]-1));
			jscolor.picker.padM.style.backgroundPosition =
				(THIS.pickerFace+THIS.pickerInset+x - Math.floor(jscolor.images.cross[0]/2)) + 'px ' +
				(THIS.pickerFace+THIS.pickerInset+y - Math.floor(jscolor.images.cross[1]/2)) + 'px';

			// redraw the slider image
			var seg = jscolor.picker.sld.childNodes;

			switch(modeID) {
				case 0:
					var rgb = HSV_RGB(THIS.hsv[0], THIS.hsv[1], 1);
					for(var i=0; i<seg.length; i+=1) {
						seg[i].style.backgroundColor = 'rgb('+
							(rgb[0]*(1-i/seg.length)*100)+'%,'+
							(rgb[1]*(1-i/seg.length)*100)+'%,'+
							(rgb[2]*(1-i/seg.length)*100)+'%)';
					}
					break;
				case 1:
					var rgb, s, c = [ THIS.hsv[2], 0, 0 ];
					var i = Math.floor(THIS.hsv[0]);
					var f = i%2 ? THIS.hsv[0]-i : 1-(THIS.hsv[0]-i);
					switch(i) {
						case 6:
						case 0: rgb=[0,1,2]; break;
						case 1: rgb=[1,0,2]; break;
						case 2: rgb=[2,0,1]; break;
						case 3: rgb=[2,1,0]; break;
						case 4: rgb=[1,2,0]; break;
						case 5: rgb=[0,2,1]; break;
					}
					for(var i=0; i<seg.length; i+=1) {
						s = 1 - 1/(seg.length-1)*i;
						c[1] = c[0] * (1 - s*f);
						c[2] = c[0] * (1 - s);
						seg[i].style.backgroundColor = 'rgb('+
							(c[rgb[0]]*100)+'%,'+
							(c[rgb[1]]*100)+'%,'+
							(c[rgb[2]]*100)+'%)';
					}
					break;
			}
		}


		function redrawSld() {
			// redraw the slider pointer
			switch(modeID) {
				case 0: var yComponent = 2; break;
				case 1: var yComponent = 1; break;
			}
			var y = Math.round((1-THIS.hsv[yComponent]) * (jscolor.images.sld[1]-1));
			jscolor.picker.sldM.style.backgroundPosition =
				'0 ' + (THIS.pickerFace+THIS.pickerInset+y - Math.floor(jscolor.images.arrow[1]/2)) + 'px';
		}


		function isPickerOwner() {
			return jscolor.picker && jscolor.picker.owner === THIS;
		}


		function blurTarget() {
			if(valueElement === target) {
				THIS.importColor();
			}
			if(THIS.pickerOnfocus) {
				THIS.hidePicker();
			}
		}


		function blurValue() {
			if(valueElement !== target) {
				THIS.importColor();
			}
		}


		function setPad(e) {
			var mpos = jscolor.getRelMousePos(e);
			var x = mpos.x - THIS.pickerFace - THIS.pickerInset;
			var y = mpos.y - THIS.pickerFace - THIS.pickerInset;
			switch(modeID) {
				case 0: THIS.fromHSV(x*(6/(jscolor.images.pad[0]-1)), 1 - y/(jscolor.images.pad[1]-1), null, leaveSld); break;
				case 1: THIS.fromHSV(x*(6/(jscolor.images.pad[0]-1)), null, 1 - y/(jscolor.images.pad[1]-1), leaveSld); break;
			}
		}


		function setSld(e) {
			var mpos = jscolor.getRelMousePos(e);
			var y = mpos.y - THIS.pickerFace - THIS.pickerInset;
			switch(modeID) {
				case 0: THIS.fromHSV(null, null, 1 - y/(jscolor.images.sld[1]-1), leavePad); break;
				case 1: THIS.fromHSV(null, 1 - y/(jscolor.images.sld[1]-1), null, leavePad); break;
			}
		}


		function dispatchImmediateChange() {
			if (THIS.onImmediateChange) {
				if (typeof THIS.onImmediateChange === 'string') {
					eval(THIS.onImmediateChange);
				} else {
					THIS.onImmediateChange(THIS);
				}
			}
		}


		var THIS = this;
		var modeID = this.pickerMode.toLowerCase()==='hvs' ? 1 : 0;
		var abortBlur = false;
		var
			valueElement = jscolor.fetchElement(this.valueElement),
			styleElement = jscolor.fetchElement(this.styleElement);
		var
			holdPad = false,
			holdSld = false;
		var
			leaveValue = 1<<0,
			leaveStyle = 1<<1,
			leavePad = 1<<2,
			leaveSld = 1<<3;

		// target
		jscolor.addEvent(target, 'focus', function() {
			if(THIS.pickerOnfocus) { THIS.showPicker(); }
		});
		jscolor.addEvent(target, 'blur', function() {
			if(!abortBlur) {
				window.setTimeout(function(){ abortBlur || blurTarget(); abortBlur=false; }, 0);
			} else {
				abortBlur = false;
			}
		});

		// valueElement
		if(valueElement) {
			var updateField = function() {
				THIS.fromString(valueElement.value, leaveValue);
				dispatchImmediateChange();
			};
			jscolor.addEvent(valueElement, 'keyup', updateField);
			jscolor.addEvent(valueElement, 'input', updateField);
			jscolor.addEvent(valueElement, 'blur', blurValue);
			valueElement.setAttribute('autocomplete', 'off');
		}

		// styleElement
		if(styleElement) {
			styleElement.jscStyle = {
				backgroundImage : styleElement.style.backgroundImage,
				backgroundColor : styleElement.style.backgroundColor,
				color : styleElement.style.color
			};
		}

		// require images
		switch(modeID) {
			case 0: jscolor.requireImage('hs.png'); break;
			case 1: jscolor.requireImage('hv.png'); break;
		}
		jscolor.requireImage('cross.gif');
		jscolor.requireImage('arrow.gif');

		this.importColor();
	}

};


jscolor.install();

;
/*
 * popcorn.js version 1.3
 * http://popcornjs.org
 *
 * Copyright 2011, Mozilla Foundation
 * Licensed under the MIT license
 */

(function (global, document) {

    // Popcorn.js does not support archaic browsers
    if (!document.addEventListener) {
        global.Popcorn = {
            isSupported: false
        };

        var methods = ("byId forEach extend effects error guid sizeOf isArray nop position disable enable destroy" +
              "addTrackEvent removeTrackEvent getTrackEvents getTrackEvent getLastTrackEventId " +
              "timeUpdate plugin removePlugin compose effect xhr getJSONP getScript").split(/\s+/);

        while (methods.length) {
            global.Popcorn[methods.shift()] = function () { };
        }
        return;
    }

    var

    AP = Array.prototype,
    OP = Object.prototype,

    forEach = AP.forEach,
    slice = AP.slice,
    hasOwn = OP.hasOwnProperty,
    toString = OP.toString,

    // Copy global Popcorn (may not exist)
    _Popcorn = global.Popcorn,

    //  Ready fn cache
    readyStack = [],
    readyBound = false,
    readyFired = false,

    //  Non-public internal data object
    internal = {
        events: {
            hash: {},
            apis: {}
        }
    },

    //  Non-public `requestAnimFrame`
    //  http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    requestAnimFrame = (function () {
        return global.requestAnimationFrame ||
          global.webkitRequestAnimationFrame ||
          global.mozRequestAnimationFrame ||
          global.oRequestAnimationFrame ||
          global.msRequestAnimationFrame ||
          function (callback, element) {
              global.setTimeout(callback, 16);
          };
    }()),

    //  Non-public `getKeys`, return an object's keys as an array
    getKeys = function (obj) {
        return Object.keys ? Object.keys(obj) : (function (obj) {
            var item,
                list = [];

            for (item in obj) {
                if (hasOwn.call(obj, item)) {
                    list.push(item);
                }
            }
            return list;
        })(obj);
    },

    //  Declare constructor
    //  Returns an instance object.
    Popcorn = function (entity, options) {
        //  Return new Popcorn object
        return new Popcorn.p.init(entity, options || null);
    };

    //  Popcorn API version, automatically inserted via build system.
    Popcorn.version = "1.3";

    //  Boolean flag allowing a client to determine if Popcorn can be supported
    Popcorn.isSupported = true;

    //  Instance caching
    Popcorn.instances = [];

    //  Declare a shortcut (Popcorn.p) to and a definition of
    //  the new prototype for our Popcorn constructor
    Popcorn.p = Popcorn.prototype = {

        init: function (entity, options) {

            var matches, nodeName,
                self = this;

            //  Supports Popcorn(function () { /../ })
            //  Originally proposed by Daniel Brooks

            if (typeof entity === "function") {

                //  If document ready has already fired
                if (document.readyState === "complete") {

                    entity(document, Popcorn);

                    return;
                }
                //  Add `entity` fn to ready stack
                readyStack.push(entity);

                //  This process should happen once per page load
                if (!readyBound) {

                    //  set readyBound flag
                    readyBound = true;

                    var DOMContentLoaded = function () {

                        readyFired = true;

                        //  Remove global DOM ready listener
                        document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);

                        //  Execute all ready function in the stack
                        for (var i = 0, readyStackLength = readyStack.length; i < readyStackLength; i++) {

                            readyStack[i].call(document, Popcorn);

                        }
                        //  GC readyStack
                        readyStack = null;
                    };

                    //  Register global DOM ready listener
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);
                }

                return;
            }

            if (typeof entity === "string") {
                try {
                    matches = document.querySelector(entity);
                } catch (e) {
                    throw new Error("Popcorn.js Error: Invalid media element selector: " + entity);
                }
            }

            //  Get media element by id or object reference
            this.media = matches || entity;

            //  inner reference to this media element's nodeName string value
            nodeName = (this.media.nodeName && this.media.nodeName.toLowerCase()) || "video";

            //  Create an audio or video element property reference
            this[nodeName] = this.media;

            this.options = options || {};

            //  Resolve custom ID or default prefixed ID
            this.id = this.options.id || Popcorn.guid(nodeName);

            //  Throw if an attempt is made to use an ID that already exists
            if (Popcorn.byId(this.id)) {
                throw new Error("Popcorn.js Error: Cannot use duplicate ID (" + this.id + ")");
            }

            this.isDestroyed = false;

            this.data = {

                // data structure of all
                running: {
                    cue: []
                },

                // Executed by either timeupdate event or in rAF loop
                timeUpdate: Popcorn.nop,

                // Allows disabling a plugin per instance
                disabled: {},

                // Stores DOM event queues by type
                events: {},

                // Stores Special event hooks data
                hooks: {},

                // Store track event history data
                history: [],

                // Stores ad-hoc state related data]
                state: {
                    volume: this.media.volume
                },

                // Store track event object references by trackId
                trackRefs: {},

                // Playback track event queues
                trackEvents: {
                    byStart: [{

                        start: -1,
                        end: -1
                    }],
                    byEnd: [{
                        start: -1,
                        end: -1
                    }],
                    animating: [],
                    startIndex: 0,
                    endIndex: 0,
                    previousUpdateTime: -1
                }
            };

            //  Register new instance
            Popcorn.instances.push(this);

            //  function to fire when video is ready
            var isReady = function () {

                // chrome bug: http://code.google.com/p/chromium/issues/detail?id=119598
                // it is possible the video's time is less than 0
                // this has the potential to call track events more than once, when they should not
                // start: 0, end: 1 will start, end, start again, when it should just start
                // just setting it to 0 if it is below 0 fixes this issue
                if (self.media.currentTime < 0) {

                    self.media.currentTime = 0;
                }

                self.media.removeEventListener("loadeddata", isReady, false);

                var duration, videoDurationPlus,
                    runningPlugins, runningPlugin, rpLength, rpNatives;

                //  Adding padding to the front and end of the arrays
                //  this is so we do not fall off either end
                duration = self.media.duration;

                //  Check for no duration info (NaN)
                videoDurationPlus = duration != duration ? Number.MAX_VALUE : duration + 1;

                Popcorn.addTrackEvent(self, {
                    start: videoDurationPlus,
                    end: videoDurationPlus
                });

                if (self.options.frameAnimation) {

                    //  if Popcorn is created with frameAnimation option set to true,
                    //  requestAnimFrame is used instead of "timeupdate" media event.
                    //  This is for greater frame time accuracy, theoretically up to
                    //  60 frames per second as opposed to ~4 ( ~every 15-250ms)
                    self.data.timeUpdate = function () {

                        Popcorn.timeUpdate(self, {});

                        // fire frame for each enabled active plugin of every type
                        Popcorn.forEach(Popcorn.manifest, function (key, val) {

                            runningPlugins = self.data.running[val];

                            // ensure there are running plugins on this type on this instance
                            if (runningPlugins) {

                                rpLength = runningPlugins.length;
                                for (var i = 0; i < rpLength; i++) {

                                    runningPlugin = runningPlugins[i];
                                    rpNatives = runningPlugin._natives;
                                    rpNatives && rpNatives.frame &&
                                      rpNatives.frame.call(self, {}, runningPlugin, self.currentTime());
                                }
                            }
                        });

                        self.emit("timeupdate");

                        !self.isDestroyed && requestAnimFrame(self.data.timeUpdate);
                    };

                    !self.isDestroyed && requestAnimFrame(self.data.timeUpdate);

                } else {

                    self.data.timeUpdate = function (event) {
                        Popcorn.timeUpdate(self, event);
                    };

                    if (!self.isDestroyed) {
                        self.media.addEventListener("timeupdate", self.data.timeUpdate, false);
                    }
                }
            };

            Object.defineProperty(this, "error", {
                get: function () {

                    return self.media.error;
                }
            });

            if (self.media.readyState >= 2) {

                isReady();
            } else {

                self.media.addEventListener("loadeddata", isReady, false);
            }

            return this;
        }
    };

    //  Extend constructor prototype to instance prototype
    //  Allows chaining methods to instances
    Popcorn.p.init.prototype = Popcorn.p;

    Popcorn.byId = function (str) {
        var instances = Popcorn.instances,
            length = instances.length,
            i = 0;

        for (; i < length; i++) {
            if (instances[i].id === str) {
                return instances[i];
            }
        }

        return null;
    };

    Popcorn.forEach = function (obj, fn, context) {

        if (!obj || !fn) {
            return {};
        }

        context = context || this;

        var key, len;

        // Use native whenever possible
        if (forEach && obj.forEach === forEach) {
            return obj.forEach(fn, context);
        }

        if (toString.call(obj) === "[object NodeList]") {
            for (key = 0, len = obj.length; key < len; key++) {
                fn.call(context, obj[key], key, obj);
            }
            return obj;
        }

        for (key in obj) {
            if (hasOwn.call(obj, key)) {
                fn.call(context, obj[key], key, obj);
            }
        }
        return obj;
    };

    Popcorn.extend = function (obj) {
        var dest = obj, src = slice.call(arguments, 1);

        Popcorn.forEach(src, function (copy) {
            for (var prop in copy) {
                dest[prop] = copy[prop];
            }
        });

        return dest;
    };


    // A Few reusable utils, memoized onto Popcorn
    Popcorn.extend(Popcorn, {
        noConflict: function (deep) {

            if (deep) {
                global.Popcorn = _Popcorn;
            }

            return Popcorn;
        },
        error: function (msg) {
            throw new Error(msg);
        },
        guid: function (prefix) {
            Popcorn.guid.counter++;
            return (prefix ? prefix : "") + (+new Date() + Popcorn.guid.counter);
        },
        sizeOf: function (obj) {
            var size = 0;

            for (var prop in obj) {
                size++;
            }

            return size;
        },
        isArray: Array.isArray || function (array) {
            return toString.call(array) === "[object Array]";
        },

        nop: function () { },

        position: function (elem) {

            var clientRect = elem.getBoundingClientRect(),
                bounds = {},
                doc = elem.ownerDocument,
                docElem = document.documentElement,
                body = document.body,
                clientTop, clientLeft, scrollTop, scrollLeft, top, left;

            //  Determine correct clientTop/Left
            clientTop = docElem.clientTop || body.clientTop || 0;
            clientLeft = docElem.clientLeft || body.clientLeft || 0;

            //  Determine correct scrollTop/Left
            scrollTop = (global.pageYOffset && docElem.scrollTop || body.scrollTop);
            scrollLeft = (global.pageXOffset && docElem.scrollLeft || body.scrollLeft);

            //  Temp top/left
            top = Math.ceil(clientRect.top + scrollTop - clientTop);
            left = Math.ceil(clientRect.left + scrollLeft - clientLeft);

            for (var p in clientRect) {
                bounds[p] = Math.round(clientRect[p]);
            }

            return Popcorn.extend({}, bounds, { top: top, left: left });
        },

        disable: function (instance, plugin) {

            if (!instance.data.disabled[plugin]) {

                instance.data.disabled[plugin] = true;

                for (var i = instance.data.running[plugin].length - 1, event; i >= 0; i--) {

                    event = instance.data.running[plugin][i];
                    event._natives.end.call(instance, null, event);
                }
            }

            return instance;
        },
        enable: function (instance, plugin) {

            if (instance.data.disabled[plugin]) {

                instance.data.disabled[plugin] = false;

                for (var i = instance.data.running[plugin].length - 1, event; i >= 0; i--) {

                    event = instance.data.running[plugin][i];
                    event._natives.start.call(instance, null, event);
                }
            }

            return instance;
        },
        destroy: function (instance) {
            var events = instance.data.events,
                trackEvents = instance.data.trackEvents,
                singleEvent, item, fn, plugin;

            //  Iterate through all events and remove them
            for (item in events) {
                singleEvent = events[item];
                for (fn in singleEvent) {
                    delete singleEvent[fn];
                }
                events[item] = null;
            }

            // remove all plugins off the given instance
            for (plugin in Popcorn.registryByName) {
                Popcorn.removePlugin(instance, plugin);
            }

            // Remove all data.trackEvents #1178
            trackEvents.byStart.length = 0;
            trackEvents.byEnd.length = 0;

            if (!instance.isDestroyed) {
                instance.data.timeUpdate && instance.media.removeEventListener("timeupdate", instance.data.timeUpdate, false);
                instance.isDestroyed = true;
            }
        }
    });

    //  Memoized GUID Counter
    Popcorn.guid.counter = 1;

    //  Factory to implement getters, setters and controllers
    //  as Popcorn instance methods. The IIFE will create and return
    //  an object with defined methods
    Popcorn.extend(Popcorn.p, (function () {

        var methods = "load play pause currentTime playbackRate volume duration preload playbackRate " +
                      "autoplay loop controls muted buffered readyState seeking paused played seekable ended",
            ret = {};


        //  Build methods, store in object that is returned and passed to extend
        Popcorn.forEach(methods.split(/\s+/g), function (name) {

            ret[name] = function (arg) {
                var previous;

                if (typeof this.media[name] === "function") {

                    // Support for shorthanded play(n)/pause(n) jump to currentTime
                    // If arg is not null or undefined and called by one of the
                    // allowed shorthandable methods, then set the currentTime
                    // Supports time as seconds or SMPTE
                    if (arg != null && /play|pause/.test(name)) {
                        this.media.currentTime = Popcorn.util.toSeconds(arg);
                    }

                    this.media[name]();

                    return this;
                }

                if (arg != null) {
                    // Capture the current value of the attribute property
                    previous = this.media[name];

                    // Set the attribute property with the new value
                    this.media[name] = arg;

                    // If the new value is not the same as the old value
                    // emit an "attrchanged event"
                    if (previous !== arg) {
                        this.emit("attrchange", {
                            attribute: name,
                            previousValue: previous,
                            currentValue: arg
                        });
                    }
                    return this;
                }

                return this.media[name];
            };
        });

        return ret;

    })()
    );

    Popcorn.forEach("enable disable".split(" "), function (method) {
        Popcorn.p[method] = function (plugin) {
            return Popcorn[method](this, plugin);
        };
    });

    Popcorn.extend(Popcorn.p, {

        //  Rounded currentTime
        roundTime: function () {
            return Math.round(this.media.currentTime);
        },

        //  Attach an event to a single point in time
        exec: function (id, time, fn) {
            var length = arguments.length,
                trackEvent, sec;

            // Check if first could possibly be a SMPTE string
            // p.cue( "smpte string", fn );
            // try/catch avoid awful throw in Popcorn.util.toSeconds
            // TODO: Get rid of that, replace with NaN return?
            try {
                sec = Popcorn.util.toSeconds(id);
            } catch (e) { }

            // If it can be converted into a number then
            // it's safe to assume that the string was SMPTE
            if (typeof sec === "number") {
                id = sec;
            }

            // Shift arguments based on use case
            //
            // Back compat for:
            // p.cue( time, fn );
            if (typeof id === "number" && length === 2) {
                fn = time;
                time = id;
                id = Popcorn.guid("cue");
            } else {
                // Support for new forms

                // p.cue( "empty-cue" );
                if (length === 1) {
                    // Set a time for an empty cue. It's not important what
                    // the time actually is, because the cue is a no-op
                    time = -1;

                } else {

                    // Get the trackEvent that matches the given id.
                    trackEvent = this.getTrackEvent(id);

                    if (trackEvent) {

                        // p.cue( "my-id", 12 );
                        // p.cue( "my-id", function() { ... });
                        if (typeof id === "string" && length === 2) {

                            // p.cue( "my-id", 12 );
                            // The path will update the cue time.
                            if (typeof time === "number") {
                                // Re-use existing trackEvent start callback
                                fn = trackEvent._natives.start;
                            }

                            // p.cue( "my-id", function() { ... });
                            // The path will update the cue function
                            if (typeof time === "function") {
                                fn = time;
                                // Re-use existing trackEvent start time
                                time = trackEvent.start;
                            }
                        }
                    } else {

                        if (length >= 2) {

                            // p.cue( "a", "00:00:00");
                            if (typeof time === "string") {
                                try {
                                    sec = Popcorn.util.toSeconds(time);
                                } catch (e) { }

                                time = sec;
                            }

                            // p.cue( "b", 11 );
                            if (typeof time === "number") {
                                fn = Popcorn.nop();
                            }

                            // p.cue( "c", function() {});
                            if (typeof time === "function") {
                                fn = time;
                                time = -1;
                            }
                        }
                    }
                }
            }

            //  Creating a one second track event with an empty end
            //  Or update an existing track event with new values
            Popcorn.addTrackEvent(this, {
                id: id,
                start: time,
                end: time + 1,
                _running: false,
                _natives: {
                    start: fn || Popcorn.nop,
                    end: Popcorn.nop,
                    type: "cue"
                }
            });

            return this;
        },

        // Mute the calling media, optionally toggle
        mute: function (toggle) {

            var event = toggle == null || toggle === true ? "muted" : "unmuted";

            // If `toggle` is explicitly `false`,
            // unmute the media and restore the volume level
            if (event === "unmuted") {
                this.media.muted = false;
                this.media.volume = this.data.state.volume;
            }

            // If `toggle` is either null or undefined,
            // save the current volume and mute the media element
            if (event === "muted") {
                this.data.state.volume = this.media.volume;
                this.media.muted = true;
            }

            // Trigger either muted|unmuted event
            this.emit(event);

            return this;
        },

        // Convenience method, unmute the calling media
        unmute: function (toggle) {

            return this.mute(toggle == null ? false : !toggle);
        },

        // Get the client bounding box of an instance element
        position: function () {
            return Popcorn.position(this.media);
        },

        // Toggle a plugin's playback behaviour (on or off) per instance
        toggle: function (plugin) {
            return Popcorn[this.data.disabled[plugin] ? "enable" : "disable"](this, plugin);
        },

        // Set default values for plugin options objects per instance
        defaults: function (plugin, defaults) {

            // If an array of default configurations is provided,
            // iterate and apply each to this instance
            if (Popcorn.isArray(plugin)) {

                Popcorn.forEach(plugin, function (obj) {
                    for (var name in obj) {
                        this.defaults(name, obj[name]);
                    }
                }, this);

                return this;
            }

            if (!this.options.defaults) {
                this.options.defaults = {};
            }

            if (!this.options.defaults[plugin]) {
                this.options.defaults[plugin] = {};
            }

            Popcorn.extend(this.options.defaults[plugin], defaults);

            return this;
        }
    });

    Popcorn.Events = {
        UIEvents: "blur focus focusin focusout load resize scroll unload",
        MouseEvents: "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave click dblclick",
        Events: "loadstart progress suspend emptied stalled play pause error " +
                "loadedmetadata loadeddata waiting playing canplay canplaythrough " +
                "seeking seeked timeupdate ended ratechange durationchange volumechange"
    };

    Popcorn.Events.Natives = Popcorn.Events.UIEvents + " " +
                             Popcorn.Events.MouseEvents + " " +
                             Popcorn.Events.Events;

    internal.events.apiTypes = ["UIEvents", "MouseEvents", "Events"];

    // Privately compile events table at load time
    (function (events, data) {

        var apis = internal.events.apiTypes,
        eventsList = events.Natives.split(/\s+/g),
        idx = 0, len = eventsList.length, prop;

        for (; idx < len; idx++) {
            data.hash[eventsList[idx]] = true;
        }

        apis.forEach(function (val, idx) {

            data.apis[val] = {};

            var apiEvents = events[val].split(/\s+/g),
            len = apiEvents.length,
            k = 0;

            for (; k < len; k++) {
                data.apis[val][apiEvents[k]] = true;
            }
        });
    })(Popcorn.Events, internal.events);

    Popcorn.events = {

        isNative: function (type) {
            return !!internal.events.hash[type];
        },
        getInterface: function (type) {

            if (!Popcorn.events.isNative(type)) {
                return false;
            }

            var eventApi = internal.events,
              apis = eventApi.apiTypes,
              apihash = eventApi.apis,
              idx = 0, len = apis.length, api, tmp;

            for (; idx < len; idx++) {
                tmp = apis[idx];

                if (apihash[tmp][type]) {
                    api = tmp;
                    break;
                }
            }
            return api;
        },
        //  Compile all native events to single array
        all: Popcorn.Events.Natives.split(/\s+/g),
        //  Defines all Event handling static functions
        fn: {
            trigger: function (type, data) {

                var eventInterface, evt;
                //  setup checks for custom event system
                if (this.data.events[type] && Popcorn.sizeOf(this.data.events[type])) {

                    eventInterface = Popcorn.events.getInterface(type);

                    if (eventInterface) {

                        evt = document.createEvent(eventInterface);
                        evt.initEvent(type, true, true, global, 1);

                        this.media.dispatchEvent(evt);

                        return this;
                    }

                    //  Custom events
                    Popcorn.forEach(this.data.events[type], function (obj, key) {

                        obj.call(this, data);

                    }, this);

                }

                return this;
            },
            listen: function (type, fn) {

                var self = this,
                    hasEvents = true,
                    eventHook = Popcorn.events.hooks[type],
                    origType = type,
                    tmp;

                if (!this.data.events[type]) {
                    this.data.events[type] = {};
                    hasEvents = false;
                }

                // Check and setup event hooks
                if (eventHook) {

                    // Execute hook add method if defined
                    if (eventHook.add) {
                        eventHook.add.call(this, {}, fn);
                    }

                    // Reassign event type to our piggyback event type if defined
                    if (eventHook.bind) {
                        type = eventHook.bind;
                    }

                    // Reassign handler if defined
                    if (eventHook.handler) {
                        tmp = fn;

                        fn = function wrapper(event) {
                            eventHook.handler.call(self, event, tmp);
                        };
                    }

                    // assume the piggy back event is registered
                    hasEvents = true;

                    // Setup event registry entry
                    if (!this.data.events[type]) {
                        this.data.events[type] = {};
                        // Toggle if the previous assumption was untrue
                        hasEvents = false;
                    }
                }

                //  Register event and handler
                this.data.events[type][fn.name || (fn.toString() + Popcorn.guid())] = fn;

                // only attach one event of any type
                if (!hasEvents && Popcorn.events.all.indexOf(type) > -1) {

                    this.media.addEventListener(type, function (event) {

                        Popcorn.forEach(self.data.events[type], function (obj, key) {
                            if (typeof obj === "function") {
                                obj.call(self, event);
                            }
                        });

                    }, false);
                }
                return this;
            },
            unlisten: function (type, fn) {

                if (this.data.events[type] && this.data.events[type][fn]) {

                    delete this.data.events[type][fn];

                    return this;
                }

                this.data.events[type] = null;

                return this;
            }
        },
        hooks: {
            canplayall: {
                bind: "canplaythrough",
                add: function (event, callback) {

                    var state = false;

                    if (this.media.readyState) {

                        callback.call(this, event);

                        state = true;
                    }

                    this.data.hooks.canplayall = {
                        fired: state
                    };
                },
                // declare special handling instructions
                handler: function canplayall(event, callback) {

                    if (!this.data.hooks.canplayall.fired) {
                        // trigger original user callback once
                        callback.call(this, event);

                        this.data.hooks.canplayall.fired = true;
                    }
                }
            }
        }
    };

    //  Extend Popcorn.events.fns (listen, unlisten, trigger) to all Popcorn instances
    //  Extend aliases (on, off, emit)
    Popcorn.forEach([["trigger", "emit"], ["listen", "on"], ["unlisten", "off"]], function (key) {
        Popcorn.p[key[0]] = Popcorn.p[key[1]] = Popcorn.events.fn[key[0]];
    });

    // Internal Only - Adds track events to the instance object
    Popcorn.addTrackEvent = function (obj, track) {
        var trackEvent, isUpdate, eventType;

        // Do a lookup for existing trackevents with this id
        if (track.id) {
            trackEvent = obj.getTrackEvent(track.id);
        }

        // If a track event by this id currently exists, modify it
        if (trackEvent) {
            isUpdate = true;
            // Create a new object with the existing trackEvent
            // Extend with new track properties
            track = Popcorn.extend({}, trackEvent, track);

            // Remove the existing track from the instance
            obj.removeTrackEvent(track.id);
        }

        // Determine if this track has default options set for it
        // If so, apply them to the track object
        if (track && track._natives && track._natives.type &&
            (obj.options.defaults && obj.options.defaults[track._natives.type])) {

            track = Popcorn.extend({}, obj.options.defaults[track._natives.type], track);
        }

        if (track._natives) {
            //  Supports user defined track event id
            track._id = track.id || track._id || Popcorn.guid(track._natives.type);

            //  Push track event ids into the history
            obj.data.history.push(track._id);
        }

        track.start = Popcorn.util.toSeconds(track.start, obj.options.framerate);
        track.end = Popcorn.util.toSeconds(track.end, obj.options.framerate);

        //  Store this definition in an array sorted by times
        var byStart = obj.data.trackEvents.byStart,
            byEnd = obj.data.trackEvents.byEnd,
            startIndex, endIndex;

        for (startIndex = byStart.length - 1; startIndex >= 0; startIndex--) {

            if (track.start >= byStart[startIndex].start) {
                byStart.splice(startIndex + 1, 0, track);
                break;
            }
        }

        for (endIndex = byEnd.length - 1; endIndex >= 0; endIndex--) {

            if (track.end > byEnd[endIndex].end) {
                byEnd.splice(endIndex + 1, 0, track);
                break;
            }
        }

        // Display track event immediately if it's enabled and current
        if (track.end > obj.media.currentTime &&
            track.start <= obj.media.currentTime) {

            track._running = true;
            obj.data.running[track._natives.type].push(track);

            if (!obj.data.disabled[track._natives.type]) {

                track._natives.start.call(obj, null, track);
            }
        }

        // update startIndex and endIndex
        if (startIndex <= obj.data.trackEvents.startIndex &&
          track.start <= obj.data.trackEvents.previousUpdateTime) {

            obj.data.trackEvents.startIndex++;
        }

        if (endIndex <= obj.data.trackEvents.endIndex &&
          track.end < obj.data.trackEvents.previousUpdateTime) {

            obj.data.trackEvents.endIndex++;
        }

        this.timeUpdate(obj, null, true);

        // Store references to user added trackevents in ref table
        if (track._id) {
            Popcorn.addTrackEvent.ref(obj, track);
        }

        // If the call to addTrackEvent was an update/modify call, fire an event
        if (isUpdate) {

            // Determine appropriate event type to trigger
            // they are identical in function, but the naming
            // adds some level of intuition for the end developer
            // to rely on
            if (track._natives.type === "cue") {
                eventType = "cuechange";
            } else {
                eventType = "trackchange";
            }

            // Fire an event with change information
            obj.emit(eventType, {
                id: track.id,
                previousValue: {
                    time: trackEvent.start,
                    fn: trackEvent._natives.start
                },
                currentValue: {
                    time: track.start,
                    fn: track._natives.start
                }
            });
        }
    };

    // Internal Only - Adds track event references to the instance object's trackRefs hash table
    Popcorn.addTrackEvent.ref = function (obj, track) {
        obj.data.trackRefs[track._id] = track;

        return obj;
    };

    Popcorn.removeTrackEvent = function (obj, removeId) {

        var start, end, animate,
            historyLen = obj.data.history.length,
            length = obj.data.trackEvents.byStart.length,
            index = 0,
            indexWasAt = 0,
            byStart = [],
            byEnd = [],
            animating = [],
            history = [];

        while (--length > -1) {
            start = obj.data.trackEvents.byStart[index];
            end = obj.data.trackEvents.byEnd[index];

            // Padding events will not have _id properties.
            // These should be safely pushed onto the front and back of the
            // track event array
            if (!start._id) {
                byStart.push(start);
                byEnd.push(end);
            }

            // Filter for user track events (vs system track events)
            if (start._id) {

                // If not a matching start event for removal
                if (start._id !== removeId) {
                    byStart.push(start);
                }

                // If not a matching end event for removal
                if (end._id !== removeId) {
                    byEnd.push(end);
                }

                // If the _id is matched, capture the current index
                if (start._id === removeId) {
                    indexWasAt = index;

                    // If a _teardown function was defined,
                    // enforce for track event removals
                    if (start._natives._teardown) {
                        start._natives._teardown.call(obj, start);
                    }
                }
            }
            // Increment the track index
            index++;
        }

        // Reset length to be used by the condition below to determine
        // if animating track events should also be filtered for removal.
        // Reset index below to be used by the reverse while as an
        // incrementing counter
        length = obj.data.trackEvents.animating.length;
        index = 0;

        if (length) {
            while (--length > -1) {
                animate = obj.data.trackEvents.animating[index];

                // Padding events will not have _id properties.
                // These should be safely pushed onto the front and back of the
                // track event array
                if (!animate._id) {
                    animating.push(animate);
                }

                // If not a matching animate event for removal
                if (animate._id && animate._id !== removeId) {
                    animating.push(animate);
                }
                // Increment the track index
                index++;
            }
        }

        //  Update
        if (indexWasAt <= obj.data.trackEvents.startIndex) {
            obj.data.trackEvents.startIndex--;
        }

        if (indexWasAt <= obj.data.trackEvents.endIndex) {
            obj.data.trackEvents.endIndex--;
        }

        obj.data.trackEvents.byStart = byStart;
        obj.data.trackEvents.byEnd = byEnd;
        obj.data.trackEvents.animating = animating;

        for (var i = 0; i < historyLen; i++) {
            if (obj.data.history[i] !== removeId) {
                history.push(obj.data.history[i]);
            }
        }

        // Update ordered history array
        obj.data.history = history;

        // Update track event references
        Popcorn.removeTrackEvent.ref(obj, removeId);
    };

    // Internal Only - Removes track event references from instance object's trackRefs hash table
    Popcorn.removeTrackEvent.ref = function (obj, removeId) {
        delete obj.data.trackRefs[removeId];

        return obj;
    };

    // Return an array of track events bound to this instance object
    Popcorn.getTrackEvents = function (obj) {

        var trackevents = [],
          refs = obj.data.trackEvents.byStart,
          length = refs.length,
          idx = 0,
          ref;

        for (; idx < length; idx++) {
            ref = refs[idx];
            // Return only user attributed track event references
            if (ref._id) {
                trackevents.push(ref);
            }
        }

        return trackevents;
    };

    // Internal Only - Returns an instance object's trackRefs hash table
    Popcorn.getTrackEvents.ref = function (obj) {
        return obj.data.trackRefs;
    };

    // Return a single track event bound to this instance object
    Popcorn.getTrackEvent = function (obj, trackId) {
        return obj.data.trackRefs[trackId];
    };

    // Internal Only - Returns an instance object's track reference by track id
    Popcorn.getTrackEvent.ref = function (obj, trackId) {
        return obj.data.trackRefs[trackId];
    };

    Popcorn.getLastTrackEventId = function (obj) {
        return obj.data.history[obj.data.history.length - 1];
    };

    Popcorn.timeUpdate = function (obj, event) {

        var currentTime = obj.media.currentTime,
            previousTime = obj.data.trackEvents.previousUpdateTime,
            tracks = obj.data.trackEvents,
            end = tracks.endIndex,
            start = tracks.startIndex,
            byStartLen = tracks.byStart.length,
            byEndLen = tracks.byEnd.length,
            registryByName = Popcorn.registryByName,
            trackstart = "trackstart",
            trackend = "trackend",

            byEnd, byStart, byAnimate, natives, type, runningPlugins;

        //  Playbar advancing
        if (previousTime <= currentTime) {

            while (tracks.byEnd[end] && tracks.byEnd[end].end <= currentTime) {

                byEnd = tracks.byEnd[end];
                natives = byEnd._natives;
                type = natives && natives.type;

                //  If plugin does not exist on this instance, remove it
                if (!natives ||
                    (!!registryByName[type] ||
                      !!obj[type])) {

                    if (byEnd._running === true) {

                        byEnd._running = false;
                        runningPlugins = obj.data.running[type];
                        runningPlugins.splice(runningPlugins.indexOf(byEnd), 1);

                        if (!obj.data.disabled[type]) {

                            natives.end.call(obj, event, byEnd);

                            obj.emit(trackend,
                              Popcorn.extend({}, byEnd, {
                                  plugin: type,
                                  type: trackend
                              })
                            );
                        }
                    }

                    end++;
                } else {
                    // remove track event
                    Popcorn.removeTrackEvent(obj, byEnd._id);
                    return;
                }
            }

            while (tracks.byStart[start] && tracks.byStart[start].start <= currentTime) {

                byStart = tracks.byStart[start];
                natives = byStart._natives;
                type = natives && natives.type;

                //  If plugin does not exist on this instance, remove it
                if (!natives ||
                    (!!registryByName[type] ||
                      !!obj[type])) {

                    if (byStart.end > currentTime &&
                          byStart._running === false) {

                        byStart._running = true;
                        obj.data.running[type].push(byStart);

                        if (!obj.data.disabled[type]) {

                            natives.start.call(obj, event, byStart);

                            obj.emit(trackstart,
                              Popcorn.extend({}, byStart, {
                                  plugin: type,
                                  type: trackstart
                              })
                            );
                        }
                    }
                    start++;
                } else {
                    // remove track event
                    Popcorn.removeTrackEvent(obj, byStart._id);
                    return;
                }
            }

            // Playbar receding
        } else if (previousTime > currentTime) {

            while (tracks.byStart[start] && tracks.byStart[start].start > currentTime) {

                byStart = tracks.byStart[start];
                natives = byStart._natives;
                type = natives && natives.type;

                // if plugin does not exist on this instance, remove it
                if (!natives ||
                    (!!registryByName[type] ||
                      !!obj[type])) {

                    if (byStart._running === true) {

                        byStart._running = false;
                        runningPlugins = obj.data.running[type];
                        runningPlugins.splice(runningPlugins.indexOf(byStart), 1);

                        if (!obj.data.disabled[type]) {

                            natives.end.call(obj, event, byStart);

                            obj.emit(trackend,
                              Popcorn.extend({}, byStart, {
                                  plugin: type,
                                  type: trackend
                              })
                            );
                        }
                    }
                    start--;
                } else {
                    // remove track event
                    Popcorn.removeTrackEvent(obj, byStart._id);
                    return;
                }
            }

            while (tracks.byEnd[end] && tracks.byEnd[end].end > currentTime) {

                byEnd = tracks.byEnd[end];
                natives = byEnd._natives;
                type = natives && natives.type;

                // if plugin does not exist on this instance, remove it
                if (!natives ||
                    (!!registryByName[type] ||
                      !!obj[type])) {

                    if (byEnd.start <= currentTime &&
                          byEnd._running === false) {

                        byEnd._running = true;
                        obj.data.running[type].push(byEnd);

                        if (!obj.data.disabled[type]) {

                            natives.start.call(obj, event, byEnd);

                            obj.emit(trackstart,
                              Popcorn.extend({}, byEnd, {
                                  plugin: type,
                                  type: trackstart
                              })
                            );
                        }
                    }
                    end--;
                } else {
                    // remove track event
                    Popcorn.removeTrackEvent(obj, byEnd._id);
                    return;
                }
            }
        }

        tracks.endIndex = end;
        tracks.startIndex = start;
        tracks.previousUpdateTime = currentTime;

        //enforce index integrity if trackRemoved
        tracks.byStart.length < byStartLen && tracks.startIndex--;
        tracks.byEnd.length < byEndLen && tracks.endIndex--;

    };

    //  Map and Extend TrackEvent functions to all Popcorn instances
    Popcorn.extend(Popcorn.p, {

        getTrackEvents: function () {
            return Popcorn.getTrackEvents.call(null, this);
        },

        getTrackEvent: function (id) {
            return Popcorn.getTrackEvent.call(null, this, id);
        },

        getLastTrackEventId: function () {
            return Popcorn.getLastTrackEventId.call(null, this);
        },

        removeTrackEvent: function (id) {

            Popcorn.removeTrackEvent.call(null, this, id);
            return this;
        },

        removePlugin: function (name) {
            Popcorn.removePlugin.call(null, this, name);
            return this;
        },

        timeUpdate: function (event) {
            Popcorn.timeUpdate.call(null, this, event);
            return this;
        },

        destroy: function () {
            Popcorn.destroy.call(null, this);
            return this;
        }
    });

    //  Plugin manifests
    Popcorn.manifest = {};
    //  Plugins are registered
    Popcorn.registry = [];
    Popcorn.registryByName = {};
    //  An interface for extending Popcorn
    //  with plugin functionality
    Popcorn.plugin = function (name, definition, manifest) {

        if (Popcorn.protect.natives.indexOf(name.toLowerCase()) >= 0) {
            Popcorn.error("'" + name + "' is a protected function name");
            return;
        }

        //  Provides some sugar, but ultimately extends
        //  the definition into Popcorn.p
        var reserved = ["start", "end"],
            plugin = {},
            setup,
            isfn = typeof definition === "function",
            methods = ["_setup", "_teardown", "start", "end", "frame"];

        // combines calls of two function calls into one
        var combineFn = function (first, second) {

            first = first || Popcorn.nop;
            second = second || Popcorn.nop;

            return function () {
                first.apply(this, arguments);
                second.apply(this, arguments);
            };
        };

        //  If `manifest` arg is undefined, check for manifest within the `definition` object
        //  If no `definition.manifest`, an empty object is a sufficient fallback
        Popcorn.manifest[name] = manifest = manifest || definition.manifest || {};

        // apply safe, and empty default functions
        methods.forEach(function (method) {
            definition[method] = safeTry(definition[method] || Popcorn.nop, name);
        });

        var pluginFn = function (setup, options) {

            if (!options) {
                return this;
            }

            // When the "ranges" property is set and its value is an array, short-circuit
            // the pluginFn definition to recall itself with an options object generated from
            // each range object in the ranges array. (eg. { start: 15, end: 16 } )
            if (options.ranges && Popcorn.isArray(options.ranges)) {
                Popcorn.forEach(options.ranges, function (range) {
                    // Create a fresh object, extend with current options
                    // and start/end range object's properties
                    // Works with in/out as well.
                    var opts = Popcorn.extend({}, options, range);

                    // Remove the ranges property to prevent infinitely
                    // entering this condition
                    delete opts.ranges;

                    // Call the plugin with the newly created opts object
                    this[name](opts);
                }, this);

                // Return the Popcorn instance to avoid creating an empty track event
                return this;
            }

            //  Storing the plugin natives
            var natives = options._natives = {},
                compose = "",
                originalOpts, manifestOpts;

            Popcorn.extend(natives, setup);

            options._natives.type = name;
            options._running = false;

            natives.start = natives.start || natives["in"];
            natives.end = natives.end || natives["out"];

            if (options.once) {
                natives.end = combineFn(natives.end, function () {
                    this.removeTrackEvent(options._id);
                });
            }

            // extend teardown to always call end if running
            natives._teardown = combineFn(function () {

                var args = slice.call(arguments),
                    runningPlugins = this.data.running[natives.type];

                // end function signature is not the same as teardown,
                // put null on the front of arguments for the event parameter
                args.unshift(null);

                // only call end if event is running
                args[1]._running &&
                  runningPlugins.splice(runningPlugins.indexOf(options), 1) &&
                  natives.end.apply(this, args);
            }, natives._teardown);

            // default to an empty string if no effect exists
            // split string into an array of effects
            options.compose = options.compose && options.compose.split(" ") || [];
            options.effect = options.effect && options.effect.split(" ") || [];

            // join the two arrays together
            options.compose = options.compose.concat(options.effect);

            options.compose.forEach(function (composeOption) {

                // if the requested compose is garbage, throw it away
                compose = Popcorn.compositions[composeOption] || {};

                // extends previous functions with compose function
                methods.forEach(function (method) {
                    natives[method] = combineFn(natives[method], compose[method]);
                });
            });

            //  Ensure a manifest object, an empty object is a sufficient fallback
            options._natives.manifest = manifest;

            //  Checks for expected properties
            if (!("start" in options)) {
                options.start = options["in"] || 0;
            }

            if (!options.end && options.end !== 0) {
                options.end = options["out"] || Number.MAX_VALUE;
            }

            // Use hasOwn to detect non-inherited toString, since all
            // objects will receive a toString - its otherwise undetectable
            if (!hasOwn.call(options, "toString")) {
                options.toString = function () {
                    var props = [
                      "start: " + options.start,
                      "end: " + options.end,
                      "id: " + (options.id || options._id)
                    ];

                    // Matches null and undefined, allows: false, 0, "" and truthy
                    if (options.target != null) {
                        props.push("target: " + options.target);
                    }

                    return name + " ( " + props.join(", ") + " )";
                };
            }

            // Resolves 239, 241, 242
            if (!options.target) {

                //  Sometimes the manifest may be missing entirely
                //  or it has an options object that doesn't have a `target` property
                manifestOpts = "options" in manifest && manifest.options;

                options.target = manifestOpts && "target" in manifestOpts && manifestOpts.target;
            }

            if (options._natives) {
                // ensure an initial id is there before setup is called
                options._id = Popcorn.guid(options._natives.type);
            }

            // Trigger _setup method if exists
            options._natives._setup && options._natives._setup.call(this, options);

            // Create new track event for this instance
            Popcorn.addTrackEvent(this, options);

            //  Future support for plugin event definitions
            //  for all of the native events
            Popcorn.forEach(setup, function (callback, type) {

                if (type !== "type") {

                    if (reserved.indexOf(type) === -1) {

                        this.on(type, callback);
                    }
                }

            }, this);

            return this;
        };

        //  Extend Popcorn.p with new named definition
        //  Assign new named definition
        Popcorn.p[name] = plugin[name] = function (id, options) {
            var length = arguments.length,
                trackEvent, defaults, mergedSetupOpts;

            // Shift arguments based on use case
            //
            // Back compat for:
            // p.plugin( options );
            if (id && !options) {
                options = id;
                id = null;
            } else {

                // Get the trackEvent that matches the given id.
                trackEvent = this.getTrackEvent(id);

                // If the track event does not exist, ensure that the options
                // object has a proper id
                if (!trackEvent) {
                    options.id = id;

                    // If the track event does exist, merge the updated properties
                } else {

                    options = Popcorn.extend({}, trackEvent, options);

                    Popcorn.addTrackEvent(this, options);

                    return this;
                }
            }

            this.data.running[name] = this.data.running[name] || [];

            // Merge with defaults if they exist, make sure per call is prioritized
            defaults = (this.options.defaults && this.options.defaults[name]) || {};
            mergedSetupOpts = Popcorn.extend({}, defaults, options);

            return pluginFn.call(this, isfn ? definition.call(this, mergedSetupOpts) : definition,
                                        mergedSetupOpts);
        };

        // if the manifest parameter exists we should extend it onto the definition object
        // so that it shows up when calling Popcorn.registry and Popcorn.registryByName
        if (manifest) {
            Popcorn.extend(definition, {
                manifest: manifest
            });
        }

        //  Push into the registry
        var entry = {
            fn: plugin[name],
            definition: definition,
            base: definition,
            parents: [],
            name: name
        };
        Popcorn.registry.push(
           Popcorn.extend(plugin, entry, {
               type: name
           })
        );
        Popcorn.registryByName[name] = entry;

        return plugin;
    };

    // Storage for plugin function errors
    Popcorn.plugin.errors = [];

    // Returns wrapped plugin function
    function safeTry(fn, pluginName) {
        return function () {

            //  When Popcorn.plugin.debug is true, do not suppress errors
            if (Popcorn.plugin.debug) {
                return fn.apply(this, arguments);
            }

            try {
                return fn.apply(this, arguments);
            } catch (ex) {

                // Push plugin function errors into logging queue
                Popcorn.plugin.errors.push({
                    plugin: pluginName,
                    thrown: ex,
                    source: fn.toString()
                });

                // Trigger an error that the instance can listen for
                // and react to
                this.emit("pluginerror", Popcorn.plugin.errors);
            }
        };
    }

    // Debug-mode flag for plugin development
    // True for Popcorn development versions, false for stable/tagged versions
    Popcorn.plugin.debug = (Popcorn.version === "@" + "VERSION");

    //  removePlugin( type ) removes all tracks of that from all instances of popcorn
    //  removePlugin( obj, type ) removes all tracks of type from obj, where obj is a single instance of popcorn
    Popcorn.removePlugin = function (obj, name) {

        //  Check if we are removing plugin from an instance or from all of Popcorn
        if (!name) {

            //  Fix the order
            name = obj;
            obj = Popcorn.p;

            if (Popcorn.protect.natives.indexOf(name.toLowerCase()) >= 0) {
                Popcorn.error("'" + name + "' is a protected function name");
                return;
            }

            var registryLen = Popcorn.registry.length,
                registryIdx;

            // remove plugin reference from registry
            for (registryIdx = 0; registryIdx < registryLen; registryIdx++) {
                if (Popcorn.registry[registryIdx].name === name) {
                    Popcorn.registry.splice(registryIdx, 1);
                    delete Popcorn.registryByName[name];
                    delete Popcorn.manifest[name];

                    // delete the plugin
                    delete obj[name];

                    // plugin found and removed, stop checking, we are done
                    return;
                }
            }

        }

        var byStart = obj.data.trackEvents.byStart,
            byEnd = obj.data.trackEvents.byEnd,
            animating = obj.data.trackEvents.animating,
            idx, sl;

        // remove all trackEvents
        for (idx = 0, sl = byStart.length; idx < sl; idx++) {

            if (byStart[idx] && byStart[idx]._natives && byStart[idx]._natives.type === name) {

                byStart[idx]._natives._teardown && byStart[idx]._natives._teardown.call(obj, byStart[idx]);

                byStart.splice(idx, 1);

                // update for loop if something removed, but keep checking
                idx--; sl--;
                if (obj.data.trackEvents.startIndex <= idx) {
                    obj.data.trackEvents.startIndex--;
                    obj.data.trackEvents.endIndex--;
                }
            }

            // clean any remaining references in the end index
            // we do this seperate from the above check because they might not be in the same order
            if (byEnd[idx] && byEnd[idx]._natives && byEnd[idx]._natives.type === name) {

                byEnd.splice(idx, 1);
            }
        }

        //remove all animating events
        for (idx = 0, sl = animating.length; idx < sl; idx++) {

            if (animating[idx] && animating[idx]._natives && animating[idx]._natives.type === name) {

                animating.splice(idx, 1);

                // update for loop if something removed, but keep checking
                idx--; sl--;
            }
        }

    };

    Popcorn.compositions = {};

    //  Plugin inheritance
    Popcorn.compose = function (name, definition, manifest) {

        //  If `manifest` arg is undefined, check for manifest within the `definition` object
        //  If no `definition.manifest`, an empty object is a sufficient fallback
        Popcorn.manifest[name] = manifest = manifest || definition.manifest || {};

        // register the effect by name
        Popcorn.compositions[name] = definition;
    };

    Popcorn.plugin.effect = Popcorn.effect = Popcorn.compose;

    var rnaiveExpr = /^(?:\.|#|\[)/;

    //  Basic DOM utilities and helpers API. See #1037
    Popcorn.dom = {
        debug: false,
        //  Popcorn.dom.find( selector, context )
        //
        //  Returns the first element that matches the specified selector
        //  Optionally provide a context element, defaults to `document`
        //
        //  eg.
        //  Popcorn.dom.find("video") returns the first video element
        //  Popcorn.dom.find("#foo") returns the first element with `id="foo"`
        //  Popcorn.dom.find("foo") returns the first element with `id="foo"`
        //     Note: Popcorn.dom.find("foo") is the only allowed deviation
        //           from valid querySelector selector syntax
        //
        //  Popcorn.dom.find(".baz") returns the first element with `class="baz"`
        //  Popcorn.dom.find("[preload]") returns the first element with `preload="..."`
        //  ...
        //  See https://developer.mozilla.org/En/DOM/Document.querySelector
        //
        //
        find: function (selector, context) {
            var node = null;

            //  Trim leading/trailing whitespace to avoid false negatives
            selector = selector.trim();

            //  Default context is the `document`
            context = context || document;

            if (selector) {
                //  If the selector does not begin with "#", "." or "[",
                //  it could be either a nodeName or ID w/o "#"
                if (!rnaiveExpr.test(selector)) {

                    //  Try finding an element that matches by ID first
                    node = document.getElementById(selector);

                    //  If a match was found by ID, return the element
                    if (node !== null) {
                        return node;
                    }
                }
                //  Assume no elements have been found yet
                //  Catch any invalid selector syntax errors and bury them.
                try {
                    node = context.querySelector(selector);
                } catch (e) {
                    if (Popcorn.dom.debug) {
                        throw new Error(e);
                    }
                }
            }
            return node;
        }
    };

    //  Cache references to reused RegExps
    var rparams = /\?/,
    //  XHR Setup object
    setup = {
        url: "",
        data: "",
        dataType: "",
        success: Popcorn.nop,
        type: "GET",
        async: true,
        xhr: function () {
            return new global.XMLHttpRequest();
        }
    };

    Popcorn.xhr = function (options) {

        options.dataType = options.dataType && options.dataType.toLowerCase() || null;

        if (options.dataType &&
             (options.dataType === "jsonp" || options.dataType === "script")) {

            Popcorn.xhr.getJSONP(
              options.url,
              options.success,
              options.dataType === "script"
            );
            return;
        }

        var settings = Popcorn.extend({}, setup, options);

        //  Create new XMLHttpRequest object
        settings.ajax = settings.xhr();

        if (settings.ajax) {

            if (settings.type === "GET" && settings.data) {

                //  append query string
                settings.url += (rparams.test(settings.url) ? "&" : "?") + settings.data;

                //  Garbage collect and reset settings.data
                settings.data = null;
            }


            settings.ajax.open(settings.type, settings.url, settings.async);
            settings.ajax.send(settings.data || null);

            return Popcorn.xhr.httpData(settings);
        }
    };


    Popcorn.xhr.httpData = function (settings) {

        var data, json = null,
            parser, xml = null;

        settings.ajax.onreadystatechange = function () {

            if (settings.ajax.readyState === 4) {

                try {
                    json = JSON.parse(settings.ajax.responseText);
                } catch (e) {
                    //suppress
                }

                data = {
                    xml: settings.ajax.responseXML,
                    text: settings.ajax.responseText,
                    json: json
                };

                // Normalize: data.xml is non-null in IE9 regardless of if response is valid xml
                if (!data.xml || !data.xml.documentElement) {
                    data.xml = null;

                    try {
                        parser = new DOMParser();
                        xml = parser.parseFromString(settings.ajax.responseText, "text/xml");

                        if (!xml.getElementsByTagName("parsererror").length) {
                            data.xml = xml;
                        }
                    } catch (e) {
                        // data.xml remains null
                    }
                }

                //  If a dataType was specified, return that type of data
                if (settings.dataType) {
                    data = data[settings.dataType];
                }


                settings.success.call(settings.ajax, data);

            }
        };
        return data;
    };

    Popcorn.xhr.getJSONP = function (url, success, isScript) {

        var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement,
          script = document.createElement("script"),
          isFired = false,
          params = [],
          rjsonp = /(=)\?(?=&|$)|\?\?/,
          replaceInUrl, prefix, paramStr, callback, callparam;

        if (!isScript) {

            // is there a calback already in the url
            callparam = url.match(/(callback=[^&]*)/);

            if (callparam !== null && callparam.length) {

                prefix = callparam[1].split("=")[1];

                // Since we need to support developer specified callbacks
                // and placeholders in harmony, make sure matches to "callback="
                // aren't just placeholders.
                // We coded ourselves into a corner here.
                // JSONP callbacks should never have been
                // allowed to have developer specified callbacks
                if (prefix === "?") {
                    prefix = "jsonp";
                }

                // get the callback name
                callback = Popcorn.guid(prefix);

                // replace existing callback name with unique callback name
                url = url.replace(/(callback=[^&]*)/, "callback=" + callback);
            } else {

                callback = Popcorn.guid("jsonp");

                if (rjsonp.test(url)) {
                    url = url.replace(rjsonp, "$1" + callback);
                }

                // split on first question mark,
                // this is to capture the query string
                params = url.split(/\?(.+)?/);

                // rebuild url with callback
                url = params[0] + "?";
                if (params[1]) {
                    url += params[1] + "&";
                }
                url += "callback=" + callback;
            }

            //  Define the JSONP success callback globally
            window[callback] = function (data) {
                // Fire success callbacks
                success && success(data);
                isFired = true;
            };
        }

        script.addEventListener("load", function () {

            //  Handling remote script loading callbacks
            if (isScript) {
                //  getScript
                success && success();
            }

            //  Executing for JSONP requests
            if (isFired) {
                //  Garbage collect the callback
                delete window[callback];
            }
            //  Garbage collect the script resource
            head.removeChild(script);
        }, false);

        script.src = url;

        head.insertBefore(script, head.firstChild);

        return;
    };

    Popcorn.getJSONP = Popcorn.xhr.getJSONP;

    Popcorn.getScript = Popcorn.xhr.getScript = function (url, success) {

        return Popcorn.xhr.getJSONP(url, success, true);
    };

    Popcorn.util = {
        // Simple function to parse a timestamp into seconds
        // Acceptable formats are:
        // HH:MM:SS.MMM
        // HH:MM:SS;FF
        // Hours and minutes are optional. They default to 0
        toSeconds: function (timeStr, framerate) {
            // Hours and minutes are optional
            // Seconds must be specified
            // Seconds can be followed by milliseconds OR by the frame information
            var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/,
                errorMessage = "Invalid time format",
                digitPairs, lastIndex, lastPair, firstPair,
                frameInfo, frameTime;

            if (typeof timeStr === "number") {
                return timeStr;
            }

            if (typeof timeStr === "string" &&
                  !validTimeFormat.test(timeStr)) {
                Popcorn.error(errorMessage);
            }

            digitPairs = timeStr.split(":");
            lastIndex = digitPairs.length - 1;
            lastPair = digitPairs[lastIndex];

            // Fix last element:
            if (lastPair.indexOf(";") > -1) {

                frameInfo = lastPair.split(";");
                frameTime = 0;

                if (framerate && (typeof framerate === "number")) {
                    frameTime = parseFloat(frameInfo[1], 10) / framerate;
                }

                digitPairs[lastIndex] = parseInt(frameInfo[0], 10) + frameTime;
            }

            firstPair = digitPairs[0];

            return {

                1: parseFloat(firstPair, 10),

                2: (parseInt(firstPair, 10) * 60) +
                      parseFloat(digitPairs[1], 10),

                3: (parseInt(firstPair, 10) * 3600) +
                    (parseInt(digitPairs[1], 10) * 60) +
                      parseFloat(digitPairs[2], 10)

            }[digitPairs.length || 1];
        }
    };

    // alias for exec function
    Popcorn.p.cue = Popcorn.p.exec;

    //  Protected API methods
    Popcorn.protect = {
        natives: getKeys(Popcorn.p).map(function (val) {
            return val.toLowerCase();
        })
    };

    // Setup logging for deprecated methods
    Popcorn.forEach({
        // Deprecated: Recommended
        "listen": "on",
        "unlisten": "off",
        "trigger": "emit",
        "exec": "cue"

    }, function (recommend, api) {
        var original = Popcorn.p[api];
        // Override the deprecated api method with a method of the same name
        // that logs a warning and defers to the new recommended method
        Popcorn.p[api] = function () {
            if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Deprecated method '" + api + "', " +
                  (recommend == null ? "do not use." : "use '" + recommend + "' instead.")
                );

                // Restore api after first warning
                Popcorn.p[api] = original;
            }
            return Popcorn.p[recommend].apply(this, [].slice.call(arguments));
        };
    });


    //  Exposes Popcorn to global context
    global.Popcorn = Popcorn;

})(window, window.document);
;
/*!
 * Popcorn.prototype.capture()
 *
 * Copyright 2011, Rick Waldron
 * Licensed under MIT license.
 *
 */

// Requires Popcorn.js
/* global Popcorn: true */
(function( global, Popcorn, document ) {

	var doc = document,
	defaults = {

		// Set image type, encodes as png by default
		type: "png",

		// Set to poster attribute, this occurs by default
		set: true,

		// Capture time, uses currentTime by default
		at: null,

		// Target selector, no target by default
		// Use by providing selector to an image element
		target: null,

		// Reload the video after poster is set
		// Otherwise the poster will not be displayed
		reload: true
	};

	Popcorn.prototype.capture = function( options ) {

		var context, dataUrl, seeked, targets, time,

		// Merge user options & defaults into new object
		opts = Popcorn.extend( {}, defaults, options ),

		// Media's position dimensions
		dims = this.position(),

		// Reused canvas id string
		canvasId = "popcorn-canvas-" + this.media.id,

		// The canvas element associated with this media
		canvas = doc.getElementById( canvasId );

		// If a time is provided
		if ( opts.at ) {

			// Normalize capture time in case smpte time was given
			opts.at = Popcorn.util.toSeconds( opts.at );

			// Save the current time
			time = this.currentTime();

			// Jump to the capture time
			this.currentTime( opts.at );
		}

		// If the canvas we want does not exist...
		if ( !canvas ) {

			// Create a new canvas
			canvas = doc.createElement("canvas");

			// Give it our known/expected ID
			canvas.id = canvasId;

			// Set it to the same dimensions as the target movie
			canvas.width = dims.width;
			canvas.height = dims.height;

			// Hide the canvas
			canvas.style.display = "none";

			// Append it to the same parent as the target movie
			this.media.parentNode.appendChild( canvas );
		}

		// Get the canvas's context for reading/writing
		context = canvas.getContext("2d");

		seeked = function() {

			// Draw the current media frame into the canvas
			context.drawImage( this.media, 0, 0, dims.width, dims.height );

			// Capture pixel data as a base64 encoded data url
			dataUrl = canvas.toDataURL( "image/" + opts.type );

			// If a target selector has been provided, set src to dataUrl
			if ( opts.target ) {
				targets = doc.querySelectorAll( opts.target );

				// If valid targets exist
				if ( targets.length ) {

					// Iterate all targets
					Popcorn.forEach( targets, function( node ) {

						// If target is a valid IMG element
						if ( node.nodeName === "IMG" ) {
							// Set the node's src to the captured dataUrl
							node.src = dataUrl;
						}
					});
				}
			}

			// By default, we set the poster attribute of the popcorn instance
			if ( opts.set ) {
				this.media.setAttribute( "poster", dataUrl );
			}

			// If a time is provided, Restore to original time
			if ( opts.at ) {
				// Jump back to original time
				this.listen( "loaded", function() {
					this.currentTime( time );
				});
			}

			// If a reload is provided, Restore the media
			if ( opts.reload ) {
				this.media.load();
			}

			this.unlisten( "seeked", seeked );

			this.trigger("captured");

			return dataUrl; // added by bleveque
		};

		this.listen( "seeked", seeked );

		if ( !opts.at ) {
		    var durl = seeked.call(this);
		    return durl;
		}

		return this; // modified from "return this" by bleveque
	};

})( this, this.Popcorn, this.document );
;

TAG.Telemetry = (function() {

	var requests  = [],
		sendFreq  = 1,  // telemetry data is sent once every sendFreq-th log
	    bversion  = browserVersion(),
	    platform  = navigator.platform;


	/**
	 * Get the current browser version
	 * Borrowed from http://stackoverflow.com/questions/5916900/detect-version-of-browser
	 * @method browserVersion
	 */
	function browserVersion() {
	    var ua= navigator.userAgent, tem, 
	    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) || [];
	    if(/trident/i.test(M[1])){
	        tem=  /\brv[ :]+(\d+(\.\d+)?)/g.exec(ua) || [];
	        return 'IE '+(tem[1] || '');
	    }
	    M= M[2]? [M[1], M[2]]:[navigator.appName, navigator.appVersion, '-?'];
	    if((tem= ua.match(/version\/([\.\d]+)/i))!= null) M[2]= tem[1];
	    return M.join(' ');
	}

	/**
	 * Register an element with the telemetry module
	 * @method registerTelemetry
	 * @param {jQuery Obj} element      the element or the jQuery selector to which we'll attach a telemetry event handler
	 * @param {String} etype            the type of event (e.g., 'mousedown') for which we'll create the handler
	 * @param {String} ttype            the type of telemetry request to log
	 * @param {Function} preHandler     do any pre-handling based on current state of TAG, add any additional
	 *                                     properties to the eventual telemetry object. Accepts the telemetry
	 *                                     object to augment and the event, and returns true if we should abort
	 *                                     further handling.
	 */
	function register(element, etype, ttype, preHandler) {
		$(element).on(etype + '.tag_telemetry', function(evt) {
			var date = new Date(),
				tobj = {
					ttype:      ttype,
					tagserver:  localStorage.ip || '',
					browser:    bversion,
					platform:   platform,
					time_stamp: date.getTime(),
					time_human: date.toString(),
					machine_id : localStorage.machId,
					session_id : TELEMETRY_SESSION_ID,
					mode : null,
					custom_1: null,
					custom_2: null,
					custom_3: null,
					custom_4: null,
					custom_5: null
				},
				ret = true;

			// if preHandler returns true, return
			if((preHandler && preHandler(tobj, evt)) || TELEMETRY_SWITCH==='off') {
				return;
			}

			requests.push(tobj);

			if(requests.length >= sendFreq - 1) { // tweak this later
				postTelemetryRequests();
			} 
		});
	}

	/**
	 * Make a request to the telemetry server using the requests variable
	 * @method postTelemetryRequests
	 */
	function postTelemetryRequests() {
	    var data = JSON.stringify(requests);

		requests.length = 0;

		$.ajax({
			type: 'POST',
			url: 'http://browntagserver.com:12043/',
			data: data, // this should be encrypted.toString() for encrypting the data
			async: true, // this is the default, but just make it explicit
			success: function() {
				console.log('POST request to server worked');
			},
			error: function(e) {
				console.log('telemetry error! look at node output...');
			}
		});
	}

	return {
		register: register
	}
})();
;
TAG.Util.makeNamespace("TAG.TESTS");

/**
 * TAG testing framework
 *
 * The TEST SCRIPTS section below has a few test routines. These
 * routines are made public at the bottom of this file. They call
 * runTests on a collection of TEST SCRIPT ACTIONs, which are defined
 * in the second section. These are 'atomic' actions that can
 * be combined to make more complex routines. There are a few
 * TEST SUPPORT FUNCTIONs defined in the last section below.
 */

TAG.TESTS = (function () {

	var emptyTest = {
		tests: [],
		intervals: []
	};

	var highlightColors = [
		'rgba(255,100,0,0.9)',
		'rgba(255,0,100,0.9)',
		'rgba(100,255,0,0.9)',
		'rgba(100,0,255,0.9)',
		'rgba(0,255,100,0.9)',
		'rgba(0,100,255,0.9)'
	];

	var testTimeout; // the currently-running timeout

	/**********************\
	|**** TEST SCRIPTS ****|
	\**********************/

	function testEnterCollections() {
		runTests(combineTestObjs([
			navigate_to_start,
			start_to_collections,
			collections_to_start,
			{tests: 2, intervals: 2}
		]));
	}

	function testSelectCollections() {
		runTests(combineTestObjs([
			navigate_to_collections,
			pick_random_collection,
			{tests: 1, intervals: 10}
		]));
	}

	function testSelectArtworks() {
		runTests(combineTestObjs([
			navigate_to_collections,
			pick_random_collection,
			pick_random_collection,
			pick_random_artwork,
			{tests: 1, intervals: 10}
		]));
	}

	function testDragArtwork() {
		runTests(combineTestObjs([
			navigate_to_garibaldi,
			pan_artwork,
			{tests: 4, intervals: 2}
		]));
	}

	/*****************************\
	|**** TEST SCRIPT ACTIONS ****|
	\*****************************/

	/* navigate from the start screen to the collections view */
	function start_to_collections() {
		return {
			tests: [
				function() {
					clickEvent($('#overlay'));
				}
			],
			intervals: [
				2000
			]
		};
	}

	/* navigate from the collections view to the start screen */
	function collections_to_start() {
		return {
			tests: [
				function() {
					clickEvent($('#catalogBackButton'));
				}
			],
			intervals: [
				2000
			]
		};
	}

	/* pick a random collection from the collections list */
	function pick_random_collection() {
		return {
			tests: [
				function() {
					var collectionClickables = $('.collectionClickable'),
						collection = randElt(collectionClickables);
					if(collection) {
						clickEvent($(collection));
					}
				}
			],
			intervals: [
				2000
			]
		};
	}

	/* pick a random artwork tile (make sure it's not already selected) */
	function pick_random_artwork() {
		return {
			tests: [
				function() {
					var artTiles = $('.tile'),
						tile = randElt(artTiles),
						alreadySelected;
					if(!tile) {
						console.log("RETURNING: no artwork tiles yet");
						return;
					}
					alreadySelected = $('.already_selected_in_test');
					while(artTiles.length > 1 && $(tile).hasClass('already_selected_in_test')) {
						tile = randElt(artTiles);
					}
					alreadySelected.removeClass('already_selected_in_test');
					$(tile).addClass('already_selected_in_test');
					clickEvent($(tile));
				}
			],
			intervals: [
				1000
			]
		}
	}

	/* pan the given artwork */
	function pan_artwork() {
		var tagWidth = $('#tagRoot').width(),
			tagHeight = $('#tagRoot').height();
		return {
			tests: [
				function() {
					dragEvent($('.artworkCanvasTesting')[0], {
						startX: tagWidth/2,
						endX: 2*tagWidth/3,
						startY: tagHeight/2,
						endY: 4*tagHeight/5
					});
				},
				function() {
					dragEvent($('.artworkCanvasTesting')[0], {
						startX: tagWidth/2,
						endX: tagWidth - 10,
						startY: tagHeight/2,
						endY: tagHeight - 10
					});
				},
				function() {
					dragEvent($('.artworkCanvasTesting')[0], {
						startX: tagWidth/2,
						endX: 10,
						startY: tagHeight/2,
						endY: tagHeight/2
					});
				},
				function() {
					dragEvent($('.artworkCanvasTesting')[0], {
						startX: tagWidth/2,
						endX: tagWidth/2,
						startY: tagHeight/2,
						endY: 10
					});
				}
			],
			intervals: [
				1500,
				1500,
				1500,
				1500
			]
		}
	}

	/* navigate to the garibaldi panorama */
	function navigate_to_garibaldi() {
		return {
			tests: [
				function() {
					var garibaldiId = "48880741-040a-4657-a3ef-0a2f9bbe27cd";

					TAG.Worktop.Database.getDoq(garibaldiId, function(doq) {
						var prevInfo = {prevPage: "catalog", prevScroll: 0},
							options = {catalogState: {}, doq: doq, split: 'L' },
			            	deepZoom = new TAG.Layout.ArtworkViewer(prevInfo, options, null);
		            	TAG.Util.UI.slidePageLeft(deepZoom.getRoot());
					}, genErrorHandler('navigate_to_garibaldi'), genErrorHandler('navigate_to_garibaldi'));
				}
			],
			intervals: [
				1000
			]
		}
	}

	/* navigate to start page */
	function navigate_to_start() {
		return {
			tests: [
				function() {
					TAG.Layout.StartPage(null, function (root) {
			            TAG.Util.UI.slidePageRight(root);
			        }, true);
				}
			],
			intervals: [
				1000
			]
		}
	}

	/* navigate to collections view */
	function navigate_to_collections() {
		return {
			tests: [
				function() {
					var newCatalog = new TAG.Layout.CollectionsPage();
    			    $('#overlay').on('click', function(){});
        			TAG.Util.UI.slidePageLeft(newCatalog.getRoot());
        		}
        	],
        	intervals: [
        		1000
        	]
        }
	}

	/***********************************\
	|**** TESTING SUPPORT FUNCTIONS ****|
	\***********************************/

	/**
	 * Run a series of tests
	 * @param testObj.tests       an array of tests to run
	 * @param testObj.intervals   array of time intervals (ms) between these tests
	 * @return                    -1 if an error was thrown during testing
	 */
	function runTests(testObj) {
		var tests = testObj.tests,
			intervals = testObj.intervals;
		// TODO check that tests and intervals are arrays, that they have equal lengths, etc...
		try {
			showStartOverlay();
			runTest(0, tests, intervals);
		} catch(e) {
			console.log('error in runTests: '+e.message);
			return -1;
		}
	}

	/**
	 * Called by runTests, calls a single test, then calls runTest with incremented index
	 */
	function runTest(index, tests, intervals, testNum) {
		testNum = testNum || 1;
		var type;
		if(index < tests.length) {
			type = typeof tests[index];
			testTimeout = setTimeout(function() {
				if(type === "function") {
					console.log("RUNNING TEST #"+testNum);
					tests[index]();
					runTest(index+1, tests, intervals, testNum+1);
				} else if(type === "number" && intervals[index] > 0) { // repeat previous tests[index] commands intervals[index] times
					intervals[index]--;
					runTest(Math.max(0, index - tests[index]), tests, intervals, testNum+1);
				}
			}, type === "function" ? intervals[index] : 0);
		}
	}

	/**
	 * Helper function to concatenate different testing objects
	 * @param testObjs       array of test objects (or functions that will generate test objects) to combine
	 * @return               combined test objects
	 */
	function combineTestObjs(testObjs) {
		// TODO validate input
		if(testObjs.length === 0) {
			return {
				tests: [],
				intervals: []
			};
		}
		var combinedTests = [],
			combinedIntervals = [],
			i,
			currObj;
		for(i=0;i<testObjs.length;i++) {
			currObj = typeof testObjs[i] === 'function' ? testObjs[i]() : testObjs[i];
			combinedTests = combinedTests.concat(currObj.tests);
			combinedIntervals = combinedIntervals.concat(currObj.intervals);
		}
		return {
			tests: combinedTests,
			intervals: combinedIntervals
		};
	}

	/**
	 * Create click event on the input element
	 */
	function clickEvent(target) {
		var $target = $(target);
		highlightTarget($target);
		$target.trigger('click');
	}

	/**
	 * Simulate a pinch zoom event
	 */
	function pinchZoomEvent(target, eventData) {
		// TODO
	}

	/**
	 * Create mousemove event -- be careful to leave enough interval time to call this
	 * @param target       target element for event
	 * @param eventData    object with the following properties:
	 *            startX     starting x coordinate relative to #tagRoot
	 *            startY     ...
	 *            endX       ...
	 *            endY
	 */
	function dragEvent(target, eventData) {
		var $target = $(target),
			simulatedEvent,
			clientX = eventData.startX + $('#tagRoot').offset().left,
			clientY = eventData.startY + $('#tagRoot').offset().top,
			screenX = clientX,
			screenY = clientY,
			endX = clientX + (eventData.endX - eventData.startX),
			endY = clientY + (eventData.endY - eventData.startY),
			deltaX = endX - clientX,
			deltaY = endY - clientY,
			distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY),
			distancePerMove = 20,
			numMoves = distance/distancePerMove,
			i;

		// mousedown at (startX, startY)
		simulatedEvent = document.createEvent('MouseEvent');
        simulatedEvent.initMouseEvent('mousedown', true, true, window, 1,
                   screenX, screenY,
                   clientX, clientY, false,
                   false, false, false, 0, null);
        highlightTarget($target, eventData.startX, eventData.startY, true);
        $target[0].dispatchEvent(simulatedEvent);

        // call mouseMoves to create mousemove events
        mouseMoves(0, numMoves, {
		       	target: $target,
		       	startClientX: clientX,
		       	startClientY: clientY,
		       	startScreenX: screenX,
		       	startScreenY: screenY,
		       	endClientX: endX,
		       	endClientY: endY,
		       	endScreenX: endX,
		       	endScreenY: endY
		    }, function() {
	       	    // mouseup at (endX, endY)
			 	simulatedEvent = document.createEvent('MouseEvent');
		        simulatedEvent.initMouseEvent('mouseup', true, true, window, 1,
		                    endX, endY,
		                    endX, endY, false,
		                    false, false, false, 0, null);
		        $target[0].dispatchEvent(simulatedEvent);
	        }
	    );
	}

	/**
	 * Recursive call to execute mousemove events
	 * @param ctr        the number of move events we've called
	 * @param numMoves   the number of move events we will call
	 * @param data       event data with properties:
	 *           startClientX        starting x position in context of browser window
	 *           startClientY        ...
	 *           endClientX          ...
	 *           endClientY          ...
	 *           target              target element
	 * @param callback   function to be called when all moves have executed
	 */
	function mouseMoves(ctr, numMoves, data, callback) {
		var simulatedEvent,
			f = (ctr + 1) / numMoves,
			startX = data.startClientX,
			startY = data.startClientY,
			endX = data.endClientX,
			endY = data.endClientY,
			$target = data.target,
			lerpX = lerp(startX, endX, f),
			lerpY = lerp(startY, endY, f);
		if(ctr < numMoves) {
			simulatedEvent = document.createEvent('MouseEvent');
	        simulatedEvent.initMouseEvent('mousemove', true, true, window, 1,
	                    lerpX, lerpY,
	                    lerpX, lerpY, false,
	                    false, false, false, 0, null);
	        highlightTarget($target, lerpX - $('#tagRoot').offset().left, lerpY - $('#tagRoot').offset().top, true);
	       	$($target)[0].dispatchEvent(simulatedEvent);
	       	setTimeout(function() {
	       		mouseMoves(ctr+1, numMoves, data, callback);
	       	}, 0);
		} else {
			callback && callback();
		}
	}

	/**
	 * Linearly interpolate between start and stop by t in [0,1]
	 */
	function lerp(start, stop, t) {
		return (1-t)*start + t*stop;
	}


	/**
	 * Highlight the target of a testing event (visualize events)
	 * @param target          the element to highlight
	 * @param left            (optional) the left offset of the event within the target
	 * @param top             (optional) ....
	 * @param animateRadius   (optional) if true, highlights get smaller as they disappear
	 * @param highlightWidth  (optional) width of the highlight circle
	 */
	function highlightTarget(target, left, top, animateRadius, highlightWidth) {
		var $target = $(target),
			tagname = $target.prop('tagName').toLowerCase(),
			highlightOverlay = $(document.createElement('div')),
			highlightWidth = highlightWidth || 30,
			isAbs = ($target.css('position') === 'absolute' || $target.css('position') === 'relative'),
			oldBackgroundColor,
			marginLeftOffset = left ? $target.width() - left : $target.width()/2,
			marginTopOffset = top ? $target.height() - top : $target.height()/2,
			leftOffset = left ? left : $target.width()/2,
			topOffset = top ? top : $target.height()/2;

		if(tagname === 'img' || tagname === 'video') { // can't append a highlight inside an img or video
			oldBackgroundColor = $target.css('background-color');
			$target.css('background-color', 'rgba(255,100,0,0.8)');
			setTimeout(function() {
				$target.css('background-color', oldBackgroundColor);
			}, 1000);
		} else {
			highlightOverlay.css({
				'border-radius': '100px',
				'background-color': randElt(highlightColors),
				'position': 'absolute',
				'margin-top': isAbs ? '' : '-' + (marginTopOffset + highlightWidth/2) + 'px',
				'margin-left': isAbs ? '' : (marginLeftOffset - highlightWidth/2) + 'px',
				'top': isAbs ? (topOffset - highlightWidth/2) + 'px' : '',
				'left': isAbs ? (leftOffset - highlightWidth/2) + 'px' : '',
				'opacity': 0,
				'width': highlightWidth+'px',
				'height': highlightWidth+'px'
			});
			$target.append(highlightOverlay);
			highlightOverlay.animate({
				opacity: 1,
			}, 20, function() {
				var animOpts = {
					opacity: 0
				};
				if(animateRadius) {
					animOpts.width = highlightWidth/2;
					animOpts.height = highlightWidth/2;
					if(isAbs) {
						animOpts.left = (leftOffset - highlightWidth/2) + highlightWidth/4;
						animOpts.top = (topOffset - highlightWidth/2) + highlightWidth/4;
					} else {
						animOpts.marginLeft = (marginLeftOffset - highlightWidth/2 + highlightWidth/4);
						animOpts.marginTop = -(marginTopOffset + highlightWidth/2 - highlightWidth/4);
					}
				}
				highlightOverlay.animate(animOpts, 1200, function() {
					highlightOverlay.remove();
				});
			});
		}
	}

	/**
	 * @param arr     array for which we want a random index
	 * @return        random index into array, -1 if arr is empty
	 */
	function randIndex(arr) {
		if(arr.length === 0) {
			return -1;
		} else {
			return Math.floor(Math.random() * arr.length);
		}
	}

	/**
	 * returns random element from input array
	 * @param arr     input array
	 * @return        random element, null if arr=[]
	 */
	function randElt(arr) {
		var ind;
		console.log("arr.length = "+arr.length);
		if(arr.length === 0) {
			return null;
		} else {
			ind = randIndex(arr);
			console.log('index = '+ind);
			return arr[ind];
		}
	}

	/**
	 * Returns a basic error callback function (long-term, should define
	 * case-specific error funcs that actually do some error handling).
	 *
	 * @param calling      string: calling function's name
	 */
	function genErrorHandler(calling) {
		var str = calling ? ('error in '+calling) : 'error';
		return function(err) {
			console.log(str + ': ' + e.message);
		};
	}

	/**
	 * Show an overlay explaining that the first step in the test is to
	 * navigate to the correct starting page.
	 */
	function showStartOverlay() {
		var rootContainer = $('#tagContainer'), // this is demo.html-specific!
			overlay = $(document.createElement('div')),
			message = $(document.createElement('div'));

		overlay.css({
			'background-color': 'rgba(0,0,0,0.9)',
			height: '100%',
			opacity: 0,
			position: 'absolute',
			width: '100%',
			'z-index': 100000000000000000
		});

		message.css({
			color: '#ffdd00',
			position: 'absolute',
			'font-family': 'sourceSans',
			'font-size': '60px',
			'text-align': 'center',
			top: '40%',
			width: '100%'
		});

		message.text('starting test...');

		overlay.append(message);
		rootContainer.append(overlay);

		overlay.animate({
			opacity: 1
		}, 100, function() {
			setTimeout(function(){
				overlay.animate({
					opacity: 0
				}, 100, function() {
					overlay.remove();
				});
			}, 1000);
		});
	}

	/**
	 * Cancels the currently-running test
	 */
	function cancelTest() {
		clearTimeout(testTimeout);
	}

	// publicize test functions
	return {
		testEnterCollections: testEnterCollections,
		testSelectCollections: testSelectCollections,
		testSelectArtworks: testSelectArtworks,
		testDragArtwork: testDragArtwork,
		cancelTest: cancelTest,
		runTests: runTests
	};
})();
;
// TAG (Touch Art Gallery) does not collect or publish any personal information.

/**
 * This file is responsible for performing initial setup. Please see the comments for load
 * and init below.
 */
(function () { // TODO merging: make sure everything necessary from the win8 app is here
    "use strict";
    var newUser = false;
    if (IS_WINDOWS) {
        $(document).on('ready', load);
    } else {
        load();
    }

    /**
     * The first real TAG function called. Sets up the embedding within iframe and
     * calls init, which takes care of loading scripts and displaying the first page.
     * @method load
     */
    function load() {
        var container,              // container to hold embedding
            positioning,            // try to be friendly to the positioning the host set (either abs or rel);
                                    //    if we're embedding in iframe, doesn't matter
            tagRootContainer,       // the following two use table positioning to center the embedding
            tagRootInnerContainer,  //    vertically and horizontally
            tagRoot,                // the div containing TAG -- considered the "root" of the TAG-related DOM
            w,                      // width of embedding
            h,                      // height of embedding
            l;                      // left of tagRoot
        
        TELEMETRY_SESSION_ID = TAG.Util.IdCreator();
        if (!localStorage.tagTelemetry) {
            newUser = true;
        }
        if (!localStorage.machId) {
            localStorage.machId= TAG.Util.IdCreator();
        }
    
        
        if(containerId && $('#'+containerId).length > 0) {
            container = $('#'+containerId);
        } else {
            console.log('no containerId specified, or the containerId does not match an element');
            return; // no TAG for you
        }

        if(urlToParse || urlToLoad) {
            pageToLoad = parseQueryParams();
        }

        // if we're in the windows app, localStorage.ip should take precedence (starting on the last server
        // running makes more sense than in the web app, where TAG should start to whichever server is specified
        // by the museum/institution)
        localStorage.ip = (IS_WINDOWS ? (localStorage.ip || ip) : (pageToLoad.tagserver || ip || localStorage.ip)) || 'browntagserver.com';

        positioning = container.css('position');
        if(positioning !== 'relative' && positioning !== 'absolute') {
            container.css('position', 'relative');
        }

        tagRootContainer = $(document.createElement('div')).attr('id', 'tagRootContainer');
        container.append(tagRootContainer);

        tagRootInnerContainer = $(document.createElement('div')).attr('id', 'tagRootInnerContainer');
        tagRootContainer.append(tagRootInnerContainer);
        
        tagRoot = $(document.createElement('div')).attr('id', 'tagRoot');
        tagRootInnerContainer.append(tagRoot);
        
        w = container.width();
        h = container.height();
        l = 0;

        if (IS_WEBAPP) {
            if (w / h > 16 / 9) { // constrain width or height depending on the embedding dimensions
                l = (w - 16 / 9 * h) / 2;
                w = 16 / 9 * h;
            } else {
                h = 9 / 16 * w;
            }
        }

        tagRoot.css({
            'font-size':  (w/9.6) + '%', // so font-size percentages for descendents work well
            height:       h + "px",
            left:         l + "px",
            'max-width':  w + "px",
            'max-height': h + "px",
            width:        w + "px"
        });

        // bleveque: I got rid of the demo.html handlers here, since they don't really belong (delete this comment if after 8/15/14)

        init();
    }

    /**
     * Parses page url for a specific TAG page to load
     * @method parseQueryParams
     * @return {Object}              the tag params found
     */
    function parseQueryParams() {
        var url     = urlToParse,                 // url of host site
            param,                                // param
            ret     = {};                         // will return this

        param = url.match(/tagserver=[^\&]*/);
        if(param && param.length > 0) {
            ret.tagserver = param[0].split(/=/)[1];
        }

        param = url.match(/tagpagename=[a-zA-Z]+/);
        
        if(param && param.length > 0) {
            ret.pagename = param[0].split(/=/)[1];
            switch(ret.pagename) {
                case 'collections':
                    param = url.match(/tagcollectionid=[a-f0-9\-]+/);
                    if(param && param.length > 0) {
                        ret.collectionid = param[0].split(/=/)[1];
                        param = url.match(/tagartworkid=[a-f0-9\-]+/);
                        if(param && param.length > 0) {
                            ret.artworkid = param[0].split(/=/)[1];
                        }
                        return ret;
                    }
                    break;
                case 'artwork':
                case 'video':
                    param = url.match(/tagguid=[a-f0-9\-]+/);
                    var prevPage = url.match(/prevpage=[a-f0-9\-]+/);
                    if(param && param.length > 0) {
                        ret.guid = param[0].split(/=/)[1];
                        if (prevPage && prevPage.length > 0) {
                            ret.prevpage = prevPage[0].split(/=/)[1];
                        }
                        return ret;
                    }
                    break;
                case 'tour':
                    param = url.match(/tagguid=[a-f0-9\-]+/);
                    if(param && param.length > 0) {
                        ret.guid = param[0].split(/=/)[1];
                        var prevPage = url.match(/prevpage=[a-f0-9\-]+/);
                        ret.onlytour = url.match(/tagonlytour=true/) ? true : false;
                        if (prevPage && prevPage.length > 0) {
                            ret.prevpage = prevPage[0].split(/=/)[1];
                        }
                        return ret;
                    }
                    break;
            }
        } else if (urlToLoad) {
            // if we didn't have any luck parsing urlToParse, try urlToLoad
            // this makes urlToLoad the "default" loading page, but still
            // allows users to link to specific pages by specifying url params
            urlToParse = urlToLoad;
            urlToLoad = '';
            return parseQueryParams();
        }
        return ret;
    }


    /**
     * Initialize TAG; load some scripts into the <head> element,
     * load StartPage (or TourPlayer if specified in the API call).
     * @method init
     */
    function init() {
        var TAGSCRIPTS = [                                    // scripts to load
                'js/raphael.js',
                'js/tagInk.js',
                'js/RIN/web/lib/rin-core-1.0.js'
            ],
            i,                                                // index
            oHead,                                            // head element
            oScript,                                          // script element
            oCss,                                             // link element
            tagContainer;                                     // div containing TAG

        TAGSCRIPTS.push(
            IS_WINDOWS ? 'js/WIN8_RIN/web/lib/rin-core-1.0.js'   : 'js/RIN/web/lib/rin-core-1.0.js',
            IS_WINDOWS ? 'js/WIN8_RIN/web/lib/knockout-2.1.0.js' : 'js/RIN/web/lib/knockout-2.2.1.js'
        );

        tagPath = tagPath || '';
        if(tagPath.length > 0 && tagPath[tagPath.length - 1] !== '/') {
            tagPath += '/';
        }

        // load scripts
        oHead = document.getElementsByTagName('head').item(0);
        for (i = 0; i < TAGSCRIPTS.length; i++) {
            oScript = document.createElement("script");
            oScript.type = "text/javascript";
            oScript.src = tagPath + TAGSCRIPTS[i];
            oHead.appendChild(oScript);
        }

        // load stylesheet
        oCss = document.createElement("link");
        oCss.rel = "stylesheet";
        oCss.href = tagPath+"css/TAG.css";
        oHead.appendChild(oCss);

        tagContainer = $('#tagRoot');

        $("body").css("-ms-touch-action","none");

        // set up idle timer restarting
        $('body').on('click.idleTimer', function() {
            TAG.Util.IdleTimer.restartTimer();
        });

        
        // // if the user specified the tourData API parameter, load into the corresponding tour
        // if(INPUT_TOUR_ID) {
        //     currentPage.name = TAG.Util.Constants.pages.START_PAGE;
        //     currentPage.obj  = null;

        //     TAG.Layout.StartPage(null, function (page) {
        //         TAG.Worktop.Database.getDoq(INPUT_TOUR_ID, function(tour) {
        //             var tourData = JSON.parse(unescape(tour.Metadata.Content)),
        //                 rinPlayer = TAG.Layout.TourPlayer(tourData, null, {}, null, tour);

        //             tagContainer.css('overflow', 'hidden');

        //             tagContainer.append(rinPlayer.getRoot());
        //             rinPlayer.startPlayback();

        //             currentPage.name = TAG.Util.Constants.pages.TOUR_PLAYER;
        //             currentPage.obj  = rinPlayer;
        //         }, function() {
        //             // TODO error handling
        //         }, function() {
        //             // TODO cache error handling
        //         });
        //     });
        // } else { // otherwise, load to start page
        //     currentPage.name = TAG.Util.Constants.pages.START_PAGE;
        //     currentPage.obj  = null;

        //     TAG.Layout.StartPage(null, function (page) {
        //         tagContainer.append(page);
        //     });
        // }
        // if the user specified the tourData API parameter, load into the corresponding tour
        if(pageToLoad && pageToLoad.pagename === 'tour') {
            currentPage.name = TAG.Util.Constants.pages.START_PAGE;
            currentPage.obj  = null;

            TAG.Layout.StartPage({newUser:newUser}, function (page) {
                TAG.Worktop.Database.getDoq(pageToLoad.guid, function (tour) {
                    if (pageToLoad.prevpage) {
                        TAG.Worktop.Database.getDoq(pageToLoad.prevpage, function (prevCollection) {
                            var tourData = JSON.parse(unescape(tour.Metadata.Content)),
                                rinPlayer = TAG.Layout.TourPlayer(tourData, prevCollection, {}, null, tour);

                            tagContainer.css('overflow', 'hidden');

                            tagContainer.append(rinPlayer.getRoot());
                            rinPlayer.startPlayback();

                            currentPage.name = TAG.Util.Constants.pages.TOUR_PLAYER;
                            currentPage.obj = rinPlayer;
                        });
                    } else {
                        var tourData = JSON.parse(unescape(tour.Metadata.Content)),
                               rinPlayer = TAG.Layout.TourPlayer(tourData, null, {}, null, tour);

                        tagContainer.css('overflow', 'hidden');

                        tagContainer.append(rinPlayer.getRoot());
                        rinPlayer.startPlayback();

                        currentPage.name = TAG.Util.Constants.pages.TOUR_PLAYER;
                        currentPage.obj = rinPlayer;
                    }
                }, function() {
                    // TODO error handling
                }, function() {
                    // TODO cache error handling
                });
            });
        } else if (pageToLoad && pageToLoad.pagename === 'collections') {
            currentPage.name = TAG.Util.Constants.pages.START_PAGE;
            currentPage.obj  = null;

            TAG.Layout.StartPage({ newUser: newUser }, function (page) {
                var collectionsPage;
                if(pageToLoad.collectionid) {
                    TAG.Worktop.Database.getDoq(pageToLoad.collectionid, function(collection) {
                        if(pageToLoad.artworkid) {
                            TAG.Worktop.Database.getDoq(pageToLoad.artworkid, function(artwork) {
                                collectionsPage = new TAG.Layout.CollectionsPage({
                                    backScroll: 0,
                                    backArtwork: artwork,
                                    backCollection: collection
                                });
                                tagContainer.append(collectionsPage.getRoot());
                            });
                        } else {
                            collectionsPage = new TAG.Layout.CollectionsPage({
                                backScroll: 0,
                                backArtwork: null,
                                backCollection: collection
                            });
                            tagContainer.append(collectionsPage.getRoot());
                        }
                    });
                } else {
                    collectionsPage = TAG.Layout.CollectionsPage();
                    tagContainer.append(collectionsPage.getRoot());
                }
                currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
                currentPage.obj  = collectionsPage;
            }, function() {
                // TODO error handling
            }, function() {
                // TODO cache error handling
            });
        } else if (pageToLoad && pageToLoad.pagename === 'artwork') {
            currentPage.name = TAG.Util.Constants.pages.START_PAGE;
            currentPage.obj  = null;

            TAG.Layout.StartPage({ newUser: newUser }, function (page) {
                TAG.Worktop.Database.getDoq(pageToLoad.guid, function (artwork) {
                    if (pageToLoad.prevpage) {
                        TAG.Worktop.Database.getDoq(pageToLoad.prevpage, function (prevCollection) {
                            var artworkViewer = TAG.Layout.ArtworkViewer({
                                doq: artwork,
                                prevScroll: 0,
                                prevCollection: prevCollection,
                                prevPage: 'catalog'
                            });
                            tagContainer.append(artworkViewer.getRoot());

                            currentPage.name = TAG.Util.Constants.pages.ARTWORK_VIEWER;
                            currentPage.obj = artworkViewer;
                        });
                    } else {
                        var artworkViewer = TAG.Layout.ArtworkViewer({
                            doq: artwork,
                            prevScroll: 0,
                            prevCollection: null,
                            prevPage: 'catalog'
                        });
                        tagContainer.append(artworkViewer.getRoot());

                        currentPage.name = TAG.Util.Constants.pages.ARTWORK_VIEWER;
                        currentPage.obj = artworkViewer;
                    }
                });
            }, function() {
                // TODO error handling
            }, function() {
                // TODO cache error handling
            });
        } else if (pageToLoad && pageToLoad.pagename === 'video') {
            currentPage.name = TAG.Util.Constants.pages.START_PAGE;
            currentPage.obj  = null;

            TAG.Layout.StartPage({ newUser: newUser }, function (page) {
                TAG.Worktop.Database.getDoq(pageToLoad.guid, function (video) {
                    if (pageToLoad.prevpage) {
                        TAG.Worktop.Database.getDoq(pageToLoad.prevpage, function (prevCollection) {
                            var videoPlayer = TAG.Layout.VideoPlayer(video, prevCollection, null);
                            tagContainer.append(videoPlayer.getRoot());

                            currentPage.name = TAG.Util.Constants.pages.VIDEO_PLAYER;
                            currentPage.obj = videoPlayer;
                        });
                    } else {
                        var videoPlayer = TAG.Layout.VideoPlayer(video, null, null);
                        tagContainer.append(videoPlayer.getRoot());

                        currentPage.name = TAG.Util.Constants.pages.VIDEO_PLAYER;
                        currentPage.obj = videoPlayer;
                    }
                });
            }, function() {
                // TODO error handling
            }, function() {
                // TODO cache error handling
            });



            
        } else { // otherwise, load to start page
            currentPage.name = TAG.Util.Constants.pages.START_PAGE;
            currentPage.obj  = null;

            TAG.Layout.StartPage({ newUser: newUser }, function (page) {
                tagContainer.append(page);
            });
        }
    }

    /*
     * The checkServerConnectivity() method makes an ajax call to the server. If it receives a response,
     * it does nothing since the computer is definitely connected to the internet. Otherwise, it appends the
     * InternetFailurePage.
     * 
     * TODO: currently, the server URL is hardcoded since it cannot be fetched from the database since that
     * hasn't been instantiated. This must be changed.
     */
    function checkServerConnectivity() {
        var request = $.ajax({
            url: "http://137.135.69.3:8080",
            dataType: "text",
            async: false,
            error: function (err) {
                $("body").append((new TAG.Layout.InternetFailurePage("Server Down")).getRoot());
                return false;
            },
        });
        return true;
    }

    var splitOverlay;
    function handleResize(evt) {
        var viewStates = Windows.UI.ViewManagement.ApplicationViewState;
        var newViewState = Windows.UI.ViewManagement.ApplicationView.value;
        switch (newViewState) {
            case viewStates.snapped:
            case viewStates.filled:
                if (!splitOverlay)
                    $("body").append(splitOverlay = new LADS.Layout.MetroSplitscreenMessage().getRoot());
                break;
            case viewStates.fullScreenLandscape:
                if (splitOverlay) {
                    splitOverlay.detach();
                    splitOverlay = null;
                }
                break;
        }
    }

    if (IS_WINDOWS) {
        WinJS.Application.start();
        WinJS.Application.onsettings = function (args) {
            args.detail.applicationcommands = {
                "priv": {
                    title: "Privacy Policy", href: "settings/privacy.html"
                }
            };
            WinJS.UI.SettingsFlyout.populateSettings(args);
        };

        var networkInformation = Windows.Networking.Connectivity.NetworkInformation;
        var lastOverlay;
        var dataLimitPrompted = false;

        Windows.Networking.Connectivity.NetworkInformation.addEventListener('networkstatuschanged', function (evt) {

            if (localStorage.ip !== "127.0.0.1" && localStorage.ip !== "localhost") {
                if (!networkInformation.getInternetConnectionProfile()) {
                    if (lastOverlay) lastOverlay.getRoot().detach();
                    $("body").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                } else {
                    switch (networkInformation.getInternetConnectionProfile().getNetworkConnectivityLevel()) {
                        case Windows.Networking.Connectivity.NetworkConnectivityLevel.none:
                        case Windows.Networking.Connectivity.NetworkConnectivityLevel.localAccess:
                        case Windows.Networking.Connectivity.NetworkConnectivityLevel.constrainedInternetAccess:
                            if (lastOverlay) lastOverlay.getRoot().detach();
                            $("body").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                            break;
                        case Windows.Networking.Connectivity.NetworkConnectivityLevel.internetAccess:
                            if (lastOverlay) lastOverlay.getRoot().detach();
                            break;
                    }
                }
            }

            if (!dataLimitPrompted && !localStorage.acceptDataUsage && networkInformation.getInternetConnectionProfile() && networkInformation.getInternetConnectionProfile().getDataPlanStatus().dataLimitInMegabytes) {
                dataLimitPrompted = true;
                $("body").append(new LADS.Layout.InternetFailurePage("Data Limit", true).getRoot());
            }
        });

        window.addEventListener('resize', handleResize);
    } else {
        setInterval(function () {
            if (!navigator.onLine) {
                if (!$("#InternetFailureroot")[0] && localStorage.ip !== "127.0.0.1" && localStorage.ip !== "localhost") {
                    $(".rootPage").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                }
            }
            
        }, 250);
        var el = document.body;
        if (el.addEventListener) {
            el.addEventListener("offline", function () {
                if (!$("#InternetFailureroot")[0] && localStorage.ip !== "127.0.0.1" && localStorage.ip !== "localhost") {
                    $(".rootPage").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                }
            }, true);
        }
        else if (el.attachEvent) {
            el.attachEvent("onoffline", function () {
                if (!$("#InternetFailureroot")[0] && localStorage.ip !== "127.0.0.1" && localStorage.ip !== "localhost") {
                    $(".rootPage").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                }
            });
        }
        else {
            el.onoffline = function () {
                if (!$("#InternetFailureroot")[0] && localStorage.ip !== "127.0.0.1" && localStorage.ip !== "localhost") {
                    $(".rootPage").append((lastOverlay = new LADS.Layout.InternetFailurePage("Internet Lost", true)).getRoot());
                }
            };
        }
    }
})();};