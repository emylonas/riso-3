package  {	import flash.display.Sprite;	import flash.display.Shape;	import flash.display.Graphics;	import flash.geom.*;	import flash.events.*;	import flash.display.Loader;	import flash.display.Sprite;    import flash.display.BitmapData;    import flash.display.Loader;    import flash.net.URLRequest;    import flash.events.Event;    import flash.events.IOErrorEvent;    import flash.geom.Matrix;	import flash.net.URLLoader;		public class Geometry {		//these hold the main geometry neccesarry in the formats		//that are required by drawTriangles so that no conversion		//is neccesry		var vertices:Vector.<Number> = new Vector.<Number>();		var texcoords:Vector.<Number>;		var indices:Vector.<int>;				//convenience variables for renderable		var width:Number;		var height:Number;		var depth:Number;				//parent is passed in for reporting any errors		public function Geometry(vertex:Array, uvt:Vector.<Number>, ind:Vector.<int>, par:Main) {						//setup variables			vertices = Vector.<Number>(vertex);			texcoords = Vector.<Number>(uvt);			indices=Vector.<int>(ind);												//do error checking vertices are 3d points so they must			//come in multiples of 3 (x,y,z)			if(vertices.length!=Math.floor(vertices.length/3)*3)par.errorString = "geometry vertices incorrect length";			vertices.length = Math.floor(vertices.length/3)*3;			//texcoords are 2 per vertex so they must by equal to			//num of vertex*2			if(texcoords.length!=Math.floor(vertices.length/3)*2)par.errorString = "geometry texcoordinate length incorrect";			texcoords.length = Math.floor(vertices.length/3)*2;			//indices form triangles so they must come in multiples			//of 3			if(indices.length!=Math.floor(indices.length/3)*3)par.errorString = "geometry indices incorrect length";			indices.length = Math.floor(indices.length/3)*3;									//set up height, width and depth these are used			//for rotating around the center of a movieclip			var minX = vertices[0];			var maxX = vertices[0];			var minY = vertices[1];			var maxY = vertices[1];			var minZ = vertices[2];			var maxZ = vertices[2];			for(var i:int=0;i<vertices.length/3;i++){				if(vertices[i]<minX)minX=vertices[i];				if(vertices[i]>maxX)maxX=vertices[i];				if(vertices[i+1]<minY)minY=vertices[i+1];				if(vertices[i+1]>maxY)maxY=vertices[i+1];				if(vertices[i+2]<minZ)minZ=vertices[i+2];				if(vertices[i+2]>maxZ)maxZ=vertices[i+2];			}			width = maxX-minX;			height = maxY-minY;			depth = maxZ-minZ;		}	}	}